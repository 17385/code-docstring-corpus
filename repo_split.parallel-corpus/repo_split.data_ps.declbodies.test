def request(method, uri, *args, **kwargs): DCNL  DCSP req_method = req_methods[method.upper()] DCNL DCSP raise_exception = kwargs.pop('raise_exception', True) DCNL DCSP raw_content = kwargs.pop('raw_content', False) DCNL DCSP kwargs['headers'] = kwargs.get('headers', {}) DCNL DCSP http_log_req(method, uri, args, kwargs) DCNL DCSP data = None DCNL DCSP if ('data' in kwargs): DCNL DCSP  DCSP data = kwargs.pop('data') DCNL DCSP elif ('body' in kwargs): DCNL DCSP  DCSP if ('Content-Type' not in kwargs['headers']): DCNL DCSP  DCSP  DCSP kwargs['headers']['Content-Type'] = 'application/json' DCNL DCSP  DCSP data = json.dumps(kwargs.pop('body')) DCNL DCSP if data: DCNL DCSP  DCSP resp = req_method(uri, data=data, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP resp = req_method(uri, **kwargs) DCNL DCSP if raw_content: DCNL DCSP  DCSP body = resp.content DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP body = resp.json() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP body = resp.content DCNL DCSP http_log_resp(resp, body) DCNL DCSP if ((resp.status_code >= 400) and raise_exception): DCNL DCSP  DCSP raise exc.from_response(resp, body) DCNL DCSP return (resp, body)
def http_log_req(method, uri, args, kwargs): DCNL  DCSP if (not pyrax.get_http_debug()): DCNL DCSP  DCSP return DCNL DCSP string_parts = [('curl DCSP -i DCSP -X DCSP %s' % method)] DCNL DCSP for element in args: DCNL DCSP  DCSP string_parts.append(('%s' % element)) DCNL DCSP for element in kwargs['headers']: DCNL DCSP  DCSP header = ("-H DCSP '%s: DCSP %s'" % (element, kwargs['headers'][element])) DCNL DCSP  DCSP string_parts.append(header) DCNL DCSP string_parts.append(uri) DCNL DCSP log = logging.getLogger('pyrax') DCNL DCSP log.debug(('\nREQ: DCSP %s\n' % ' DCSP '.join(string_parts))) DCNL DCSP if ('body' in kwargs): DCNL DCSP  DCSP pyrax._logger.debug(('REQ DCSP BODY: DCSP %s\n' % kwargs['body'])) DCNL DCSP if ('data' in kwargs): DCNL DCSP  DCSP pyrax._logger.debug(('REQ DCSP DATA: DCSP %s\n' % kwargs['data']))
def http_log_resp(resp, body): DCNL  DCSP if (not pyrax.get_http_debug()): DCNL DCSP  DCSP return DCNL DCSP log = logging.getLogger('pyrax') DCNL DCSP log.debug('RESP: DCSP %s\n%s', resp, resp.headers) DCNL DCSP if body: DCNL DCSP  DCSP log.debug('RESP DCSP BODY: DCSP %s', body)
def _resolve_id(val): DCNL  DCSP return (val if isinstance(val, six.string_types) else val.id)
def _resolve_name(val): DCNL  DCSP return (val if isinstance(val, six.string_types) else val.name)
def assure_volume(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, volume, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(volume, CloudBlockStorageVolume)): DCNL DCSP  DCSP  DCSP volume = self._manager.get(volume) DCNL DCSP  DCSP return fnc(self, volume, *args, **kwargs) DCNL DCSP return _wrapped
def assure_snapshot(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, snapshot, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(snapshot, CloudBlockStorageSnapshot)): DCNL DCSP  DCSP  DCSP snapshot = self._snapshot_manager.get(snapshot) DCNL DCSP  DCSP return fnc(self, snapshot, *args, **kwargs) DCNL DCSP return _wrapped
def _safe_quote(val): DCNL  DCSP SAFE_QUOTE_CHARS = '/.?&=,' DCNL DCSP try: DCNL DCSP  DCSP ret = urllib.parse.quote(val, safe=SAFE_QUOTE_CHARS) DCNL DCSP except KeyError: DCNL DCSP  DCSP ret = urllib.parse.quote(val.encode('utf-8'), safe=SAFE_QUOTE_CHARS) DCNL DCSP return ret
def runproc(cmd): DCNL  DCSP proc = Popen([cmd], shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True) DCNL DCSP (stdoutdata, stderrdata) = proc.communicate() DCNL DCSP return (stdoutdata, stderrdata)
def get_checksum(content, encoding='utf8', block_size=8192): DCNL  DCSP md = hashlib.md5() DCNL DCSP def safe_update(txt): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP md.update(txt) DCNL DCSP  DCSP except UnicodeEncodeError: DCNL DCSP  DCSP  DCSP md.update(txt.encode(encoding)) DCNL DCSP try: DCNL DCSP  DCSP isfile = os.path.isfile(content) DCNL DCSP except TypeError: DCNL DCSP  DCSP isfile = False DCNL DCSP if isfile: DCNL DCSP  DCSP with open(content, 'rb') as ff: DCNL DCSP  DCSP  DCSP txt = ff.read(block_size) DCNL DCSP  DCSP  DCSP while txt: DCNL DCSP  DCSP  DCSP  DCSP safe_update(txt) DCNL DCSP  DCSP  DCSP  DCSP txt = ff.read(block_size) DCNL DCSP elif hasattr(content, 'read'): DCNL DCSP  DCSP pos = content.tell() DCNL DCSP  DCSP content.seek(0) DCNL DCSP  DCSP txt = content.read(block_size) DCNL DCSP  DCSP while txt: DCNL DCSP  DCSP  DCSP safe_update(txt) DCNL DCSP  DCSP  DCSP txt = content.read(block_size) DCNL DCSP  DCSP content.seek(pos) DCNL DCSP else: DCNL DCSP  DCSP safe_update(content) DCNL DCSP return md.hexdigest()
def _join_chars(chars, length): DCNL  DCSP mult = (int((length / len(chars))) + 1) DCNL DCSP mult_chars = (chars * mult) DCNL DCSP return ''.join(random.sample(mult_chars, length))
def random_unicode(length=20): DCNL  DCSP def get_char(): DCNL DCSP  DCSP return six.unichr(random.randint(32, 1000)) DCNL DCSP chars = u''.join([get_char() for ii in six.moves.range(length)]) DCNL DCSP return _join_chars(chars, length)
def random_ascii(length=20, ascii_only=False): DCNL  DCSP return _join_chars(string.ascii_letters, length)
def coerce_to_list(val): DCNL  DCSP if val: DCNL DCSP  DCSP if (not isinstance(val, (list, tuple))): DCNL DCSP  DCSP  DCSP val = [val] DCNL DCSP else: DCNL DCSP  DCSP val = [] DCNL DCSP return val
def folder_size(pth, ignore=None): DCNL  DCSP if (not os.path.isdir(pth)): DCNL DCSP  DCSP raise exc.FolderNotFound DCNL DCSP ignore = coerce_to_list(ignore) DCNL DCSP def get_size(total, root, names): DCNL DCSP  DCSP paths = [os.path.realpath(os.path.join(root, nm)) for nm in names] DCNL DCSP  DCSP for pth in paths[::(-1)]: DCNL DCSP  DCSP  DCSP if (not os.path.exists(pth)): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP  DCSP elif os.path.isdir(pth): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP  DCSP elif match_pattern(pth, ignore): DCNL DCSP  DCSP  DCSP  DCSP paths.remove(pth) DCNL DCSP  DCSP total[0] += sum((os.stat(pth).st_size for pth in paths)) DCNL DCSP total = [0] DCNL DCSP os.path.walk(pth, get_size, total) DCNL DCSP return total[0]
def add_method(obj, func, name=None): DCNL  DCSP if (name is None): DCNL DCSP  DCSP name = func.func_name DCNL DCSP method = types.MethodType(func, obj, obj.__class__) DCNL DCSP setattr(obj, name, method)
def wait_until(obj, att, desired, callback=None, interval=5, attempts=0, verbose=False, verbose_atts=None): DCNL  DCSP if callback: DCNL DCSP  DCSP waiter = _WaitThread(obj=obj, att=att, desired=desired, callback=callback, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts) DCNL DCSP  DCSP waiter.start() DCNL DCSP  DCSP return waiter DCNL DCSP else: DCNL DCSP  DCSP return _wait_until(obj=obj, att=att, desired=desired, callback=None, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts)
def _wait_until(obj, att, desired, callback, interval, attempts, verbose, verbose_atts): DCNL  DCSP if (not isinstance(desired, (list, tuple))): DCNL DCSP  DCSP desired = [desired] DCNL DCSP if (verbose_atts is None): DCNL DCSP  DCSP verbose_atts = [] DCNL DCSP if (not isinstance(verbose_atts, (list, tuple))): DCNL DCSP  DCSP verbose_atts = [verbose_atts] DCNL DCSP infinite = (attempts == 0) DCNL DCSP attempt = 0 DCNL DCSP start = time.time() DCNL DCSP while (infinite or (attempt < attempts)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj.get() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP obj = obj.manager.get(obj.id) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP raise exc.NoReloadError(("The DCSP 'wait_until' DCSP method DCSP is DCSP not DCSP supported DCSP for DCSP '%s' DCSP objects." % obj.__class__)) DCNL DCSP  DCSP attval = getattr(obj, att) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP elapsed = (time.time() - start) DCNL DCSP  DCSP  DCSP msgs = [('Current DCSP value DCSP of DCSP %s: DCSP %s DCSP (elapsed: DCSP %4.1f DCSP seconds)' % (att, attval, elapsed))] DCNL DCSP  DCSP  DCSP for vatt in verbose_atts: DCNL DCSP  DCSP  DCSP  DCSP vattval = getattr(obj, vatt, None) DCNL DCSP  DCSP  DCSP  DCSP msgs.append(('%s=%s' % (vatt, vattval))) DCNL DCSP  DCSP  DCSP print(' DCSP '.join(msgs)) DCNL DCSP  DCSP if (attval in desired): DCNL DCSP  DCSP  DCSP return obj DCNL DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP attempt += 1 DCNL DCSP return obj
def wait_for_build(obj, att=None, desired=None, callback=None, interval=None, attempts=None, verbose=None, verbose_atts=None): DCNL  DCSP att = (att or 'status') DCNL DCSP desired = (desired or ['ACTIVE', 'ERROR', 'available', 'COMPLETED']) DCNL DCSP interval = (interval or 20) DCNL DCSP attempts = (attempts or 0) DCNL DCSP verbose_atts = (verbose_atts or 'progress') DCNL DCSP return wait_until(obj, att, desired, callback=callback, interval=interval, attempts=attempts, verbose=verbose, verbose_atts=verbose_atts)
def _parse_datetime_string(val): DCNL  DCSP dt = None DCNL DCSP lenval = len(val) DCNL DCSP fmt = {19: '%Y-%m-%d DCSP %H:%M:%S', 10: '%Y-%m-%d'}.get(lenval) DCNL DCSP if (fmt is None): DCNL DCSP  DCSP raise exc.InvalidDateTimeString(("The DCSP supplied DCSP value DCSP '%s' DCSP does DCSP not DCSP match DCSP either DCSP of DCSP the DCSP formats DCSP 'YYYY-MM-DD DCSP HH:MM:SS' DCSP or DCSP 'YYYY-MM-DD'." % val)) DCNL DCSP return datetime.datetime.strptime(val, fmt)
def iso_time_string(val, show_tzinfo=False): DCNL  DCSP if (not val): DCNL DCSP  DCSP return '' DCNL DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP dt = _parse_datetime_string(val) DCNL DCSP else: DCNL DCSP  DCSP dt = val DCNL DCSP if (not isinstance(dt, datetime.datetime)): DCNL DCSP  DCSP dt = datetime.datetime.fromordinal(dt.toordinal()) DCNL DCSP has_tz = (dt.tzinfo is not None) DCNL DCSP if (show_tzinfo and has_tz): DCNL DCSP  DCSP ret = ''.join(dt.isoformat().rsplit(':', 1)) DCNL DCSP elif (show_tzinfo and (not has_tz)): DCNL DCSP  DCSP ret = ('%s+0000' % dt.isoformat().split('.')[0]) DCNL DCSP elif ((not show_tzinfo) and has_tz): DCNL DCSP  DCSP ret = dt.isoformat()[:(-6)] DCNL DCSP elif ((not show_tzinfo) and (not has_tz)): DCNL DCSP  DCSP ret = dt.isoformat().split('.')[0] DCNL DCSP return ret
def rfc2822_format(val): DCNL  DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, (datetime.datetime, datetime.date)): DCNL DCSP  DCSP val = time.mktime(val.timetuple()) DCNL DCSP if isinstance(val, numbers.Number): DCNL DCSP  DCSP return email.utils.formatdate(val) DCNL DCSP else: DCNL DCSP  DCSP return val
def to_timestamp(val): DCNL  DCSP if isinstance(val, numbers.Number): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, six.string_types): DCNL DCSP  DCSP dt = _parse_datetime_string(val) DCNL DCSP else: DCNL DCSP  DCSP dt = val DCNL DCSP return time.mktime(dt.timetuple())
def get_id(id_or_obj): DCNL  DCSP if isinstance(id_or_obj, (six.string_types + (int,))): DCNL DCSP  DCSP return id_or_obj DCNL DCSP try: DCNL DCSP  DCSP return id_or_obj.id DCNL DCSP except AttributeError: DCNL DCSP  DCSP return id_or_obj
def get_name(name_or_obj): DCNL  DCSP if isinstance(name_or_obj, six.string_types): DCNL DCSP  DCSP return name_or_obj DCNL DCSP try: DCNL DCSP  DCSP return name_or_obj.name DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exc.MissingName(name_or_obj)
def params_to_dict(params, dct): DCNL  DCSP for (param, val) in params.items(): DCNL DCSP  DCSP if (val is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP dct[param] = val DCNL DCSP return dct
def dict_to_qs(dct): DCNL  DCSP itms = [('%s=%s' % (key, val)) for (key, val) in list(dct.items()) if (val is not None)] DCNL DCSP return '&'.join(itms)
def match_pattern(nm, patterns): DCNL  DCSP patterns = coerce_to_list(patterns) DCNL DCSP for pat in patterns: DCNL DCSP  DCSP if fnmatch.fnmatch(nm, pat): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def update_exc(exc, msg, before=True, separator='\n'): DCNL  DCSP emsg = exc.message DCNL DCSP if before: DCNL DCSP  DCSP parts = (msg, separator, emsg) DCNL DCSP else: DCNL DCSP  DCSP parts = (emsg, separator, msg) DCNL DCSP new_msg = ('%s%s%s' % parts) DCNL DCSP new_args = ((new_msg,) + exc.args[1:]) DCNL DCSP exc.message = new_msg DCNL DCSP exc.args = new_args DCNL DCSP return exc
def case_insensitive_update(dct1, dct2): DCNL  DCSP lowkeys = dict([(key.lower(), key) for key in dct1]) DCNL DCSP for (key, val) in dct2.items(): DCNL DCSP  DCSP d1_key = lowkeys.get(key.lower(), key) DCNL DCSP  DCSP dct1[d1_key] = val
def env(*args, **kwargs): DCNL  DCSP for arg in args: DCNL DCSP  DCSP value = os.environ.get(arg, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('default', '')
def unauthenticated(fnc): DCNL  DCSP fnc.unauthenticated = True DCNL DCSP return fnc
def isunauthenticated(fnc): DCNL  DCSP return getattr(fnc, 'unauthenticated', False)
def safe_issubclass(*args): DCNL  DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(mod_str) DCNL DCSP return getattr(sys.modules[mod_str], class_str)
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, (six.string_types, six.binary_type))): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, six.text_type): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def to_slug(value, incoming=None, errors='strict'): DCNL  DCSP value = safe_decode(value, incoming, errors) DCNL DCSP value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii') DCNL DCSP value = SLUGIFY_STRIP_RE.sub('', value).strip().lower() DCNL DCSP return SLUGIFY_HYPHENATE_RE.sub('-', value)
def _id_type(ityp): DCNL  DCSP if (ityp.lower() == 'rackspace'): DCNL DCSP  DCSP ityp = 'rax_identity.RaxIdentity' DCNL DCSP elif (ityp.lower() == 'keystone'): DCNL DCSP  DCSP ityp = 'keystone_identity.KeystoneIdentity' DCNL DCSP return ityp
def get_environment(): DCNL  DCSP return settings.environment
def set_environment(env): DCNL  DCSP settings.environment = env
def list_environments(): DCNL  DCSP return settings.environments
def get_setting(key, env=None): DCNL  DCSP return settings.get(key, env=env)
def set_setting(key, val, env=None): DCNL  DCSP return settings.set(key, val, env=env)
def set_default_region(region): DCNL  DCSP global default_region DCNL DCSP default_region = region
def create_context(id_type=None, env=None, username=None, password=None, tenant_id=None, tenant_name=None, api_key=None, verify_ssl=None): DCNL  DCSP if env: DCNL DCSP  DCSP set_environment(env) DCNL DCSP return _create_identity(id_type=id_type, username=username, password=password, tenant_id=tenant_id, tenant_name=tenant_name, api_key=api_key, verify_ssl=verify_ssl, return_context=True)
def _create_identity(id_type=None, username=None, password=None, tenant_id=None, tenant_name=None, api_key=None, verify_ssl=None, return_context=False): DCNL  DCSP if id_type: DCNL DCSP  DCSP cls = _import_identity(id_type) DCNL DCSP else: DCNL DCSP  DCSP cls = settings.get('identity_class') DCNL DCSP if (not cls): DCNL DCSP  DCSP raise exc.IdentityClassNotDefined('No DCSP identity DCSP class DCSP has DCSP been DCSP defined DCSP for DCSP the DCSP current DCSP environment.') DCNL DCSP if (verify_ssl is None): DCNL DCSP  DCSP verify_ssl = get_setting('verify_ssl') DCNL DCSP context = cls(username=username, password=password, tenant_id=tenant_id, tenant_name=tenant_name, api_key=api_key, verify_ssl=verify_ssl) DCNL DCSP if return_context: DCNL DCSP  DCSP return context DCNL DCSP else: DCNL DCSP  DCSP global identity DCNL DCSP  DCSP identity = context
def _assure_identity(fnc): DCNL  DCSP def _wrapped(*args, **kwargs): DCNL DCSP  DCSP if (identity is None): DCNL DCSP  DCSP  DCSP _create_identity() DCNL DCSP  DCSP return fnc(*args, **kwargs) DCNL DCSP return _wrapped
def _require_auth(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP @_assure_identity DCNL DCSP def _wrapped(*args, **kwargs): DCNL DCSP  DCSP if (not identity.authenticated): DCNL DCSP  DCSP  DCSP msg = ("Authentication DCSP required DCSP before DCSP calling DCSP '%s'." % fnc.__name__) DCNL DCSP  DCSP  DCSP raise exc.NotAuthenticated(msg) DCNL DCSP  DCSP return fnc(*args, **kwargs) DCNL DCSP return _wrapped
def _safe_region(region=None, context=None): DCNL  DCSP ret = (region or settings.get('region')) DCNL DCSP context = (context or identity) DCNL DCSP if (not ret): DCNL DCSP  DCSP if (not context): DCNL DCSP  DCSP  DCSP _create_identity() DCNL DCSP  DCSP  DCSP context = identity DCNL DCSP  DCSP ret = context.get_default_region() DCNL DCSP if (not ret): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ret = regions[0] DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP ret = '' DCNL DCSP return ret
@_assure_identity DCNL def auth_with_token(token, tenant_id=None, tenant_name=None, region=None): DCNL  DCSP global regions, services DCNL DCSP identity.auth_with_token(token, tenant_id=tenant_id, tenant_name=tenant_name) DCNL DCSP regions = tuple(identity.regions) DCNL DCSP services = tuple(identity.services.keys()) DCNL DCSP connect_to_services(region=region)
@_assure_identity DCNL def set_credentials(username, api_key=None, password=None, region=None, tenant_id=None, authenticate=True): DCNL  DCSP global regions, services DCNL DCSP pw_key = (password or api_key) DCNL DCSP region = _safe_region(region) DCNL DCSP tenant_id = (tenant_id or settings.get('tenant_id')) DCNL DCSP identity.set_credentials(username=username, password=pw_key, tenant_id=tenant_id, region=region, authenticate=authenticate) DCNL DCSP regions = tuple(identity.regions) DCNL DCSP services = tuple(identity.services.keys()) DCNL DCSP connect_to_services(region=region)
@_assure_identity DCNL def set_credential_file(cred_file, region=None, authenticate=True): DCNL  DCSP global regions, services DCNL DCSP region = _safe_region(region) DCNL DCSP identity.set_credential_file(cred_file, region=region, authenticate=authenticate) DCNL DCSP regions = tuple(identity.regions) DCNL DCSP services = tuple(identity.services.keys()) DCNL DCSP connect_to_services(region=region)
def keyring_auth(username=None, region=None, authenticate=True): DCNL  DCSP if (not keyring): DCNL DCSP  DCSP raise exc.KeyringModuleNotInstalled("The DCSP 'keyring' DCSP Python DCSP module DCSP is DCSP not DCSP installed DCSP on DCSP this DCSP system.") DCNL DCSP if (username is None): DCNL DCSP  DCSP username = settings.get('keyring_username') DCNL DCSP if (not username): DCNL DCSP  DCSP raise exc.KeyringUsernameMissing('No DCSP username DCSP specified DCSP for DCSP keyring DCSP authentication.') DCNL DCSP password = keyring.get_password('pyrax', username) DCNL DCSP if (password is None): DCNL DCSP  DCSP raise exc.KeyringPasswordNotFound(("No DCSP password DCSP was DCSP found DCSP for DCSP the DCSP username DCSP '%s'." % username)) DCNL DCSP set_credentials(username, password, region=region, authenticate=authenticate)
@_assure_identity DCNL def authenticate(connect=True): DCNL  DCSP identity.authenticate()
def clear_credentials(): DCNL  DCSP global identity, regions, services, cloudservers, cloudfiles, cloud_cdn DCNL DCSP global cloud_loadbalancers, cloud_databases, cloud_blockstorage, cloud_dns DCNL DCSP global cloud_networks, cloud_monitoring, autoscale, images, queues DCNL DCSP identity = None DCNL DCSP regions = tuple() DCNL DCSP services = tuple() DCNL DCSP cloudservers = None DCNL DCSP cloudfiles = None DCNL DCSP cloud_cdn = None DCNL DCSP cloud_loadbalancers = None DCNL DCSP cloud_databases = None DCNL DCSP cloud_blockstorage = None DCNL DCSP cloud_dns = None DCNL DCSP cloud_networks = None DCNL DCSP cloud_monitoring = None DCNL DCSP autoscale = None DCNL DCSP images = None DCNL DCSP queues = None
def _make_agent_name(base): DCNL  DCSP if base: DCNL DCSP  DCSP if ('pyrax' in base): DCNL DCSP  DCSP  DCSP return base DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('%s DCSP %s' % (USER_AGENT, base)) DCNL DCSP else: DCNL DCSP  DCSP return USER_AGENT
def connect_to_services(region=None): DCNL  DCSP global cloudservers, cloudfiles, cloud_loadbalancers, cloud_databases DCNL DCSP global cloud_blockstorage, cloud_dns, cloud_networks, cloud_monitoring DCNL DCSP global autoscale, images, queues, cloud_cdn DCNL DCSP cloudservers = connect_to_cloudservers(region=region) DCNL DCSP cloudfiles = connect_to_cloudfiles(region=region) DCNL DCSP cloud_cdn = connect_to_cloud_cdn(region=region) DCNL DCSP cloud_loadbalancers = connect_to_cloud_loadbalancers(region=region) DCNL DCSP cloud_databases = connect_to_cloud_databases(region=region) DCNL DCSP cloud_blockstorage = connect_to_cloud_blockstorage(region=region) DCNL DCSP cloud_dns = connect_to_cloud_dns(region=region) DCNL DCSP cloud_networks = connect_to_cloud_networks(region=region) DCNL DCSP cloud_monitoring = connect_to_cloud_monitoring(region=region) DCNL DCSP autoscale = connect_to_autoscale(region=region) DCNL DCSP images = connect_to_images(region=region) DCNL DCSP queues = connect_to_queues(region=region)
def _get_service_endpoint(context, svc, region=None, public=True): DCNL  DCSP region = _safe_region(region) DCNL DCSP context = (context or identity) DCNL DCSP url_type = {True: 'public', False: 'private'}[public] DCNL DCSP svc_obj = context.services.get(svc) DCNL DCSP if (not svc_obj): DCNL DCSP  DCSP return None DCNL DCSP ep = svc_obj.endpoints.get(region, {}).get(url_type) DCNL DCSP if (not ep): DCNL DCSP  DCSP ep = svc_obj.endpoints.get('ALL', {}).get(url_type) DCNL DCSP return ep
def connect_to_cloudservers(region=None, context=None, verify_ssl=None, **kwargs): DCNL  DCSP context = (context or identity) DCNL DCSP _cs_auth_plugin.discover_auth_systems() DCNL DCSP id_type = get_setting('identity_type') DCNL DCSP if (id_type != 'keystone'): DCNL DCSP  DCSP auth_plugin = _cs_auth_plugin.load_plugin(id_type) DCNL DCSP else: DCNL DCSP  DCSP auth_plugin = None DCNL DCSP region = _safe_region(region, context=context) DCNL DCSP mgt_url = _get_service_endpoint(context, 'compute', region) DCNL DCSP cloudservers = None DCNL DCSP if (not mgt_url): DCNL DCSP  DCSP return DCNL DCSP if (verify_ssl is None): DCNL DCSP  DCSP insecure = (not get_setting('verify_ssl')) DCNL DCSP else: DCNL DCSP  DCSP insecure = (not verify_ssl) DCNL DCSP try: DCNL DCSP  DCSP extensions = nc.discover_extensions(_cs_max_version) DCNL DCSP except AttributeError: DCNL DCSP  DCSP extensions = None DCNL DCSP clt_class = _cs_client.get_client_class(_cs_max_version) DCNL DCSP cloudservers = clt_class(context.username, context.password, project_id=context.tenant_id, auth_url=context.auth_endpoint, auth_system=id_type, region_name=region, service_type='compute', auth_plugin=auth_plugin, insecure=insecure, extensions=extensions, http_log_debug=_http_debug, **kwargs) DCNL DCSP agt = cloudservers.client.USER_AGENT DCNL DCSP cloudservers.client.USER_AGENT = _make_agent_name(agt) DCNL DCSP cloudservers.client.management_url = mgt_url DCNL DCSP cloudservers.client.auth_token = context.token DCNL DCSP cloudservers.exceptions = _cs_exceptions DCNL DCSP cloudservers.list_images = cloudservers.images.list DCNL DCSP cloudservers.list_flavors = cloudservers.flavors.list DCNL DCSP cloudservers.list = cloudservers.servers.list DCNL DCSP def list_base_images(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP base DCSP images; DCSP excludes DCSP any DCSP images DCSP created\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP by DCSP this DCSP account.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in cloudservers.images.list() if (not hasattr(image, 'server'))] DCNL DCSP def list_snapshots(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP all DCSP images DCSP created DCSP by DCSP this DCSP account; DCSP in DCSP other DCSP words, DCSP it\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP excludes DCSP all DCSP the DCSP base DCSP images.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in cloudservers.images.list() if hasattr(image, 'server')] DCNL DCSP def find_images_by_name(expr): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP a DCSP list DCSP of DCSP images DCSP whose DCSP name DCSP contains DCSP the DCSP specified DCSP expression.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP value DCSP passed DCSP is DCSP treated DCSP as DCSP a DCSP regular DCSP expression, DCSP allowing DCSP for DCSP more\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP specific DCSP searches DCSP than DCSP simple DCSP wildcards. DCSP The DCSP matching DCSP is DCSP done DCSP in DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP case-insensitive DCSP manner.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return [image for image in cloudservers.images.list() if re.search(expr, image.name, re.I)] DCNL DCSP cloudservers.list_base_images = list_base_images DCNL DCSP cloudservers.list_snapshots = list_snapshots DCNL DCSP cloudservers.find_images_by_name = find_images_by_name DCNL DCSP cloudservers.identity = identity DCNL DCSP return cloudservers
def connect_to_cloudfiles(region=None, public=None): DCNL  DCSP if (public is None): DCNL DCSP  DCSP is_public = (not bool(get_setting('use_servicenet'))) DCNL DCSP else: DCNL DCSP  DCSP is_public = public DCNL DCSP ret = _create_client(ep_name='object_store', region=region, public=is_public) DCNL DCSP if ret: DCNL DCSP  DCSP region = _safe_region(region) DCNL DCSP  DCSP ret.cdn_management_url = _get_service_endpoint(None, 'object_cdn', region, public=is_public) DCNL DCSP return ret
def connect_to_cloud_databases(region=None): DCNL  DCSP return _create_client(ep_name='database', region=region)
def connect_to_cloud_cdn(region=None): DCNL  DCSP return _create_client(ep_name='cdn', region=region)
def connect_to_cloud_loadbalancers(region=None): DCNL  DCSP return _create_client(ep_name='load_balancer', region=region)
def connect_to_cloud_blockstorage(region=None): DCNL  DCSP return _create_client(ep_name='volume', region=region)
def connect_to_cloud_dns(region=None): DCNL  DCSP return _create_client(ep_name='dns', region=region)
def connect_to_cloud_networks(region=None): DCNL  DCSP return _create_client(ep_name='compute:network', region=region)
def connect_to_cloud_monitoring(region=None): DCNL  DCSP return _create_client(ep_name='monitor', region=region)
def connect_to_autoscale(region=None): DCNL  DCSP return _create_client(ep_name='autoscale', region=region)
def connect_to_images(region=None, public=True): DCNL  DCSP return _create_client(ep_name='image', region=region, public=public)
def connect_to_queues(region=None, public=True): DCNL  DCSP return _create_client(ep_name='queues', region=region, public=public)
def client_class_for_service(service): DCNL  DCSP return _client_classes.get(service)
def get_encoding(): DCNL  DCSP return (settings.get('encoding') or default_encoding)
def assure_image(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, img, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(img, Image)): DCNL DCSP  DCSP  DCSP img = self._manager.get(img) DCNL DCSP  DCSP return fnc(self, img, *args, **kwargs) DCNL DCSP return _wrapped
def assure_check(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, check, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(check, CloudMonitorCheck)): DCNL DCSP  DCSP  DCSP check = self._check_manager.get(check) DCNL DCSP  DCSP return fnc(self, check, *args, **kwargs) DCNL DCSP return _wrapped
def assure_entity(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, entity, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(entity, CloudMonitorEntity)): DCNL DCSP  DCSP  DCSP entity = self._entity_manager.get(entity) DCNL DCSP  DCSP return fnc(self, entity, *args, **kwargs) DCNL DCSP return _wrapped
def assure_container(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, container, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(container, Container)): DCNL DCSP  DCSP  DCSP container = self.get(container) DCNL DCSP  DCSP return fnc(self, container, *args, **kwargs) DCNL DCSP return _wrapped
def _massage_metakeys(dct, prfx): DCNL  DCSP lowprefix = prfx.lower() DCNL DCSP ret = {} DCNL DCSP for (k, v) in list(dct.items()): DCNL DCSP  DCSP if (not k.lower().startswith(lowprefix)): DCNL DCSP  DCSP  DCSP k = ('%s%s' % (prfx, k)) DCNL DCSP  DCSP ret[k] = v DCNL DCSP return ret
def get_file_size(fileobj): DCNL  DCSP currpos = fileobj.tell() DCNL DCSP fileobj.seek(0, 2) DCNL DCSP total_size = fileobj.tell() DCNL DCSP fileobj.seek(currpos) DCNL DCSP return total_size
def from_response(response, body): DCNL  DCSP if isinstance(response, dict): DCNL DCSP  DCSP status = response.get('status_code') DCNL DCSP else: DCNL DCSP  DCSP status = response.status_code DCNL DCSP cls = _code_map.get(int(status), ClientException) DCNL DCSP request_id = response.headers.get('x-compute-request-id') DCNL DCSP if body: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP details = 'n/a' DCNL DCSP  DCSP if isinstance(body, dict): DCNL DCSP  DCSP  DCSP message = body.get('message') DCNL DCSP  DCSP  DCSP details = body.get('details') DCNL DCSP  DCSP  DCSP if (message is details is None): DCNL DCSP  DCSP  DCSP  DCSP error = body[body.keys()[0]] DCNL DCSP  DCSP  DCSP  DCSP if isinstance(error, dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP details = error.get('details', None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = error DCNL DCSP  DCSP  DCSP  DCSP  DCSP details = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = body DCNL DCSP  DCSP return cls(code=status, message=message, details=details, request_id=request_id) DCNL DCSP else: DCNL DCSP  DCSP return cls(code=status, request_id=request_id)
def assure_queue(fnc): DCNL  DCSP @wraps(fnc) DCNL DCSP def _wrapped(self, queue, *args, **kwargs): DCNL DCSP  DCSP if (not isinstance(queue, Queue)): DCNL DCSP  DCSP  DCSP queue = self._manager.get(queue) DCNL DCSP  DCSP return fnc(self, queue, *args, **kwargs) DCNL DCSP return _wrapped
def option_chooser(options, attr=None): DCNL  DCSP for (num, option) in enumerate(options): DCNL DCSP  DCSP if attr: DCNL DCSP  DCSP  DCSP print(('%s: DCSP %s' % (num, getattr(option, attr)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print(('%s: DCSP %s' % (num, option))) DCNL DCSP escape_opt = (num + 1) DCNL DCSP print(('%s: DCSP I DCSP want DCSP to DCSP exit!' % escape_opt)) DCNL DCSP choice = six.moves.input('Selection: DCSP ') DCNL DCSP try: DCNL DCSP  DCSP ichoice = int(choice) DCNL DCSP  DCSP if (ichoice > escape_opt): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Valid DCSP entries DCSP are DCSP the DCSP numbers DCSP 0-%s. DCSP Received DCSP '%s'." % (escape_opt, choice))) DCNL DCSP  DCSP sys.exit() DCNL DCSP if (ichoice == escape_opt): DCNL DCSP  DCSP print('Bye!') DCNL DCSP  DCSP sys.exit() DCNL DCSP return ichoice
def safe_int(val, allow_zero=True): DCNL  DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) and (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
def safe_int(val, allow_zero=True): DCNL  DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) and (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
def safe_int(val, allow_zero=True): DCNL  DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) and (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
def safe_int(val, allow_zero=True): DCNL  DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) and (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
def safe_int(val, allow_zero=True): DCNL  DCSP try: DCNL DCSP  DCSP ret = int(val) DCNL DCSP except ValueError: DCNL DCSP  DCSP print(("Sorry, DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP integer." % val)) DCNL DCSP  DCSP return False DCNL DCSP if ((not allow_zero) and (ret == 0)): DCNL DCSP  DCSP print('Please DCSP enter DCSP a DCSP non-zero DCSP integer.') DCNL DCSP  DCSP return False DCNL DCSP return ret
def _safe_id(): DCNL  DCSP val = utils.random_ascii() DCNL DCSP for bad in '#;/?': DCNL DCSP  DCSP val = val.replace(bad, '') DCNL DCSP return val
def strip_headers(post): DCNL  DCSP if ('\n\n' in post): DCNL DCSP  DCSP (headers, body) = post.split('\n\n', 1) DCNL DCSP  DCSP return body.lower() DCNL DCSP else: DCNL DCSP  DCSP return post.lower()
def remove_outputs(nb): DCNL  DCSP for ws in nb.worksheets: DCNL DCSP  DCSP for cell in ws.cells: DCNL DCSP  DCSP  DCSP if (cell.cell_type == 'code'): DCNL DCSP  DCSP  DCSP  DCSP cell.outputs = [] DCNL DCSP  DCSP  DCSP  DCSP if ('prompt_number' in cell): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del cell['prompt_number']
def encoder_type(encode): DCNL  DCSP return {'0': '', '1': 'shikata_ga_nai', '2': '', '3': 'MULTIENCODE', '4': 'BACKDOOR'}.get(encode, 'ERROR')
def ms_module(exploit): DCNL  DCSP return {'1': 'exploit/multi/browser/adobe_flash_hacking_team_uaf', '2': 'exploit/multi/browser/adobe_flash_nellymoser_bof', '3': 'exploit/multi/browser/adobe_flash_shader_drawing_fill', '4': 'exploit/windows/browser/ms14_012_textrange', '5': 'exploit/windows/browser/ms14_012_cmarkup_uaf', '6': 'exploit/windows/browser/ms13_080_cdisplaypointer', '7': 'exploit/windows/browser/ie_setmousecapture_uaf', '8': 'exploit/multi/browser/java_jre17_jmxbean_2', '9': 'exploit/multi/browser/java_jre17_jmxbean', '10': 'exploit/windows/browser/ms13_009_ie_slayoutrun_uaf', '11': 'exploit/windows/browser/ie_cbutton_uaf', '12': 'exploit/multi/browser/java_jre17_exec', '13': 'exploit/windows/browser/ie_execcommand_uaf', '14': 'exploit/multi/browser/java_atomicreferencearray', '15': 'exploit/multi/browser/java_verifier_field_access', '16': 'exploit/windows/browser/ms12_037_same_id', '17': 'exploit/windows/browser/msxml_get_definition_code_exec', '18': 'exploit/windows/browser/adobe_flash_rtmp', '19': 'exploit/windows/browser/adobe_flash_mp4_cprt', '20': 'exploit/windows/browser/ms12_004_midi', '21': 'multi/browser/java_rhino\nset DCSP target DCSP 1', '22': 'windows/browser/ms11_050_mshtml_cobjectelement', '23': 'windows/browser/adobe_flashplayer_flash10o', '24': 'windows/browser/cisco_anyconnect_exec', '25': 'windows/browser/ms11_003_ie_css_import', '26': 'windows/browser/wmi_admintools', '27': 'windows/browser/ms10_090_ie_css_clip', '28': 'windows/browser/java_codebase_trust', '29': 'windows/browser/java_docbase_bof', '30': 'windows/browser/webdav_dll_hijacker', '31': 'windows/browser/adobe_flashplayer_avm', '32': 'windows/browser/adobe_shockwave_rcsl_corruption', '33': 'windows/browser/adobe_cooltype_sing', '34': 'windows/browser/apple_quicktime_marshaled_punk', '35': 'windows/browser/ms10_042_helpctr_xss_cmd_exec', '36': 'windows/browser/ms10_018_ie_behaviors', '37': 'windows/browser/ms10_002_aurora', '38': 'windows/browser/ms10_018_ie_tabular_activex', '39': 'windows/browser/ms09_002_memory_corruption', '40': 'windows/browser/ms09_072_style_object', '41': 'windows/browser/ie_iscomponentinstalled', '42': 'windows/browser/ms08_078_xml_corruption', '43': 'windows/browser/ie_unsafe_scripting', '44': 'multi/browser/firefox_escape_retval', '45': 'windows/browser/mozilla_mchannel', '46': 'auxiliary/server/browser_autopwn'}.get(exploit, 'ERROR')
def ms_payload(payload): DCNL  DCSP return {'1': 'windows/shell_reverse_tcp', '2': 'windows/meterpreter/reverse_tcp', '3': 'windows/vncinject/reverse_tcp', '4': 'windows/x64/shell_reverse_tcp', '5': 'windows/x64/meterpreter/reverse_tcp', '6': 'windows/meterpreter/reverse_tcp_allports', '7': 'windows/meterpreter/reverse_https', '8': 'windows/meterpreter/reverse_tcp_dns', '9': 'windows/download_exec'}.get(payload, 'ERROR')
def ms_payload_2(payload): DCNL  DCSP return {'1': 'shellcode/pyinject', '2': 'shellcode/multipyinject', '3': 'set/reverse_shell', '4': 'set/reverse_shell', '5': 'set/reverse_shell', '6': 'shellcode/alphanum'}.get(payload, 'ERROR')
def ms_payload_3(payload): DCNL  DCSP return {'1': 'windows/shell_reverse_tcp', '2': 'windows/meterpreter/reverse_tcp', '3': 'windows/vncinject/reverse_tcp', '4': 'windows/x64/shell_reverse_tcp', '5': 'windows/x64/meterpreter/reverse_tcp', '6': 'windows/x64/shell_bind_tcp', '7': 'windows/meterpreter/reverse_https'}.get(payload, 'ERROR')
def ms_attacks(exploit): DCNL  DCSP return {'1': 'dll_hijacking', '2': 'unc_embed', '3': 'exploit/windows/fileformat/ms15_100_mcl_exe', '4': 'exploit/windows/fileformat/ms14_017_rtf', '5': 'exploit/windows/fileformat/ms11_006_createsizeddibsection', '6': 'exploit/windows/fileformat/ms10_087_rtf_pfragments_bof', '7': 'exploit/windows/fileformat/adobe_flashplayer_button', '8': 'exploit/windows/fileformat/adobe_cooltype_sing', '9': 'exploit/windows/fileformat/adobe_flashplayer_newfunction', '10': 'exploit/windows/fileformat/adobe_collectemailinfo', '11': 'exploit/windows/fileformat/adobe_geticon', '12': 'exploit/windows/fileformat/adobe_jbig2decode', '13': 'exploit/windows/fileformat/adobe_pdf_embedded_exe', '14': 'exploit/windows/fileformat/adobe_utilprintf', '15': 'custom/exe/to/vba/payload', '16': 'exploit/windows/fileformat/adobe_u3d_meshdecl', '17': 'exploit/windows/fileformat/adobe_pdf_embedded_exe_nojs', '18': 'exploit/windows/fileformat/foxit_title_bof', '19': 'exploit/windows/fileformat/apple_quicktime_pnsize', '20': 'exploit/windows/fileformat/nuance_pdf_launch_overflow', '21': 'exploit/windows/fileformat/adobe_reader_u3d', '22': 'exploit/windows/fileformat/ms12_027_mscomctl_bof'}.get(exploit, 'INVALID')
def teensy_config(choice): DCNL  DCSP return {'1': 'powershell_down.ino', '2': 'wscript.ino', '3': 'powershell_reverse.ino', '4': 'beef.ino', '5': 'java_applet.ino', '6': 'gnome_wget.ino'}.get(choice, 'ERROR')
def webattack_vector(attack_vector): DCNL  DCSP return {'1': 'java', '2': 'browser', '3': 'harvester', '4': 'tabnapping', '5': 'webjacking', '6': 'multiattack', '7': 'fsattack'}.get(attack_vector, 'ERROR')
def category(category): DCNL  DCSP return {'0': '0', '1': 'phishing', '2': 'webattack', '3': 'infectious', '4': 'payloads', '5': 'mailer', '6': 'arduino', '7': 'sms', '8': 'wireless', '9': 'modules', '10': 'cloner', '11': 'harvester', '12': 'tabnapping', '13': 'teensy', '14': 'binary2teensy', '15': 'dll_hijacking', '16': 'multiattack', '17': 'java_applet', '18': 'encoding', '19': 'fasttrack', '20': 'autopwn', '21': 'mssql', '22': 'scan', '23': 'direct', '24': 'exploits', '25': 'active_target', '26': 'shell', '27': 'set', '28': 'teensy2powershell', '29': 'powershell', '30': 'delldrac', '31': 'ridenum', '32': 'psexec', '33': 'fsattack'}.get(category, 'ERROR')
def value_type(value): DCNL  DCSP return {'METASPLOIT_PATH': True, 'METASPLOIT_DATABASE': True, 'ENCOUNT': False, 'AUTO_MIGRATE': False, 'CUSTOM_EXE': True, 'BACKDOOR_EXECUTION': False, 'METERPRETER_MULTI_SCRIPT': False, 'LINUX_METERPRETER_MULTI_SCRIPT': False, 'METERPRETER_MULTI_COMMANDS': True, 'LINUX_METERPRETER_MULTI_COMMANDS': True, 'METASPLOIT_IFRAME_PORT': False, 'ETTERCAP': False, 'ETTERCAP_PATH': True, 'ETTERCAP_DSNIFF_INTERFACE': True, 'DSNIFF': False, 'AUTO_DETECT': False, 'SENDMAIL': False, 'EMAIL_PROVIDER': True, 'WEBATTACK_EMAIL': False, 'APACHE_SERVER': False, 'APACHE_DIRECTORY': True, 'WEB_PORT': False, 'JAVA_ID_PARAM': True, 'JAVA_REPEATER': False, 'JAVA_TIME': True, 'WEBATTACK_SSL': False, 'SELF_SIGNED_CERT': False, 'PEM_CLIENT': True, 'PEM_SERVER': True, 'WEBJACKING_TIME': False, 'COMMAND_CENTER_INTERFACE': True, 'COMMAND_CENTER_PORT': False, 'SET_INTERACTIVE_SHELL': False, 'TERMINAL': True, 'DIGITAL_SIGNATURE_STEAL': False, 'UPX_ENCODE': False, 'UPX_PATH': True, 'AUTO_REDIRECT': False, 'HARVESTER_REDIRECT': False, 'HARVESTER_URL': True, 'UNC_EMBED': False, 'ACCESS_POINT_SSID': True, 'AIRBASE_NG_PATH': True, 'DNSSPOOF_PATH': True, 'AP_CHANNEL': False, 'POWERSHELL_INJECTION': False, 'POWERSHELL_VERBOSE': False, 'WEB_PROFILER': False, 'OSX_REVERSE_PORT': False, 'LINUX_REVERSE_PORT': False, 'USER_AGENT_STRING': True, 'SET_SHELL_STAGER': False, 'AUTOMATIC_LISTENER': False, 'METASPLOIT_MODE': False, 'HARVESTER_LOG': True, 'STAGE_ENCODING': False, 'TRACK_EMAIL_ADDRESSES': False, 'WGET_DEEP': True}.get(value, 'ERROR')
def getfqdn(name=''): DCNL  DCSP name = name.strip() DCNL DCSP if ((not name) or (name == '0.0.0.0')): DCNL DCSP  DCSP name = gethostname() DCNL DCSP try: DCNL DCSP  DCSP (hostname, aliases, ipaddrs) = gethostbyaddr(name) DCNL DCSP except error: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP aliases.insert(0, hostname) DCNL DCSP  DCSP for name in aliases: DCNL DCSP  DCSP  DCSP if ('.' in name): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP name = hostname DCNL DCSP return name
def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None): DCNL  DCSP (host, port) = address DCNL DCSP err = None DCNL DCSP for res in getaddrinfo(host, port, 0, SOCK_STREAM): DCNL DCSP  DCSP (af, socktype, proto, canonname, sa) = res DCNL DCSP  DCSP sock = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = socket(af, socktype, proto) DCNL DCSP  DCSP  DCSP if (timeout is not _GLOBAL_DEFAULT_TIMEOUT): DCNL DCSP  DCSP  DCSP  DCSP sock.settimeout(timeout) DCNL DCSP  DCSP  DCSP if source_address: DCNL DCSP  DCSP  DCSP  DCSP sock.bind(source_address) DCNL DCSP  DCSP  DCSP sock.connect(sa) DCNL DCSP  DCSP  DCSP return sock DCNL DCSP  DCSP except error as _: DCNL DCSP  DCSP  DCSP err = _ DCNL DCSP  DCSP  DCSP if (sock is not None): DCNL DCSP  DCSP  DCSP  DCSP sock.close() DCNL DCSP if (err is not None): DCNL DCSP  DCSP raise err DCNL DCSP else: DCNL DCSP  DCSP raise error('getaddrinfo DCSP returns DCSP an DCSP empty DCSP list')
def is_valid_ipv6(ip): DCNL  DCSP pattern = re.compile('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ^\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s* DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Leading DCSP whitespace\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?!.*::.*::) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Only DCSP a DCSP single DCSP whildcard DCSP allowed\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?!:)|:(?=:)) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP iff DCSP it DCSP would DCSP be DCSP part DCSP of DCSP a DCSP wildcard\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Repeat DCSP 6 DCSP times:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP A DCSP group DCSP of DCSP at DCSP most DCSP four DCSP hexadecimal DCSP digits\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?<=::)|(?<!::):) DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP unless DCSP preceeded DCSP by DCSP wildcard\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ){6} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Either\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Another DCSP group\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:(?<=::)|(?<!::):) DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP unless DCSP preceeded DCSP by DCSP wildcard\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [0-9a-f]{0,4} DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Last DCSP group\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP (?<=::) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Colon DCSP iff DCSP preceeded DCSP by DCSP exacly DCSP one DCSP colon\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP (?<!:) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP (?<=:) DCSP (?<!::) DCSP : DCSP  DCSP  DCSP  DCSP #\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP OR\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP A DCSP v4 DCSP address DCSP with DCSP NO DCSP leading DCSP zeros\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:25[0-4]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?: DCSP \\.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?:25[0-4]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ){3}\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\s* DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Trailing DCSP whitespace\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP $\n DCSP  DCSP  DCSP  DCSP ', ((re.VERBOSE | re.IGNORECASE) | re.DOTALL)) DCNL DCSP return (pattern.match(ip) is not None)
def capture(func, *args, **kwargs): DCNL  DCSP (stdout, stderr) = (sys.stdout, sys.stderr) DCNL DCSP sys.stdout = c1 = io.StringIO() DCNL DCSP sys.stderr = c2 = io.StringIO() DCNL DCSP result = None DCNL DCSP try: DCNL DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP except: DCNL DCSP  DCSP traceback.print_exc() DCNL DCSP sys.stdout = stdout DCNL DCSP sys.stderr = stderr DCNL DCSP return (result, c1.getvalue(), c2.getvalue())
def launch(): DCNL  DCSP core.print_status('Launching DCSP Metasploit DCSP and DCSP attacking DCSP the DCSP systems DCSP specified. DCSP This DCSP may DCSP take DCSP a DCSP moment..') DCNL DCSP try: DCNL DCSP  DCSP child = pexpect.spawn('{0} DCSP -r DCSP {1}\r\n\r\n'.format(os.path.join((core.meta_path + 'msfconsole')), os.path.join((core.setdir + 'autopwn.answer')))) DCNL DCSP  DCSP child.interact() DCNL DCSP except Exception as error: DCNL DCSP  DCSP core.log(error)
def load_version(): DCNL  DCSP globals_dict = {} DCNL DCSP with codecs.open(os.path.join('imblearn', 'version.py'), encoding='utf-8-sig') as fp: DCNL DCSP  DCSP exec fp.read() in globals_dict DCNL DCSP return globals_dict
def test_bc_sk_estimator(): DCNL  DCSP check_estimator(BalanceCascade)
def test_bc_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP bc = BalanceCascade(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP bc = BalanceCascade(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP bc = BalanceCascade(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP bc = BalanceCascade(ratio=ratio) DCNL DCSP assert_raises(ValueError, bc.fit, X, Y)
def test_bc_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(bc.ratio, ratio) DCNL DCSP assert_equal(bc.bootstrap, True) DCNL DCSP assert_equal(bc.n_max_subset, None) DCNL DCSP assert_equal(bc.random_state, RND_SEED)
def test_bc_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y_single_class)
def test_bc_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, bc.fit_sample, X, Y)
def test_bc_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP bc.fit(X, Y) DCNL DCSP assert_equal(bc.min_c_, 0) DCNL DCSP assert_equal(bc.maj_c_, 1) DCNL DCSP assert_equal(bc.stats_c_[0], 8) DCNL DCSP assert_equal(bc.stats_c_[1], 12)
def test_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, bc.sample, X, Y)
def test_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, bootstrap=False) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 14, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_fit_sample_half(): DCNL  DCSP ratio = 0.8 DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, bootstrap=False) DCNL DCSP (X_resampled, y_resampled) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)], [0.9281014, 0.53085498], [0.3084254, 0.33299982]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.28893132, (-0.38761769)]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx])
def test_fit_sample_auto_decision_tree(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'decision-tree' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_fit_sample_auto_random_forest(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'random-forest' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_fit_sample_auto_adaboost(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'adaboost' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 16, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_fit_sample_auto_gradient_boosting(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'gradient-boosting' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 16, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_fit_sample_auto_linear_svm(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'linear-svm' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_init_wrong_classifier(): DCNL  DCSP classifier = 'rnd' DCNL DCSP bc = BalanceCascade(classifier=classifier) DCNL DCSP assert_raises(NotImplementedError, bc.fit_sample, X, Y)
def test_fit_sample_auto_early_stop(): DCNL  DCSP ratio = 'auto' DCNL DCSP n_subset = 1 DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, n_max_subset=n_subset) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]]) DCNL DCSP y_gt = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]) DCNL DCSP idx_gt = np.array([[0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_fit_sample_auto_early_stop_2(): DCNL  DCSP ratio = 'auto' DCNL DCSP n_subset = 2 DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, n_max_subset=n_subset, bootstrap=False) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.70472253, (-0.73309052)], [(-0.18410027), (-0.45194484)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 8, 14, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_sample_wrong_X(): DCNL  DCSP bc = BalanceCascade(random_state=RND_SEED) DCNL DCSP bc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, bc.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP bc = BalanceCascade(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP bc = BalanceCascade(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y)
def test_give_classifier_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = RandomForestClassifier(random_state=RND_SEED) DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, estimator=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_give_classifier_wrong_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 2 DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, estimator=classifier) DCNL DCSP assert_raises(ValueError, bc.fit_sample, X, Y)
def test_rf_wth_bootstrap(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = RandomForestClassifier(random_state=RND_SEED) DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, estimator=classifier, bootstrap=False) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])
def test_ee_sk_estimator(): DCNL  DCSP check_estimator(EasyEnsemble)
def test_ee_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y)
def test_ee_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(ee.ratio, ratio) DCNL DCSP assert_equal(ee.replacement, False) DCNL DCSP assert_equal(ee.n_subsets, 10) DCNL DCSP assert_equal(ee.random_state, RND_SEED)
def test_ee_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ee.fit, X, y_single_class)
def test_ee_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ee.fit, X, Y)
def test_ee_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED) DCNL DCSP ee.fit(X, Y) DCNL DCSP assert_equal(ee.min_c_, 0) DCNL DCSP assert_equal(ee.maj_c_, 1) DCNL DCSP assert_equal(ee.stats_c_[0], 2) DCNL DCSP assert_equal(ee.stats_c_[2], 3) DCNL DCSP assert_equal(ee.stats_c_[1], 5)
def test_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ee.sample, X, Y)
def test_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED, return_indices=True, n_subsets=3) DCNL DCSP (X_resampled, y_resampled, idx_under) = ee.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [1.35269503, 0.44812421], [0.5220963, 0.11349303], [1.10915364, 0.05718352], [0.22039505, 0.26469445]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [(-2.10724436), 0.70263997], [0.22039505, 0.26469445], [1.10915364, 0.05718352]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [0.5220963, 0.11349303], [1.10915364, 0.05718352], [0.59091459, 0.40692742]]]) DCNL DCSP y_gt = np.array([[0, 0, 1, 1, 2, 2], [0, 0, 1, 1, 2, 2], [0, 0, 1, 1, 2, 2]]) DCNL DCSP idx_gt = np.array([[5, 9, 4, 0, 2, 3], [5, 9, 8, 6, 3, 2], [5, 9, 8, 0, 2, 1]]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_fit_sample_half(): DCNL  DCSP ratio = 0.6 DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=RND_SEED, n_subsets=3) DCNL DCSP (X_resampled, y_resampled) = ee.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [1.35269503, 0.44812421], [0.5220963, 0.11349303], [(-2.10724436), 0.70263997], [1.10915364, 0.05718352], [0.22039505, 0.26469445], [0.59091459, 0.40692742]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [(-2.10724436), 0.70263997], [0.5220963, 0.11349303], [0.22039505, 0.26469445], [1.10915364, 0.05718352], [0.59091459, 0.40692742]], [[0.85117925, 1.0185556], [(-0.58539673), 0.62515052], [(-1.23195149), 0.15427291], [0.5220963, 0.11349303], [1.35269503, 0.44812421], [1.10915364, 0.05718352], [0.59091459, 0.40692742], [0.22039505, 0.26469445]]]) DCNL DCSP y_gt = np.array([[0, 0, 1, 1, 1, 2, 2, 2], [0, 0, 1, 1, 1, 2, 2, 2], [0, 0, 1, 1, 1, 2, 2, 2]]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_random_state_none(): DCNL  DCSP ratio = 'auto' DCNL DCSP ee = EasyEnsemble(ratio=ratio, random_state=None) DCNL DCSP (X_resampled, y_resampled) = ee.fit_sample(X, Y)
def test_sample_wrong_X(): DCNL  DCSP ee = EasyEnsemble(random_state=RND_SEED) DCNL DCSP ee.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ee.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 10) DCNL DCSP ee = EasyEnsemble(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ee.fit, X, y)
def test_cnn_sk_estimator(): DCNL  DCSP check_estimator(CondensedNearestNeighbour)
def test_cnn_init(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP assert_equal(cnn.n_seeds_S, 1) DCNL DCSP assert_equal(cnn.n_jobs, 1)
def test_cnn_fit_single_class(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y_single_class)
def test_cnn_fit(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_equal(cnn.min_c_, 0) DCNL DCSP assert_equal(cnn.maj_c_, 2) DCNL DCSP assert_equal(cnn.stats_c_[0], 2) DCNL DCSP assert_equal(cnn.stats_c_[1], 6) DCNL DCSP assert_equal(cnn.stats_c_[2], 12)
def test_cnn_sample_wt_fit(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cnn.sample, X, Y)
def test_cnn_fit_sample(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_cnn_fit_sample_with_indices(): DCNL  DCSP cnn = CondensedNearestNeighbour(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP idx_gt = np.array([4, 11, 17, 12, 19, 9, 5, 7, 14, 18]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_cnn_sample_wrong_X(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cnn.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y)
def test_cnn_fit_sample_with_object(): DCNL  DCSP knn = KNeighborsClassifier(n_neighbors=1) DCNL DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampled, y_resampled) = cnn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [0.05230552, 0.09043907], [(-1.25020462), (-0.40402054)], [0.70524765, 0.39816382], [0.35831463, 1.33483198], [(-0.284881), (-0.62730973)], [0.03394306, 0.03986753], [(-0.01252787), 0.34102657], [0.15198585, 0.12512646]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED, n_neighbors=1) DCNL DCSP (X_resampled, y_resampled) = cnn.fit_sample(X, Y) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_cnn_fit_sample_with_wrong_object(): DCNL  DCSP knn = 'rnd' DCNL DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED, n_neighbors=knn) DCNL DCSP assert_raises(ValueError, cnn.fit_sample, X, Y)
def test_nearmiss_sk_estimator(): DCNL  DCSP check_estimator(NearMiss)
def test_nearmiss_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
def test_nearmiss_wrong_version(): DCNL  DCSP version = 1000 DCNL DCSP nm2 = NearMiss(version=version, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm2.fit_sample, X, Y)
def test_nearmiss_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_equal(nm2.version, VERSION_NEARMISS) DCNL DCSP assert_equal(nm2.n_neighbors, 3) DCNL DCSP assert_equal(nm2.ratio, ratio) DCNL DCSP assert_equal(nm2.random_state, RND_SEED)
def test_nearmiss_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm2.fit, X, y_single_class)
def test_nm_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
def test_nm2_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm2.fit(X, Y) DCNL DCSP assert_equal(nm2.min_c_, 0) DCNL DCSP assert_equal(nm2.maj_c_, 2) DCNL DCSP assert_equal(nm2.stats_c_[0], 3) DCNL DCSP assert_equal(nm2.stats_c_[1], 5) DCNL DCSP assert_equal(nm2.stats_c_[2], 7)
def test_nm2_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm2.sample, X, Y)
def test_nm2_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm2_fit_sample_auto_indices(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm2_fit_sample_half(): DCNL  DCSP ratio = 0.7 DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [1.17737838, (-0.2002118)], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm2_sample_wrong_X(): DCNL  DCSP nm2 = NearMiss(random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm2.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm2.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm = NearMiss(random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm.fit, X, y)
def test_nm2_fit_sample_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm2.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm2__wrong_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = 'rnd' DCNL DCSP nm2 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, nm2.fit_sample, X, Y)
def test_cc_sk_estimator(): DCNL  DCSP check_estimator(ClusterCentroids)
def test_cc_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, cc.fit, X, Y)
def test_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(cc.ratio, ratio)
def test_cc_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y_single_class)
def test_cc_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cc.fit, X, Y)
def test_cc_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_equal(cc.min_c_, 0) DCNL DCSP assert_equal(cc.maj_c_, 1) DCNL DCSP assert_equal(cc.stats_c_[0], 3) DCNL DCSP assert_equal(cc.stats_c_[1], 7)
def test_sample_wrong_X(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cc.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cc.sample, X, Y)
def test_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.06738818, (-0.529627)], [0.17901516, 0.69860992], [0.094035, (-2.55298982)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_fit_sample_half(): DCNL  DCSP ratio = 0.5 DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.19220316, 0.32337101], [0.094035, (-2.55298982)], [0.20792588, 1.49407907], [0.04352327, (-0.20515826)], [0.12372842, 0.6536186]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X_dft_ratio(): DCNL  DCSP cc = ClusterCentroids(random_state=RND_SEED) DCNL DCSP cc.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cc.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 10) DCNL DCSP cc = ClusterCentroids(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y)
def test_multiclass_fit_sample(): DCNL  DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP cc = ClusterCentroids(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = cc.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampled) DCNL DCSP assert_equal(count_y_res[0], 2) DCNL DCSP assert_equal(count_y_res[1], 2) DCNL DCSP assert_equal(count_y_res[2], 2)
def test_fit_sample_object(): DCNL  DCSP ratio = 'auto' DCNL DCSP cluster = KMeans(random_state=RND_SEED) DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED, estimator=cluster) DCNL DCSP (X_resampled, y_resampled) = cc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.06738818, (-0.529627)], [0.17901516, 0.69860992], [0.094035, (-2.55298982)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_fit_sample_wrong_object(): DCNL  DCSP ratio = 'auto' DCNL DCSP cluster = 'rnd' DCNL DCSP cc = ClusterCentroids(ratio=ratio, random_state=RND_SEED, estimator=cluster) DCNL DCSP assert_raises(ValueError, cc.fit_sample, X, Y)
def test_enn_sk_estimator(): DCNL  DCSP check_estimator(RepeatedEditedNearestNeighbours)
def test_renn_init(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_equal(renn.n_neighbors, 3) DCNL DCSP assert_equal(renn.kind_sel, 'all') DCNL DCSP assert_equal(renn.n_jobs, (-1)) DCNL DCSP assert_equal(renn.random_state, RND_SEED)
def test_renn_iter_wrong(): DCNL  DCSP max_iter = (-1) DCNL DCSP renn = RepeatedEditedNearestNeighbours(max_iter=max_iter, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, renn.fit_sample, X, Y)
def test_renn_fit_single_class(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, renn.fit, X, y_single_class)
def test_renn_fit(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP renn.fit(X, Y) DCNL DCSP assert_equal(renn.min_c_, 0) DCNL DCSP assert_equal(renn.maj_c_, 2) DCNL DCSP assert_equal(renn.stats_c_[0], 4) DCNL DCSP assert_equal(renn.stats_c_[1], 16) DCNL DCSP assert_equal(renn.stats_c_[2], 20)
def test_renn_sample_wt_fit(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, renn.sample, X, Y)
def test_renn_fit_sample(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_renn_fit_sample_with_indices(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP idx_gt = np.array([6, 13, 32, 39, 4, 5, 16, 22, 23, 24, 30, 37, 2, 11, 12, 17, 20, 21, 25, 26, 28, 31, 33, 34, 35, 36]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_renn_fit_sample_mode_object(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [2.94290565, (-0.13986434)], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [1.84864913, 0.14729596], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [1.67314371, 0.19231498], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_renn_sample_wrong_X(): DCNL  DCSP renn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP renn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, renn.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 40) DCNL DCSP enn = RepeatedEditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y)
def test_renn_fit_sample_mode(): DCNL  DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP renn = RepeatedEditedNearestNeighbours(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = renn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [2.94290565, (-0.13986434)], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [1.84864913, 0.14729596], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [1.67314371, 0.19231498], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_renn_not_good_object(): DCNL  DCSP nn = 'rnd' DCNL DCSP renn = RepeatedEditedNearestNeighbours(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP assert_raises(ValueError, renn.fit_sample, X, Y)
def test_nearmiss_sk_estimator(): DCNL  DCSP check_estimator(NearMiss)
def test_nearmiss_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
def test_nearmiss_wrong_version(): DCNL  DCSP version = 1000 DCNL DCSP nm3 = NearMiss(version=version, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y)
def test_nearmiss_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_equal(nm3.version, VERSION_NEARMISS) DCNL DCSP assert_equal(nm3.n_neighbors, 3) DCNL DCSP assert_equal(nm3.ratio, ratio) DCNL DCSP assert_equal(nm3.random_state, RND_SEED)
def test_nearmiss_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm3.fit, X, y_single_class)
def test_nm_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
def test_nm3_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm3.fit(X, Y) DCNL DCSP assert_equal(nm3.min_c_, 0) DCNL DCSP assert_equal(nm3.maj_c_, 2) DCNL DCSP assert_equal(nm3.stats_c_[0], 3) DCNL DCSP assert_equal(nm3.stats_c_[1], 5) DCNL DCSP assert_equal(nm3.stats_c_[2], 7)
def test_nm3_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm3.sample, X, Y)
def test_nm3_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm3_fit_sample_auto_indices(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 0, 2, 3, 5, 1, 4]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm3_fit_sample_half(): DCNL  DCSP ratio = 0.7 DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [(-0.05903827), 0.10947647], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm3_sample_wrong_X(): DCNL  DCSP nm3 = NearMiss(random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm3.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm3.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm = NearMiss(random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm.fit, X, y)
def test_nm3_fit_sample_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nn3 = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm3.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [1.17737838, (-0.2002118)], [(-0.60413357), 0.24628718], [0.03142011, 0.12323596], [1.15157493, (-1.2981518)], [(-0.54619583), 1.73009918], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 0, 2, 3, 5, 1, 4]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm3_wrong_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = 'rnd' DCNL DCSP nn3 = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y) DCNL DCSP nn3 = 'rnd' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn, n_neighbors_ver3=nn3) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y)
def test_iht_sk_estimator(): DCNL  DCSP check_estimator(InstanceHardnessThreshold)
def test_iht_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP iht = InstanceHardnessThreshold(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP iht = InstanceHardnessThreshold(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP iht = InstanceHardnessThreshold(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP iht = InstanceHardnessThreshold(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit, X, Y)
def test_iht_wrong_estimator(): DCNL  DCSP ratio = 0.7 DCNL DCSP est = 'rnd' DCNL DCSP iht = InstanceHardnessThreshold(estimator=est, ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(NotImplementedError, iht.fit_sample, X, Y)
def test_iht_init(): DCNL  DCSP ratio = 'auto' DCNL DCSP iht = InstanceHardnessThreshold(ESTIMATOR, ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(iht.ratio, ratio) DCNL DCSP assert_equal(iht.random_state, RND_SEED)
def test_iht_fit_single_class(): DCNL  DCSP iht = InstanceHardnessThreshold(ESTIMATOR, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y_single_class)
def test_iht_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP iht = InstanceHardnessThreshold(ESTIMATOR, ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, iht.fit, X, Y)
def test_iht_fit(): DCNL  DCSP iht = InstanceHardnessThreshold(ESTIMATOR, random_state=RND_SEED) DCNL DCSP iht.fit(X, Y) DCNL DCSP assert_equal(iht.min_c_, 0) DCNL DCSP assert_equal(iht.maj_c_, 1) DCNL DCSP assert_equal(iht.stats_c_[0], 6) DCNL DCSP assert_equal(iht.stats_c_[1], 9)
def test_iht_sample_wt_fit(): DCNL  DCSP iht = InstanceHardnessThreshold(ESTIMATOR, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, iht.sample, X, Y)
def test_iht_fit_sample(): DCNL  DCSP iht = InstanceHardnessThreshold(ESTIMATOR, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_with_indices(): DCNL  DCSP iht = InstanceHardnessThreshold(ESTIMATOR, return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP idx_gt = np.array([0, 1, 2, 3, 5, 6, 7, 9, 10, 12, 13, 14]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_iht_fit_sample_half(): DCNL  DCSP ratio = 0.7 DCNL DCSP iht = InstanceHardnessThreshold(ESTIMATOR, ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.30126957), (-0.66268378)], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_knn(): DCNL  DCSP est = 'knn' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [(-0.65571327), 0.42412021], [0.20246714, (-0.34727125)], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_decision_tree(): DCNL  DCSP est = 'decision-tree' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_random_forest(): DCNL  DCSP est = 'random-forest' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_adaboost(): DCNL  DCSP est = 'adaboost' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_gradient_boosting(): DCNL  DCSP est = 'gradient-boosting' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_linear_svm(): DCNL  DCSP est = 'linear-svm' DCNL DCSP iht = InstanceHardnessThreshold(est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.03852113), 0.40910479], [(-0.43877303), 1.07366684], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_sample_wrong_X(): DCNL  DCSP iht = InstanceHardnessThreshold(random_state=RND_SEED) DCNL DCSP iht.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, iht.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP iht = InstanceHardnessThreshold(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP iht = InstanceHardnessThreshold(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y)
def test_iht_fit_sample_class_obj(): DCNL  DCSP est = GradientBoostingClassifier(random_state=RND_SEED) DCNL DCSP iht = InstanceHardnessThreshold(estimator=est, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = iht.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [0.91542919, (-0.65453327)], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.18430329), 0.52328473], [(-0.65571327), 0.42412021], [(-0.28305528), 0.30284991], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087]]) DCNL DCSP y_gt = np.array([0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_iht_fit_sample_wrong_class_obj(): DCNL  DCSP from sklearn.cluster import KMeans DCNL DCSP est = KMeans() DCNL DCSP iht = InstanceHardnessThreshold(estimator=est, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, iht.fit_sample, X, Y)
def test_ncr_sk_estimator(): DCNL  DCSP check_estimator(NeighbourhoodCleaningRule)
def test_ncr_init(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP assert_equal(ncr.n_neighbors, 3) DCNL DCSP assert_equal(ncr.n_jobs, 1) DCNL DCSP assert_equal(ncr.random_state, RND_SEED)
def test_ncr_fit_single_class(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ncr.fit, X, y_single_class)
def test_ncr_fit(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP ncr.fit(X, Y) DCNL DCSP assert_equal(ncr.min_c_, 0) DCNL DCSP assert_equal(ncr.maj_c_, 2) DCNL DCSP assert_equal(ncr.stats_c_[0], 2) DCNL DCSP assert_equal(ncr.stats_c_[1], 6) DCNL DCSP assert_equal(ncr.stats_c_[2], 7)
def test_ncr_sample_wt_fit(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ncr.sample, X, Y)
def test_ncr_fit_sample(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_ncr_fit_sample_with_indices(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP idx_gt = np.array([10, 11, 3, 5, 7, 13, 14]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_ncr_sample_wrong_X(): DCNL  DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP ncr.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ncr.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP ncr = NeighbourhoodCleaningRule(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ncr.fit, X, y)
def test_ncr_fit_sample_nn_obj(): DCNL  DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP ncr = NeighbourhoodCleaningRule(return_indices=True, random_state=RND_SEED, n_neighbors=nn) DCNL DCSP (X_resampled, y_resampled, idx_under) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP idx_gt = np.array([10, 11, 3, 5, 7, 13, 14]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_ncr_wrong_nn_obj(): DCNL  DCSP nn = 'rnd' DCNL DCSP ncr = NeighbourhoodCleaningRule(return_indices=True, random_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, ncr.fit_sample, X, Y)
def test_rus_sk_estimator(): DCNL  DCSP check_estimator(RandomUnderSampler)
def test_rus_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP rus = RandomUnderSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP rus = RandomUnderSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP rus = RandomUnderSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP rus = RandomUnderSampler(ratio=ratio) DCNL DCSP assert_raises(ValueError, rus.fit, X, Y)
def test_rus_init(): DCNL  DCSP ratio = 'auto' DCNL DCSP rus = RandomUnderSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(rus.random_state, RND_SEED)
def test_rus_fit_single_class(): DCNL  DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, rus.fit, X, y_single_class)
def test_rus_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP rus = RandomUnderSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, rus.fit, X, Y)
def test_rus_fit(): DCNL  DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP rus.fit(X, Y) DCNL DCSP assert_equal(rus.min_c_, 0) DCNL DCSP assert_equal(rus.maj_c_, 1) DCNL DCSP assert_equal(rus.stats_c_[0], 3) DCNL DCSP assert_equal(rus.stats_c_[1], 7)
def test_rus_sample_wt_fit(): DCNL  DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, rus.sample, X, Y)
def test_rus_fit_sample(): DCNL  DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_rus_fit_sample_with_indices(): DCNL  DCSP rus = RandomUnderSampler(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1]) DCNL DCSP idx_gt = np.array([1, 3, 8, 6, 7, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_rus_fit_sample_half(): DCNL  DCSP ratio = 0.5 DCNL DCSP rus = RandomUnderSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = rus.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.04352327, (-0.20515826)], [0.15490546, 0.3130677], [0.15490546, 0.3130677], [0.15490546, 0.3130677]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_rus_sample_wrong_X(): DCNL  DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP rus.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, rus.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 10) DCNL DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, rus.fit, X, y)
def test_multiclass_fit_sample(): DCNL  DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP rus = RandomUnderSampler(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = rus.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampled) DCNL DCSP assert_equal(count_y_res[0], 2) DCNL DCSP assert_equal(count_y_res[1], 2) DCNL DCSP assert_equal(count_y_res[2], 2)
def test_enn_sk_estimator(): DCNL  DCSP check_estimator(EditedNearestNeighbours)
def test_enn_init(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_equal(enn.n_neighbors, 3) DCNL DCSP assert_equal(enn.kind_sel, 'all') DCNL DCSP assert_equal(enn.n_jobs, 1) DCNL DCSP assert_equal(enn.random_state, RND_SEED)
def test_enn_fit_single_class(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y_single_class)
def test_enn_fit(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP enn.fit(X, Y) DCNL DCSP assert_equal(enn.min_c_, 0) DCNL DCSP assert_equal(enn.maj_c_, 2) DCNL DCSP assert_equal(enn.stats_c_[0], 2) DCNL DCSP assert_equal(enn.stats_c_[1], 6) DCNL DCSP assert_equal(enn.stats_c_[2], 12)
def test_enn_sample_wt_fit(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, enn.sample, X, Y)
def test_enn_fit_sample(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [0.78318102, 2.59153329], [0.52726792, (-0.38735648)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_enn_fit_sample_with_indices(): DCNL  DCSP enn = EditedNearestNeighbours(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [0.78318102, 2.59153329], [0.52726792, (-0.38735648)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([4, 11, 0, 3, 1, 8, 15]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_enn_fit_sample_mode(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.42772181, 0.526027], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [(-0.284881), (-0.62730973)], [0.57062627, 1.19528323], [0.78318102, 2.59153329], [0.35831463, 1.33483198], [(-0.14313184), (-1.0412815)], [(-0.09816301), (-0.74662486)], [0.52726792, (-0.38735648)], [0.2821046, (-0.07862747)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_enn_sample_wrong_X(): DCNL  DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP enn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, enn.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, enn.fit, X, y)
def test_enn_fit_sample_with_nn_object(): DCNL  DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP enn = EditedNearestNeighbours(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = enn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.10903849), (-0.12085181)], [0.01936241, 0.17799828], [2.59928271, 0.93323465], [1.42772181, 0.526027], [1.92365863, 0.82718767], [0.25738379, 0.95564169], [(-0.284881), (-0.62730973)], [0.57062627, 1.19528323], [0.78318102, 2.59153329], [0.35831463, 1.33483198], [(-0.14313184), (-1.0412815)], [(-0.09816301), (-0.74662486)], [0.52726792, (-0.38735648)], [0.2821046, (-0.07862747)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_enn_not_good_object(): DCNL  DCSP nn = 'rnd' DCNL DCSP enn = EditedNearestNeighbours(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP assert_raises(ValueError, enn.fit_sample, X, Y)
def test_tl_sk_estimator(): DCNL  DCSP check_estimator(TomekLinks)
def test_tl_init(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP assert_equal(tl.n_jobs, 1) DCNL DCSP assert_equal(tl.random_state, RND_SEED)
def test_tl_fit_single_class(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y_single_class)
def test_tl_fit(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP tl.fit(X, Y) DCNL DCSP assert_equal(tl.min_c_, 0) DCNL DCSP assert_equal(tl.maj_c_, 1) DCNL DCSP assert_equal(tl.stats_c_[0], 7) DCNL DCSP assert_equal(tl.stats_c_[1], 13)
def test_tl_sample_wt_fit(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, tl.sample, X, Y)
def test_tl_fit_sample(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = tl.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.31230513, 0.1216318], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.2184254, 0.24299982], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)]]) DCNL DCSP y_gt = np.array([1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_tl_fit_sample_with_indices(): DCNL  DCSP tl = TomekLinks(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = tl.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.31230513, 0.1216318], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.2184254, 0.24299982], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)]]) DCNL DCSP y_gt = np.array([1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0]) DCNL DCSP idx_gt = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 16, 17, 18, 19]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_tl_sample_wrong_X(): DCNL  DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP tl.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, tl.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 7)) + ([2] * 10))) DCNL DCSP tl = TomekLinks(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, tl.fit, X, y)
def test_allknn_sk_estimator(): DCNL  DCSP check_estimator(AllKNN)
def test_allknn_init(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP assert_equal(allknn.n_neighbors, 3) DCNL DCSP assert_equal(allknn.kind_sel, 'all') DCNL DCSP assert_equal(allknn.n_jobs, (-1)) DCNL DCSP assert_equal(allknn.random_state, RND_SEED)
def test_allknn_fit_single_class(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, allknn.fit, X, y_single_class)
def test_allknn_fit(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP allknn.fit(X, Y) DCNL DCSP assert_equal(allknn.min_c_, 0) DCNL DCSP assert_equal(allknn.maj_c_, 2) DCNL DCSP assert_equal(allknn.stats_c_[0], 4) DCNL DCSP assert_equal(allknn.stats_c_[1], 16) DCNL DCSP assert_equal(allknn.stats_c_[2], 20)
def test_allknn_sample_wt_fit(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, allknn.sample, X, Y)
def test_allknn_fit_sample(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_allclose(y_resampled, y_gt, rtol=R_TOL)
def test_allknn_fit_sample_with_indices(): DCNL  DCSP allknn = AllKNN(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP idx_gt = np.array([6, 13, 32, 39, 4, 5, 14, 16, 22, 23, 24, 30, 37, 2, 11, 12, 17, 20, 21, 25, 26, 28, 31, 33, 34, 35, 36]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_allclose(y_resampled, y_gt, rtol=R_TOL) DCNL DCSP assert_allclose(idx_under, idx_gt, rtol=R_TOL)
def test_allknn_fit_sample_mode(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_allknn_sample_wrong_X(): DCNL  DCSP allknn = AllKNN(random_state=RND_SEED) DCNL DCSP allknn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, allknn.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 40) DCNL DCSP ann = AllKNN(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ann.fit, X, y)
def test_allknn_fit_sample_with_nn_object(): DCNL  DCSP nn = NearestNeighbors(n_neighbors=4) DCNL DCSP allknn = AllKNN(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP (X_resampled, y_resampled) = allknn.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.53171468), (-0.53735182)], [(-0.88864036), (-0.33782387)], [(-0.46226554), (-0.50481004)], [(-0.34474418), 0.21969797], [(-0.12840393), 0.66446571], [1.02956816, 0.36061601], [1.12202806, 0.33811558], [(-0.35946678), 0.72510189], [(-1.10146139), 0.91782682], [0.73489726, 0.43915195], [(-0.28479268), 0.70459548], [0.50307437, 0.498805], [0.84929742, 0.41042894], [0.62649535, 0.46600596], [0.98382284, 0.37184502], [0.69804044, 0.44810796], [1.32319756, (-0.13181616)], [0.04296502, (-0.37981873)], [0.28294738, (-1.00125525)], [0.34218094, (-0.58781961)], [0.2096964, (-0.61814058)], [1.59068979, (-0.96622933)], [0.73418199, (-0.02222847)], [0.79270821, (-0.41386668)], [1.16606871, (-0.25641059)], [1.0304995, (-0.16955962)], [0.48921682, (-1.38504507)], [(-0.03918551), (-0.68540745)], [0.24991051, (-1.00864997)], [0.80541964, (-0.34465185)], [0.1732627, (-1.61323172)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_alknn_not_good_object(): DCNL  DCSP nn = 'rnd' DCNL DCSP allknn = AllKNN(n_neighbors=nn, random_state=RND_SEED, kind_sel='mode') DCNL DCSP assert_raises(ValueError, allknn.fit_sample, X, Y)
def test_nearmiss_sk_estimator(): DCNL  DCSP check_estimator(NearMiss)
def test_nearmiss_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit, X, Y)
def test_nearmiss_wrong_version(): DCNL  DCSP version = 1000 DCNL DCSP nm1 = NearMiss(version=version, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm1.fit_sample, X, Y)
def test_nearmiss_init(): DCNL  DCSP ratio = 1.0 DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_equal(nm1.version, VERSION_NEARMISS) DCNL DCSP assert_equal(nm1.n_neighbors, 3) DCNL DCSP assert_equal(nm1.ratio, ratio) DCNL DCSP assert_equal(nm1.random_state, RND_SEED)
def test_nearmiss_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, nm1.fit, X, y_single_class)
def test_nm_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP nm = NearMiss(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, nm.fit, X, Y)
def test_nm1_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm1.fit(X, Y) DCNL DCSP assert_equal(nm1.min_c_, 0) DCNL DCSP assert_equal(nm1.maj_c_, 2) DCNL DCSP assert_equal(nm1.stats_c_[0], 3) DCNL DCSP assert_equal(nm1.stats_c_[1], 5) DCNL DCSP assert_equal(nm1.stats_c_[2], 7)
def test_nm1_sample_wt_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_raises(RuntimeError, nm1.sample, X, Y)
def test_nm1_fit_sample_auto(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm1_fit_sample_auto_indices(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm1_fit_sample_half(): DCNL  DCSP ratio = 0.7 DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP (X_resampled, y_resampled) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [1.17737838, (-0.2002118)], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295], [0.99272351, (-0.11631728)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_nm1_sample_wrong_X(): DCNL  DCSP nm1 = NearMiss(random_state=RND_SEED) DCNL DCSP nm1.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, nm1.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP nm1 = NearMiss(random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP assert_warns(UserWarning, nm1.fit, X, y)
def test_nm1_fit_sample_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = NearestNeighbors(n_neighbors=3) DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn) DCNL DCSP (X_resampled, y_resampled, idx_under) = nm1.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.91464286, 1.61369212], [(-0.80809175), (-1.09917302)], [(-0.20497017), (-0.26630228)], [(-0.05903827), 0.10947647], [0.03142011, 0.12323596], [(-0.60413357), 0.24628718], [0.50701028, (-0.17636928)], [0.4960075, 0.86130762], [0.45713638, 1.31069295]]) DCNL DCSP y_gt = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2]) DCNL DCSP idx_gt = np.array([3, 10, 11, 2, 8, 5, 9, 1, 6]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_nm1_wrong_nn_obj(): DCNL  DCSP ratio = 'auto' DCNL DCSP nn = 'rnd' DCNL DCSP nm1 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS, return_indices=True, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, nm1.fit_sample, X, Y)
def test_oss_sk_estimator(): DCNL  DCSP check_estimator(OneSidedSelection)
def test_oss_init(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP assert_equal(oss.n_seeds_S, 1) DCNL DCSP assert_equal(oss.n_jobs, 1) DCNL DCSP assert_equal(oss.random_state, RND_SEED)
def test_oss_fit_single_class(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y_single_class)
def test_oss_fit(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP oss.fit(X, Y) DCNL DCSP assert_equal(oss.min_c_, 0) DCNL DCSP assert_equal(oss.maj_c_, 1) DCNL DCSP assert_equal(oss.stats_c_[0], 6) DCNL DCSP assert_equal(oss.stats_c_[1], 9)
def test_oss_sample_wt_fit(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, oss.sample, X, Y)
def test_oss_fit_sample(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_oss_fit_sample_with_indices(): DCNL  DCSP oss = OneSidedSelection(return_indices=True, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled, idx_under) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP idx_gt = np.array([0, 3, 9, 12, 13, 14, 1, 2, 5, 6, 8, 11]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP assert_array_equal(idx_under, idx_gt)
def test_oss_sample_wrong_X(): DCNL  DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP oss.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, oss.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 15) DCNL DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP oss = OneSidedSelection(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, oss.fit, X, y)
def test_oss_with_object(): DCNL  DCSP knn = KNeighborsClassifier(n_neighbors=1) DCNL DCSP oss = OneSidedSelection(random_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampled, y_resampled) = oss.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-0.3879569), 0.6894251], [0.91542919, (-0.65453327)], [(-0.65571327), 0.42412021], [1.06446472, (-1.09279772)], [0.30543283, (-0.02589502)], [(-0.00717161), 0.00318087], [(-0.09322739), 1.28177189], [(-0.77740357), 0.74097941], [(-0.43877303), 1.07366684], [(-0.85795321), 0.82980738], [(-0.30126957), (-0.66268378)], [0.20246714, (-0.34727125)]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP knn = 1 DCNL DCSP oss = OneSidedSelection(random_state=RND_SEED, n_neighbors=knn) DCNL DCSP (X_resampled, y_resampled) = oss.fit_sample(X, Y) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_oss_with_wrong_object(): DCNL  DCSP knn = 'rnd' DCNL DCSP oss = OneSidedSelection(random_state=RND_SEED, n_neighbors=knn) DCNL DCSP assert_raises(ValueError, oss.fit_sample, X, Y)
def make_pipeline(*steps): DCNL  DCSP return Pipeline(pipeline._name_estimators(steps))
def test_ros_sk_estimator(): DCNL  DCSP check_estimator(RandomOverSampler)
def test_ros_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ros.fit_sample, X, Y)
def test_ros_init(): DCNL  DCSP ratio = 'auto' DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(ros.random_state, RND_SEED)
def test_ros_fit_single_class(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ros.fit, X, y_single_class)
def test_ros_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ros.fit, X, Y)
def test_ros_fit(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP ros.fit(X, Y) DCNL DCSP assert_equal(ros.min_c_, 0) DCNL DCSP assert_equal(ros.maj_c_, 1) DCNL DCSP assert_equal(ros.stats_c_[0], 3) DCNL DCSP assert_equal(ros.stats_c_[1], 7)
def test_ros_sample_wt_fit(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ros.sample, X, Y)
def test_ros_fit_sample(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.92923648, 0.76103773], [0.47104475, 0.44386323]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_ros_fit_sample_half(): DCNL  DCSP ratio = 0.5 DCNL DCSP ros = RandomOverSampler(ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0]) DCNL DCSP assert_array_equal(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X(): DCNL  DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP ros.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ros.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_continuous_error(): DCNL  DCSP y = np.linspace(0, 1, 10) DCNL DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ros.fit, X, y)
def test_multiclass_fit_sample(): DCNL  DCSP y = Y.copy() DCNL DCSP y[5] = 2 DCNL DCSP y[6] = 2 DCNL DCSP ros = RandomOverSampler(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ros.fit_sample(X, y) DCNL DCSP count_y_res = Counter(y_resampled) DCNL DCSP assert_equal(count_y_res[0], 5) DCNL DCSP assert_equal(count_y_res[1], 5) DCNL DCSP assert_equal(count_y_res[2], 5)
def test_ada_sk_estimator(): DCNL  DCSP check_estimator(ADASYN)
def test_ada_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ada.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ada.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ada.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, ada.fit, X, Y)
def test_ada_init(): DCNL  DCSP ratio = 'auto' DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_equal(ada.random_state, RND_SEED)
def test_ada_fit_single_class(): DCNL  DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, ada.fit, X, y_single_class)
def test_ada_fit_invalid_ratio(): DCNL  DCSP ratio = (1.0 / 10000.0) DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ada.fit, X, Y)
def test_ada_fit(): DCNL  DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP ada.fit(X, Y) DCNL DCSP assert_equal(ada.min_c_, 0) DCNL DCSP assert_equal(ada.maj_c_, 1) DCNL DCSP assert_equal(ada.stats_c_[0], 8) DCNL DCSP assert_equal(ada.stats_c_[1], 12)
def test_ada_sample_wt_fit(): DCNL  DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, ada.sample, X, Y)
def test_ada_fit_sample(): DCNL  DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ada.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29427267, 0.21740707], [0.68118697, (-0.25220353)], [1.37180201, 0.37279378], [(-0.59243851), (-0.80715327)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_ada_fit_sample_half(): DCNL  DCSP ratio = 0.8 DCNL DCSP ada = ADASYN(ratio=ratio, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = ada.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X(): DCNL  DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP ada.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, ada.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ada.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP ada = ADASYN(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, ada.fit, X, y)
def test_ada_fit_sample_nn_obj(): DCNL  DCSP nn = NearestNeighbors(n_neighbors=6) DCNL DCSP ada = ADASYN(random_state=RND_SEED, n_neighbors=nn) DCNL DCSP (X_resampled, y_resampled) = ada.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29427267, 0.21740707], [0.68118697, (-0.25220353)], [1.37180201, 0.37279378], [(-0.59243851), (-0.80715327)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_ada_wrong_nn_obj(): DCNL  DCSP nn = 'rnd' DCNL DCSP ada = ADASYN(random_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, ada.fit_sample, X, Y)
def test_smote_sk_estimator(): DCNL  DCSP check_estimator(SMOTE)
def test_smote_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP smote = SMOTE(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTE(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP smote = SMOTE(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTE(ratio=ratio, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
def test_smote_wrong_kind(): DCNL  DCSP kind = 'rnd' DCNL DCSP smote = SMOTE(kind=kind, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
def test_smote_fit_single_class(): DCNL  DCSP smote = SMOTE(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
def test_smote_fit(): DCNL  DCSP smote = SMOTE(random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_equal(smote.min_c_, 0) DCNL DCSP assert_equal(smote.maj_c_, 1) DCNL DCSP assert_equal(smote.stats_c_[0], 8) DCNL DCSP assert_equal(smote.stats_c_[1], 12)
def test_smote_sample_wt_fit(): DCNL  DCSP smote = SMOTE(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
def test_sample_regular(): DCNL  DCSP kind = 'regular' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_regular_half(): DCNL  DCSP ratio = 0.8 DCNL DCSP kind = 'regular' DCNL DCSP smote = SMOTE(ratio=ratio, random_state=RND_SEED, kind=kind) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.36784496, (-0.1953161)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_borderline1(): DCNL  DCSP kind = 'borderline1' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.3765279, (-0.2009615)], [0.55276636, (-0.10550373)], [0.45413452, (-0.08883319)], [1.21118683, (-0.22817957)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_borderline2(): DCNL  DCSP kind = 'borderline2' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [0.33339622, 0.49870937]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_svm(): DCNL  DCSP kind = 'svm' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [1.44015515, (-1.30621303)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X(): DCNL  DCSP sm = SMOTE(random_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTE(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTE(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
def test_fit_sample_nn_obj(): DCNL  DCSP kind = 'borderline1' DCNL DCSP nn_m = NearestNeighbors(n_neighbors=11) DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.3765279, (-0.2009615)], [0.55276636, (-0.10550373)], [0.45413452, (-0.08883319)], [1.21118683, (-0.22817957)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_regular_with_nn(): DCNL  DCSP kind = 'regular' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_wrong_nn(): DCNL  DCSP kind = 'borderline1' DCNL DCSP nn_m = 'rnd' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y) DCNL DCSP nn_k = 'rnd' DCNL DCSP nn_m = NearestNeighbors(n_neighbors=10) DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k, m_neighbors=nn_m) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y) DCNL DCSP kind = 'regular' DCNL DCSP nn_k = 'rnd' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
def test_sample_regular_with_nn_svm(): DCNL  DCSP kind = 'svm' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP svm = SVC(random_state=RND_SEED) DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k, svm_estimator=svm) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [0.77481731, 0.60935141], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.3084254, 0.33299982], [0.70472253, (-0.73309052)], [0.28893132, (-0.38761769)], [1.15514042, 0.0129463], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-1.11515198), (-0.93689695)], [(-0.18410027), (-0.45194484)], [0.9281014, 0.53085498], [(-0.14374509), 0.27370049], [(-0.41635887), (-0.38299653)], [0.08711622, 0.93259929], [1.70580611, (-0.11219234)], [0.47436888, (-0.2645749)], [1.07844561, (-0.19435291)], [1.44015515, (-1.30621303)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_regular_wrong_svm(): DCNL  DCSP kind = 'svm' DCNL DCSP nn_k = NearestNeighbors(n_neighbors=6) DCNL DCSP svm = 'rnd' DCNL DCSP smote = SMOTE(random_state=RND_SEED, kind=kind, k_neighbors=nn_k, svm_estimator=svm) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
def _import_module_with_version_check(module_name, minimum_version, install_info=None): DCNL  DCSP from distutils.version import LooseVersion DCNL DCSP try: DCNL DCSP  DCSP module = __import__(module_name) DCNL DCSP except ImportError as exc: DCNL DCSP  DCSP user_friendly_info = 'Module DCSP "{0}" DCSP could DCSP not DCSP be DCSP found. DCSP {1}'.format(module_name, (install_info or 'Please DCSP install DCSP it DCSP properly DCSP to DCSP use DCSP imbalanced-learn.')) DCNL DCSP  DCSP exc.args += (user_friendly_info,) DCNL DCSP  DCSP raise DCNL DCSP module_version = getattr(module, '__version__', '0.0.0') DCNL DCSP version_too_old = (not (LooseVersion(module_version) >= LooseVersion(minimum_version))) DCNL DCSP if version_too_old: DCNL DCSP  DCSP message = 'A DCSP {module_name} DCSP version DCSP of DCSP at DCSP least DCSP {minimum_version} DCSP is DCSP required DCSP to DCSP use DCSP imbalanced-learn. DCSP {module_version} DCSP was DCSP found. DCSP Please DCSP upgrade DCSP {module_name}'.format(module_name=module_name, minimum_version=minimum_version, module_version=module_version) DCNL DCSP  DCSP raise ImportError(message) DCNL DCSP return module
def _check_module_dependencies(is_imbalanced_dataset_installing=False): DCNL  DCSP for (module_name, module_metadata) in REQUIRED_MODULE_METADATA: DCNL DCSP  DCSP if (not (is_imbalanced_dataset_installing and (not module_metadata['required_at_installation']))): DCNL DCSP  DCSP  DCSP _import_module_with_version_check(module_name=module_name, minimum_version=module_metadata['min_version'], install_info=module_metadata.get('install_info'))
def sensitivity_specificity_support(y_true, y_pred, labels=None, pos_label=1, average=None, warn_for=('sensitivity', 'specificity'), sample_weight=None): DCNL  DCSP average_options = (None, 'micro', 'macro', 'weighted', 'samples') DCNL DCSP if ((average not in average_options) and (average != 'binary')): DCNL DCSP  DCSP raise ValueError(('average DCSP has DCSP to DCSP be DCSP one DCSP of DCSP ' + str(average_options))) DCNL DCSP (y_type, y_true, y_pred) = _check_targets(y_true, y_pred) DCNL DCSP present_labels = unique_labels(y_true, y_pred) DCNL DCSP if (average == 'binary'): DCNL DCSP  DCSP if (y_type == 'binary'): DCNL DCSP  DCSP  DCSP if (pos_label not in present_labels): DCNL DCSP  DCSP  DCSP  DCSP if (len(present_labels) < 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (0.0, 0.0, 0) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('pos_label=%r DCSP is DCSP not DCSP a DCSP valid DCSP label: DCSP %r' % (pos_label, present_labels))) DCNL DCSP  DCSP  DCSP labels = [pos_label] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(("Target DCSP is DCSP %s DCSP but DCSP average='binary'. DCSP Please DCSP choose DCSP another DCSP average DCSP setting." % y_type)) DCNL DCSP elif (pos_label not in (None, 1)): DCNL DCSP  DCSP warnings.warn(("Note DCSP that DCSP pos_label DCSP (set DCSP to DCSP %r) DCSP is DCSP ignored DCSP when DCSP average DCSP != DCSP 'binary' DCSP (got DCSP %r). DCSP You DCSP may DCSP use DCSP labels=[pos_label] DCSP to DCSP specify DCSP a DCSP single DCSP positive DCSP class." % (pos_label, average)), UserWarning) DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = present_labels DCNL DCSP  DCSP n_labels = None DCNL DCSP else: DCNL DCSP  DCSP n_labels = len(labels) DCNL DCSP  DCSP labels = np.hstack([labels, np.setdiff1d(present_labels, labels, assume_unique=True)]) DCNL DCSP if y_type.startswith('multilabel'): DCNL DCSP  DCSP raise ValueError('imblearn DCSP does DCSP not DCSP support DCSP multilabel') DCNL DCSP elif (average == 'samples'): DCNL DCSP  DCSP raise ValueError('Sample-based DCSP precision, DCSP recall, DCSP fscore DCSP is DCSP not DCSP meaningful DCSP outside DCSP multilabel DCSP classification. DCSP See DCSP the DCSP accuracy_score DCSP instead.') DCNL DCSP else: DCNL DCSP  DCSP le = LabelEncoder() DCNL DCSP  DCSP le.fit(labels) DCNL DCSP  DCSP y_true = le.transform(y_true) DCNL DCSP  DCSP y_pred = le.transform(y_pred) DCNL DCSP  DCSP sorted_labels = le.classes_ DCNL DCSP  DCSP tp = (y_true == y_pred) DCNL DCSP  DCSP tp_bins = y_true[tp] DCNL DCSP  DCSP if (sample_weight is not None): DCNL DCSP  DCSP  DCSP tp_bins_weights = np.asarray(sample_weight)[tp] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tp_bins_weights = None DCNL DCSP  DCSP if len(tp_bins): DCNL DCSP  DCSP  DCSP tp_sum = bincount(tp_bins, weights=tp_bins_weights, minlength=len(labels)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP true_sum = pred_sum = tp_sum = np.zeros(len(labels)) DCNL DCSP  DCSP if len(y_pred): DCNL DCSP  DCSP  DCSP pred_sum = bincount(y_pred, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP if len(y_true): DCNL DCSP  DCSP  DCSP true_sum = bincount(y_true, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP tn_sum = (y_true.size - ((pred_sum + true_sum) - tp_sum)) DCNL DCSP  DCSP indices = np.searchsorted(sorted_labels, labels[:n_labels]) DCNL DCSP  DCSP tp_sum = tp_sum[indices] DCNL DCSP  DCSP true_sum = true_sum[indices] DCNL DCSP  DCSP pred_sum = pred_sum[indices] DCNL DCSP  DCSP tn_sum = tn_sum[indices] DCNL DCSP if (average == 'micro'): DCNL DCSP  DCSP tp_sum = np.array([tp_sum.sum()]) DCNL DCSP  DCSP pred_sum = np.array([pred_sum.sum()]) DCNL DCSP  DCSP true_sum = np.array([true_sum.sum()]) DCNL DCSP  DCSP tn_sum = np.array([tn_sum.sum()]) DCNL DCSP with np.errstate(divide='ignore', invalid='ignore'): DCNL DCSP  DCSP specificity = _prf_divide(tn_sum, ((tn_sum + pred_sum) - tp_sum), 'specificity', 'predicted', average, warn_for) DCNL DCSP  DCSP sensitivity = _prf_divide(tp_sum, true_sum, 'sensitivity', 'true', average, warn_for) DCNL DCSP if (average == 'weighted'): DCNL DCSP  DCSP weights = true_sum DCNL DCSP  DCSP if (weights.sum() == 0): DCNL DCSP  DCSP  DCSP return (0, 0, None) DCNL DCSP elif (average == 'samples'): DCNL DCSP  DCSP weights = sample_weight DCNL DCSP else: DCNL DCSP  DCSP weights = None DCNL DCSP if (average is not None): DCNL DCSP  DCSP assert ((average != 'binary') or (len(specificity) == 1)) DCNL DCSP  DCSP specificity = np.average(specificity, weights=weights) DCNL DCSP  DCSP sensitivity = np.average(sensitivity, weights=weights) DCNL DCSP  DCSP true_sum = None DCNL DCSP return (sensitivity, specificity, true_sum)
def sensitivity_score(y_true, y_pred, labels=None, pos_label=1, average='binary', sample_weight=None): DCNL  DCSP (s, _, _) = sensitivity_specificity_support(y_true, y_pred, labels=labels, pos_label=pos_label, average=average, warn_for=('sensitivity',), sample_weight=sample_weight) DCNL DCSP return s
def specificity_score(y_true, y_pred, labels=None, pos_label=1, average='binary', sample_weight=None): DCNL  DCSP (_, s, _) = sensitivity_specificity_support(y_true, y_pred, labels=labels, pos_label=pos_label, average=average, warn_for=('specificity',), sample_weight=sample_weight) DCNL DCSP return s
def geometric_mean_score(y_true, y_pred, labels=None, pos_label=1, average='multiclass', sample_weight=None, correction=0.0): DCNL  DCSP if ((average is None) or (average != 'multiclass')): DCNL DCSP  DCSP (sen, spe, _) = sensitivity_specificity_support(y_true, y_pred, labels=labels, pos_label=pos_label, average=average, warn_for=('specificity', 'specificity'), sample_weight=sample_weight) DCNL DCSP  DCSP LOGGER.debug(('The DCSP sensitivity DCSP and DCSP specificity DCSP are DCSP : DCSP %s DCSP - DCSP %s' % (sen, spe))) DCNL DCSP  DCSP return np.sqrt((sen * spe)) DCNL DCSP else: DCNL DCSP  DCSP present_labels = unique_labels(y_true, y_pred) DCNL DCSP  DCSP if (labels is None): DCNL DCSP  DCSP  DCSP labels = present_labels DCNL DCSP  DCSP  DCSP n_labels = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n_labels = len(labels) DCNL DCSP  DCSP  DCSP labels = np.hstack([labels, np.setdiff1d(present_labels, labels, assume_unique=True)]) DCNL DCSP  DCSP le = LabelEncoder() DCNL DCSP  DCSP le.fit(labels) DCNL DCSP  DCSP y_true = le.transform(y_true) DCNL DCSP  DCSP y_pred = le.transform(y_pred) DCNL DCSP  DCSP sorted_labels = le.classes_ DCNL DCSP  DCSP tp = (y_true == y_pred) DCNL DCSP  DCSP tp_bins = y_true[tp] DCNL DCSP  DCSP if (sample_weight is not None): DCNL DCSP  DCSP  DCSP tp_bins_weights = np.asarray(sample_weight)[tp] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tp_bins_weights = None DCNL DCSP  DCSP if len(tp_bins): DCNL DCSP  DCSP  DCSP tp_sum = bincount(tp_bins, weights=tp_bins_weights, minlength=len(labels)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP true_sum = tp_sum = np.zeros(len(labels)) DCNL DCSP  DCSP if len(y_true): DCNL DCSP  DCSP  DCSP true_sum = bincount(y_true, weights=sample_weight, minlength=len(labels)) DCNL DCSP  DCSP indices = np.searchsorted(sorted_labels, labels[:n_labels]) DCNL DCSP  DCSP tp_sum = tp_sum[indices] DCNL DCSP  DCSP true_sum = true_sum[indices] DCNL DCSP  DCSP recall = _prf_divide(tp_sum, true_sum, 'recall', 'true', None, 'recall') DCNL DCSP  DCSP recall[(recall == 0)] = correction DCNL DCSP  DCSP return sp.stats.mstats.gmean(recall)
def make_index_balanced_accuracy(alpha=0.1, squared=True): DCNL  DCSP def decorate(scoring_func): DCNL DCSP  DCSP @functools.wraps(scoring_func) DCNL DCSP  DCSP def compute_score(*args, **kwargs): DCNL DCSP  DCSP  DCSP tags_scoring_func = getcallargs(scoring_func, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (('y_score' in tags_scoring_func) or ('y_prob' in tags_scoring_func) or ('y2' in tags_scoring_func)): DCNL DCSP  DCSP  DCSP  DCSP raise AttributeError('The DCSP function DCSP {} DCSP has DCSP an DCSP unsupported DCSP attribute. DCSP Metric DCSP with`y_pred` DCSP are DCSP the DCSP only DCSP supported DCSP metrics DCSP is DCSP the DCSP only DCSP supported.') DCNL DCSP  DCSP  DCSP _score = scoring_func(*args, **kwargs) DCNL DCSP  DCSP  DCSP if squared: DCNL DCSP  DCSP  DCSP  DCSP _score = np.power(_score, 2) DCNL DCSP  DCSP  DCSP sens_spec_sig = signature(sensitivity_specificity_support) DCNL DCSP  DCSP  DCSP params_sens_spec = set(sens_spec_sig._parameters.keys()) DCNL DCSP  DCSP  DCSP sel_params = params_sens_spec.intersection(set(tags_scoring_func)) DCNL DCSP  DCSP  DCSP tags_scoring_func = dict(((k, tags_scoring_func[k]) for k in sel_params)) DCNL DCSP  DCSP  DCSP if (scoring_func.__name__ == 'geometric_mean_score'): DCNL DCSP  DCSP  DCSP  DCSP if ('average' in tags_scoring_func): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (tags_scoring_func['average'] == 'multiclass'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tags_scoring_func['average'] = 'macro' DCNL DCSP  DCSP  DCSP elif ((scoring_func.__name__ == 'accuracy_score') or (scoring_func.__name__ == 'jaccard_similarity_score')): DCNL DCSP  DCSP  DCSP  DCSP tags_scoring_func['average'] = 'binary' DCNL DCSP  DCSP  DCSP tags_sens_spec = sens_spec_sig.bind(**tags_scoring_func) DCNL DCSP  DCSP  DCSP (sen, spe, _) = sensitivity_specificity_support(*tags_sens_spec.args, **tags_sens_spec.kwargs) DCNL DCSP  DCSP  DCSP dom = (sen - spe) DCNL DCSP  DCSP  DCSP return ((1.0 + (alpha * dom)) * _score) DCNL DCSP  DCSP return compute_score DCNL DCSP return decorate
def classification_report_imbalanced(y_true, y_pred, labels=None, target_names=None, sample_weight=None, digits=2, alpha=0.1): DCNL  DCSP if (labels is None): DCNL DCSP  DCSP labels = unique_labels(y_true, y_pred) DCNL DCSP else: DCNL DCSP  DCSP labels = np.asarray(labels) DCNL DCSP last_line_heading = 'avg DCSP / DCSP total' DCNL DCSP if (target_names is None): DCNL DCSP  DCSP target_names = [('%s' % l) for l in labels] DCNL DCSP name_width = max((len(cn) for cn in target_names)) DCNL DCSP width = max(name_width, len(last_line_heading), digits) DCNL DCSP headers = ['pre', 'rec', 'spe', 'f1', 'geo', 'iba', 'sup'] DCNL DCSP fmt = ('%% DCSP %ds' % width) DCNL DCSP fmt += ' DCSP  DCSP ' DCNL DCSP fmt += ' DCSP '.join(['% DCSP 9s' for _ in headers]) DCNL DCSP fmt += '\n' DCNL DCSP headers = ([''] + headers) DCNL DCSP report = (fmt % tuple(headers)) DCNL DCSP report += '\n' DCNL DCSP (precision, recall, f1, support) = precision_recall_fscore_support(y_true, y_pred, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP specificity = specificity_score(y_true, y_pred, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP geo_mean = geometric_mean_score(y_pred, y_true, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP iba_gmean = make_index_balanced_accuracy(alpha=alpha, squared=True)(geometric_mean_score) DCNL DCSP iba = iba_gmean(y_pred, y_true, labels=labels, average=None, sample_weight=sample_weight) DCNL DCSP for (i, label) in enumerate(labels): DCNL DCSP  DCSP values = [target_names[i]] DCNL DCSP  DCSP for v in (precision[i], recall[i], specificity[i], f1[i], geo_mean[i], iba[i]): DCNL DCSP  DCSP  DCSP values += ['{0:0.{1}f}'.format(v, digits)] DCNL DCSP  DCSP values += ['{0}'.format(support[i])] DCNL DCSP  DCSP report += (fmt % tuple(values)) DCNL DCSP report += '\n' DCNL DCSP values = [last_line_heading] DCNL DCSP for v in (np.average(precision, weights=support), np.average(recall, weights=support), np.average(specificity, weights=support), np.average(f1, weights=support), np.average(geo_mean, weights=support), np.average(iba, weights=support)): DCNL DCSP  DCSP values += ['{0:0.{1}f}'.format(v, digits)] DCNL DCSP values += ['{0}'.format(np.sum(support))] DCNL DCSP report += (fmt % tuple(values)) DCNL DCSP return report
def make_prediction(dataset=None, binary=False): DCNL  DCSP if (dataset is None): DCNL DCSP  DCSP dataset = datasets.load_iris() DCNL DCSP X = dataset.data DCNL DCSP y = dataset.target DCNL DCSP if binary: DCNL DCSP  DCSP (X, y) = (X[(y < 2)], y[(y < 2)]) DCNL DCSP (n_samples, n_features) = X.shape DCNL DCSP p = np.arange(n_samples) DCNL DCSP rng = check_random_state(37) DCNL DCSP rng.shuffle(p) DCNL DCSP (X, y) = (X[p], y[p]) DCNL DCSP half = int((n_samples / 2)) DCNL DCSP rng = np.random.RandomState(0) DCNL DCSP X = np.c_[(X, rng.randn(n_samples, (200 * n_features)))] DCNL DCSP clf = svm.SVC(kernel='linear', probability=True, random_state=0) DCNL DCSP probas_pred = clf.fit(X[:half], y[:half]).predict_proba(X[half:]) DCNL DCSP if binary: DCNL DCSP  DCSP probas_pred = probas_pred[:, 1] DCNL DCSP y_pred = clf.predict(X[half:]) DCNL DCSP y_true = y[half:] DCNL DCSP return (y_true, y_pred, probas_pred)
def test_sensitivity_specificity_score_binary(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP (sen, spe, sup) = sensitivity_specificity_support(y_true, y_pred, average=None) DCNL DCSP assert_allclose(sen, [0.88, 0.68], rtol=R_TOL) DCNL DCSP assert_allclose(spe, [0.68, 0.88], rtol=R_TOL) DCNL DCSP assert_array_equal(sup, [25, 25]) DCNL DCSP for (kwargs, my_assert) in [({}, assert_no_warnings), ({'average': 'binary'}, assert_no_warnings)]: DCNL DCSP  DCSP sen = my_assert(sensitivity_score, y_true, y_pred, **kwargs) DCNL DCSP  DCSP assert_allclose(sen, 0.68, rtol=R_TOL) DCNL DCSP  DCSP spe = my_assert(specificity_score, y_true, y_pred, **kwargs) DCNL DCSP  DCSP assert_allclose(spe, 0.88, rtol=R_TOL)
def test_sensitivity_specificity_f_binary_single_class(): DCNL  DCSP assert_equal(1.0, sensitivity_score([1, 1], [1, 1])) DCNL DCSP assert_equal(0.0, specificity_score([1, 1], [1, 1])) DCNL DCSP assert_equal(0.0, sensitivity_score([(-1), (-1)], [(-1), (-1)])) DCNL DCSP assert_equal(0.0, specificity_score([(-1), (-1)], [(-1), (-1)]))
@ignore_warnings DCNL def test_sensitivity_specificity_extra_labels(): DCNL  DCSP y_true = [1, 3, 3, 2] DCNL DCSP y_pred = [1, 1, 3, 2] DCNL DCSP actual = specificity_score(y_true, y_pred, labels=[0, 1, 2, 3, 4], average=None) DCNL DCSP assert_allclose([1.0, 0.67, 1.0, 1.0, 1.0], actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_pred, labels=[0, 1, 2, 3, 4], average='macro') DCNL DCSP assert_allclose(np.mean([1.0, 0.67, 1.0, 1.0, 1.0]), actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_pred, labels=[0, 1, 2, 3, 4], average='micro') DCNL DCSP assert_allclose((15.0 / 16.0), actual, rtol=R_TOL) DCNL DCSP actual = specificity_score(y_true, y_pred, labels=[0, 1, 2, 3, 4], average='macro') DCNL DCSP assert_allclose(np.mean([1.0, 0.67, 1.0, 1.0, 1.0]), actual, rtol=R_TOL)
@ignore_warnings DCNL def test_sensitivity_specificity_ignored_labels(): DCNL  DCSP y_true = [1, 1, 2, 3] DCNL DCSP y_pred = [1, 3, 3, 3] DCNL DCSP specificity_13 = partial(specificity_score, y_true, y_pred, labels=[1, 3]) DCNL DCSP specificity_all = partial(specificity_score, y_true, y_pred, labels=None) DCNL DCSP assert_allclose([1.0, 0.33], specificity_13(average=None), rtol=R_TOL) DCNL DCSP assert_allclose(np.mean([1.0, 0.33]), specificity_13(average='macro'), rtol=R_TOL) DCNL DCSP assert_allclose(np.average([1.0, 0.33], weights=[2.0, 1.0]), specificity_13(average='weighted'), rtol=R_TOL) DCNL DCSP assert_allclose((3.0 / (3.0 + 2.0)), specificity_13(average='micro'), rtol=R_TOL) DCNL DCSP for average in ['macro', 'weighted', 'micro']: DCNL DCSP  DCSP assert_not_equal(specificity_13(average=average), specificity_all(average=average))
def test_sensitivity_specificity_error_multilabels(): DCNL  DCSP y_true = [1, 3, 3, 2] DCNL DCSP y_pred = [1, 1, 3, 2] DCNL DCSP y_true_bin = label_binarize(y_true, classes=np.arange(5)) DCNL DCSP y_pred_bin = label_binarize(y_pred, classes=np.arange(5)) DCNL DCSP assert_raises(ValueError, sensitivity_score, y_true_bin, y_pred_bin)
@ignore_warnings DCNL def test_sensitivity_specificity_support_errors(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP assert_raises(ValueError, sensitivity_specificity_support, y_true, y_pred, pos_label=2, average='binary') DCNL DCSP assert_raises(ValueError, sensitivity_specificity_support, [0, 1, 2], [1, 2, 0], average='mega')
def test_sensitivity_specificity_unused_pos_label(): DCNL  DCSP assert_warns_message(UserWarning, "Note DCSP that DCSP pos_label DCSP (set DCSP to DCSP 2) DCSP is DCSP ignored DCSP when DCSP average DCSP != DCSP 'binary' DCSP (got DCSP 'macro'). DCSP You DCSP may DCSP use DCSP labels=[pos_label] DCSP to DCSP specify DCSP a DCSP single DCSP positive DCSP class.", sensitivity_specificity_support, [1, 2, 1], [1, 2, 2], pos_label=2, average='macro')
def test_geometric_mean_support_binary(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP geo_mean = geometric_mean_score(y_true, y_pred) DCNL DCSP assert_allclose(geo_mean, 0.77, rtol=R_TOL)
def test_iba_geo_mean_binary(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP iba_gmean = make_index_balanced_accuracy(alpha=0.5, squared=True)(geometric_mean_score) DCNL DCSP iba = iba_gmean(y_true, y_pred) DCNL DCSP assert_allclose(iba, 0.5948, rtol=R_TOL)
def _format_report(report): DCNL  DCSP return ' DCSP '.join(report.split())
def test_classification_report_imbalanced_multiclass(): DCNL  DCSP iris = datasets.load_iris() DCNL DCSP (y_true, y_pred, _) = make_prediction(dataset=iris, binary=False) DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP setosa DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP versicolor DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP virginica DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred, labels=np.arange(len(iris.target_names)), target_names=iris.target_names) DCNL DCSP assert_equal(_format_report(report), expected_report) DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP 0 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP 1 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP 2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred) DCNL DCSP assert_equal(_format_report(report), expected_report)
def test_classification_report_imbalanced_multiclass_with_digits(): DCNL  DCSP iris = datasets.load_iris() DCNL DCSP (y_true, y_pred, _) = make_prediction(dataset=iris, binary=False) DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP setosa DCSP 0.82609 DCSP 0.79167 DCSP 0.92157 DCSP 0.80851 DCSP 0.86409 DCSP 0.74085 DCSP 24 DCSP versicolor DCSP 0.33333 DCSP 0.09677 DCSP 0.86364 DCSP 0.15000 DCSP 0.43809 DCSP 0.18727 DCSP 31 DCSP virginica DCSP 0.41860 DCSP 0.90000 DCSP 0.54545 DCSP 0.57143 DCSP 0.62645 DCSP 0.37208 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51375 DCSP 0.53333 DCSP 0.79733 DCSP 0.47310 DCSP 0.62464 DCSP 0.41370 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred, labels=np.arange(len(iris.target_names)), target_names=iris.target_names, digits=5) DCNL DCSP assert_equal(_format_report(report), expected_report) DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP 0 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP 1 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP 2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred) DCNL DCSP assert_equal(_format_report(report), expected_report)
def test_classification_report_imbalanced_multiclass_with_string_label(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=False) DCNL DCSP y_true = np.array(['blue', 'green', 'red'])[y_true] DCNL DCSP y_pred = np.array(['blue', 'green', 'red'])[y_pred] DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP green DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP red DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred) DCNL DCSP assert_equal(_format_report(report), expected_report) DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP a DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP b DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP c DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred, target_names=['a', 'b', 'c']) DCNL DCSP assert_equal(_format_report(report), expected_report)
def test_classification_report_imbalanced_multiclass_with_unicode_label(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=False) DCNL DCSP labels = np.array([u'blue\xa2', u'green\xa2', u'red\xa2']) DCNL DCSP y_true = labels[y_true] DCNL DCSP y_pred = labels[y_pred] DCNL DCSP expected_report = u'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue\xa2 DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP green\xa2 DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP red\xa2 DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP if (np_version[:3] < (1, 7, 0)): DCNL DCSP  DCSP expected_message = 'NumPy DCSP < DCSP 1.7.0 DCSP does DCSP not DCSP implement DCSP searchsorted DCSP on DCSP unicode DCSP data DCSP correctly.' DCNL DCSP  DCSP assert_raise_message(RuntimeError, expected_message, classification_report_imbalanced, y_true, y_pred) DCNL DCSP else: DCNL DCSP  DCSP report = classification_report_imbalanced(y_true, y_pred) DCNL DCSP  DCSP assert_equal(_format_report(report), expected_report)
def test_classification_report_imbalanced_multiclass_with_long_string_label(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=False) DCNL DCSP labels = np.array(['blue', ('green' * 5), 'red']) DCNL DCSP y_true = labels[y_true] DCNL DCSP y_pred = labels[y_pred] DCNL DCSP expected_report = 'pre DCSP rec DCSP spe DCSP f1 DCSP geo DCSP iba DCSP sup DCSP blue DCSP 0.83 DCSP 0.79 DCSP 0.92 DCSP 0.81 DCSP 0.86 DCSP 0.74 DCSP 24 DCSP greengreengreengreengreen DCSP 0.33 DCSP 0.10 DCSP 0.86 DCSP 0.15 DCSP 0.44 DCSP 0.19 DCSP 31 DCSP red DCSP 0.42 DCSP 0.90 DCSP 0.55 DCSP 0.57 DCSP 0.63 DCSP 0.37 DCSP 20 DCSP avg DCSP / DCSP total DCSP 0.51 DCSP 0.53 DCSP 0.80 DCSP 0.47 DCSP 0.62 DCSP 0.41 DCSP 75' DCNL DCSP report = classification_report_imbalanced(y_true, y_pred) DCNL DCSP assert_equal(_format_report(report), expected_report)
def test_iba_sklearn_metrics(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP acc = make_index_balanced_accuracy(alpha=0.5, squared=True)(accuracy_score) DCNL DCSP score = acc(y_true, y_pred) DCNL DCSP assert_equal(score, 0.54756) DCNL DCSP jss = make_index_balanced_accuracy(alpha=0.5, squared=True)(jaccard_similarity_score) DCNL DCSP score = jss(y_true, y_pred) DCNL DCSP assert_equal(score, 0.54756) DCNL DCSP pre = make_index_balanced_accuracy(alpha=0.5, squared=True)(precision_score) DCNL DCSP score = pre(y_true, y_pred) DCNL DCSP assert_equal(score, 0.65025) DCNL DCSP rec = make_index_balanced_accuracy(alpha=0.5, squared=True)(recall_score) DCNL DCSP score = rec(y_true, y_pred) DCNL DCSP assert_equal(score, 0.4161600000000001)
def test_iba_error_y_score_prob(): DCNL  DCSP (y_true, y_pred, _) = make_prediction(binary=True) DCNL DCSP aps = make_index_balanced_accuracy(alpha=0.5, squared=True)(average_precision_score) DCNL DCSP assert_raises(AttributeError, aps, y_true, y_pred) DCNL DCSP brier = make_index_balanced_accuracy(alpha=0.5, squared=True)(brier_score_loss) DCNL DCSP assert_raises(AttributeError, brier, y_true, y_pred) DCNL DCSP kappa = make_index_balanced_accuracy(alpha=0.5, squared=True)(cohen_kappa_score) DCNL DCSP assert_raises(AttributeError, kappa, y_true, y_pred) DCNL DCSP ras = make_index_balanced_accuracy(alpha=0.5, squared=True)(roc_auc_score) DCNL DCSP assert_raises(AttributeError, ras, y_true, y_pred)
def test_imblearn_classification_scorers(): DCNL  DCSP (X, y) = make_blobs(random_state=0, centers=2) DCNL DCSP (X_train, X_test, y_train, y_test) = train_test_split(X, y, random_state=0) DCNL DCSP clf = LinearSVC(random_state=0) DCNL DCSP clf.fit(X_train, y_train) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='macro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='weighted') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=None, average='micro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(sensitivity_score, pos_label=1) DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='macro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='weighted') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=None, average='micro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(specificity_score, pos_label=1) DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.95, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='macro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='weighted') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=None, average='micro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geometric_mean_score, pos_label=1) DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.92, rtol=R_TOL) DCNL DCSP geo_mean_iba = make_index_balanced_accuracy()(geometric_mean_score) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='macro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='weighted') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=None, average='micro') DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.85, rtol=R_TOL) DCNL DCSP scorer = make_scorer(geo_mean_iba, pos_label=1) DCNL DCSP grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, scoring=scorer) DCNL DCSP grid.fit(X_train, y_train).predict(X_test) DCNL DCSP assert_allclose(grid.best_score_, 0.84, rtol=R_TOL)
def make_imbalance(X, y, ratio, min_c_=None, random_state=None): DCNL  DCSP if isinstance(ratio, float): DCNL DCSP  DCSP if (ratio > 1): DCNL DCSP  DCSP  DCSP raise ValueError('Ration DCSP cannot DCSP be DCSP greater DCSP than DCSP one.') DCNL DCSP  DCSP elif (ratio <= 0): DCNL DCSP  DCSP  DCSP raise ValueError('Ratio DCSP cannot DCSP be DCSP negative.') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Ratio DCSP must DCSP be DCSP a DCSP float DCSP between DCSP 0.0 DCSP < DCSP ratio DCSP < DCSP 1.0') DCNL DCSP (X, y) = check_X_y(X, y) DCNL DCSP random_state = check_random_state(random_state) DCNL DCSP stats_c_ = Counter(y) DCNL DCSP LOGGER.info('The DCSP original DCSP target DCSP distribution DCSP in DCSP the DCSP dataset DCSP is: DCSP %s', stats_c_) DCNL DCSP if (min_c_ is None): DCNL DCSP  DCSP min_c_ = min(stats_c_, key=stats_c_.get) DCNL DCSP n_min_samples = int((np.count_nonzero((y != min_c_)) * ratio)) DCNL DCSP if (n_min_samples > stats_c_[min_c_]): DCNL DCSP  DCSP raise ValueError('Current DCSP imbalance DCSP ratio DCSP of DCSP data DCSP is DCSP lower DCSP than DCSP desired DCSP ratio!') DCNL DCSP if (n_min_samples == 0): DCNL DCSP  DCSP raise ValueError('Not DCSP enough DCSP samples DCSP for DCSP desired DCSP ratio!') DCNL DCSP mask = (y == min_c_) DCNL DCSP idx_maj = np.where((~ mask))[0] DCNL DCSP idx_min = np.where(mask)[0] DCNL DCSP idx_min = random_state.choice(idx_min, size=n_min_samples, replace=False) DCNL DCSP idx = np.concatenate((idx_min, idx_maj), axis=0) DCNL DCSP (X_resampled, y_resampled) = (X[idx, :], y[idx]) DCNL DCSP LOGGER.info('Make DCSP the DCSP dataset DCSP imbalanced: DCSP %s', Counter(y_resampled)) DCNL DCSP return (X_resampled, y_resampled)
def test_make_imbalance_bad_ratio(): DCNL  DCSP min_c_ = 1 DCNL DCSP ratio = 0.0 DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = (-2.0) DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = 2.0 DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP assert_raises(ValueError, make_imbalance, X, Y, ratio, min_c_)
def test_make_imbalance_invalid_ratio(): DCNL  DCSP y_ = np.zeros((X.shape[0],)) DCNL DCSP y_[0] = 1 DCNL DCSP ratio = 0.5 DCNL DCSP assert_raises(ValueError, make_imbalance, X, y_, ratio)
def test_make_imbalance_single_class(): DCNL  DCSP y_ = np.zeros((X.shape[0],)) DCNL DCSP ratio = 0.5 DCNL DCSP assert_raises(ValueError, make_imbalance, X, y_, ratio)
def test_make_imbalance_1(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.5, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 500) DCNL DCSP assert_equal(counter[1], 250) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_make_imbalance_2(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.25, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 500) DCNL DCSP assert_equal(counter[1], 125) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_make_imbalance_3(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.1, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 500) DCNL DCSP assert_equal(counter[1], 50) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_make_imbalance_4(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.01, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 500) DCNL DCSP assert_equal(counter[1], 5) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_make_imbalance_5(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.01, min_c_=0) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[1], 500) DCNL DCSP assert_equal(counter[0], 5) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_make_imbalance_multiclass(): DCNL  DCSP y_ = np.zeros(1000) DCNL DCSP y_[100:500] = 1 DCNL DCSP y_[500:] = 2 DCNL DCSP (X_, y_) = make_imbalance(X, y_, ratio=0.1, min_c_=0) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 90) DCNL DCSP assert_equal(counter[1], 400) DCNL DCSP assert_equal(counter[2], 500) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))
def test_smote_sk_estimator(): DCNL  DCSP check_estimator(SMOTETomek)
def test_smote_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTETomek(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
def test_smote_fit_single_class(): DCNL  DCSP smote = SMOTETomek(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
def test_smote_fit(): DCNL  DCSP smote = SMOTETomek(random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_equal(smote.min_c_, 0) DCNL DCSP assert_equal(smote.maj_c_, 1) DCNL DCSP assert_equal(smote.stats_c_[0], 8) DCNL DCSP assert_equal(smote.stats_c_[1], 12)
def test_smote_sample_wt_fit(): DCNL  DCSP smote = SMOTETomek(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
def test_sample_regular(): DCNL  DCSP smote = SMOTETomek(random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_regular_half(): DCNL  DCSP ratio = 0.8 DCNL DCSP smote = SMOTETomek(ratio=ratio, random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.45784496, (-0.1053161)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X(): DCNL  DCSP sm = SMOTETomek(random_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTETomek(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTETomek(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
def test_validate_estimator_init(): DCNL  DCSP smote = SMOTE(random_state=RND_SEED) DCNL DCSP tomek = TomekLinks(random_state=RND_SEED) DCNL DCSP smt = SMOTETomek(smote=smote, tomek=tomek, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_validate_estimator_default(): DCNL  DCSP smt = SMOTETomek(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_validate_estimator_deprecation(): DCNL  DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP smt = SMOTETomek(random_state=RND_SEED, n_jobs=(-1)) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP smt = SMOTETomek(random_state=RND_SEED, k=5) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_error_wrong_object(): DCNL  DCSP smote = 'rnd' DCNL DCSP tomek = 'rnd' DCNL DCSP smt = SMOTETomek(smote=smote, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y) DCNL DCSP smt = SMOTETomek(tomek=tomek, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y)
def test_senn_sk_estimator(): DCNL  DCSP check_estimator(SMOTEENN)
def test_senn_bad_ratio(): DCNL  DCSP ratio = (-1.0) DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = 'rnd' DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP smote = SMOTEENN(ratio=ratio) DCNL DCSP assert_raises(ValueError, smote.fit, X, Y)
def test_smote_fit_single_class(): DCNL  DCSP smote = SMOTEENN(random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, smote.fit, X, y_single_class)
def test_smote_fit(): DCNL  DCSP smote = SMOTEENN(random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP assert_equal(smote.min_c_, 0) DCNL DCSP assert_equal(smote.maj_c_, 1) DCNL DCSP assert_equal(smote.stats_c_[0], 8) DCNL DCSP assert_equal(smote.stats_c_[1], 12)
def test_smote_sample_wt_fit(): DCNL  DCSP smote = SMOTEENN(random_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, smote.sample, X, Y)
def test_sample_regular(): DCNL  DCSP smote = SMOTEENN(random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_regular_half(): DCNL  DCSP ratio = 0.8 DCNL DCSP smote = SMOTEENN(ratio=ratio, random_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampled, y_resampled) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.36784496, (-0.1953161)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_sample_wrong_X(): DCNL  DCSP sm = SMOTEENN(random_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))
def test_senn_multiclass_error(): DCNL  DCSP y = np.linspace(0, 1, 20) DCNL DCSP sm = SMOTEENN(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP sm = SMOTEENN(random_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, sm.fit, X, y)
def test_validate_estimator_init(): DCNL  DCSP smote = SMOTE(random_state=RND_SEED) DCNL DCSP enn = EditedNearestNeighbours(random_state=RND_SEED) DCNL DCSP smt = SMOTEENN(smote=smote, enn=enn, random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_validate_estimator_default(): DCNL  DCSP smt = SMOTEENN(random_state=RND_SEED) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_validate_estimator_deprecation(): DCNL  DCSP X_gt = np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [0.29307743, (-0.14670439)], [0.84976473, (-0.15570176)], [0.61319159, (-0.11571668)], [0.66052536, (-0.28246517)], [(-0.28162401), (-2.10400981)], [0.83680821, 1.72827342], [0.08711622, 0.93259929]]) DCNL DCSP y_gt = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]) DCNL DCSP smt = SMOTEENN(random_state=RND_SEED, n_jobs=(-1)) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt) DCNL DCSP smt = SMOTEENN(random_state=RND_SEED, k=5) DCNL DCSP (X_resampled, y_resampled) = smt.fit_sample(X, Y) DCNL DCSP assert_allclose(X_resampled, X_gt, rtol=R_TOL) DCNL DCSP assert_array_equal(y_resampled, y_gt)
def test_error_wrong_object(): DCNL  DCSP smote = 'rnd' DCNL DCSP enn = 'rnd' DCNL DCSP smt = SMOTEENN(smote=smote, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y) DCNL DCSP smt = SMOTEENN(enn=enn, random_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smt.fit, X, Y)
def parse_content_type(content_type): DCNL  DCSP if ((content_type is not None) and (';' in content_type)): DCNL DCSP  DCSP return parse_header(content_type) DCNL DCSP return (content_type, empty.dict)
def content_type(content_type): DCNL  DCSP def decorator(method): DCNL DCSP  DCSP method.content_type = content_type DCNL DCSP  DCSP return method DCNL DCSP return decorator
def underscore(text): DCNL  DCSP return UNDERSCORE[1].sub('\\1_\\2', UNDERSCORE[0].sub('\\1_\\2', text)).lower()
def camelcase(text): DCNL  DCSP return (text[0] + ''.join(text.title().split('_'))[1:])
def content_type(transformers, default=None): DCNL  DCSP transformers = {content_type: (auto_kwargs(transformer) if transformer else transformer) for (content_type, transformer) in transformers.items()} DCNL DCSP default = (default and auto_kwargs(default)) DCNL DCSP def transform(data, request): DCNL DCSP  DCSP transformer = transformers.get(request.content_type.split(';')[0], default) DCNL DCSP  DCSP if (not transformer): DCNL DCSP  DCSP  DCSP return data DCNL DCSP  DCSP return transformer(data) DCNL DCSP return transform
def suffix(transformers, default=None): DCNL  DCSP transformers = {suffix: (auto_kwargs(transformer) if transformer else transformer) for (suffix, transformer) in transformers.items()} DCNL DCSP default = (default and auto_kwargs(default)) DCNL DCSP def transform(data, request): DCNL DCSP  DCSP path = request.path DCNL DCSP  DCSP transformer = default DCNL DCSP  DCSP for (suffix_test, suffix_transformer) in transformers.items(): DCNL DCSP  DCSP  DCSP if path.endswith(suffix_test): DCNL DCSP  DCSP  DCSP  DCSP transformer = suffix_transformer DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return (transformer(data) if transformer else data) DCNL DCSP return transform
def prefix(transformers, default=None): DCNL  DCSP transformers = {prefix: (auto_kwargs(transformer) if transformer else transformer) for (prefix, transformer) in transformers.items()} DCNL DCSP default = (default and auto_kwargs(default)) DCNL DCSP def transform(data, request=None, response=None): DCNL DCSP  DCSP path = request.path DCNL DCSP  DCSP transformer = default DCNL DCSP  DCSP for (prefix_test, prefix_transformer) in transformers.items(): DCNL DCSP  DCSP  DCSP if path.startswith(prefix_test): DCNL DCSP  DCSP  DCSP  DCSP transformer = prefix_transformer DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return (transformer(data) if transformer else data) DCNL DCSP return transform
def all(*transformers): DCNL  DCSP transformers = tuple((auto_kwargs(transformer) for transformer in transformers)) DCNL DCSP def transform(data, request=None, response=None): DCNL DCSP  DCSP for transformer in transformers: DCNL DCSP  DCSP  DCSP data = transformer(data, request=request, response=response) DCNL DCSP  DCSP return data DCNL DCSP return transform
def all(*validators): DCNL  DCSP def validate_all(fields): DCNL DCSP  DCSP for validator in validators: DCNL DCSP  DCSP  DCSP errors = validator(fields) DCNL DCSP  DCSP  DCSP if errors: DCNL DCSP  DCSP  DCSP  DCSP return errors DCNL DCSP validate_all.__doc__ = ' DCSP and DCSP '.join((validator.__doc__ for validator in validators)) DCNL DCSP return validate_all
def any(*validators): DCNL  DCSP def validate_any(fields): DCNL DCSP  DCSP errors = {} DCNL DCSP  DCSP for validator in validators: DCNL DCSP  DCSP  DCSP validation_errors = validator(fields) DCNL DCSP  DCSP  DCSP if (not validation_errors): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP errors.update(validation_errors) DCNL DCSP  DCSP return errors DCNL DCSP validate_any.__doc__ = ' DCSP or DCSP '.join((validator.__doc__ for validator in validators)) DCNL DCSP return validate_any
def contains_one_of(*fields): DCNL  DCSP message = 'Must DCSP contain DCSP any DCSP one DCSP of DCSP the DCSP following DCSP fields: DCSP {0}'.format(', DCSP '.join(fields)) DCNL DCSP def check_contains(endpoint_fields): DCNL DCSP  DCSP for field in fields: DCNL DCSP  DCSP  DCSP if (field in endpoint_fields): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP errors = {} DCNL DCSP  DCSP for field in fields: DCNL DCSP  DCSP  DCSP errors[field] = 'one DCSP of DCSP these DCSP must DCSP have DCSP a DCSP value' DCNL DCSP  DCSP return errors DCNL DCSP check_contains.__doc__ = message DCNL DCSP return check_contains
def is_method(function): DCNL  DCSP return isinstance(function, MethodType)
def is_coroutine(function): DCNL  DCSP return ((function.__code__.co_flags & 128) or getattr(function, '_is_coroutine', False))
def arguments(function, extra_arguments=0): DCNL  DCSP if (not hasattr(function, '__code__')): DCNL DCSP  DCSP return () DCNL DCSP return function.__code__.co_varnames[:(function.__code__.co_argcount + extra_arguments)]
def takes_kwargs(function): DCNL  DCSP return bool((function.__code__.co_flags & 8))
def takes_args(function): DCNL  DCSP return bool((function.__code__.co_flags & 4))
def takes_arguments(function, *named_arguments): DCNL  DCSP return set(named_arguments).intersection(arguments(function))
def takes_all_arguments(function, *named_arguments): DCNL  DCSP return bool((takes_arguments(function, *named_arguments) == set(named_arguments)))
def generate_accepted_kwargs(function, *named_arguments): DCNL  DCSP if (hasattr(function, '__code__') and takes_kwargs(function)): DCNL DCSP  DCSP function_takes_kwargs = True DCNL DCSP  DCSP function_takes_arguments = [] DCNL DCSP else: DCNL DCSP  DCSP function_takes_kwargs = False DCNL DCSP  DCSP function_takes_arguments = takes_arguments(function, *named_arguments) DCNL DCSP def accepted_kwargs(kwargs): DCNL DCSP  DCSP if function_takes_kwargs: DCNL DCSP  DCSP  DCSP return kwargs DCNL DCSP  DCSP elif function_takes_arguments: DCNL DCSP  DCSP  DCSP return {key: value for (key, value) in kwargs.items() if (key in function_takes_arguments)} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {} DCNL DCSP return accepted_kwargs
def to(location, code=falcon.HTTP_302): DCNL  DCSP raise falcon.http_status.HTTPStatus(code, {'location': location})
def permanent(location): DCNL  DCSP to(location, falcon.HTTP_301)
def found(location): DCNL  DCSP to(location, falcon.HTTP_302)
def see_other(location): DCNL  DCSP to(location, falcon.HTTP_303)
def temporary(location): DCNL  DCSP to(location, falcon.HTTP_307)
def not_found(*args, **kwargs): DCNL  DCSP raise falcon.HTTPNotFound()
def authenticator(function, challenges=()): DCNL  DCSP challenges = (challenges or ('{} DCSP realm="simple"'.format(function.__name__),)) DCNL DCSP def wrapper(verify_user): DCNL DCSP  DCSP def authenticate(request, response, **kwargs): DCNL DCSP  DCSP  DCSP result = function(request, response, verify_user, **kwargs) DCNL DCSP  DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPUnauthorized('Authentication DCSP Required', 'Please DCSP provide DCSP valid DCSP {0} DCSP credentials'.format(function.__doc__.splitlines()[0]), challenges=challenges) DCNL DCSP  DCSP  DCSP if (result is False): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPUnauthorized('Invalid DCSP Authentication', 'Provided DCSP {0} DCSP credentials DCSP were DCSP invalid'.format(function.__doc__.splitlines()[0]), challenges=challenges) DCNL DCSP  DCSP  DCSP request.context['user'] = result DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP authenticate.__doc__ = function.__doc__ DCNL DCSP  DCSP return authenticate DCNL DCSP return wrapper
@authenticator DCNL def basic(request, response, verify_user, realm='simple', **kwargs): DCNL  DCSP http_auth = request.auth DCNL DCSP response.set_header('WWW-Authenticate', 'Basic') DCNL DCSP if (http_auth is None): DCNL DCSP  DCSP return DCNL DCSP if isinstance(http_auth, bytes): DCNL DCSP  DCSP http_auth = http_auth.decode('utf8') DCNL DCSP try: DCNL DCSP  DCSP (auth_type, user_and_key) = http_auth.split(' DCSP ', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPUnauthorized('Authentication DCSP Error', 'Authentication DCSP header DCSP is DCSP improperly DCSP formed', challenges=('Basic DCSP realm="{}"'.format(realm),)) DCNL DCSP if (auth_type.lower() == 'basic'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (user_id, key) = base64.decodebytes(bytes(user_and_key.strip(), 'utf8')).decode('utf8').split(':', 1) DCNL DCSP  DCSP  DCSP user = verify_user(user_id, key) DCNL DCSP  DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP  DCSP response.set_header('WWW-Authenticate', '') DCNL DCSP  DCSP  DCSP  DCSP return user DCNL DCSP  DCSP except (binascii.Error, ValueError): DCNL DCSP  DCSP  DCSP raise HTTPUnauthorized('Authentication DCSP Error', 'Unable DCSP to DCSP determine DCSP user DCSP and DCSP password DCSP with DCSP provided DCSP encoding', challenges=('Basic DCSP realm="{}"'.format(realm),)) DCNL DCSP return False
@authenticator DCNL def api_key(request, response, verify_user, **kwargs): DCNL  DCSP api_key = request.get_header('X-Api-Key') DCNL DCSP if api_key: DCNL DCSP  DCSP user = verify_user(api_key) DCNL DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP return user DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return None
@authenticator DCNL def token(request, response, verify_user, **kwargs): DCNL  DCSP token = request.get_header('Authorization') DCNL DCSP if token: DCNL DCSP  DCSP verified_token = verify_user(token) DCNL DCSP  DCSP if verified_token: DCNL DCSP  DCSP  DCSP return verified_token DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return None
def verify(user, password): DCNL  DCSP def verify_user(user_name, user_password): DCNL DCSP  DCSP if ((user_name == user) and (user_password == password)): DCNL DCSP  DCSP  DCSP return user_name DCNL DCSP  DCSP return False DCNL DCSP return verify_user
def json_convert(*kinds): DCNL  DCSP def register_json_converter(function): DCNL DCSP  DCSP for kind in kinds: DCNL DCSP  DCSP  DCSP json_converters[kind] = function DCNL DCSP  DCSP return function DCNL DCSP return register_json_converter
@content_type('application/json') DCNL def json(content, request=None, response=None, **kwargs): DCNL  DCSP if hasattr(content, 'read'): DCNL DCSP  DCSP return content DCNL DCSP if (isinstance(content, tuple) and getattr(content, '_fields', None)): DCNL DCSP  DCSP content = {field: getattr(content, field) for field in content._fields} DCNL DCSP return json_converter.dumps(content, default=_json_converter, **kwargs).encode('utf8')
def on_valid(valid_content_type, on_invalid=json): DCNL  DCSP invalid_kwargs = introspect.generate_accepted_kwargs(on_invalid, 'request', 'response') DCNL DCSP invalid_takes_response = introspect.takes_all_arguments(on_invalid, 'response') DCNL DCSP def wrapper(function): DCNL DCSP  DCSP valid_kwargs = introspect.generate_accepted_kwargs(function, 'request', 'response') DCNL DCSP  DCSP valid_takes_response = introspect.takes_all_arguments(function, 'response') DCNL DCSP  DCSP @content_type(valid_content_type) DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP def output_content(content, response, **kwargs): DCNL DCSP  DCSP  DCSP if ((type(content) == dict) and ('errors' in content)): DCNL DCSP  DCSP  DCSP  DCSP response.content_type = on_invalid.content_type DCNL DCSP  DCSP  DCSP  DCSP if invalid_takes_response: DCNL DCSP  DCSP  DCSP  DCSP  DCSP kwargs['response'] = response DCNL DCSP  DCSP  DCSP  DCSP return on_invalid(content, **invalid_kwargs(kwargs)) DCNL DCSP  DCSP  DCSP if valid_takes_response: DCNL DCSP  DCSP  DCSP  DCSP kwargs['response'] = response DCNL DCSP  DCSP  DCSP return function(content, **valid_kwargs(kwargs)) DCNL DCSP  DCSP return output_content DCNL DCSP return wrapper
@content_type('text/plain') DCNL def text(content, **kwargs): DCNL  DCSP if hasattr(content, 'read'): DCNL DCSP  DCSP return content DCNL DCSP return str(content).encode('utf8')
@content_type('text/html') DCNL def html(content, **kwargs): DCNL  DCSP if hasattr(content, 'read'): DCNL DCSP  DCSP return content DCNL DCSP elif hasattr(content, 'render'): DCNL DCSP  DCSP return content.render().encode('utf8') DCNL DCSP return str(content).encode('utf8')
@content_type('application/json') DCNL def json_camelcase(content, **kwargs): DCNL  DCSP return json(_camelcase(content), **kwargs)
@content_type('application/json') DCNL def pretty_json(content, **kwargs): DCNL  DCSP return json(content, indent=4, separators=(',', ': DCSP '), **kwargs)
def image(image_format, doc=None): DCNL  DCSP @on_valid('image/{0}'.format(image_format)) DCNL DCSP def image_handler(data, **kwargs): DCNL DCSP  DCSP if hasattr(data, 'read'): DCNL DCSP  DCSP  DCSP return data DCNL DCSP  DCSP elif hasattr(data, 'save'): DCNL DCSP  DCSP  DCSP output = stream() DCNL DCSP  DCSP  DCSP if (introspect.takes_all_arguments(data.save, 'format') or introspect.takes_kwargs(data.save)): DCNL DCSP  DCSP  DCSP  DCSP data.save(output, format=image_format.upper()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP data.save(output) DCNL DCSP  DCSP  DCSP output.seek(0) DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP elif hasattr(data, 'render'): DCNL DCSP  DCSP  DCSP return data.render() DCNL DCSP  DCSP elif os.path.isfile(data): DCNL DCSP  DCSP  DCSP return open(data, 'rb') DCNL DCSP image_handler.__doc__ = (doc or '{0} DCSP formatted DCSP image'.format(image_format)) DCNL DCSP return image_handler
def video(video_type, video_mime, doc=None): DCNL  DCSP @on_valid(video_mime) DCNL DCSP def video_handler(data, **kwargs): DCNL DCSP  DCSP if hasattr(data, 'read'): DCNL DCSP  DCSP  DCSP return data DCNL DCSP  DCSP elif hasattr(data, 'save'): DCNL DCSP  DCSP  DCSP output = stream() DCNL DCSP  DCSP  DCSP data.save(output, format=video_type.upper()) DCNL DCSP  DCSP  DCSP output.seek(0) DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP elif hasattr(data, 'render'): DCNL DCSP  DCSP  DCSP return data.render() DCNL DCSP  DCSP elif os.path.isfile(data): DCNL DCSP  DCSP  DCSP return open(data, 'rb') DCNL DCSP video_handler.__doc__ = (doc or '{0} DCSP formatted DCSP video'.format(video_type)) DCNL DCSP return video_handler
@on_valid('file/dynamic') DCNL def file(data, response, **kwargs): DCNL  DCSP if hasattr(data, 'read'): DCNL DCSP  DCSP (name, data) = (getattr(data, 'name', ''), data) DCNL DCSP elif os.path.isfile(data): DCNL DCSP  DCSP (name, data) = (data, open(data, 'rb')) DCNL DCSP else: DCNL DCSP  DCSP response.content_type = 'text/plain' DCNL DCSP  DCSP response.status = HTTP_NOT_FOUND DCNL DCSP  DCSP return 'File DCSP not DCSP found!' DCNL DCSP response.content_type = (mimetypes.guess_type(name, None)[0] or 'application/octet-stream') DCNL DCSP return data
def on_content_type(handlers, default=None, error='The DCSP requested DCSP content DCSP type DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL  DCSP def output_type(data, request, response): DCNL DCSP  DCSP handler = handlers.get(request.content_type.split(';')[0], default) DCNL DCSP  DCSP if (not handler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = handler.content_type DCNL DCSP  DCSP return handler(data, request=request, response=response) DCNL DCSP output_type.__doc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__doc__ for function in handlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(handlers.keys()) DCNL DCSP return output_type
def accept_quality(accept, default=1): DCNL  DCSP quality = default DCNL DCSP if (accept and (';' in accept)): DCNL DCSP  DCSP (accept, rest) = accept.split(';', 1) DCNL DCSP  DCSP accept_quality = RE_ACCEPT_QUALITY.search(rest) DCNL DCSP  DCSP if accept_quality: DCNL DCSP  DCSP  DCSP quality = float(accept_quality.groupdict().get('quality', quality).strip()) DCNL DCSP return (quality, accept.strip())
def accept(handlers, default=None, error='The DCSP requested DCSP content DCSP type DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL  DCSP def output_type(data, request, response): DCNL DCSP  DCSP accept = request.accept DCNL DCSP  DCSP if (accept in ('', '*', '/')): DCNL DCSP  DCSP  DCSP handler = (default or (handlers and next(iter(handlers.values())))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP handler = default DCNL DCSP  DCSP  DCSP accepted = [accept_quality(accept_type) for accept_type in accept.split(',')] DCNL DCSP  DCSP  DCSP accepted.sort(key=itemgetter(0)) DCNL DCSP  DCSP  DCSP for (quality, accepted_content_type) in reversed(accepted): DCNL DCSP  DCSP  DCSP  DCSP if (accepted_content_type in handlers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP handler = handlers[accepted_content_type] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not handler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = handler.content_type DCNL DCSP  DCSP return handler(data, request=request, response=response) DCNL DCSP output_type.__doc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__doc__ for function in handlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(handlers.keys()) DCNL DCSP return output_type
def suffix(handlers, default=None, error='The DCSP requested DCSP suffix DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL  DCSP def output_type(data, request, response): DCNL DCSP  DCSP path = request.path DCNL DCSP  DCSP handler = default DCNL DCSP  DCSP for (suffix_test, suffix_handler) in handlers.items(): DCNL DCSP  DCSP  DCSP if path.endswith(suffix_test): DCNL DCSP  DCSP  DCSP  DCSP handler = suffix_handler DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not handler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = handler.content_type DCNL DCSP  DCSP return handler(data, request=request, response=response) DCNL DCSP output_type.__doc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__doc__ for function in handlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(handlers.keys()) DCNL DCSP return output_type
def prefix(handlers, default=None, error='The DCSP requested DCSP prefix DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL  DCSP def output_type(data, request, response): DCNL DCSP  DCSP path = request.path DCNL DCSP  DCSP handler = default DCNL DCSP  DCSP for (prefix_test, prefix_handler) in handlers.items(): DCNL DCSP  DCSP  DCSP if path.startswith(prefix_test): DCNL DCSP  DCSP  DCSP  DCSP handler = prefix_handler DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not handler): DCNL DCSP  DCSP  DCSP raise falcon.HTTPNotAcceptable(error) DCNL DCSP  DCSP response.content_type = handler.content_type DCNL DCSP  DCSP return handler(data, request=request, response=response) DCNL DCSP output_type.__doc__ = 'Supports DCSP any DCSP of DCSP the DCSP following DCSP formats: DCSP {0}'.format(', DCSP '.join((function.__doc__ for function in handlers.values()))) DCNL DCSP output_type.content_type = ', DCSP '.join(handlers.keys()) DCNL DCSP return output_type
@content_type('text/plain') DCNL def text(body, charset='utf-8', **kwargs): DCNL  DCSP return body.read().decode(charset)
@content_type('application/json') DCNL def json(body, charset='utf-8', **kwargs): DCNL  DCSP return json_converter.loads(text(body, charset=charset))
def json_underscore(body, charset='utf-8', **kwargs): DCNL  DCSP return _underscore_dict(json(body, charset=charset))
@content_type('application/x-www-form-urlencoded') DCNL def urlencoded(body, charset='ascii', **kwargs): DCNL  DCSP return parse_query_string(text(body, charset=charset), False)
@content_type('multipart/form-data') DCNL def multipart(body, **header_params): DCNL  DCSP if (header_params and ('boundary' in header_params)): DCNL DCSP  DCSP if (type(header_params['boundary']) is str): DCNL DCSP  DCSP  DCSP header_params['boundary'] = header_params['boundary'].encode() DCNL DCSP form = parse_multipart((body.stream if hasattr(body, 'stream') else body), header_params) DCNL DCSP for (key, value) in form.items(): DCNL DCSP  DCSP if ((type(value) is list) and (len(value) is 1)): DCNL DCSP  DCSP  DCSP form[key] = value[0] DCNL DCSP return form
def call(method, api_or_module, url, body='', headers=None, params=None, query_string='', scheme='http', **kwargs): DCNL  DCSP api = API(api_or_module).http.server() DCNL DCSP response = StartResponseMock() DCNL DCSP headers = ({} if (headers is None) else headers) DCNL DCSP if ((not isinstance(body, str)) and ('json' in headers.get('content-type', 'application/json'))): DCNL DCSP  DCSP body = output_format.json(body) DCNL DCSP  DCSP headers.setdefault('content-type', 'application/json') DCNL DCSP params = (params if params else {}) DCNL DCSP params.update(kwargs) DCNL DCSP if params: DCNL DCSP  DCSP query_string = '{}{}{}'.format(query_string, ('&' if query_string else ''), urlencode(params, True)) DCNL DCSP result = api(create_environ(path=url, method=method, headers=headers, query_string=query_string, body=body, scheme=scheme), response) DCNL DCSP if result: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response.data = result[0].decode('utf8') DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP response.data = [] DCNL DCSP  DCSP  DCSP for chunk in result: DCNL DCSP  DCSP  DCSP  DCSP response.data.append(chunk.decode('utf8')) DCNL DCSP  DCSP  DCSP response.data = ''.join(response.data) DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP response.data = result[0] DCNL DCSP  DCSP response.content_type = response.headers_dict['content-type'] DCNL DCSP  DCSP if (response.content_type == 'application/json'): DCNL DCSP  DCSP  DCSP response.data = json.loads(response.data) DCNL DCSP return response
def cli(method, *args, **arguments): DCNL  DCSP collect_output = arguments.pop('collect_output', True) DCNL DCSP command_args = ([method.__name__] + list(args)) DCNL DCSP for (name, values) in arguments.items(): DCNL DCSP  DCSP if (not isinstance(values, (tuple, list))): DCNL DCSP  DCSP  DCSP values = (values,) DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP command_args.append('--{0}'.format(name)) DCNL DCSP  DCSP  DCSP if (not (value in (True, False))): DCNL DCSP  DCSP  DCSP  DCSP command_args.append('{0}'.format(value)) DCNL DCSP old_sys_argv = sys.argv DCNL DCSP sys.argv = [str(part) for part in command_args] DCNL DCSP old_output = method.interface.cli.output DCNL DCSP if collect_output: DCNL DCSP  DCSP method.interface.cli.outputs = (lambda data: to_return.append(data)) DCNL DCSP to_return = [] DCNL DCSP try: DCNL DCSP  DCSP method.interface.cli() DCNL DCSP except Exception as e: DCNL DCSP  DCSP to_return = (e,) DCNL DCSP method.interface.cli.output = old_output DCNL DCSP sys.argv = old_sys_argv DCNL DCSP return ((to_return and to_return[0]) or None)
def _built_in_directive(directive): DCNL  DCSP directive.directive = True DCNL DCSP return directive
@_built_in_directive DCNL def module(default=None, api=None, **kwargs): DCNL  DCSP return (api.module if api else default)
@_built_in_directive DCNL def api(default=None, api=None, **kwargs): DCNL  DCSP return (api if api else default)
@_built_in_directive DCNL def api_version(default=None, api_version=None, **kwargs): DCNL  DCSP return api_version
@_built_in_directive DCNL def documentation(default=None, api_version=None, api=None, **kwargs): DCNL  DCSP api_version = (default or api_version) DCNL DCSP if api: DCNL DCSP  DCSP return api.http.documentation(base_url='', api_version=api_version)
@_built_in_directive DCNL def session(context_name='session', request=None, **kwargs): DCNL  DCSP return (request and request.context.get(context_name, None))
@_built_in_directive DCNL def user(default=None, request=None, **kwargs): DCNL  DCSP return ((request and request.context.get('user', None)) or default)
def default_output_format(content_type='application/json', apply_globally=False, api=None): DCNL  DCSP def decorator(formatter): DCNL DCSP  DCSP formatter = hug.output_format.content_type(content_type)(formatter) DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.defaults.output_format = formatter DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(formatter)) DCNL DCSP  DCSP  DCSP apply_to_api.http.output_format = formatter DCNL DCSP  DCSP return formatter DCNL DCSP return decorator
def default_input_format(content_type='application/json', apply_globally=False, api=None): DCNL  DCSP def decorator(formatter): DCNL DCSP  DCSP formatter = hug.output_format.content_type(content_type)(formatter) DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.defaults.input_format[content_type] = formatter DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(formatter)) DCNL DCSP  DCSP  DCSP apply_to_api.http.set_input_format(content_type, formatter) DCNL DCSP  DCSP return formatter DCNL DCSP return decorator
def directive(apply_globally=False, api=None): DCNL  DCSP def decorator(directive_method): DCNL DCSP  DCSP if apply_globally: DCNL DCSP  DCSP  DCSP hug.defaults.directives[underscore(directive_method.__name__)] = directive_method DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(directive_method)) DCNL DCSP  DCSP  DCSP apply_to_api.add_directive(directive_method) DCNL DCSP  DCSP directive_method.directive = True DCNL DCSP  DCSP return directive_method DCNL DCSP return decorator
def startup(api=None): DCNL  DCSP def startup_wrapper(startup_function): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(startup_function)) DCNL DCSP  DCSP apply_to_api.http.add_startup_handler(startup_function) DCNL DCSP  DCSP return startup_function DCNL DCSP return startup_wrapper
def request_middleware(api=None): DCNL  DCSP def decorator(middleware_method): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(middleware_method)) DCNL DCSP  DCSP class MiddlewareRouter(object, ): DCNL DCSP  DCSP  DCSP __slots__ = () DCNL DCSP  DCSP  DCSP def process_request(self, request, response): DCNL DCSP  DCSP  DCSP  DCSP return middleware_method(request, response) DCNL DCSP  DCSP apply_to_api.http.add_middleware(MiddlewareRouter()) DCNL DCSP  DCSP return middleware_method DCNL DCSP return decorator
def response_middleware(api=None): DCNL  DCSP def decorator(middleware_method): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(middleware_method)) DCNL DCSP  DCSP class MiddlewareRouter(object, ): DCNL DCSP  DCSP  DCSP __slots__ = () DCNL DCSP  DCSP  DCSP def process_response(self, request, response, resource): DCNL DCSP  DCSP  DCSP  DCSP return middleware_method(request, response, resource) DCNL DCSP  DCSP apply_to_api.http.add_middleware(MiddlewareRouter()) DCNL DCSP  DCSP return middleware_method DCNL DCSP return decorator
def middleware_class(api=None): DCNL  DCSP def decorator(middleware_class): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(middleware_class)) DCNL DCSP  DCSP apply_to_api.http.add_middleware(middleware_class()) DCNL DCSP  DCSP return middleware_class DCNL DCSP return decorator
def extend_api(route='', api=None, base_url=''): DCNL  DCSP def decorator(extend_with): DCNL DCSP  DCSP apply_to_api = (hug.API(api) if api else hug.api.from_object(extend_with)) DCNL DCSP  DCSP for extended_api in extend_with(): DCNL DCSP  DCSP  DCSP apply_to_api.extend(extended_api, route, base_url) DCNL DCSP  DCSP return extend_with DCNL DCSP return decorator
def wraps(function): DCNL  DCSP def wrap(decorator): DCNL DCSP  DCSP decorator = functools.wraps(function)(decorator) DCNL DCSP  DCSP if (not hasattr(function, 'original')): DCNL DCSP  DCSP  DCSP decorator.original = function DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP decorator.original = function.original DCNL DCSP  DCSP  DCSP delattr(function, 'original') DCNL DCSP  DCSP return decorator DCNL DCSP return wrap
def auto_kwargs(function): DCNL  DCSP supported = introspect.arguments(function) DCNL DCSP @wraps(function) DCNL DCSP def call_function(*args, **kwargs): DCNL DCSP  DCSP return function(*args, **{key: value for (key, value) in kwargs.items() if (key in supported)}) DCNL DCSP return call_function
@hug.post('/upload') DCNL def upload_file(body): DCNL  DCSP print ('body: DCSP ', body) DCNL DCSP return {'filename': list(body.keys()).pop(), 'filesize': len(list(body.values()).pop())}
@hug.get('/image.png', output=hug.output_format.png_image) DCNL def image(): DCNL  DCSP return '../artwork/logo.png'
@hug.startup() DCNL def add_data(api): DCNL  DCSP data.append("It's DCSP working")
@hug.startup() DCNL def add_more_data(api): DCNL  DCSP data.append('Even DCSP subsequent DCSP calls')
@hug.get() DCNL def test(): DCNL  DCSP return data
@hug.post() DCNL def post_here(body): DCNL  DCSP return body
@hug.get() DCNL def hello(request): DCNL  DCSP return 'Hello DCSP World!'
@hug.get(output=hug.output_format.mp4_video) DCNL def watch(): DCNL  DCSP return 'movie.mp4'
@hug.directive(apply_globally=False) DCNL def my_directive(default=None, **kwargs): DCNL  DCSP return default
@hug.default_input_format('application/made-up') DCNL def made_up_formatter(data): DCNL  DCSP return data
@hug.default_output_format() DCNL def output_formatter(data): DCNL  DCSP return hug.output_format.json(data)
@hug.get() DCNL def made_up_api(hug_my_directive=True): DCNL  DCSP return hug_my_directive
@hug.directive(apply_globally=True) DCNL def my_directive_global(default=None, **kwargs): DCNL  DCSP return default
@hug.default_input_format('application/made-up', apply_globally=True) DCNL def made_up_formatter_global(data): DCNL  DCSP return data
@hug.default_output_format(apply_globally=True) DCNL def output_formatter_global(data): DCNL  DCSP return hug.output_format.json(data)
@hug.request_middleware() DCNL def handle_request(request, response): DCNL  DCSP return
@hug.startup() DCNL def on_startup(api): DCNL  DCSP return
@hug.static() DCNL def static(): DCNL  DCSP return ('',)
@hug.sink('/all') DCNL def sink(path): DCNL  DCSP return path
@hug.exception(FakeException) DCNL def handle_exception(exception): DCNL  DCSP return True
@hug.not_found() DCNL def not_found_handler(): DCNL  DCSP return True
def test_from_object(): DCNL  DCSP assert (hug.api.from_object(TestAPI) == api)
def test_api_fixture(hug_api): DCNL  DCSP assert isinstance(hug_api, hug.API) DCNL DCSP assert (hug_api != api)
def test_content_type(): DCNL  DCSP transformer = hug.transform.content_type({'application/json': int, 'text/plain': str}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP content_type = 'application/json' DCNL DCSP request = FakeRequest() DCNL DCSP assert (transformer('1', request) == 1) DCNL DCSP request.content_type = 'text/plain' DCNL DCSP assert (transformer(2, request) == '2') DCNL DCSP request.content_type = 'undefined' DCNL DCSP (transformer({'data': 'value'}, request) == {'data': 'value'})
def test_suffix(): DCNL  DCSP transformer = hug.transform.suffix({'.js': int, '.txt': str}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP path = 'hey.js' DCNL DCSP request = FakeRequest() DCNL DCSP assert (transformer('1', request) == 1) DCNL DCSP request.path = 'hey.txt' DCNL DCSP assert (transformer(2, request) == '2') DCNL DCSP request.path = 'hey.undefined' DCNL DCSP (transformer({'data': 'value'}, request) == {'data': 'value'})
def test_prefix(): DCNL  DCSP transformer = hug.transform.prefix({'js/': int, 'txt/': str}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP path = 'js/hey' DCNL DCSP request = FakeRequest() DCNL DCSP assert (transformer('1', request) == 1) DCNL DCSP request.path = 'txt/hey' DCNL DCSP assert (transformer(2, request) == '2') DCNL DCSP request.path = 'hey.undefined' DCNL DCSP (transformer({'data': 'value'}, request) == {'data': 'value'})
def test_all(): DCNL  DCSP def annotate(data, response): DCNL DCSP  DCSP return {'Text': data} DCNL DCSP assert (hug.transform.all(str, annotate)(1, response='hi') == {'Text': '1'})
def test_to(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.to('/') DCNL DCSP assert ('302' in redirect.value.status)
def test_permanent(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.permanent('/') DCNL DCSP assert ('301' in redirect.value.status)
def test_found(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.found('/') DCNL DCSP assert ('302' in redirect.value.status)
def test_see_other(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.see_other('/') DCNL DCSP assert ('303' in redirect.value.status)
def test_temporary(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.temporary('/') DCNL DCSP assert ('307' in redirect.value.status)
def test_text(): DCNL  DCSP (hug.output_format.text('Hello DCSP World!') == 'Hello DCSP World!') DCNL DCSP (hug.output_format.text(str(1)) == '1')
def test_html(): DCNL  DCSP (hug.output_format.html('<html>Hello DCSP World!</html>') == '<html>Hello DCSP World!</html>') DCNL DCSP (hug.output_format.html(str(1)) == '1') DCNL DCSP with open(os.path.join(BASE_DIRECTORY, 'README.md'), 'rb') as html_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.html(html_file), 'read') DCNL DCSP class FakeHTMLWithRender: DCNL DCSP  DCSP def render(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.html(FakeHTMLWithRender()) == 'test')
def test_json(): DCNL  DCSP now = datetime.now() DCNL DCSP test_data = {'text': 'text', 'datetime': now, 'bytes': 'bytes'} DCNL DCSP output = hug.output_format.json(test_data).decode('utf8') DCNL DCSP assert ('text' in output) DCNL DCSP assert ('bytes' in output) DCNL DCSP assert (now.isoformat() in output) DCNL DCSP class NewObject(object, ): DCNL DCSP  DCSP pass DCNL DCSP test_data['non_serializable'] = NewObject() DCNL DCSP with pytest.raises(TypeError): DCNL DCSP  DCSP hug.output_format.json(test_data).decode('utf8') DCNL DCSP class NamedTupleObject(namedtuple('BaseTuple', ('name', 'value')), ): DCNL DCSP  DCSP pass DCNL DCSP data = NamedTupleObject('name', 'value') DCNL DCSP converted = hug.input_format.json(BytesIO(hug.output_format.json(data))) DCNL DCSP assert (converted == {'name': 'name', 'value': 'value'}) DCNL DCSP data = set((1, 2, 3, 3)) DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(data))) == [1, 2, 3]) DCNL DCSP data = (number for number in range(1, 4)) DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(data))) == [1, 2, 3]) DCNL DCSP data = [Decimal(1.5), Decimal('155.23'), Decimal('1234.25')] DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(data))) == ['1.5', '155.23', '1234.25']) DCNL DCSP with open(os.path.join(BASE_DIRECTORY, 'README.md'), 'rb') as json_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.json(json_file), 'read') DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json('\x9c'))) == 'nA==') DCNL DCSP class MyCrazyObject(object, ): DCNL DCSP  DCSP pass DCNL DCSP @hug.output_format.json_convert(MyCrazyObject) DCNL DCSP def convert(instance): DCNL DCSP  DCSP return 'Like DCSP anyone DCSP could DCSP convert DCSP this' DCNL DCSP assert (hug.input_format.json(BytesIO(hug.output_format.json(MyCrazyObject()))) == 'Like DCSP anyone DCSP could DCSP convert DCSP this')
def test_pretty_json(): DCNL  DCSP test_data = {'text': 'text'} DCNL DCSP assert (hug.output_format.pretty_json(test_data).decode('utf8') == '{\n DCSP  DCSP  DCSP  DCSP "text": DCSP "text"\n}')
def test_json_camelcase(): DCNL  DCSP test_data = {'under_score': 'values_can', 'be_converted': [{'to_camelcase': 'value'}, 'wont_be_convert']} DCNL DCSP output = hug.output_format.json_camelcase(test_data).decode('utf8') DCNL DCSP assert ('underScore' in output) DCNL DCSP assert ('values_can' in output) DCNL DCSP assert ('beConverted' in output) DCNL DCSP assert ('toCamelcase' in output) DCNL DCSP assert ('value' in output) DCNL DCSP assert ('wont_be_convert' in output)
def test_image(): DCNL  DCSP logo_path = os.path.join(BASE_DIRECTORY, 'artwork', 'logo.png') DCNL DCSP assert hasattr(hug.output_format.png_image(logo_path, hug.Response()), 'read') DCNL DCSP with open(logo_path, 'rb') as image_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.png_image(image_file, hug.Response()), 'read') DCNL DCSP assert (hug.output_format.png_image('Not DCSP Existent', hug.Response()) is None) DCNL DCSP class FakeImageWithSave: DCNL DCSP  DCSP def save(self, to, format): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSave(), hug.Response()), 'read') DCNL DCSP class FakeImageWithRender: DCNL DCSP  DCSP def render(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.svg_xml_image(FakeImageWithRender(), hug.Response()) == 'test') DCNL DCSP class FakeImageWithSaveNoFormat: DCNL DCSP  DCSP def save(self, to): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSaveNoFormat(), hug.Response()), 'read')
def test_file(): DCNL  DCSP class FakeResponse(object, ): DCNL DCSP  DCSP pass DCNL DCSP logo_path = os.path.join(BASE_DIRECTORY, 'artwork', 'logo.png') DCNL DCSP fake_response = FakeResponse() DCNL DCSP assert hasattr(hug.output_format.file(logo_path, fake_response), 'read') DCNL DCSP assert (fake_response.content_type == 'image/png') DCNL DCSP with open(logo_path, 'rb') as image_file: DCNL DCSP  DCSP hasattr(hug.output_format.file(image_file, fake_response), 'read') DCNL DCSP assert (not hasattr(hug.output_format.file('NON DCSP EXISTENT DCSP FILE', fake_response), 'read'))
def test_video(): DCNL  DCSP gif_path = os.path.join(BASE_DIRECTORY, 'artwork', 'example.gif') DCNL DCSP assert hasattr(hug.output_format.mp4_video(gif_path, hug.Response()), 'read') DCNL DCSP with open(gif_path, 'rb') as image_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.mp4_video(image_file, hug.Response()), 'read') DCNL DCSP assert (hug.output_format.mp4_video('Not DCSP Existent', hug.Response()) is None) DCNL DCSP class FakeVideoWithSave: DCNL DCSP  DCSP def save(self, to, format): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.mp4_video(FakeVideoWithSave(), hug.Response()), 'read') DCNL DCSP class FakeVideoWithSave: DCNL DCSP  DCSP def render(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.avi_video(FakeVideoWithSave(), hug.Response()) == 'test')
def test_on_valid(): DCNL  DCSP error_dict = {'errors': {'so': 'many'}} DCNL DCSP expected = hug.output_format.json(error_dict) DCNL DCSP assert (hug.output_format.mp4_video(error_dict, hug.Response()) == expected) DCNL DCSP assert (hug.output_format.png_image(error_dict, hug.Response()) == expected) DCNL DCSP @hug.output_format.on_valid('image', hug.output_format.file) DCNL DCSP def my_output_format(data): DCNL DCSP  DCSP raise ValueError('This DCSP should DCSP never DCSP be DCSP called') DCNL DCSP assert my_output_format(error_dict, hug.Response())
def test_on_content_type(): DCNL  DCSP formatter = hug.output_format.on_content_type({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP content_type = 'application/json' DCNL DCSP request = FakeRequest() DCNL DCSP response = FakeRequest() DCNL DCSP converted = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), request, response)) DCNL DCSP assert (converted == {'name': 'name'}) DCNL DCSP request.content_type = 'text/plain' DCNL DCSP assert (formatter('hi', request, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP request.content_type = 'undefined; DCSP always' DCNL DCSP  DCSP formatter('hi', request, response)
def test_accept(): DCNL  DCSP formatter = hug.output_format.accept({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP accept = 'application/json' DCNL DCSP request = FakeRequest() DCNL DCSP response = FakeRequest() DCNL DCSP converted = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), request, response)) DCNL DCSP assert (converted == {'name': 'name'}) DCNL DCSP request.accept = 'text/plain' DCNL DCSP assert (formatter('hi', request, response) == 'hi') DCNL DCSP request.accept = 'application/json, DCSP text/plain; DCSP q=0.5' DCNL DCSP assert (formatter('hi', request, response) == '"hi"') DCNL DCSP request.accept = 'text/plain; DCSP q=0.5, DCSP application/json' DCNL DCSP assert (formatter('hi', request, response) == '"hi"') DCNL DCSP request.accept = 'application/json;q=0.4,text/plain; DCSP q=0.5' DCNL DCSP assert (formatter('hi', request, response) == 'hi') DCNL DCSP request.accept = '*' DCNL DCSP assert (formatter('hi', request, response) in ['"hi"', 'hi']) DCNL DCSP request.accept = 'undefined; DCSP always' DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP formatter('hi', request, response) DCNL DCSP formatter = hug.output_format.accept({'application/json': hug.output_format.json, 'text/plain': hug.output_format.text}, hug.output_format.json) DCNL DCSP assert (formatter('hi', request, response) == '"hi"')
def test_suffix(): DCNL  DCSP formatter = hug.output_format.suffix({'.js': hug.output_format.json, '.html': hug.output_format.text}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP path = 'endpoint.js' DCNL DCSP request = FakeRequest() DCNL DCSP response = FakeRequest() DCNL DCSP converted = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), request, response)) DCNL DCSP assert (converted == {'name': 'name'}) DCNL DCSP request.path = 'endpoint.html' DCNL DCSP assert (formatter('hi', request, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP request.path = 'undefined.always' DCNL DCSP  DCSP formatter('hi', request, response)
def test_prefix(): DCNL  DCSP formatter = hug.output_format.prefix({'js/': hug.output_format.json, 'html/': hug.output_format.text}) DCNL DCSP class FakeRequest(object, ): DCNL DCSP  DCSP path = 'js/endpoint' DCNL DCSP request = FakeRequest() DCNL DCSP response = FakeRequest() DCNL DCSP converted = hug.input_format.json(formatter(BytesIO(hug.output_format.json({'name': 'name'})), request, response)) DCNL DCSP assert (converted == {'name': 'name'}) DCNL DCSP request.path = 'html/endpoint' DCNL DCSP assert (formatter('hi', request, response) == 'hi') DCNL DCSP with pytest.raises(hug.HTTPNotAcceptable): DCNL DCSP  DCSP request.path = 'undefined.always' DCNL DCSP  DCSP formatter('hi', request, response)
def test_simple_class_based_view(): DCNL  DCSP @hug.object.urls('/endpoint', requires=()) DCNL DCSP class MyClass(object, ): DCNL DCSP  DCSP @hug.object.get() DCNL DCSP  DCSP def my_method(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP @hug.object.post() DCNL DCSP  DCSP def my_method_two(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'endpoint').data == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'endpoint').data == 'bye')
def test_simple_class_based_method_view(): DCNL  DCSP @hug.object.http_methods() DCNL DCSP class EndPoint(object, ): DCNL DCSP  DCSP def get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP def post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'endpoint').data == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'endpoint').data == 'bye')
def test_routing_class_based_method_view_with_sub_routing(): DCNL  DCSP @hug.object.http_methods() DCNL DCSP class EndPoint(object, ): DCNL DCSP  DCSP def get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP @hug.object.urls('/home/') DCNL DCSP  DCSP def post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'endpoint').data == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'home').data == 'bye')
def test_routing_class_with_cli_commands(): DCNL  DCSP @hug.object(name='git', version='1.0.0') DCNL DCSP class GIT(object, ): DCNL DCSP  DCSP 'An DCSP example DCSP of DCSP command DCSP like DCSP calls DCSP via DCSP an DCSP Object' DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP def push(self, branch='master'): DCNL DCSP  DCSP  DCSP return 'Pushing DCSP {}'.format(branch) DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP def pull(self, branch='master'): DCNL DCSP  DCSP  DCSP return 'Pulling DCSP {}'.format(branch) DCNL DCSP assert ('token' in hug.test.cli(GIT.push, branch='token')) DCNL DCSP assert ('another DCSP token' in hug.test.cli(GIT.pull, branch='another DCSP token'))
def test_routing_class_based_method_view_with_cli_routing(): DCNL  DCSP @hug.object.http_methods() DCNL DCSP class EndPoint(object, ): DCNL DCSP  DCSP @hug.object.cli DCNL DCSP  DCSP def get(self): DCNL DCSP  DCSP  DCSP return 'hi DCSP there!' DCNL DCSP  DCSP def post(self): DCNL DCSP  DCSP  DCSP return 'bye' DCNL DCSP assert (hug.test.get(api, 'endpoint').data == 'hi DCSP there!') DCNL DCSP assert (hug.test.post(api, 'endpoint').data == 'bye') DCNL DCSP assert (hug.test.cli(EndPoint.get) == 'hi DCSP there!')
def test_routing_instance(): DCNL  DCSP class EndPoint(object, ): DCNL DCSP  DCSP @hug.object DCNL DCSP  DCSP def one(self): DCNL DCSP  DCSP  DCSP return 'one' DCNL DCSP  DCSP @hug.object DCNL DCSP  DCSP def two(self): DCNL DCSP  DCSP  DCSP return 2 DCNL DCSP hug.object.get()(EndPoint()) DCNL DCSP assert (hug.test.get(api, 'one').data == 'one') DCNL DCSP assert (hug.test.get(api, 'two').data == 2)
def test_is_method(): DCNL  DCSP assert (not hug.introspect.is_method(function_with_kwargs)) DCNL DCSP assert hug.introspect.is_method(Object().my_method)
def test_arguments(): DCNL  DCSP def function(argument1, argument2): DCNL DCSP  DCSP pass DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_kwargs)) == ('argument1',)) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_args)) == ('argument1',)) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_neither)) == ('argument1', 'argument2')) DCNL DCSP assert (tuple(hug.introspect.arguments(function_with_both)) == ('argument1', 'argument2', 'argument3'))
def test_takes_kwargs(): DCNL  DCSP assert hug.introspect.takes_kwargs(function_with_kwargs) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_args)) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_neither)) DCNL DCSP assert hug.introspect.takes_kwargs(function_with_both)
def test_takes_args(): DCNL  DCSP assert (not hug.introspect.takes_args(function_with_kwargs)) DCNL DCSP assert hug.introspect.takes_args(function_with_args) DCNL DCSP assert (not hug.introspect.takes_args(function_with_neither)) DCNL DCSP assert hug.introspect.takes_args(function_with_both)
def test_takes_arguments(): DCNL  DCSP assert (hug.introspect.takes_arguments(function_with_kwargs, 'argument1', 'argument3') == set(('argument1',))) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_args, 'bacon') == set()) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_neither, 'argument1', 'argument2') == set(('argument1', 'argument2'))) DCNL DCSP assert (hug.introspect.takes_arguments(function_with_both, 'argument3', 'bacon') == set(('argument3',)))
def test_takes_all_arguments(): DCNL  DCSP assert (not hug.introspect.takes_all_arguments(function_with_kwargs, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert (not hug.introspect.takes_all_arguments(function_with_args, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert (not hug.introspect.takes_all_arguments(function_with_neither, 'argument1', 'argument2', 'argument3')) DCNL DCSP assert hug.introspect.takes_all_arguments(function_with_both, 'argument1', 'argument2', 'argument3')
def test_generate_accepted_kwargs(): DCNL  DCSP source_dictionary = {'argument1': 1, 'argument2': 2, 'hey': 'there', 'hi': 'hello'} DCNL DCSP kwargs = hug.introspect.generate_accepted_kwargs(function_with_kwargs, 'bacon', 'argument1')(source_dictionary) DCNL DCSP assert (kwargs == source_dictionary) DCNL DCSP kwargs = hug.introspect.generate_accepted_kwargs(function_with_args, 'bacon', 'argument1')(source_dictionary) DCNL DCSP assert (kwargs == {'argument1': 1}) DCNL DCSP kwargs = hug.introspect.generate_accepted_kwargs(function_with_neither, 'argument1', 'argument2')(source_dictionary) DCNL DCSP assert (kwargs == {'argument1': 1, 'argument2': 2}) DCNL DCSP kwargs = hug.introspect.generate_accepted_kwargs(function_with_both, 'argument1', 'argument2')(source_dictionary) DCNL DCSP assert (kwargs == source_dictionary)
@pytest.fixture DCNL def hug_api(): DCNL  DCSP api = TestAPI('fake_api_{}'.format(randint(0, 1000000))) DCNL DCSP api.route = Routers(hug.routing.URLRouter().api(api), hug.routing.LocalRouter().api(api), hug.routing.CLIRouter().api(api)) DCNL DCSP return api
def test_basic_call_coroutine(): DCNL  DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP assert (loop.run_until_complete(hello_world()) == 'Hello DCSP World!')
def test_nested_basic_call_coroutine(): DCNL  DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP def hello_world(): DCNL DCSP  DCSP return asyncio.async(nested_hello_world()) DCNL DCSP @hug.local() DCNL DCSP @asyncio.coroutine DCNL DCSP def nested_hello_world(): DCNL DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP assert (loop.run_until_complete(hello_world()) == 'Hello DCSP World!')
def test_basic_call_on_method_coroutine(): DCNL  DCSP class API(object, ): DCNL DCSP  DCSP @hug.call() DCNL DCSP  DCSP @asyncio.coroutine DCNL DCSP  DCSP def hello_world(self=None): DCNL DCSP  DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP api_instance = API() DCNL DCSP assert api_instance.hello_world.interface.http DCNL DCSP assert (loop.run_until_complete(api_instance.hello_world()) == 'Hello DCSP World!') DCNL DCSP assert (hug.test.get(api, '/hello_world').data == 'Hello DCSP World!')
def test_basic_call_on_method_through_api_instance_coroutine(): DCNL  DCSP class API(object, ): DCNL DCSP  DCSP def hello_world(self): DCNL DCSP  DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP api_instance = API() DCNL DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP def hello_world(): DCNL DCSP  DCSP return api_instance.hello_world() DCNL DCSP assert (api_instance.hello_world() == 'Hello DCSP World!') DCNL DCSP assert (hug.test.get(api, '/hello_world').data == 'Hello DCSP World!')
def test_basic_call_on_method_registering_without_decorator_coroutine(): DCNL  DCSP class API(object, ): DCNL DCSP  DCSP def __init__(self): DCNL DCSP  DCSP  DCSP hug.call()(self.hello_world_method) DCNL DCSP  DCSP @asyncio.coroutine DCNL DCSP  DCSP def hello_world_method(self): DCNL DCSP  DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP api_instance = API() DCNL DCSP assert (loop.run_until_complete(api_instance.hello_world_method()) == 'Hello DCSP World!') DCNL DCSP assert (hug.test.get(api, '/hello_world_method').data == 'Hello DCSP World!')
def test_type(): DCNL  DCSP with pytest.raises(NotImplementedError): DCNL DCSP  DCSP hug.types.Type()('value')
def test_number(): DCNL  DCSP assert (hug.types.number('1') == 1) DCNL DCSP assert (hug.types.number(1) == 1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.number('bacon')
def test_range(): DCNL  DCSP assert (hug.types.in_range(1, 10)('1') == 1) DCNL DCSP assert (hug.types.in_range(1, 10)(1) == 1) DCNL DCSP assert ('1' in hug.types.in_range(1, 10).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)('bacon') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)('15') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.in_range(1, 10)((-34))
def test_less_than(): DCNL  DCSP assert (hug.types.less_than(10)('1') == 1) DCNL DCSP assert (hug.types.less_than(10)(1) == 1) DCNL DCSP assert (hug.types.less_than(10)((-10)) == (-10)) DCNL DCSP assert ('10' in hug.types.less_than(10).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.less_than(10)(10)
def test_greater_than(): DCNL  DCSP assert (hug.types.greater_than(10)('11') == 11) DCNL DCSP assert (hug.types.greater_than(10)(11) == 11) DCNL DCSP assert (hug.types.greater_than(10)(1000) == 1000) DCNL DCSP assert ('10' in hug.types.greater_than(10).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.greater_than(10)(9)
def test_multiple(): DCNL  DCSP assert (hug.types.multiple('value') == ['value']) DCNL DCSP assert (hug.types.multiple(['value1', 'value2']) == ['value1', 'value2'])
def test_delimited_list(): DCNL  DCSP assert (hug.types.delimited_list(',')('value1,value2') == ['value1', 'value2']) DCNL DCSP assert (hug.types.delimited_list(',')(['value1', 'value2']) == ['value1', 'value2']) DCNL DCSP assert (hug.types.delimited_list('|-|')('value1|-|value2|-|value3,value4') == ['value1', 'value2', 'value3,value4']) DCNL DCSP assert (',' in hug.types.delimited_list(',').__doc__)
def test_comma_separated_list(): DCNL  DCSP assert (hug.types.comma_separated_list('value') == ['value']) DCNL DCSP assert (hug.types.comma_separated_list('value1,value2') == ['value1', 'value2'])
def test_float_number(): DCNL  DCSP assert (hug.types.float_number('1.1') == 1.1) DCNL DCSP assert (hug.types.float_number('1') == float(1)) DCNL DCSP assert (hug.types.float_number(1.1) == 1.1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.float_number('bacon')
def test_decimal(): DCNL  DCSP assert (hug.types.decimal('1.1') == Decimal('1.1')) DCNL DCSP assert (hug.types.decimal('1') == Decimal('1')) DCNL DCSP assert (hug.types.decimal(1.1) == Decimal(1.1)) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.decimal('bacon')
def test_boolean(): DCNL  DCSP assert hug.types.boolean('1') DCNL DCSP assert hug.types.boolean('T') DCNL DCSP assert (not hug.types.boolean('')) DCNL DCSP assert hug.types.boolean('False') DCNL DCSP assert (not hug.types.boolean(False))
def test_mapping(): DCNL  DCSP mapping_type = hug.types.mapping({'n': None, 'l': [], 's': set()}) DCNL DCSP assert (mapping_type('n') is None) DCNL DCSP assert (mapping_type('l') == []) DCNL DCSP assert (mapping_type('s') == set()) DCNL DCSP assert ('n' in mapping_type.__doc__) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP mapping_type('bacon')
def test_smart_boolean(): DCNL  DCSP assert hug.types.smart_boolean('true') DCNL DCSP assert hug.types.smart_boolean('t') DCNL DCSP assert hug.types.smart_boolean('1') DCNL DCSP assert hug.types.smart_boolean(1) DCNL DCSP assert (not hug.types.smart_boolean('')) DCNL DCSP assert (not hug.types.smart_boolean('false')) DCNL DCSP assert (not hug.types.smart_boolean('f')) DCNL DCSP assert (not hug.types.smart_boolean('0')) DCNL DCSP assert (not hug.types.smart_boolean(0)) DCNL DCSP assert hug.types.smart_boolean(True) DCNL DCSP assert (not hug.types.smart_boolean(None)) DCNL DCSP assert (not hug.types.smart_boolean(False)) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP hug.types.smart_boolean('bacon')
def test_text(): DCNL  DCSP assert (hug.types.text('1') == '1') DCNL DCSP assert (hug.types.text(1) == '1') DCNL DCSP assert (hug.types.text('text') == 'text') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.text(['one', 'two'])
def test_uuid(): DCNL  DCSP assert (hug.types.uuid('{12345678-1234-5678-1234-567812345678}') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP assert (hug.types.uuid('12345678-1234-5678-1234-567812345678') == UUID('12345678123456781234567812345678')) DCNL DCSP assert (hug.types.uuid('12345678123456781234567812345678') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP assert (hug.types.uuid('urn:uuid:12345678-1234-5678-1234-567812345678') == UUID('12345678-1234-5678-1234-567812345678')) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuid(1) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuid('12345678-1234-5678-1234-56781234567G') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuid('12345678-1234-5678-1234-5678123456781') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.uuid('12345678-1234-5678-1234-56781234567')
def test_length(): DCNL  DCSP assert (hug.types.length(1, 10)('bacon') == 'bacon') DCNL DCSP assert (hug.types.length(1, 10)(42) == '42') DCNL DCSP assert ('42' in hug.types.length(1, 42).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('bacon DCSP is DCSP the DCSP greatest DCSP food DCSP known DCSP to DCSP man') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.length(1, 10)('bacon DCSP is DCSP th')
def test_shorter_than(): DCNL  DCSP assert (hug.types.shorter_than(10)('hi DCSP there') == 'hi DCSP there') DCNL DCSP assert (hug.types.shorter_than(10)(1) == '1') DCNL DCSP assert (hug.types.shorter_than(10)('') == '') DCNL DCSP assert ('10' in hug.types.shorter_than(10).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.shorter_than(10)('there DCSP is DCSP quite DCSP a DCSP bit DCSP of DCSP text DCSP here, DCSP in DCSP fact DCSP way DCSP more DCSP than DCSP allowed')
def test_longer_than(): DCNL  DCSP assert (hug.types.longer_than(10)('quite DCSP a DCSP bit DCSP of DCSP text DCSP here DCSP should DCSP be') == 'quite DCSP a DCSP bit DCSP of DCSP text DCSP here DCSP should DCSP be') DCNL DCSP assert (hug.types.longer_than(10)(12345678910) == '12345678910') DCNL DCSP assert (hug.types.longer_than(10)(100123456789100) == '100123456789100') DCNL DCSP assert ('10' in hug.types.longer_than(10).__doc__) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP assert hug.types.longer_than(10)('short')
def test_cut_off(): DCNL  DCSP assert (hug.types.cut_off(10)('text') == 'text') DCNL DCSP assert (hug.types.cut_off(10)(10) == '10') DCNL DCSP assert (hug.types.cut_off(10)('some DCSP really DCSP long DCSP text') == 'some DCSP reall') DCNL DCSP assert ('10' in hug.types.cut_off(10).__doc__)
def test_inline_dictionary(): DCNL  DCSP assert (hug.types.inline_dictionary('1:2') == {'1': '2'}) DCNL DCSP assert (hug.types.inline_dictionary('1:2|3:4') == {'1': '2', '3': '4'}) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.inline_dictionary('1')
def test_one_of(): DCNL  DCSP assert (hug.types.one_of(('bacon', 'sausage', 'pancakes'))('bacon') == 'bacon') DCNL DCSP assert (hug.types.one_of(['bacon', 'sausage', 'pancakes'])('sausage') == 'sausage') DCNL DCSP assert (hug.types.one_of({'bacon', 'sausage', 'pancakes'})('pancakes') == 'pancakes') DCNL DCSP assert ('bacon' in hug.types.one_of({'bacon', 'sausage', 'pancakes'}).__doc__) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP hug.types.one_of({'bacon', 'sausage', 'pancakes'})('syrup')
def test_accept(): DCNL  DCSP custom_converter = (lambda value: (value + ' DCSP converted')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value') DCNL DCSP with pytest.raises(TypeError): DCNL DCSP  DCSP custom_type(1)
def test_accept_custom_exception_text(): DCNL  DCSP custom_converter = (lambda value: (value + ' DCSP converted')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', 'Error DCSP occurred') DCNL DCSP assert (custom_type('bacon') == 'bacon DCSP converted') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type(1)
def test_accept_custom_exception_handlers(): DCNL  DCSP custom_converter = (lambda value: ((str(int(value)) if value else value) + ' DCSP converted')) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', exception_handlers={TypeError: '0 DCSP provided'}) DCNL DCSP assert (custom_type('1') == '1 DCSP converted') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type('bacon') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP custom_type(0) DCNL DCSP custom_type = hug.types.accept(custom_converter, 'A DCSP string DCSP Value', exception_handlers={TypeError: KeyError}) DCNL DCSP with pytest.raises(KeyError): DCNL DCSP  DCSP custom_type(0)
def test_json(): DCNL  DCSP assert (hug.types.json({'this': 'works'}) == {'this': 'works'}) DCNL DCSP assert (hug.types.json(json.dumps({'this': 'works'})) == {'this': 'works'}) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP hug.types.json('Invalid DCSP JSON')
def test_multi(): DCNL  DCSP multi_type = hug.types.multi(hug.types.json, hug.types.smart_boolean) DCNL DCSP assert (multi_type({'this': 'works'}) == {'this': 'works'}) DCNL DCSP assert (multi_type(json.dumps({'this': 'works'})) == {'this': 'works'}) DCNL DCSP assert multi_type('t') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP multi_type('Bacon!')
def test_chain(): DCNL  DCSP chain_type = hug.types.Chain(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP assert (chain_type(12345678901) == '12345678901') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP chain_type(1)
def test_nullable(): DCNL  DCSP nullable_type = hug.types.Nullable(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP assert (nullable_type(12345678901) == '12345678901') DCNL DCSP assert (nullable_type(None) is None) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP nullable_type(1)
def test_schema_type(): DCNL  DCSP class User(hug.types.Schema, ): DCNL DCSP  DCSP username = hug.types.text DCNL DCSP  DCSP password = hug.types.Chain(hug.types.text, hug.types.LongerThan(10)) DCNL DCSP user_one = User({'username': 'brandon', 'password': 'password123'}) DCNL DCSP user_two = User(user_one) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP user_three = User({'username': 'brandon', 'password': '123'}) DCNL DCSP user_three = User({'username': 'brandon', 'password': '123'}, force=True) DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP del user_one.username DCNL DCSP assert ('username' in User.__slots__) DCNL DCSP assert ('_username' in User.__slots__) DCNL DCSP assert (user_one._username == 'brandon') DCNL DCSP assert (user_two == user_one) DCNL DCSP assert (user_three._username == 'brandon') DCNL DCSP assert (user_one.username == 'brandon') DCNL DCSP assert (user_two.username == 'brandon') DCNL DCSP assert (user_three.username == 'brandon') DCNL DCSP assert (user_one.password == 'password123') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP user_one.password = 'test' DCNL DCSP assert (user_one.password == 'password123')
def test_marshmallow_schema(): DCNL  DCSP class UserSchema(Schema, ): DCNL DCSP  DCSP name = fields.Str() DCNL DCSP schema_type = hug.types.MarshmallowSchema(UserSchema()) DCNL DCSP assert (schema_type({'name': 'test'}) == {'name': 'test'}) DCNL DCSP assert (schema_type('{"name": DCSP "test"}') == {'name': 'test'}) DCNL DCSP assert (schema_type.__doc__ == 'UserSchema') DCNL DCSP with pytest.raises(InvalidTypeData): DCNL DCSP  DCSP schema_type({'name': 1})
def test_create_type(): DCNL  DCSP @hug.type(extend=hug.types.text, exception_handlers={TypeError: ValueError, LookupError: 'Hi!'}, error_text='Invalid') DCNL DCSP def prefixed_string(value): DCNL DCSP  DCSP if (value == 'hi'): DCNL DCSP  DCSP  DCSP raise TypeError('Repeat DCSP of DCSP prefix') DCNL DCSP  DCSP elif (value == 'bye'): DCNL DCSP  DCSP  DCSP raise LookupError('Never DCSP say DCSP goodbye!') DCNL DCSP  DCSP elif (value == '1+1'): DCNL DCSP  DCSP  DCSP raise ArithmeticError('Testing DCSP different DCSP error DCSP types') DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixed_string() DCNL DCSP assert (my_type('there') == 'hi-there') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type([]) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type('hi') DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP my_type('bye') DCNL DCSP @hug.type(extend=hug.types.text, exception_handlers={TypeError: ValueError}) DCNL DCSP def prefixed_string(value): DCNL DCSP  DCSP if (value == '1+1'): DCNL DCSP  DCSP  DCSP raise ArithmeticError('Testing DCSP different DCSP error DCSP types') DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixed_string() DCNL DCSP with pytest.raises(ArithmeticError): DCNL DCSP  DCSP my_type('1+1') DCNL DCSP @hug.type(extend=hug.types.text) DCNL DCSP def prefixed_string(value): DCNL DCSP  DCSP return ('hi-' + value) DCNL DCSP my_type = prefixed_string() DCNL DCSP assert (my_type('there') == 'hi-there')
@hug.get() DCNL def made_up_hello(): DCNL  DCSP return 'hello'
def test_basic_auth(): DCNL  DCSP @hug.get(requires=hug.authentication.basic(hug.authentication.verify('Tim', 'Custom DCSP password'))) DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP world!' DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Not DCSP correctly DCSP formed'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Nospaces'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'Basic DCSP VXNlcjE6bXlwYXNzd29yZA'}).status) DCNL DCSP token = b64encode('{0}:{1}'.format('Tim', 'Custom DCSP password').encode('utf8')).decode('utf8') DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'Authorization': 'Basic DCSP {0}'.format(token)}).data == 'Hello DCSP world!') DCNL DCSP token = ('Basic DCSP ' + b64encode('{0}:{1}'.format('Tim', 'Custom DCSP password').encode('utf8'))) DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'Authorization': token}).data == 'Hello DCSP world!') DCNL DCSP token = ('Basic DCSP ' + b64encode('{0}:{1}'.format('Tim', 'Wrong DCSP password').encode('utf8'))) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': token}).status)
def test_api_key(): DCNL  DCSP @hug.authentication.api_key DCNL DCSP def api_key_authentication(api_key): DCNL DCSP  DCSP if (api_key == 'Bacon'): DCNL DCSP  DCSP  DCSP return 'Timothy' DCNL DCSP @hug.get(requires=api_key_authentication) DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP world!' DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'X-Api-Key': 'Bacon'}).data == 'Hello DCSP world!') DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'X-Api-Key': 'Invalid'}).status)
def test_token_auth(): DCNL  DCSP precomptoken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoibXkgZGF0YSIsInVzZXIiOiJUaW1vdGh5In0.8QqdQMJUTq0Dq7vHlnDjdoCKFPDAlvxGCpc_8XF41nI' DCNL DCSP @hug.authentication.token DCNL DCSP def token_authentication(token): DCNL DCSP  DCSP if (token == precomptoken): DCNL DCSP  DCSP  DCSP return 'Timothy' DCNL DCSP @hug.get(requires=token_authentication) DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP assert (hug.test.get(api, 'hello_world', headers={'Authorization': precomptoken}).data == 'Hello DCSP World!') DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_world', headers={'Authorization': 'eyJhbGci'}).status)
def test_documentation_carry_over(): DCNL  DCSP authentication = hug.authentication.basic(hug.authentication.verify('User1', 'mypassword')) DCNL DCSP assert (authentication.__doc__ == 'Basic DCSP HTTP DCSP Authentication')
def test_text(): DCNL  DCSP test_data = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.text(test_data) == '{"a": DCSP "b"}')
def test_json(): DCNL  DCSP test_data = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.json(test_data) == {'a': 'b'})
def test_json_underscore(): DCNL  DCSP test_data = BytesIO('{"CamelCase": DCSP {"becauseWeCan": DCSP "ValueExempt"}}') DCNL DCSP assert (hug.input_format.json_underscore(test_data) == {'camel_case': {'because_we_can': 'ValueExempt'}})
def test_urlencoded(): DCNL  DCSP test_data = BytesIO('foo=baz&foo=bar&name=John+Doe') DCNL DCSP assert (hug.input_format.urlencoded(test_data) == {'name': 'John DCSP Doe', 'foo': ['baz', 'bar']})
def test_multipart(): DCNL  DCSP with open(os.path.join(BASE_DIRECTORY, 'artwork', 'koala.png'), 'rb') as koala: DCNL DCSP  DCSP prepared_request = requests.Request('POST', 'http://localhost/', files={'koala': koala}).prepare() DCNL DCSP  DCSP koala.seek(0) DCNL DCSP  DCSP file_content = hug.input_format.multipart(BytesIO(prepared_request.body), **parse_header(prepared_request.headers['Content-Type'])[1])['koala'] DCNL DCSP  DCSP assert (file_content == koala.read())
def test_all(): DCNL  DCSP assert (not hug.validate.all(hug.validate.contains_one_of('first', 'year'), hug.validate.contains_one_of('last', 'place'))(TEST_SCHEMA)) DCNL DCSP assert hug.validate.all(hug.validate.contains_one_of('last', 'year'), hug.validate.contains_one_of('first', 'place'))(TEST_SCHEMA)
def test_any(): DCNL  DCSP assert (not hug.validate.any(hug.validate.contains_one_of('last', 'year'), hug.validate.contains_one_of('first', 'place'))(TEST_SCHEMA)) DCNL DCSP assert hug.validate.any(hug.validate.contains_one_of('last', 'year'), hug.validate.contains_one_of('no', 'way'))(TEST_SCHEMA)
def test_contains_one_of(): DCNL  DCSP assert hug.validate.contains_one_of('no', 'way')(TEST_SCHEMA) DCNL DCSP assert (not hug.validate.contains_one_of('last', 'place')(TEST_SCHEMA))
def scope_key(instance, xblock): DCNL  DCSP scope_key_dict = {} DCNL DCSP scope_key_dict['name'] = instance.name DCNL DCSP if ((instance.scope.user == UserScope.NONE) or (instance.scope.user == UserScope.ALL)): DCNL DCSP  DCSP pass DCNL DCSP elif (instance.scope.user == UserScope.ONE): DCNL DCSP  DCSP scope_key_dict['user'] = unicode(xblock.scope_ids.user_id) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError() DCNL DCSP if (instance.scope.block == BlockScope.TYPE): DCNL DCSP  DCSP scope_key_dict['block'] = unicode(xblock.scope_ids.block_type) DCNL DCSP elif (instance.scope.block == BlockScope.USAGE): DCNL DCSP  DCSP scope_key_dict['block'] = unicode(xblock.scope_ids.usage_id) DCNL DCSP elif (instance.scope.block == BlockScope.DEFINITION): DCNL DCSP  DCSP scope_key_dict['block'] = unicode(xblock.scope_ids.def_id) DCNL DCSP elif (instance.scope.block == BlockScope.ALL): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError() DCNL DCSP replacements = list(itertools.product('._-', '._-')) DCNL DCSP substitution_list = dict(zip('./\\,_ DCSP +:-', (''.join(x) for x in replacements))) DCNL DCSP key_list = [] DCNL DCSP def encode(char): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Replace DCSP all DCSP non-alphanumeric DCSP characters DCSP with DCSP -n- DCSP where DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP their DCSP UTF8 DCSP code.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TODO: DCSP Test DCSP for DCSP UTF8 DCSP which DCSP is DCSP not DCSP ASCII\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if char.isalnum(): DCNL DCSP  DCSP  DCSP return char DCNL DCSP  DCSP elif (char in substitution_list): DCNL DCSP  DCSP  DCSP return substitution_list[char] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '_{}_'.format(ord(char)) DCNL DCSP for item in ['block', 'name', 'user']: DCNL DCSP  DCSP if (item in scope_key_dict): DCNL DCSP  DCSP  DCSP field = scope_key_dict[item] DCNL DCSP  DCSP  DCSP if (field.startswith('.') or field.startswith('_')): DCNL DCSP  DCSP  DCSP  DCSP field = ('_' + field) DCNL DCSP  DCSP  DCSP field = ''.join((encode(char) for char in field)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP field = 'NONE.NONE' DCNL DCSP  DCSP key_list.append(field) DCNL DCSP key = '/'.join(key_list) DCNL DCSP return key
def test_setting_the_same_value_marks_field_as_dirty(): DCNL  DCSP class FieldTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP block DCSP for DCSP set DCSP - DCSP get DCSP test.' DCNL DCSP  DCSP non_mutable = String(scope=Scope.settings) DCNL DCSP  DCSP list_field = List(scope=Scope.settings) DCNL DCSP  DCSP dict_field = Dict(scope=Scope.settings) DCNL DCSP runtime = TestRuntime(services={'field-data': DictFieldData({})}) DCNL DCSP field_tester = FieldTester(runtime, scope_ids=Mock(spec=ScopeIds)) DCNL DCSP assert_equals(len(field_tester._dirty_fields), 0) DCNL DCSP assert_false(field_tester.fields['list_field'].is_set_on(field_tester)) DCNL DCSP assert_false(field_tester.fields['dict_field'].is_set_on(field_tester)) DCNL DCSP assert_false(field_tester.fields['non_mutable'].is_set_on(field_tester)) DCNL DCSP field_tester.non_mutable = field_tester.non_mutable DCNL DCSP field_tester.list_field = field_tester.list_field DCNL DCSP field_tester.dict_field = field_tester.dict_field DCNL DCSP assert_not_in(field_tester.fields['non_mutable'], field_tester._dirty_fields) DCNL DCSP assert_in(field_tester.fields['list_field'], field_tester._dirty_fields) DCNL DCSP assert_in(field_tester.fields['dict_field'], field_tester._dirty_fields) DCNL DCSP assert_false(field_tester.fields['non_mutable'].is_set_on(field_tester)) DCNL DCSP assert_false(field_tester.fields['list_field'].is_set_on(field_tester)) DCNL DCSP assert_false(field_tester.fields['dict_field'].is_set_on(field_tester))
def _num_plugins_cached(): DCNL  DCSP return len(plugin.PLUGIN_CACHE.keys())
def setup_save_failure(set_many): DCNL  DCSP field_data = MagicMock(spec=FieldData) DCNL DCSP field_data.get = (lambda block, name, default=None: 99) DCNL DCSP field_data.set_many = set_many DCNL DCSP class FieldTester(XBlock, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Test DCSP XBlock DCSP with DCSP three DCSP fields\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP field_a = Integer(scope=Scope.settings) DCNL DCSP  DCSP field_b = Integer(scope=Scope.content, default=10) DCNL DCSP  DCSP field_c = Integer(scope=Scope.user_state, default=42) DCNL DCSP field_tester = FieldTester(TestRuntime(services={'field-data': field_data}), scope_ids=Mock(spec=ScopeIds)) DCNL DCSP return field_tester
def test_get_mutable_mark_dirty(): DCNL  DCSP class MutableTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP class DCSP with DCSP mutable DCSP fields.' DCNL DCSP  DCSP list_field = List(default=[]) DCNL DCSP mutable_test = MutableTester(TestRuntime(services={'field-data': DictFieldData({})}), scope_ids=Mock(spec=ScopeIds)) DCNL DCSP assert_equals(len(mutable_test._dirty_fields), 0) DCNL DCSP _test_get = mutable_test.list_field DCNL DCSP assert_equals(len(mutable_test._dirty_fields), 1) DCNL DCSP mutable_test.list_field = [] DCNL DCSP assert_equals(len(mutable_test._dirty_fields), 1) DCNL DCSP mutable_test.save() DCNL DCSP assert_equals(len(mutable_test._dirty_fields), 1) DCNL DCSP _test_get = mutable_test.list_field DCNL DCSP assert_equals(len(mutable_test._dirty_fields), 1)
def test_change_mutable_default(): DCNL  DCSP class MutableTester(XBlock, ): DCNL DCSP  DCSP 'Test DCSP class DCSP with DCSP mutable DCSP fields.' DCNL DCSP  DCSP list_field = List() DCNL DCSP field_data_a = DictFieldData({}) DCNL DCSP mutable_test_a = MutableTester(TestRuntime(services={'field-data': field_data_a}), scope_ids=Mock(spec=ScopeIds)) DCNL DCSP field_data_b = DictFieldData({}) DCNL DCSP mutable_test_b = MutableTester(TestRuntime(services={'field-data': field_data_b}), scope_ids=Mock(spec=ScopeIds)) DCNL DCSP mutable_test_a.list_field DCNL DCSP mutable_test_a.save() DCNL DCSP with assert_raises(KeyError): DCNL DCSP  DCSP field_data_a.get(mutable_test_a, 'list_field') DCNL DCSP mutable_test_a.list_field.append(1) DCNL DCSP mutable_test_a.save() DCNL DCSP assert_equals([1], field_data_a.get(mutable_test_a, 'list_field')) DCNL DCSP with assert_raises(KeyError): DCNL DCSP  DCSP field_data_b.get(mutable_test_b, 'list_field')
def blocks_are_equivalent(block1, block2): DCNL  DCSP if (block1.__class__ != block2.__class__): DCNL DCSP  DCSP return False DCNL DCSP if (set(block1.fields) != set(block2.fields)): DCNL DCSP  DCSP return False DCNL DCSP for field_name in block1.fields: DCNL DCSP  DCSP if (field_name in ('parent', 'children')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (getattr(block1, field_name) != getattr(block2, field_name)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (block1.has_children != block2.has_children): DCNL DCSP  DCSP return False DCNL DCSP if block1.has_children: DCNL DCSP  DCSP if (len(block1.children) != len(block2.children)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for (child_id1, child_id2) in zip(block1.children, block2.children): DCNL DCSP  DCSP  DCSP if (child_id1 == child_id2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP child1 = block1.runtime.get_block(child_id1) DCNL DCSP  DCSP  DCSP child2 = block2.runtime.get_block(child_id2) DCNL DCSP  DCSP  DCSP if (not blocks_are_equivalent(child1, child2)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
def _unabc(cls, msg="{} DCSP isn't DCSP implemented"): DCNL  DCSP def make_dummy_method(ab_name): DCNL DCSP  DCSP 'A DCSP function DCSP to DCSP make DCSP the DCSP dummy DCSP method, DCSP to DCSP close DCSP over DCSP ab_name.' DCNL DCSP  DCSP def dummy_method(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP 'The DCSP method DCSP provided DCSP for DCSP all DCSP missing DCSP abstract DCSP methods.' DCNL DCSP  DCSP  DCSP raise NotImplementedError(msg.format(ab_name)) DCNL DCSP  DCSP return dummy_method DCNL DCSP for ab_name in cls.__abstractmethods__: DCNL DCSP  DCSP setattr(cls, ab_name, make_dummy_method(ab_name)) DCNL DCSP cls.__abstractmethods__ = () DCNL DCSP return cls
def unabc(msg): DCNL  DCSP if isinstance(msg, type): DCNL DCSP  DCSP return _unabc(msg) DCNL DCSP else: DCNL DCSP  DCSP return partial(_unabc, msg=msg)
def test_dummy_user_service_current_user(): DCNL  DCSP user = XBlockUser(full_name='tester') DCNL DCSP user_service = SingleUserService(user) DCNL DCSP current_user = user_service.get_current_user() DCNL DCSP assert_equals(current_user, user) DCNL DCSP assert_equals(current_user.full_name, 'tester') DCNL DCSP assert_is_instance(current_user.emails, collections.Iterable) DCNL DCSP assert_false(isinstance(current_user.emails, basestring)) DCNL DCSP assert_is_instance(current_user.opt_attrs, collections.Mapping)
def test_dummy_user_service_exception(): DCNL  DCSP user_service = UserService() DCNL DCSP with assert_raises(NotImplementedError): DCNL DCSP  DCSP user_service.get_current_user()
def get_namespace_attrs(): DCNL  DCSP return ' DCSP '.join(('xmlns:{}="{}"'.format(k, v) for (k, v) in XML_NAMESPACES.items()))
def squish(text): DCNL  DCSP return re.sub('\\s+', ' DCSP ', text)
def check_field(collection, field): DCNL  DCSP print ('Getting DCSP %s DCSP from DCSP %r' % (field.name, collection)) DCNL DCSP assert_equals(field.default, getattr(collection, field.name)) DCNL DCSP new_value = ('new DCSP ' + field.name) DCNL DCSP print ('Setting DCSP %s DCSP to DCSP %s DCSP on DCSP %r' % (field.name, new_value, collection)) DCNL DCSP setattr(collection, field.name, new_value) DCNL DCSP print ('Checking DCSP %s DCSP on DCSP %r' % (field.name, collection)) DCNL DCSP assert_equals(new_value, getattr(collection, field.name)) DCNL DCSP print ('Deleting DCSP %s DCSP from DCSP %r' % (field.name, collection)) DCNL DCSP delattr(collection, field.name) DCNL DCSP print ('Back DCSP to DCSP defaults DCSP for DCSP %s DCSP in DCSP %r' % (field.name, collection)) DCNL DCSP assert_equals(field.default, getattr(collection, field.name))
def test_ugettext_calls(): DCNL  DCSP runtime = TestRuntime() DCNL DCSP block = XBlockWithServices(runtime, scope_ids=Mock(spec=[])) DCNL DCSP assert_equals(block.ugettext('test'), u'test') DCNL DCSP assert_true(isinstance(block.ugettext('test'), unicode)) DCNL DCSP runtime = TestRuntime(services={'i18n': None}) DCNL DCSP block = XBlockWithServices(runtime, scope_ids=Mock(spec=[])) DCNL DCSP with assert_raises(NoSuchServiceError): DCNL DCSP  DCSP block.ugettext('test')
def default_select(identifier, all_entry_points): DCNL  DCSP if (len(all_entry_points) == 0): DCNL DCSP  DCSP raise PluginMissingError(identifier) DCNL DCSP elif (len(all_entry_points) == 1): DCNL DCSP  DCSP return all_entry_points[0] DCNL DCSP elif (len(all_entry_points) > 1): DCNL DCSP  DCSP raise AmbiguousPluginError(all_entry_points)
def public(type=None, **kwargs): DCNL  DCSP def wrapper(function): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Just DCSP return DCSP the DCSP function DCSP (for DCSP now)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return function DCNL DCSP return wrapper
def webob_to_django_response(webob_response): DCNL  DCSP from django.http import HttpResponse DCNL DCSP django_response = HttpResponse(webob_response.app_iter, content_type=webob_response.content_type, status=webob_response.status_code) DCNL DCSP for (name, value) in webob_response.headerlist: DCNL DCSP  DCSP django_response[name] = value DCNL DCSP return django_response
def querydict_to_multidict(query_dict, wrap=None): DCNL  DCSP wrap = (wrap or (lambda val: val)) DCNL DCSP return MultiDict(chain.from_iterable((izip(repeat(key), (wrap(v) for v in vals)) for (key, vals) in query_dict.iterlists())))
def django_to_webob_request(django_request): DCNL  DCSP return DjangoWebobRequest(django_request)
def run_script(pycode): DCNL  DCSP if (pycode[0] == '\n'): DCNL DCSP  DCSP pycode = pycode[1:] DCNL DCSP pycode.rstrip() DCNL DCSP pycode = textwrap.dedent(pycode) DCNL DCSP globs = {} DCNL DCSP exec pycode in globs, globs DCNL DCSP return globs
def generate_key(key_length=64): DCNL  DCSP if hasattr(random, 'SystemRandom'): DCNL DCSP  DCSP choice = random.SystemRandom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = random.choice DCNL DCSP return ''.join(map((lambda x: choice((string.digits + string.letters))), range(key_length)))
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL  DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP old_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(old_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_mode & 511)) is None): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.readline() DCNL DCSP  DCSP return key
def _translate_attachment_detail_view(_context, vol): DCNL  DCSP d = _translate_attachment_summary_view(_context, vol) DCNL DCSP return d
def _translate_attachment_summary_view(_context, vol): DCNL  DCSP d = {} DCNL DCSP conductor_id = vol['id'] DCNL DCSP d['id'] = conductor_id DCNL DCSP d['conductor_id'] = conductor_id DCNL DCSP return d
def _translate_conductor_detail_view(context, vol, image_id=None): DCNL  DCSP d = _translate_conductor_summary_view(context, vol, image_id) DCNL DCSP return d
def _translate_conductor_summary_view(context, vol, image_id=None): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availability_zone'] = vol['availability_zone'] DCNL DCSP d['created_at'] = vol['created_at'] DCNL DCSP d['display_name'] = vol['display_name'] DCNL DCSP d['display_description'] = vol['display_description'] DCNL DCSP if (vol['conductor_type_id'] and vol.get('conductor_type')): DCNL DCSP  DCSP d['conductor_type'] = vol['conductor_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['conductor_type'] = str(vol['conductor_type_id']) DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('conductor_metadata'): DCNL DCSP  DCSP metadata = vol.get('conductor_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (vol.get('metadata') and isinstance(vol.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = vol['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP if vol.get('conductor_glance_metadata'): DCNL DCSP  DCSP d['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP d['bootable'] = 'false' DCNL DCSP return d
def remove_invalid_options(context, search_options, allowed_search_options): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(bad_options)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del search_options[opt]
def serializers(**serializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def deserializers(**deserializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def response(code): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
def action_peek_json(body): DCNL  DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
def action_peek_xml(body): DCNL  DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
def action(name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
def extends(*args, **kwargs): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
def _list_hosts(req, service=None): DCNL  DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['monitor.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
def check_host(fn): DCNL  DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
def pipeline_factory(loader, global_conf, **local_conf): DCNL  DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
def get_items(obj): DCNL  DCSP return list(obj.items())
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL  DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
def make_links(parent, selector=None): DCNL  DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL  DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL  DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
def get_pagination_params(request): DCNL  DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
def _get_marker_param(request): DCNL  DCSP return request.GET['marker']
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
def remove_version_from_href(href): DCNL  DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
def unquote_header_value(value): DCNL  DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
def parse_list_header(value): DCNL  DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
def parse_options_header(value): DCNL  DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def build_filter(class_name, *args): DCNL  DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
def load_filters(filters_path): DCNL  DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
def match_filter(filters, userargs, exec_dirs=[]): DCNL  DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def set_brain(brain): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = brain
def reset(): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = None
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL  DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
def int_from_bool_as_string(subject): DCNL  DCSP return ((bool_from_string(subject) and 1) or 0)
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def find_config(config_path): DCNL  DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP monitor-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def trycmd(*args, **kwargs): DCNL  DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
def last_completed_audit_period(unit=None): DCNL  DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL  DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
def safe_minidom_parse_string(xml_string): DCNL  DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
def xhtml_escape(value): DCNL  DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
def utf8(value): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
def delete_if_exists(pathname): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def get_from_path(items, path): DCNL  DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
def flatten_dict(dict_, flattened=None): DCNL  DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
def partition_dict(dict_, keys): DCNL  DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
def map_dict_keys(dict_, key_map): DCNL  DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
def subset_dict(dict_, keys): DCNL  DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
def check_isinstance(obj, cls): DCNL  DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
def bool_from_str(val): DCNL  DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
def is_valid_boolstr(val): DCNL  DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
def is_valid_ipv4(address): DCNL  DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def monkey_patch(): DCNL  DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
def convert_to_list_dict(lst, label): DCNL  DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
def timefunc(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
def generate_glance_url(): DCNL  DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL def logging_error(message): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
def make_dev_path(dev, partition=None, base='/dev'): DCNL  DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
def total_seconds(td): DCNL  DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
def sanitize_hostname(hostname): DCNL  DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def hash_file(file_like_object): DCNL  DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL  DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
def service_is_up(service): DCNL  DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
def generate_mac_address(): DCNL  DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
def read_file_as_root(file_path): DCNL  DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL  DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
def strcmp_const_time(s1, s2): DCNL  DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
def walk_class_hierarchy(clazz, encountered=None): DCNL  DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def to_bytes(text, default=0): DCNL  DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def enforce(context, action, target): DCNL  DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
def check_is_admin(roles): DCNL  DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
def periodic_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def short_cycle_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def _get_my_ip(): DCNL  DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
def register_models(): DCNL  DCSP from sqlalchemy import create_engine DCNL DCSP models = (Service,) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = monitor.exception.wrap_db_error(session.query) DCNL DCSP session.flush = monitor.exception.wrap_db_error(session.flush) DCNL DCSP return session
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def is_admin_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
def is_user_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
def authorize_project_context(context, project_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_user_context(context, user_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_quota_class_context(context, class_name): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def require_admin_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def model_query(context, *args, **kwargs): DCNL  DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
def exact_filter(query, model, filters, legal_keys): DCNL  DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL  DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserved_host_memory_mb) DCNL DCSP free_disk_gb = (disk_gb - (FLAGS.reserved_host_disk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_disk_gb -= instance.root_gb DCNL DCSP  DCSP free_disk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return dict(free_ram_mb=free_ram_mb, free_disk_gb=free_disk_gb, current_workload=work, running_vms=vms)
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL  DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node_ref = models.ComputeNode() DCNL DCSP  DCSP session.add(compute_node_ref) DCNL DCSP  DCSP compute_node_ref.update(values) DCNL DCSP return compute_node_ref
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL  DCSP session = get_session() DCNL DCSP if auto_adjust: DCNL DCSP  DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref = compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
def compute_node_get_by_host(context, host): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.query(models.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP node = session.query(models.ComputeNode).options(joinedload('service')).filter_by(deleted=False, service_id=service.id) DCNL DCSP  DCSP return node.first()
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL  DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = models.ComputeNode.__table__ DCNL DCSP  DCSP if (free_ram_mb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_delta) DCNL DCSP  DCSP if (free_disk_gb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = (table.c.free_disk_gb + free_disk_gb_delta) DCNL DCSP  DCSP if (work_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.current_workload = (table.c.current_workload + work_delta) DCNL DCSP  DCSP if (vm_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.running_vms = (table.c.running_vms + vm_delta) DCNL DCSP return compute_node
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL  DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_disk_gb != None): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = free_disk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_node.current_workload = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_node.running_vms = vms DCNL DCSP return compute_node
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def service_destroy(context, service_id): DCNL  DCSP return IMPL.service_destroy(context, service_id)
def service_get(context, service_id): DCNL  DCSP return IMPL.service_get(context, service_id)
def service_get_by_host_and_topic(context, host, topic): DCNL  DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
def service_get_all(context, disabled=None): DCNL  DCSP return IMPL.service_get_all(context, disabled)
def service_get_all_by_topic(context, topic): DCNL  DCSP return IMPL.service_get_all_by_topic(context, topic)
def service_get_all_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_by_host(context, host)
def service_get_all_bmc_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_bmc_by_host(context, host)
def service_get_all_servicemanage_sorted(context): DCNL  DCSP return IMPL.service_get_all_servicemanage_sorted(context)
def service_get_by_args(context, host, binary): DCNL  DCSP return IMPL.service_get_by_args(context, host, binary)
def service_create(context, values): DCNL  DCSP return IMPL.service_create(context, values)
def service_update(context, service_id, values): DCNL  DCSP return IMPL.service_update(context, service_id, values)
def compute_node_get(context, compute_id): DCNL  DCSP return IMPL.compute_node_get(context, compute_id)
def compute_node_get_all(context): DCNL  DCSP return IMPL.compute_node_get_all(context)
def compute_node_create(context, values): DCNL  DCSP return IMPL.compute_node_create(context, values)
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL  DCSP return IMPL.compute_node_update(context, compute_id, values, auto_adjust)
def monitor_todo_format(physical_line): DCNL  DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'ENERGY DCSP N101: DCSP Use DCSP TODO(NAME)')
def monitor_except_format(logical_line): DCNL  DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "ENERGY DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
def monitor_except_format_assert(logical_line): DCNL  DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'ENERGY DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
def monitor_one_import_per_line(logical_line): DCNL  DCSP pos = logical_line.find(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) and ((parts[0] == 'import') or ((parts[0] == 'from') and (parts[2] == 'import'))) and (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yield (pos, 'ENERGY DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
def monitor_import_module_only(logical_line): DCNL  DCSP def importModuleCheck(mod, parent=None, added=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP find DCSP module DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valid = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_mod = __import__(parent, globals(), locals(), [mod], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(getattr(parent_mod, mod)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(mod, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(sys.modules[mod]) DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if added: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("ENERGY DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("ENERGY DCSP N302: DCSP import DCSP only DCSP modules. DCSP '%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not added): DCNL DCSP  DCSP  DCSP  DCSP added = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.append(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importModuleCheck(mod, parent, added) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ("ERROR: DCSP import DCSP '%s' DCSP failed: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(name) DCNL DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.find(mod), 'ENERGY DCSP N303: DCSP Invalid DCSP import, DCSP AttributeError DCSP raised') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') and (',' not in logical_line) and ((len(split_line) == 2) or ((len(split_line) == 4) and (split_line[2] == 'as')))): DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP rval = importModuleCheck(mod) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yield rval)
def monitor_import_alphabetical(physical_line, line_number, lines): DCNL  DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('ENERGY DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
def monitor_docstring_start_space(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N401: DCSP one DCSP line DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
def monitor_docstring_one_line(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP end = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and end and (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') and physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP a DCSP period')
def monitor_docstring_multiline_end(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
def check_l18n(): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N703: DCSP Multiple DCSP positional DCSP placeholders')
def monitor_localization_strings(logical_line, tokens): DCNL  DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
def readlines(filename): DCNL  DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
def add_monitor(): DCNL  DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('monitor')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
def _sanitize_default(s): DCNL  DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'monitor' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
def serializers(**serializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def deserializers(**deserializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def response(code): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
def action_peek_json(body): DCNL  DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
def action_peek_xml(body): DCNL  DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
def action(name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
def extends(*args, **kwargs): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
def _list_hosts(req, service=None): DCNL  DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['monitor.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
def check_host(fn): DCNL  DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
def pipeline_factory(loader, global_conf, **local_conf): DCNL  DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
def get_items(obj): DCNL  DCSP return list(obj.items())
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL  DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
def make_links(parent, selector=None): DCNL  DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL  DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL  DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
def get_pagination_params(request): DCNL  DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
def _get_marker_param(request): DCNL  DCSP return request.GET['marker']
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
def remove_version_from_href(href): DCNL  DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
def unquote_header_value(value): DCNL  DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
def parse_list_header(value): DCNL  DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
def parse_options_header(value): DCNL  DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def build_filter(class_name, *args): DCNL  DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
def load_filters(filters_path): DCNL  DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
def match_filter(filters, userargs, exec_dirs=[]): DCNL  DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def set_brain(brain): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = brain
def reset(): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = None
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL  DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
def int_from_bool_as_string(subject): DCNL  DCSP return ((bool_from_string(subject) and 1) or 0)
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def find_config(config_path): DCNL  DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP monitor-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def trycmd(*args, **kwargs): DCNL  DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
def last_completed_audit_period(unit=None): DCNL  DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL  DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
def safe_minidom_parse_string(xml_string): DCNL  DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
def xhtml_escape(value): DCNL  DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
def utf8(value): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
def delete_if_exists(pathname): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def get_from_path(items, path): DCNL  DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
def flatten_dict(dict_, flattened=None): DCNL  DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
def partition_dict(dict_, keys): DCNL  DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
def map_dict_keys(dict_, key_map): DCNL  DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
def subset_dict(dict_, keys): DCNL  DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
def check_isinstance(obj, cls): DCNL  DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
def bool_from_str(val): DCNL  DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
def is_valid_boolstr(val): DCNL  DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
def is_valid_ipv4(address): DCNL  DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def monkey_patch(): DCNL  DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
def convert_to_list_dict(lst, label): DCNL  DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
def timefunc(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
def generate_glance_url(): DCNL  DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL def logging_error(message): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
def make_dev_path(dev, partition=None, base='/dev'): DCNL  DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
def total_seconds(td): DCNL  DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
def sanitize_hostname(hostname): DCNL  DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def hash_file(file_like_object): DCNL  DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL  DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
def service_is_up(service): DCNL  DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
def generate_mac_address(): DCNL  DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
def read_file_as_root(file_path): DCNL  DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL  DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
def strcmp_const_time(s1, s2): DCNL  DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
def walk_class_hierarchy(clazz, encountered=None): DCNL  DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def to_bytes(text, default=0): DCNL  DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def enforce(context, action, target): DCNL  DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
def check_is_admin(roles): DCNL  DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
def periodic_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def short_cycle_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def _get_my_ip(): DCNL  DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
def register_models(): DCNL  DCSP from sqlalchemy import create_engine DCNL DCSP models = (Service,) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = monitor.exception.wrap_db_error(session.query) DCNL DCSP session.flush = monitor.exception.wrap_db_error(session.flush) DCNL DCSP return session
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def is_admin_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
def is_user_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
def authorize_project_context(context, project_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_user_context(context, user_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_quota_class_context(context, class_name): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def require_admin_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def model_query(context, *args, **kwargs): DCNL  DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
def exact_filter(query, model, filters, legal_keys): DCNL  DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL  DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserved_host_memory_mb) DCNL DCSP free_disk_gb = (disk_gb - (FLAGS.reserved_host_disk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_disk_gb -= instance.root_gb DCNL DCSP  DCSP free_disk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return dict(free_ram_mb=free_ram_mb, free_disk_gb=free_disk_gb, current_workload=work, running_vms=vms)
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL  DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node_ref = models.ComputeNode() DCNL DCSP  DCSP session.add(compute_node_ref) DCNL DCSP  DCSP compute_node_ref.update(values) DCNL DCSP return compute_node_ref
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL  DCSP session = get_session() DCNL DCSP if auto_adjust: DCNL DCSP  DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref = compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
def compute_node_get_by_host(context, host): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.query(models.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP node = session.query(models.ComputeNode).options(joinedload('service')).filter_by(deleted=False, service_id=service.id) DCNL DCSP  DCSP return node.first()
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL  DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = models.ComputeNode.__table__ DCNL DCSP  DCSP if (free_ram_mb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_delta) DCNL DCSP  DCSP if (free_disk_gb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = (table.c.free_disk_gb + free_disk_gb_delta) DCNL DCSP  DCSP if (work_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.current_workload = (table.c.current_workload + work_delta) DCNL DCSP  DCSP if (vm_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.running_vms = (table.c.running_vms + vm_delta) DCNL DCSP return compute_node
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL  DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_disk_gb != None): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = free_disk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_node.current_workload = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_node.running_vms = vms DCNL DCSP return compute_node
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def service_destroy(context, service_id): DCNL  DCSP return IMPL.service_destroy(context, service_id)
def service_get(context, service_id): DCNL  DCSP return IMPL.service_get(context, service_id)
def service_get_by_host_and_topic(context, host, topic): DCNL  DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
def service_get_all(context, disabled=None): DCNL  DCSP return IMPL.service_get_all(context, disabled)
def service_get_all_by_topic(context, topic): DCNL  DCSP return IMPL.service_get_all_by_topic(context, topic)
def service_get_all_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_by_host(context, host)
def service_get_all_bmc_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_bmc_by_host(context, host)
def service_get_all_servicemanage_sorted(context): DCNL  DCSP return IMPL.service_get_all_servicemanage_sorted(context)
def service_get_by_args(context, host, binary): DCNL  DCSP return IMPL.service_get_by_args(context, host, binary)
def service_create(context, values): DCNL  DCSP return IMPL.service_create(context, values)
def service_update(context, service_id, values): DCNL  DCSP return IMPL.service_update(context, service_id, values)
def compute_node_get(context, compute_id): DCNL  DCSP return IMPL.compute_node_get(context, compute_id)
def compute_node_get_all(context): DCNL  DCSP return IMPL.compute_node_get_all(context)
def compute_node_create(context, values): DCNL  DCSP return IMPL.compute_node_create(context, values)
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL  DCSP return IMPL.compute_node_update(context, compute_id, values, auto_adjust)
def run_command_with_code(cmd, redirect_output=True, check_exit_code=True): DCNL  DCSP if redirect_output: DCNL DCSP  DCSP stdout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stdout = None DCNL DCSP proc = subprocess.Popen(cmd, cwd=ROOT, stdout=stdout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_code and (proc.returncode != 0)): DCNL DCSP  DCSP die('Command DCSP "%s" DCSP failed.\n%s', ' DCSP '.join(cmd), output) DCNL DCSP return (output, proc.returncode)
def create_virtualenv(venv=VENV, no_site_packages=True): DCNL  DCSP print 'Creating DCSP venv...', DCNL DCSP if no_site_packages: DCNL DCSP  DCSP run_command(['virtualenv', '-q', '--no-site-packages', VENV]) DCNL DCSP else: DCNL DCSP  DCSP run_command(['virtualenv', '-q', VENV]) DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_command(['tools/with_venv.sh', 'easy_install', 'pip>1.0']).strip()): DCNL DCSP  DCSP die('Failed DCSP to DCSP install DCSP pip.') DCNL DCSP print 'done.'
def parse_args(): DCNL  DCSP parser = optparse.OptionParser() DCNL DCSP parser.add_option('-n', '--no-site-packages', dest='no_site_packages', default=False, action='store_true', help='Do DCSP not DCSP inherit DCSP packages DCSP from DCSP global DCSP Python DCSP install') DCNL DCSP return parser.parse_args()
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL  DCSP def print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % dict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % dict(action=action)) DCNL DCSP  DCSP sys.stdout.write(msg) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_id) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinished' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_period)
def _find_monitor(cs, monitor): DCNL  DCSP return utils.find_resource(cs.monitors, monitor)
def _find_monitor_snapshot(cs, snapshot): DCNL  DCSP return utils.find_resource(cs.monitor_snapshots, snapshot)
def _find_backup(cs, backup): DCNL  DCSP return utils.find_resource(cs.backups, backup)
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL  DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_id') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attached_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attached DCSP to'])
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL  DCSP monitor_metadata = None DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP monitor_metadata = _extract_metadata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_id, args.source_volid, args.display_name, args.display_description, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_id, metadata=monitor_metadata) DCNL DCSP _print_monitor(monitor)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.delete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.force_delete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL  DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor(cs, args.monitor).update(**kwargs)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP metadata = _extract_metadata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metadata(monitor, metadata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.delete_metadata(monitor, metadata.keys())
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL  DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status, 'monitor_id': args.monitor_id} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL  DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL  DCSP snapshot = cs.monitor_snapshots.create(args.monitor_id, args.force, args.display_name, args.display_description) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL  DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot_id) DCNL DCSP snapshot.delete()
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL  DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor_snapshot(cs, args.snapshot).update(**kwargs)
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL  DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL  DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_and_extra_specs_list(vtypes)
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL  DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL  DCSP cs.monitor_types.delete(args.id)
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL  DCSP vtype = _find_monitor_type(cs, args.vtype) DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP keypair = _extract_metadata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
def do_endpoints(cs, args): DCNL  DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_dict(e['endpoints'][0], e['name'])
def do_credentials(cs, args): DCNL  DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_dict(catalog['access']['user'], 'User DCSP Credentials') DCNL DCSP utils.print_dict(catalog['access']['token'], 'Token')
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL  DCSP _quota_show(cs.quotas.get(args.tenant))
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL  DCSP _quota_show(cs.quotas.defaults(args.tenant))
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL  DCSP _quota_update(cs.quotas, args.tenant, args)
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL  DCSP _quota_show(cs.quota_classes.get(args.class_name))
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL  DCSP _quota_update(cs.quota_classes, args.class_name, args)
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL  DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL  DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
def _find_monitor_type(cs, vtype): DCNL  DCSP return utils.find_resource(cs.monitor_types, vtype)
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor_id) DCNL DCSP monitor.upload_to_image(args.force, args.image_name, args.container_format, args.disk_format)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL  DCSP cs.backups.create(args.monitor, args.container, args.display_name, args.display_description)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL  DCSP backup = _find_backup(cs, args.backup) DCNL DCSP info = dict() DCNL DCSP info.update(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_dict(info)
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL  DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL  DCSP backup = _find_backup(cs, args.backup) DCNL DCSP backup.delete()
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL  DCSP cs.restores.restore(args.backup, args.monitor_id)
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL  DCSP extensions = client.list_extensions.show_all() DCNL DCSP fields = ['Name', 'Summary', 'Alias', 'Updated'] DCNL DCSP utils.print_list(extensions, fields)
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def int_from_bool_as_string(subject): DCNL  DCSP return ((bool_from_string(subject) and 1) or 0)
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def arg(*args, **kwargs): DCNL  DCSP def _decorator(func): DCNL DCSP  DCSP add_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _decorator
def env(*vars, **kwargs): DCNL  DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('default', '')
def add_arg(f, *args, **kwargs): DCNL  DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL  DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.append(hook)
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL  DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys and (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP redefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.update(hook_kwargs) DCNL DCSP return extra_kwargs
def unauthenticated(f): DCNL  DCSP f.unauthenticated = True DCNL DCSP return f
def isunauthenticated(f): DCNL  DCSP return getattr(f, 'unauthenticated', False)
def service_type(stype): DCNL  DCSP def inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
def get_service_type(f): DCNL  DCSP return getattr(f, 'service_type', None)
def find_resource(manager, name_or_id): DCNL  DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_id, int) or name_or_id.isdigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_id)) DCNL DCSP except exceptions.NotFound: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuid.UUID(strutils.safe_decode(name_or_id)) DCNL DCSP  DCSP return manager.get(name_or_id) DCNL DCSP except (ValueError, exceptions.NotFound): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(human_id=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(name=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP except (UnicodeDecodeError, exceptions.NotFound): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommandError(msg) DCNL DCSP except exceptions.NoUniqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP found DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP raise exceptions.CommandError(msg)
def safe_issubclass(*args): DCNL  DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(mod_str) DCNL DCSP return getattr(sys.modules[mod_str], class_str)
def slugify(value): DCNL  DCSP import unicodedata DCNL DCSP if (not isinstance(value, unicode)): DCNL DCSP  DCSP value = unicode(value) DCNL DCSP value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore') DCNL DCSP value = unicode(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
def will_expire_soon(expiry): DCNL  DCSP soon = (timeutils.utcnow() + datetime.timedelta(seconds=30)) DCNL DCSP return (expiry < soon)
def safe_quote(s): DCNL  DCSP return (urllib.quote(s) if (s == urllib.unquote(s)) else s)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
def assert_crypto_availability(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kwds): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwds) DCNL DCSP return wrapper
def generate_aes_key(token, secret): DCNL  DCSP return hashlib.sha256((token + secret)).digest()
def compute_mac(token, serialized_data): DCNL  DCSP return hash_data((serialized_data + token))
def hash_data(data): DCNL  DCSP return base64.b64encode(hashlib.sha1(data).digest())
def sign_data(token, data): DCNL  DCSP mac_data = {} DCNL DCSP mac_data['serialized_data'] = json.dumps(data) DCNL DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP mac_data['mac'] = mac DCNL DCSP md = (MAC_MARKER + base64.b64encode(json.dumps(mac_data))) DCNL DCSP return md
def verify_signed_data(token, data): DCNL  DCSP if data.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = data[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_data = json.loads(base64.b64decode(data)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP  DCSP  DCSP if (mac != mac_data['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvalidMacError(('invalid DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_data['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loads(mac_data['serialized_data']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvalidMacError('invalid DCSP MAC; DCSP data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL  DCSP iv = os.urandom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP data = json.dumps(data) DCNL DCSP encoded_data = base64.b64encode((iv + cipher.encrypt(data))) DCNL DCSP encoded_data = (ENCRYPT_MARKER + encoded_data) DCNL DCSP return encoded_data
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL  DCSP if data.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoded_data = data[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP decoded_data = base64.b64decode(encoded_data) DCNL DCSP  DCSP  DCSP iv = decoded_data[:16] DCNL DCSP  DCSP  DCSP encrypted_data = decoded_data[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP decrypted_data = cipher.decrypt(encrypted_data) DCNL DCSP  DCSP  DCSP return json.loads(decrypted_data) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
def is_ans1_token(token): DCNL  DCSP return (token[:3] == PKI_ANS1_PREFIX)
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
def cms_hash_token(token_id): DCNL  DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
def getid(obj): DCNL  DCSP try: DCNL DCSP  DCSP return obj.id DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
def from_response(response, body): DCNL  DCSP cls = _code_map.get(response.status_code, ClientException) DCNL DCSP if response.headers: DCNL DCSP  DCSP request_id = response.headers.get('x-compute-request-id') DCNL DCSP else: DCNL DCSP  DCSP request_id = None DCNL DCSP if body: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP details = 'n/a' DCNL DCSP  DCSP if hasattr(body, 'keys'): DCNL DCSP  DCSP  DCSP error = body[body.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP details = error.get('details', None) DCNL DCSP  DCSP return cls(code=response.status_code, message=message, details=details, request_id=request_id) DCNL DCSP else: DCNL DCSP  DCSP return cls(code=response.status_code, request_id=request_id)
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL  DCSP def print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % dict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % dict(action=action)) DCNL DCSP  DCSP sys.stdout.write(msg) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_id) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinished' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_period)
def _find_monitor(cs, monitor): DCNL  DCSP return utils.find_resource(cs.monitors, monitor)
def _find_monitor_snapshot(cs, snapshot): DCNL  DCSP return utils.find_resource(cs.monitor_snapshots, snapshot)
def _find_backup(cs, backup): DCNL  DCSP return utils.find_resource(cs.backups, backup)
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL  DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_id') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attached_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attached DCSP to'])
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL  DCSP monitor_metadata = None DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP monitor_metadata = _extract_metadata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_id, args.source_volid, args.display_name, args.display_description, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_id, metadata=monitor_metadata) DCNL DCSP _print_monitor(monitor)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.delete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.force_delete()
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL  DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor(cs, args.monitor).update(**kwargs)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP metadata = _extract_metadata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metadata(monitor, metadata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.delete_metadata(monitor, metadata.keys())
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL  DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status, 'monitor_id': args.monitor_id} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL  DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL  DCSP snapshot = cs.monitor_snapshots.create(args.monitor_id, args.force, args.display_name, args.display_description) DCNL DCSP _print_monitor_snapshot(snapshot)
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL  DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot_id) DCNL DCSP snapshot.delete()
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL  DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor_snapshot(cs, args.snapshot).update(**kwargs)
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL  DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL  DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_and_extra_specs_list(vtypes)
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL  DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL  DCSP cs.monitor_types.delete(args.id)
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL  DCSP vtype = _find_monitor_type(cs, args.vtype) DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP keypair = _extract_metadata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
def do_endpoints(cs, args): DCNL  DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_dict(e['endpoints'][0], e['name'])
def do_credentials(cs, args): DCNL  DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_dict(catalog['access']['user'], 'User DCSP Credentials') DCNL DCSP utils.print_dict(catalog['access']['token'], 'Token')
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL  DCSP _quota_show(cs.quotas.get(args.tenant))
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL  DCSP _quota_show(cs.quotas.defaults(args.tenant))
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL  DCSP _quota_update(cs.quotas, args.tenant, args)
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL  DCSP _quota_show(cs.quota_classes.get(args.class_name))
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL  DCSP _quota_update(cs.quota_classes, args.class_name, args)
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL  DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL  DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
def _find_monitor_type(cs, vtype): DCNL  DCSP return utils.find_resource(cs.monitor_types, vtype)
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL  DCSP monitor = _find_monitor(cs, args.monitor_id) DCNL DCSP monitor.upload_to_image(args.force, args.image_name, args.container_format, args.disk_format)
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL  DCSP cs.backups.create(args.monitor, args.container, args.display_name, args.display_description)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL  DCSP backup = _find_backup(cs, args.backup) DCNL DCSP info = dict() DCNL DCSP info.update(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_dict(info)
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL  DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL  DCSP backup = _find_backup(cs, args.backup) DCNL DCSP backup.delete()
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL  DCSP cs.restores.restore(args.backup, args.monitor_id)
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL  DCSP extensions = client.list_extensions.show_all() DCNL DCSP fields = ['Name', 'Summary', 'Alias', 'Updated'] DCNL DCSP utils.print_list(extensions, fields)
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def int_from_bool_as_string(subject): DCNL  DCSP return ((bool_from_string(subject) and 1) or 0)
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def arg(*args, **kwargs): DCNL  DCSP def _decorator(func): DCNL DCSP  DCSP add_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _decorator
def env(*vars, **kwargs): DCNL  DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('default', '')
def add_arg(f, *args, **kwargs): DCNL  DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL  DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.append(hook)
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL  DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys and (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP redefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.update(hook_kwargs) DCNL DCSP return extra_kwargs
def unauthenticated(f): DCNL  DCSP f.unauthenticated = True DCNL DCSP return f
def isunauthenticated(f): DCNL  DCSP return getattr(f, 'unauthenticated', False)
def service_type(stype): DCNL  DCSP def inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
def get_service_type(f): DCNL  DCSP return getattr(f, 'service_type', None)
def find_resource(manager, name_or_id): DCNL  DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_id, int) or name_or_id.isdigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_id)) DCNL DCSP except exceptions.NotFound: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuid.UUID(strutils.safe_decode(name_or_id)) DCNL DCSP  DCSP return manager.get(name_or_id) DCNL DCSP except (ValueError, exceptions.NotFound): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(human_id=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(name=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP except (UnicodeDecodeError, exceptions.NotFound): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommandError(msg) DCNL DCSP except exceptions.NoUniqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP found DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP raise exceptions.CommandError(msg)
def safe_issubclass(*args): DCNL  DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(mod_str) DCNL DCSP return getattr(sys.modules[mod_str], class_str)
def slugify(value): DCNL  DCSP import unicodedata DCNL DCSP if (not isinstance(value, unicode)): DCNL DCSP  DCSP value = unicode(value) DCNL DCSP value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore') DCNL DCSP value = unicode(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
def will_expire_soon(expiry): DCNL  DCSP soon = (timeutils.utcnow() + datetime.timedelta(seconds=30)) DCNL DCSP return (expiry < soon)
def safe_quote(s): DCNL  DCSP return (urllib.quote(s) if (s == urllib.unquote(s)) else s)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
def assert_crypto_availability(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kwds): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwds) DCNL DCSP return wrapper
def generate_aes_key(token, secret): DCNL  DCSP return hashlib.sha256((token + secret)).digest()
def compute_mac(token, serialized_data): DCNL  DCSP return hash_data((serialized_data + token))
def hash_data(data): DCNL  DCSP return base64.b64encode(hashlib.sha1(data).digest())
def sign_data(token, data): DCNL  DCSP mac_data = {} DCNL DCSP mac_data['serialized_data'] = json.dumps(data) DCNL DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP mac_data['mac'] = mac DCNL DCSP md = (MAC_MARKER + base64.b64encode(json.dumps(mac_data))) DCNL DCSP return md
def verify_signed_data(token, data): DCNL  DCSP if data.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = data[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_data = json.loads(base64.b64decode(data)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP  DCSP  DCSP if (mac != mac_data['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvalidMacError(('invalid DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_data['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loads(mac_data['serialized_data']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvalidMacError('invalid DCSP MAC; DCSP data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL  DCSP iv = os.urandom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP data = json.dumps(data) DCNL DCSP encoded_data = base64.b64encode((iv + cipher.encrypt(data))) DCNL DCSP encoded_data = (ENCRYPT_MARKER + encoded_data) DCNL DCSP return encoded_data
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL  DCSP if data.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoded_data = data[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP decoded_data = base64.b64decode(encoded_data) DCNL DCSP  DCSP  DCSP iv = decoded_data[:16] DCNL DCSP  DCSP  DCSP encrypted_data = decoded_data[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP decrypted_data = cipher.decrypt(encrypted_data) DCNL DCSP  DCSP  DCSP return json.loads(decrypted_data) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
def is_ans1_token(token): DCNL  DCSP return (token[:3] == PKI_ANS1_PREFIX)
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
def cms_hash_token(token_id): DCNL  DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
def getid(obj): DCNL  DCSP try: DCNL DCSP  DCSP return obj.id DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
def from_response(response, body): DCNL  DCSP cls = _code_map.get(response.status_code, ClientException) DCNL DCSP if response.headers: DCNL DCSP  DCSP request_id = response.headers.get('x-compute-request-id') DCNL DCSP else: DCNL DCSP  DCSP request_id = None DCNL DCSP if body: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP details = 'n/a' DCNL DCSP  DCSP if hasattr(body, 'keys'): DCNL DCSP  DCSP  DCSP error = body[body.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP details = error.get('details', None) DCNL DCSP  DCSP return cls(code=response.status_code, message=message, details=details, request_id=request_id) DCNL DCSP else: DCNL DCSP  DCSP return cls(code=response.status_code, request_id=request_id)
def to_primitive(value, convert_instances=False, level=0): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > 3): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP o = [] DCNL DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP o.append(to_primitive(v, convert_instances=convert_instances, level=level)) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP o = {} DCNL DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP o[k] = to_primitive(v, convert_instances=convert_instances, level=level) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, datetime.datetime): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return to_primitive(dict(value.iteritems()), convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return to_primitive(list(value), convert_instances=convert_instances, level=level) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return to_primitive(value.__dict__, convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError as e: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(): DCNL  DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def set_rules(rules): DCNL  DCSP global _rules DCNL DCSP _rules = rules
def reset(): DCNL  DCSP global _rules DCNL DCSP _rules = None
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL  DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def _parse_list_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
def _parse_tokenize(rule): DCNL  DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
def reducer(*tokens): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def _parse_text_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
def parse_rule(rule): DCNL  DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError) as exc: DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def unique_id(token_id): DCNL  DCSP return cms.cms_hash_token(token_id)
def default_expire_time(): DCNL  DCSP expire_delta = datetime.timedelta(seconds=CONF.token.expiration) DCNL DCSP return (timeutils.utcnow() + expire_delta)
def validate_auth_info(self, context, user_ref, tenant_ref): DCNL  DCSP if (not user_ref.get('enabled', True)): DCNL DCSP  DCSP msg = ('User DCSP is DCSP disabled: DCSP %s' % user_ref['id']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP user_domain_ref = self.identity_api.get_domain(context, user_ref['domain_id']) DCNL DCSP if (user_domain_ref and (not user_domain_ref.get('enabled', True))): DCNL DCSP  DCSP msg = ('Domain DCSP is DCSP disabled: DCSP %s' % user_domain_ref['id']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP if tenant_ref: DCNL DCSP  DCSP if (not tenant_ref.get('enabled', True)): DCNL DCSP  DCSP  DCSP msg = ('Tenant DCSP is DCSP disabled: DCSP %s' % tenant_ref['id']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP  DCSP project_domain_ref = self.identity_api.get_domain(context, tenant_ref['domain_id']) DCNL DCSP  DCSP if (project_domain_ref and (not project_domain_ref.get('enabled', True))): DCNL DCSP  DCSP  DCSP msg = ('Domain DCSP is DCSP disabled: DCSP %s' % project_domain_ref['id']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorized(msg)
def recreate_token_data(context, token_data=None, expires=None, user_ref=None, project_ref=None): DCNL  DCSP new_expires = expires DCNL DCSP project_id = None DCNL DCSP user_id = None DCNL DCSP domain_id = None DCNL DCSP methods = ['password', 'token'] DCNL DCSP extras = {} DCNL DCSP if token_data: DCNL DCSP  DCSP token = token_data['token'] DCNL DCSP  DCSP domain_id = (token['domain']['id'] if ('domain' in token) else None) DCNL DCSP  DCSP project_id = (token['project']['id'] if ('project' in token) else None) DCNL DCSP  DCSP if (not new_expires): DCNL DCSP  DCSP  DCSP new_expires = token.get('expires_at', token.get('expires')) DCNL DCSP  DCSP user_id = token['user']['id'] DCNL DCSP  DCSP methods = token['methods'] DCNL DCSP  DCSP extras = token['extras'] DCNL DCSP else: DCNL DCSP  DCSP token = None DCNL DCSP  DCSP project_id = (project_ref['id'] if project_ref else None) DCNL DCSP  DCSP user_id = user_ref['id'] DCNL DCSP token_data_helper = TokenDataHelper(context) DCNL DCSP return token_data_helper.get_token_data(user_id, methods, extras, domain_id, project_id, new_expires, token=token)
def render_token_data_response(token_id, token_data, created=False): DCNL  DCSP headers = [('X-Subject-Token', token_id)] DCNL DCSP headers.append(('Vary', 'X-Auth-Token')) DCNL DCSP headers.append(('Content-Type', 'application/json')) DCNL DCSP if created: DCNL DCSP  DCSP status = (201, 'Created') DCNL DCSP else: DCNL DCSP  DCSP status = (200, 'OK') DCNL DCSP body = jsonutils.dumps(token_data, cls=utils.SmarterEncoder) DCNL DCSP return webob.Response(body=body, status=('%s DCSP %s' % status), headerlist=headers)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return S3Token(app, conf) DCNL DCSP return auth_filter
def render_response(body=None, status=None, headers=None): DCNL  DCSP headers = (headers or []) DCNL DCSP headers.append(('Vary', 'X-Auth-Token')) DCNL DCSP if (body is None): DCNL DCSP  DCSP body = '' DCNL DCSP  DCSP status = (status or (204, 'No DCSP Content')) DCNL DCSP else: DCNL DCSP  DCSP body = jsonutils.dumps(body, cls=utils.SmarterEncoder) DCNL DCSP  DCSP headers.append(('Content-Type', 'application/json')) DCNL DCSP  DCSP status = (status or (200, 'OK')) DCNL DCSP return webob.Response(body=body, status=('%s DCSP %s' % status), headerlist=headers)
def render_exception(error): DCNL  DCSP body = {'error': {'code': error.code, 'title': error.title, 'message': str(error)}} DCNL DCSP if isinstance(error, exception.AuthPluginException): DCNL DCSP  DCSP body['error']['identity'] = error.authentication DCNL DCSP return render_response(status=(error.code, error.title), body=body)
def provider(name): DCNL  DCSP def wrapper(cls): DCNL DCSP  DCSP def wrapped(init): DCNL DCSP  DCSP  DCSP def __wrapped_init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP 'Initialize DCSP the DCSP wrapped DCSP object DCSP and DCSP add DCSP it DCSP to DCSP the DCSP registry.' DCNL DCSP  DCSP  DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP REGISTRY[name] = self DCNL DCSP  DCSP  DCSP return __wrapped_init__ DCNL DCSP  DCSP cls.__init__ = wrapped(cls.__init__) DCNL DCSP  DCSP return cls DCNL DCSP return wrapper
def requires(*dependencies): DCNL  DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP 'Inject DCSP each DCSP dependency DCSP from DCSP the DCSP registry.' DCNL DCSP  DCSP self.__wrapped_init__(*args, **kwargs) DCNL DCSP  DCSP for dependency in self._dependencies: DCNL DCSP  DCSP  DCSP if (dependency not in REGISTRY): DCNL DCSP  DCSP  DCSP  DCSP raise UnresolvableDependencyException(dependency) DCNL DCSP  DCSP  DCSP setattr(self, dependency, REGISTRY[dependency]) DCNL DCSP def wrapped(cls): DCNL DCSP  DCSP 'Note DCSP the DCSP required DCSP dependencies DCSP on DCSP the DCSP object DCSP for DCSP later DCSP injection.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP dependencies DCSP of DCSP the DCSP parent DCSP class DCSP are DCSP combined DCSP with DCSP that DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP child DCSP class DCSP to DCSP create DCSP a DCSP new DCSP set DCSP of DCSP dependencies.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP existing_dependencies = getattr(cls, '_dependencies', set()) DCNL DCSP  DCSP cls._dependencies = existing_dependencies.union(dependencies) DCNL DCSP  DCSP if (not hasattr(cls, '__wrapped_init__')): DCNL DCSP  DCSP  DCSP cls.__wrapped_init__ = cls.__init__ DCNL DCSP  DCSP  DCSP cls.__init__ = wrapper DCNL DCSP  DCSP return cls DCNL DCSP return wrapped
def fail_gracefully(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kw): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kw) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logging.debug(traceback.format_exc(e)) DCNL DCSP  DCSP  DCSP logging.critical(e) DCNL DCSP  DCSP  DCSP exit(1) DCNL DCSP return wrapper
def initialize_decorator(init): DCNL  DCSP def initialize(self, *args, **kwargs): DCNL DCSP  DCSP cls = type(self) DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP if hasattr(cls, k): DCNL DCSP  DCSP  DCSP  DCSP attr = getattr(cls, k) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(attr, InstrumentedAttribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP column = attr.property.columns[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(column.type, String): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (column.type.length and (column.type.length < len(str(v)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((config.CONF.signing.token_format == 'PKI') and (self.__tablename__ == 'token') and (k == 'id')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.StringLengthExceeded(string=v, type=k, length=column.type.length) DCNL DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP return initialize
def handle_conflicts(type='object'): DCNL  DCSP def decorator(method): DCNL DCSP  DCSP @functools.wraps(method) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return method(*args, **kwargs) DCNL DCSP  DCSP  DCSP except IntegrityError as e: DCNL DCSP  DCSP  DCSP  DCSP raise exception.Conflict(type=type, details=str(e.orig)) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
def upgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP legacy_table.drop() DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP new_table.rename('endpoint')
def downgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP new_table = sql.Table('endpoint', meta, autoload=True) DCNL DCSP new_table.rename('endpoint_v3') DCNL DCSP sql.Table('service', meta, autoload=True) DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, sql.Column('id', sql.String(64), primary_key=True), sql.Column('region', sql.String(255)), sql.Column('service_id', sql.String(64), sql.ForeignKey('service.id'), nullable=False), sql.Column('extra', sql.Text())) DCNL DCSP legacy_table.create(migrate_engine, checkfirst=True)
def upgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint', meta, autoload=True) DCNL DCSP legacy_table.rename('endpoint_v2') DCNL DCSP sql.Table('service', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, sql.Column('id', sql.String(64), primary_key=True), sql.Column('legacy_endpoint_id', sql.String(64)), sql.Column('interface', sql.String(8), nullable=False), sql.Column('region', sql.String(255)), sql.Column('service_id', sql.String(64), sql.ForeignKey('service.id'), nullable=False), sql.Column('url', sql.Text(), nullable=False), sql.Column('extra', sql.Text())) DCNL DCSP new_table.create(migrate_engine, checkfirst=True)
def downgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP new_table.drop() DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP legacy_table.rename('endpoint')
def upgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP domain_table = sql.Table('domain', meta, autoload=True) DCNL DCSP domain = {'id': DEFAULT_DOMAIN_ID, 'name': 'Default', 'enabled': True, 'extra': json.dumps({'description': 'Owns DCSP users DCSP and DCSP tenants DCSP (i.e. DCSP projects) DCSP available DCSP on DCSP Identity DCSP API DCSP v2.'})} DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP insert = domain_table.insert() DCNL DCSP insert.execute(domain) DCNL DCSP session.commit()
def downgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP sql.Table('domain', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP session.execute('DELETE DCSP FROM DCSP domain DCSP WHERE DCSP id=:id', {'id': DEFAULT_DOMAIN_ID}) DCNL DCSP session.commit()
def upgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP for ref in session.query(legacy_table).all(): DCNL DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP urls = dict(((i, extra.pop(('%surl' % i))) for i in ENDPOINT_TYPES)) DCNL DCSP  DCSP for interface in ENDPOINT_TYPES: DCNL DCSP  DCSP  DCSP endpoint = {'id': uuid.uuid4().hex, 'legacy_endpoint_id': ref.id, 'interface': interface, 'region': ref.region, 'service_id': ref.service_id, 'url': urls[interface], 'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP insert = new_table.insert().values(endpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP session.commit() DCNL DCSP session.close()
def downgrade(migrate_engine): DCNL  DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP for ref in session.query(new_table).all(): DCNL DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP legacy_id = (ref.legacy_endpoint_id or extra.get('legacy_endpoint_id')) DCNL DCSP  DCSP if (not legacy_id): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP q = session.query(legacy_table) DCNL DCSP  DCSP q = q.filter_by(id=legacy_id) DCNL DCSP  DCSP legacy_ref = q.first() DCNL DCSP  DCSP if legacy_ref: DCNL DCSP  DCSP  DCSP extra = json.loads(legacy_ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP values = {'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP update = legacy_table.update().where((legacy_table.c.id == legacy_ref.id)).values(values) DCNL DCSP  DCSP  DCSP migrate_engine.execute(update) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP endpoint = {'id': legacy_id, 'region': ref.region, 'service_id': ref.service_id, 'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP insert = legacy_table.insert().values(endpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP  DCSP session.commit() DCNL DCSP session.close()
def _find_migrate_repo(): DCNL  DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
def _match_query(query, attrs): DCNL  DCSP inner = query[1:(-1)] DCNL DCSP if inner.startswith(('&', '|')): DCNL DCSP  DCSP groups = _paren_groups(inner[1:]) DCNL DCSP  DCSP return all((_match_query(group, attrs) for group in groups)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_query(query[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
def _paren_groups(source): DCNL  DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.append(source[start:(pos + 1)]) DCNL DCSP return result
def _match(key, value, attrs): DCNL  DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key == 'serviceId'): DCNL DCSP  DCSP str_sids = [str(x) for x in attrs[key]] DCNL DCSP  DCSP return (str(value) in str_sids) DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def _subs(value): DCNL  DCSP subs = {'groupOfNames': ['keystoneTenant', 'keystoneRole', 'keystoneTenantRole']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def trunc_password(password): DCNL  DCSP try: DCNL DCSP  DCSP if (len(password) > MAX_PASSWORD_LENGTH): DCNL DCSP  DCSP  DCSP return password[:MAX_PASSWORD_LENGTH] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return password DCNL DCSP except TypeError: DCNL DCSP  DCSP raise exception.ValidationError(attribute='string', target='password')
def hash_user_password(user): DCNL  DCSP try: DCNL DCSP  DCSP password = user['password'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return dict(user, password=hash_password(password))
def hash_ldap_user_password(user): DCNL  DCSP try: DCNL DCSP  DCSP password = user['password'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return dict(user, password=ldap_hash_password(password))
def hash_password(password): DCNL  DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP if passlib.hash.sha512_crypt.identify(password_utf8): DCNL DCSP  DCSP return password_utf8 DCNL DCSP h = passlib.hash.sha512_crypt.encrypt(password_utf8, rounds=CONF.crypt_strength) DCNL DCSP return h
def ldap_hash_password(password): DCNL  DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP h = passlib.hash.ldap_salted_sha1.encrypt(password_utf8) DCNL DCSP return h
def check_password(password, hashed): DCNL  DCSP if (password is None): DCNL DCSP  DCSP return False DCNL DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP return passlib.hash.sha512_crypt.verify(password_utf8, hashed)
def check_output(*popenargs, **kwargs): DCNL  DCSP if ('stdout' in kwargs): DCNL DCSP  DCSP raise ValueError('stdout DCSP argument DCSP not DCSP allowed, DCSP it DCSP will DCSP be DCSP overridden.') DCNL DCSP LOG.debug(' DCSP '.join(popenargs[0])) DCNL DCSP process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs) DCNL DCSP (output, unused_err) = process.communicate() DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP cmd = kwargs.get('args') DCNL DCSP  DCSP if (cmd is None): DCNL DCSP  DCSP  DCSP cmd = popenargs[0] DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, cmd) DCNL DCSP return output
def unixtime(dt_obj): DCNL  DCSP return time.mktime(dt_obj.utctimetuple())
def auth_str_equal(provided, known): DCNL  DCSP result = 0 DCNL DCSP p_len = len(provided) DCNL DCSP k_len = len(known) DCNL DCSP for i in xrange(p_len): DCNL DCSP  DCSP a = (ord(provided[i]) if (i < p_len) else 0) DCNL DCSP  DCSP b = (ord(known[i]) if (i < k_len) else 0) DCNL DCSP  DCSP result |= (a ^ b) DCNL DCSP return ((p_len == k_len) & (result == 0))
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error((_('Verify DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl', output=err) DCNL DCSP return output
def is_ans1_token(token): DCNL  DCSP return (token[:3] == PKI_ANS1_PREFIX)
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL  DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP if (retcode == 3): DCNL DCSP  DCSP  DCSP LOG.error(_("Signing DCSP error: DCSP Unable DCSP to DCSP load DCSP certificate DCSP - DCSP ensure DCSP you've DCSP configured DCSP PKI DCSP with DCSP 'keystone-manage DCSP pki_setup'")) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error((_('Signing DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
def cms_hash_token(token_id): DCNL  DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
def from_xml(xml): DCNL  DCSP if (xml is None): DCNL DCSP  DCSP return None DCNL DCSP deserializer = XmlDeserializer() DCNL DCSP return deserializer(xml)
def to_xml(d, xmlns=None): DCNL  DCSP if (d is None): DCNL DCSP  DCSP return None DCNL DCSP serialize = XmlSerializer() DCNL DCSP return serialize(d, xmlns)
def flatten(d, parent_key=''): DCNL  DCSP items = [] DCNL DCSP for (k, v) in d.items(): DCNL DCSP  DCSP new_key = (((parent_key + '.') + k) if parent_key else k) DCNL DCSP  DCSP if isinstance(v, collections.MutableMapping): DCNL DCSP  DCSP  DCSP items.extend(flatten(v, new_key).items()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP items.append((new_key, v)) DCNL DCSP return dict(items)
def protected(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, context, **kwargs): DCNL DCSP  DCSP if (('is_admin' in context) and context['is_admin']): DCNL DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = ('identity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP creds = _build_policy_check_credentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP self.policy_api.enforce(context, creds, action, flatten(kwargs)) DCNL DCSP  DCSP  DCSP LOG.debug(_('RBAC: DCSP Authorization DCSP granted')) DCNL DCSP  DCSP return f(self, context, **kwargs) DCNL DCSP return wrapper
def filterprotected(*filters): DCNL  DCSP def _filterprotected(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def wrapper(self, context, **kwargs): DCNL DCSP  DCSP  DCSP if (not context['is_admin']): DCNL DCSP  DCSP  DCSP  DCSP action = ('identity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP  DCSP creds = _build_policy_check_credentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP  DCSP target = dict() DCNL DCSP  DCSP  DCSP  DCSP if (len(filters) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for filter in filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (filter in context['query_string']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP target[filter] = context['query_string'][filter] DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug((_('RBAC: DCSP Adding DCSP query DCSP filter DCSP params DCSP (%s)') % ', DCSP '.join([('%s=%s' % (filter, target[filter])) for filter in target]))) DCNL DCSP  DCSP  DCSP  DCSP for key in kwargs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP target[key] = kwargs[key] DCNL DCSP  DCSP  DCSP  DCSP self.policy_api.enforce(context, creds, action, flatten(target)) DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('RBAC: DCSP Authorization DCSP granted')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP  DCSP return f(self, context, filters, **kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return _filterprotected
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL  DCSP path = quote((((('/' + device) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaddr, port, device, partition, method, path, headers, query_string, ssl, key_file, cert_file)
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL  DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaddr, port)), key_file=key_file, cert_file=cert_file) DCNL DCSP else: DCNL DCSP  DCSP conn = BufferedHTTPConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP if query_string: DCNL DCSP  DCSP path += ('?' + query_string) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest(method, path) DCNL DCSP if headers: DCNL DCSP  DCSP for (header, value) in headers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheader(header, value) DCNL DCSP conn.endheaders() DCNL DCSP return conn
def setup_logging(conf): DCNL  DCSP if conf.log_config: DCNL DCSP  DCSP if os.path.exists(conf.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(conf.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Unable DCSP to DCSP locate DCSP specified DCSP logging DCSP config DCSP file: DCSP %s') % conf.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if conf.debug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif conf.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(conf.log_format, conf.log_date_format) DCNL DCSP if conf.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.SysLogHandler, conf.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invalid DCSP syslog DCSP facility')) DCNL DCSP  DCSP handler = logging.SysLogHandler(address='/dev/log', facility=facility) DCNL DCSP elif conf.log_file: DCNL DCSP  DCSP logfile = conf.log_file DCNL DCSP  DCSP if conf.log_dir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(conf.log_dir, logfile) DCNL DCSP  DCSP handler = logging.WatchedFileHandler(logfile) DCNL DCSP else: DCNL DCSP  DCSP handler = logging.StreamHandler(sys.stdout) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP root_logger.addHandler(handler)
def format_url(url, data): DCNL  DCSP try: DCNL DCSP  DCSP result = (url.replace('$(', '%(') % data) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None DCNL DCSP except KeyError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s(are DCSP you DCSP missing DCSP brackets DCSP ?)') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %s DCSP - DCSP incomplete DCSP format DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (are DCSP you DCSP missing DCSP a DCSP type DCSP notifier DCSP ?)') % url)) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP return result
def filter_user(user_ref): DCNL  DCSP if user_ref: DCNL DCSP  DCSP user_ref = user_ref.copy() DCNL DCSP  DCSP user_ref.pop('password', None) DCNL DCSP  DCSP user_ref.pop('tenants', None) DCNL DCSP  DCSP user_ref.pop('groups', None) DCNL DCSP  DCSP user_ref.pop('domains', None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('password', None) DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('tenants', None) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return user_ref
def enforce(credentials, action, target, do_raise=True): DCNL  DCSP init() DCNL DCSP extra = {} DCNL DCSP if do_raise: DCNL DCSP  DCSP extra.update(exc=exception.ForbiddenAction, action=action) DCNL DCSP return common_policy.check(action, target, credentials, **extra)
def _build_user_auth(token=None, user_id=None, username=None, password=None, tenant_id=None, tenant_name=None, trust_id=None): DCNL  DCSP auth_json = {} DCNL DCSP if (token is not None): DCNL DCSP  DCSP auth_json['token'] = token DCNL DCSP if (username or password): DCNL DCSP  DCSP auth_json['passwordCredentials'] = {} DCNL DCSP if (username is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['username'] = username DCNL DCSP if (user_id is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['userId'] = user_id DCNL DCSP if (password is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['password'] = password DCNL DCSP if (tenant_name is not None): DCNL DCSP  DCSP auth_json['tenantName'] = tenant_name DCNL DCSP if (tenant_id is not None): DCNL DCSP  DCSP auth_json['tenantId'] = tenant_id DCNL DCSP if (trust_id is not None): DCNL DCSP  DCSP auth_json['trust_id'] = trust_id DCNL DCSP return auth_json
def retry(func, *args, **kwargs): DCNL  DCSP global url, token, parsed, conn DCNL DCSP retries = kwargs.get('retries', 5) DCNL DCSP use_account = 1 DCNL DCSP if ('use_account' in kwargs): DCNL DCSP  DCSP use_account = kwargs['use_account'] DCNL DCSP  DCSP del kwargs['use_account'] DCNL DCSP use_account -= 1 DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((not url[use_account]) or (not token[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (url[use_account], token[use_account]) = get_auth(swift_test_auth, swift_test_user[use_account], swift_test_key[use_account], snet=False, tenant_name=swift_test_tenant[use_account], auth_version=swift_test_auth_version, os_options={}) DCNL DCSP  DCSP  DCSP  DCSP parsed[use_account] = conn[use_account] = None DCNL DCSP  DCSP  DCSP if ((not parsed[use_account]) or (not conn[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (parsed[use_account], conn[use_account]) = http_connection(url[use_account]) DCNL DCSP  DCSP  DCSP return func(url[use_account], token[use_account], parsed[use_account], conn[use_account], *args, **kwargs) DCNL DCSP  DCSP except (socket.error, HTTPException): DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP parsed[use_account] = conn[use_account] = None DCNL DCSP  DCSP except AuthError as err: DCNL DCSP  DCSP  DCSP url[use_account] = token[use_account] = None DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except InternalServerError as err: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (attempts <= retries): DCNL DCSP  DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP  DCSP backoff *= 2 DCNL DCSP raise Exception(('No DCSP result DCSP after DCSP %s DCSP retries.' % retries))
def get_config(section_name=None, defaults=None): DCNL  DCSP config_file = os.environ.get('SWIFT_TEST_CONFIG_FILE', '/etc/swift/test.conf') DCNL DCSP config = {} DCNL DCSP if (defaults is not None): DCNL DCSP  DCSP config.update(defaults) DCNL DCSP try: DCNL DCSP  DCSP config = readconf(config_file, section_name) DCNL DCSP except SystemExit: DCNL DCSP  DCSP if (not os.path.exists(config_file)): DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP file DCSP not DCSP found' % config_file) DCNL DCSP  DCSP elif (not os.access(config_file, os.R_OK)): DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP permission DCSP denied' % config_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP section DCSP %s DCSP not DCSP found' % (config_file, section_name)) DCNL DCSP return config
def sortHeaderNames(headerNames): DCNL  DCSP headers = [a.strip() for a in headerNames.split(',') if a.strip()] DCNL DCSP headers.sort() DCNL DCSP return ', DCSP '.join(headers)
def teardown_module(): DCNL  DCSP reload(db_replicator)
def pop_stream(f): DCNL  DCSP f.flush() DCNL DCSP f.seek(0) DCNL DCSP output = f.read() DCNL DCSP f.seek(0) DCNL DCSP f.truncate() DCNL DCSP return output
def premetadata_create_container_stat_table(self, conn, put_timestamp=None): DCNL  DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_used)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuid4()), put_timestamp))
def prexsync_create_container_stat_table(self, conn, put_timestamp=None): DCNL  DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metadata DCSP TEXT DCSP DEFAULT DCSP ''\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_used)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuid4()), put_timestamp))
def premetadata_create_account_stat_table(self, conn, put_timestamp): DCNL  DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP account_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP account_stat DCSP (container_count) DCSP VALUES DCSP (0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP account_stat DCSP SET DCSP account DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ', (self.account, normalize_timestamp(time()), str(uuid4()), put_timestamp))
def app_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return ContainerController(conf)
def app_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return Application(conf)
def update_headers(response, headers): DCNL  DCSP if hasattr(headers, 'items'): DCNL DCSP  DCSP headers = headers.items() DCNL DCSP for (name, value) in headers: DCNL DCSP  DCSP if (name == 'etag'): DCNL DCSP  DCSP  DCSP response.headers[name] = value.replace('"', '') DCNL DCSP  DCSP elif (name not in ('date', 'content-length', 'content-type', 'connection', 'x-put-timestamp', 'x-delete-after')): DCNL DCSP  DCSP  DCSP response.headers[name] = value
def source_key(resp): DCNL  DCSP return float((resp.getheader('x-put-timestamp') or resp.getheader('x-timestamp') or 0))
def delay_denial(func): DCNL  DCSP func.delay_denial = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
def headers_to_account_info(headers, status_int=HTTP_OK): DCNL  DCSP headers = dict(((k.lower(), v) for (k, v) in dict(headers).iteritems())) DCNL DCSP return {'status': status_int, 'container_count': headers.get('x-account-container-count'), 'total_object_count': headers.get('x-account-object-count'), 'bytes': headers.get('x-account-bytes-used'), 'meta': dict(((key[15:], value) for (key, value) in headers.iteritems() if key.startswith('x-account-meta-')))}
def headers_to_container_info(headers, status_int=HTTP_OK): DCNL  DCSP headers = dict(((k.lower(), v) for (k, v) in dict(headers).iteritems())) DCNL DCSP return {'status': status_int, 'read_acl': headers.get('x-container-read'), 'write_acl': headers.get('x-container-write'), 'sync_key': headers.get('x-container-sync-key'), 'object_count': headers.get('x-container-object-count'), 'bytes': headers.get('x-container-bytes-used'), 'versions': headers.get('x-versions-location'), 'cors': {'allow_origin': headers.get('x-container-meta-access-control-allow-origin'), 'allow_headers': headers.get('x-container-meta-access-control-allow-headers'), 'expose_headers': headers.get('x-container-meta-access-control-expose-headers'), 'max_age': headers.get('x-container-meta-access-control-max-age')}, 'meta': dict(((key[17:], value) for (key, value) in headers.iteritems() if key.startswith('x-container-meta-')))}
def cors_validation(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP controller = a[0] DCNL DCSP  DCSP req = a[1] DCNL DCSP  DCSP req_origin = req.headers.get('Origin', None) DCNL DCSP  DCSP if req_origin: DCNL DCSP  DCSP  DCSP container_info = controller.container_info(controller.account_name, controller.container_name) DCNL DCSP  DCSP  DCSP cors_info = container_info.get('cors', {}) DCNL DCSP  DCSP  DCSP resp = func(*a, **kw) DCNL DCSP  DCSP  DCSP expose_headers = ['cache-control', 'content-language', 'content-type', 'expires', 'last-modified', 'pragma', 'etag', 'x-timestamp', 'x-trans-id'] DCNL DCSP  DCSP  DCSP for header in resp.headers: DCNL DCSP  DCSP  DCSP  DCSP if (header.startswith('x-container-meta') or header.startswith('x-object-meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP expose_headers.append(header.lower()) DCNL DCSP  DCSP  DCSP if cors_info.get('expose_headers'): DCNL DCSP  DCSP  DCSP  DCSP expose_headers.extend([a.strip() for a in cors_info['expose_headers'].split(' DCSP ') if a.strip()]) DCNL DCSP  DCSP  DCSP resp.headers['Access-Control-Expose-Headers'] = ', DCSP '.join(expose_headers) DCNL DCSP  DCSP  DCSP resp.headers['Access-Control-Allow-Origin'] = req_origin DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
def get_container_info(env, app, swift_source=None): DCNL  DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 3, 4, True) DCNL DCSP cache_key = get_container_memcache_key(account, container) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP container_info = cache.get(cache_key) DCNL DCSP  DCSP if (not container_info): DCNL DCSP  DCSP  DCSP resp = make_pre_authed_request(env, 'HEAD', ('/%s/%s/%s' % (version, account, container)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP container_info = headers_to_container_info(resp.headers, resp.status_int) DCNL DCSP  DCSP env[env_key] = container_info DCNL DCSP return env[env_key]
def get_account_info(env, app, swift_source=None): DCNL  DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 2, 4, True) DCNL DCSP cache_key = get_account_memcache_key(account) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP account_info = cache.get(cache_key) DCNL DCSP  DCSP if (not account_info): DCNL DCSP  DCSP  DCSP resp = make_pre_authed_request(env, 'HEAD', ('/%s/%s' % (version, account)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP account_info = headers_to_account_info(resp.headers, resp.status_int) DCNL DCSP  DCSP env[env_key] = account_info DCNL DCSP return env[env_key]
def copy_headers_into(from_r, to_r): DCNL  DCSP for (k, v) in from_r.headers.items(): DCNL DCSP  DCSP if k.lower().startswith('x-object-meta-'): DCNL DCSP  DCSP  DCSP to_r.headers[k] = v
def is_informational(status): DCNL  DCSP return ((100 <= status) and (status <= 199))
def is_success(status): DCNL  DCSP return ((200 <= status) and (status <= 299))
def is_redirection(status): DCNL  DCSP return ((300 <= status) and (status <= 399))
def is_client_error(status): DCNL  DCSP return ((400 <= status) and (status <= 499))
def is_server_error(status): DCNL  DCSP return ((500 <= status) and (status <= 599))
def check_metadata(req, target_type): DCNL  DCSP prefix = ('x-%s-meta-' % target_type.lower()) DCNL DCSP meta_count = 0 DCNL DCSP meta_size = 0 DCNL DCSP for (key, value) in req.headers.iteritems(): DCNL DCSP  DCSP if (isinstance(value, basestring) and (len(value) > MAX_HEADER_SIZE)): DCNL DCSP  DCSP  DCSP return HTTPBadRequest('Header DCSP Line DCSP Too DCSP Long') DCNL DCSP  DCSP if (not key.lower().startswith(prefix)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key = key[len(prefix):] DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body='Metadata DCSP name DCSP cannot DCSP be DCSP empty', request=req, content_type='text/plain') DCNL DCSP  DCSP meta_count += 1 DCNL DCSP  DCSP meta_size += (len(key) + len(value)) DCNL DCSP  DCSP if (len(key) > MAX_META_NAME_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Metadata DCSP name DCSP too DCSP long; DCSP max DCSP %d' % MAX_META_NAME_LENGTH), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (len(value) > MAX_META_VALUE_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Metadata DCSP value DCSP too DCSP long; DCSP max DCSP %d' % MAX_META_VALUE_LENGTH), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (meta_count > MAX_META_COUNT): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Too DCSP many DCSP metadata DCSP items; DCSP max DCSP %d' % MAX_META_COUNT), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (meta_size > MAX_META_OVERALL_SIZE): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Total DCSP metadata DCSP too DCSP large; DCSP max DCSP %d' % MAX_META_OVERALL_SIZE), request=req, content_type='text/plain') DCNL DCSP return None
def check_object_creation(req, object_name): DCNL  DCSP if (req.content_length and (req.content_length > MAX_FILE_SIZE)): DCNL DCSP  DCSP return HTTPRequestEntityTooLarge(body='Your DCSP request DCSP is DCSP too DCSP large.', request=req, content_type='text/plain') DCNL DCSP if ((req.content_length is None) and (req.headers.get('transfer-encoding') != 'chunked')): DCNL DCSP  DCSP return HTTPLengthRequired(request=req) DCNL DCSP if (('X-Copy-From' in req.headers) and req.content_length): DCNL DCSP  DCSP return HTTPBadRequest(body='Copy DCSP requests DCSP require DCSP a DCSP zero DCSP byte DCSP body', request=req, content_type='text/plain') DCNL DCSP if (len(object_name) > MAX_OBJECT_NAME_LENGTH): DCNL DCSP  DCSP return HTTPBadRequest(body=('Object DCSP name DCSP length DCSP of DCSP %d DCSP longer DCSP than DCSP %d' % (len(object_name), MAX_OBJECT_NAME_LENGTH)), request=req, content_type='text/plain') DCNL DCSP if ('Content-Type' not in req.headers): DCNL DCSP  DCSP return HTTPBadRequest(request=req, content_type='text/plain', body='No DCSP content DCSP type') DCNL DCSP if (not check_utf8(req.headers['Content-Type'])): DCNL DCSP  DCSP return HTTPBadRequest(request=req, body='Invalid DCSP Content-Type', content_type='text/plain') DCNL DCSP if ('x-object-manifest' in req.headers): DCNL DCSP  DCSP value = req.headers['x-object-manifest'] DCNL DCSP  DCSP container = prefix = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (container, prefix) = value.split('/', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ((not container) or (not prefix) or ('?' in value) or ('&' in value) or (prefix[0] == '/')): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(request=req, body='X-Object-Manifest DCSP must DCSP in DCSP the DCSP format DCSP container/prefix') DCNL DCSP return check_metadata(req, 'object')
def check_mount(root, drive): DCNL  DCSP if (not (urllib.quote_plus(drive) == drive)): DCNL DCSP  DCSP return False DCNL DCSP path = os.path.join(root, drive) DCNL DCSP return (os.path.exists(path) and os.path.ismount(path))
def check_float(string): DCNL  DCSP try: DCNL DCSP  DCSP float(string) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
def check_utf8(string): DCNL  DCSP if (not string): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP if isinstance(string, unicode): DCNL DCSP  DCSP  DCSP string.encode('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP string.decode('UTF-8') DCNL DCSP  DCSP return ('\x00' not in string) DCNL DCSP except UnicodeError: DCNL DCSP  DCSP return False
def monkey_patch_mimetools(): DCNL  DCSP orig_parsetype = mimetools.Message.parsetype DCNL DCSP def parsetype(self): DCNL DCSP  DCSP if (not self.typeheader): DCNL DCSP  DCSP  DCSP self.type = None DCNL DCSP  DCSP  DCSP self.maintype = None DCNL DCSP  DCSP  DCSP self.subtype = None DCNL DCSP  DCSP  DCSP self.plisttext = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP orig_parsetype(self) DCNL DCSP mimetools.Message.parsetype = parsetype
def get_socket(conf, default_port=8080): DCNL  DCSP bind_addr = (conf.get('bind_ip', '0.0.0.0'), int(conf.get('bind_port', default_port))) DCNL DCSP address_family = [addr[0] for addr in socket.getaddrinfo(bind_addr[0], bind_addr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (addr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP sock = None DCNL DCSP bind_timeout = int(conf.get('bind_timeout', 30)) DCNL DCSP retry_until = (time.time() + bind_timeout) DCNL DCSP warn_ssl = False DCNL DCSP while ((not sock) and (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = listen(bind_addr, backlog=int(conf.get('backlog', 4096)), family=address_family) DCNL DCSP  DCSP  DCSP if ('cert_file' in conf): DCNL DCSP  DCSP  DCSP  DCSP warn_ssl = True DCNL DCSP  DCSP  DCSP  DCSP sock = ssl.wrap_socket(sock, certfile=conf['cert_file'], keyfile=conf['key_file']) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise Exception((_('Could DCSP not DCSP bind DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP %s DCSP seconds') % (bind_addr[0], bind_addr[1], bind_timeout))) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 600) DCNL DCSP if warn_ssl: DCNL DCSP  DCSP ssl_warning_message = 'WARNING: DCSP SSL DCSP should DCSP only DCSP be DCSP enabled DCSP for DCSP testing DCSP purposes. DCSP Use DCSP external DCSP SSL DCSP termination DCSP for DCSP a DCSP production DCSP deployment.' DCNL DCSP  DCSP get_logger(conf).warning(ssl_warning_message) DCNL DCSP  DCSP print _(ssl_warning_message) DCNL DCSP return sock
def run_wsgi(conf_file, app_section, *args, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP (app, conf, logger, log_name) = init_request_processor(conf_file, app_section, *args, **kwargs) DCNL DCSP except ConfigFileError as e: DCNL DCSP  DCSP print e DCNL DCSP  DCSP return DCNL DCSP sock = get_socket(conf, default_port=kwargs.get('default_port', 8080)) DCNL DCSP drop_privileges(conf.get('user', 'swift')) DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP capture_stdio(logger) DCNL DCSP def run_server(): DCNL DCSP  DCSP wsgi.HttpProtocol.default_request_version = 'HTTP/1.0' DCNL DCSP  DCSP wsgi.HttpProtocol.log_request = (lambda *a: None) DCNL DCSP  DCSP wsgi.HttpProtocol.log_message = (lambda s, f, *a: logger.error(('ERROR DCSP WSGI: DCSP ' + (f % a)))) DCNL DCSP  DCSP wsgi.WRITE_TIMEOUT = int((conf.get('client_timeout') or 60)) DCNL DCSP  DCSP eventlet.hubs.use_hub(get_hub()) DCNL DCSP  DCSP eventlet.patcher.monkey_patch(all=False, socket=True) DCNL DCSP  DCSP eventlet_debug = config_true_value(conf.get('eventlet_debug', 'no')) DCNL DCSP  DCSP eventlet.debug.hub_exceptions(eventlet_debug) DCNL DCSP  DCSP app = loadapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP  DCSP pool = GreenPool(size=1024) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wsgi.server(sock, app, NullLogger(), custom_pool=pool) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err[0] != errno.EINVAL): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP pool.waitall() DCNL DCSP worker_count = int(conf.get('workers', '1')) DCNL DCSP if (worker_count == 0): DCNL DCSP  DCSP run_server() DCNL DCSP  DCSP return DCNL DCSP def kill_children(*args): DCNL DCSP  DCSP 'Kills DCSP the DCSP entire DCSP process DCSP group.' DCNL DCSP  DCSP logger.error('SIGTERM DCSP received') DCNL DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP  DCSP os.killpg(0, signal.SIGTERM) DCNL DCSP def hup(*args): DCNL DCSP  DCSP 'Shuts DCSP down DCSP the DCSP server, DCSP but DCSP allows DCSP running DCSP requests DCSP to DCSP complete' DCNL DCSP  DCSP logger.error('SIGHUP DCSP received') DCNL DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP running = [True] DCNL DCSP signal.signal(signal.SIGTERM, kill_children) DCNL DCSP signal.signal(signal.SIGHUP, hup) DCNL DCSP children = [] DCNL DCSP while running[0]: DCNL DCSP  DCSP while (len(children) < worker_count): DCNL DCSP  DCSP  DCSP pid = os.fork() DCNL DCSP  DCSP  DCSP if (pid == 0): DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP run_server() DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Child DCSP %d DCSP exiting DCSP normally' % os.getpid())) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Started DCSP child DCSP %s' % pid)) DCNL DCSP  DCSP  DCSP  DCSP children.append(pid) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (pid, status) = os.wait() DCNL DCSP  DCSP  DCSP if (os.WIFEXITED(status) or os.WIFSIGNALED(status)): DCNL DCSP  DCSP  DCSP  DCSP logger.error(('Removing DCSP dead DCSP child DCSP %s' % pid)) DCNL DCSP  DCSP  DCSP  DCSP children.remove(pid) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno not in (errno.EINTR, errno.ECHILD)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP logger.notice('User DCSP quit') DCNL DCSP  DCSP  DCSP break DCNL DCSP greenio.shutdown_safe(sock) DCNL DCSP sock.close() DCNL DCSP logger.notice('Exited')
def init_request_processor(conf_file, app_section, *args, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP conf = appconfig(('config:%s' % conf_file), name=app_section) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ConfigFileError(('Error DCSP trying DCSP to DCSP load DCSP config DCSP %s: DCSP %s' % (conf_file, e))) DCNL DCSP validate_configuration() DCNL DCSP log_name = conf.get('log_name', app_section) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = get_logger(conf, log_name, log_to_console=kwargs.pop('verbose', False), log_route='wsgi') DCNL DCSP if config_true_value(conf.get('disable_fallocate', 'no')): DCNL DCSP  DCSP disable_fallocate() DCNL DCSP monkey_patch_mimetools() DCNL DCSP app = loadapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP return (app, conf, logger, log_name)
def make_pre_authed_request(env, method=None, path=None, body=None, headers=None, agent='Swift', swift_source=None): DCNL  DCSP query_string = None DCNL DCSP if (path and ('?' in path)): DCNL DCSP  DCSP (path, query_string) = path.split('?', 1) DCNL DCSP newenv = make_pre_authed_env(env, method, path=unquote(path), agent=agent, query_string=query_string, swift_source=swift_source) DCNL DCSP if (not headers): DCNL DCSP  DCSP headers = {} DCNL DCSP if body: DCNL DCSP  DCSP return Request.blank(path, environ=newenv, body=body, headers=headers) DCNL DCSP else: DCNL DCSP  DCSP return Request.blank(path, environ=newenv, headers=headers)
def make_pre_authed_env(env, method=None, path=None, agent='Swift', query_string=None, swift_source=None): DCNL  DCSP newenv = {} DCNL DCSP for name in ('eventlet.posthooks', 'HTTP_USER_AGENT', 'HTTP_HOST', 'PATH_INFO', 'QUERY_STRING', 'REMOTE_USER', 'REQUEST_METHOD', 'SCRIPT_NAME', 'SERVER_NAME', 'SERVER_PORT', 'SERVER_PROTOCOL', 'swift.cache', 'swift.source', 'swift.trans_id'): DCNL DCSP  DCSP if (name in env): DCNL DCSP  DCSP  DCSP newenv[name] = env[name] DCNL DCSP if method: DCNL DCSP  DCSP newenv['REQUEST_METHOD'] = method DCNL DCSP if path: DCNL DCSP  DCSP newenv['PATH_INFO'] = path DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP if (query_string is not None): DCNL DCSP  DCSP newenv['QUERY_STRING'] = query_string DCNL DCSP if agent: DCNL DCSP  DCSP newenv['HTTP_USER_AGENT'] = (agent % {'orig': env.get('HTTP_USER_AGENT', '')}).strip() DCNL DCSP elif ((agent == '') and ('HTTP_USER_AGENT' in newenv)): DCNL DCSP  DCSP del newenv['HTTP_USER_AGENT'] DCNL DCSP if swift_source: DCNL DCSP  DCSP newenv['swift.source'] = swift_source DCNL DCSP newenv['swift.authorize'] = (lambda req: None) DCNL DCSP newenv['swift.authorize_override'] = True DCNL DCSP newenv['REMOTE_USER'] = '.wsgi.pre_authed' DCNL DCSP newenv['wsgi.input'] = StringIO('') DCNL DCSP if ('SCRIPT_NAME' not in newenv): DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP return newenv
def _func_on_containers(logger, conf, concurrency_key, func): DCNL  DCSP bench = Bench(logger, conf, []) DCNL DCSP pool = eventlet.GreenPool(int(getattr(conf, concurrency_key))) DCNL DCSP for container in conf.containers: DCNL DCSP  DCSP pool.spawn_n(func, bench.url, bench.token, container) DCNL DCSP pool.waitall()
def delete_containers(logger, conf): DCNL  DCSP def _deleter(url, token, container): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP client.delete_container(url, token, container) DCNL DCSP  DCSP except client.ClientException as e: DCNL DCSP  DCSP  DCSP if (e.http_status != HTTP_CONFLICT): DCNL DCSP  DCSP  DCSP  DCSP logger.warn(("Unable DCSP to DCSP delete DCSP container DCSP '%s'. DCSP Got DCSP http DCSP status DCSP '%d'." % (container, e.http_status))) DCNL DCSP _func_on_containers(logger, conf, 'del_concurrency', _deleter)
def create_containers(logger, conf): DCNL  DCSP _func_on_containers(logger, conf, 'put_concurrency', client.put_container)
def direct_get_account(node, part, account, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL  DCSP path = ('/' + account) DCNL DCSP qs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qs += ('&marker=%s' % quote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qs += ('&limit=%d' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qs += ('&prefix=%s' % quote(prefix)) DCNL DCSP if delimiter: DCNL DCSP  DCSP qs += ('&delimiter=%s' % quote(delimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, query_string=qs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Account DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP return (resp_headers, []) DCNL DCSP return (resp_headers, json_loads(resp.read()))
def direct_head_container(node, part, account, container, conn_timeout=5, response_timeout=15): DCNL  DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP direct DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return resp_headers
def direct_get_container(node, part, account, container, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL  DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP qs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qs += ('&marker=%s' % quote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qs += ('&limit=%d' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qs += ('&prefix=%s' % quote(prefix)) DCNL DCSP if delimiter: DCNL DCSP  DCSP qs += ('&delimiter=%s' % quote(delimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, query_string=qs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP stats DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP return (resp_headers, []) DCNL DCSP return (resp_headers, json_loads(resp.read()))
def direct_head_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return resp_headers
def direct_get_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, headers={}): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, headers=headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP if resp_chunk_size: DCNL DCSP  DCSP def _object_body(): DCNL DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP  DCSP while buf: DCNL DCSP  DCSP  DCSP  DCSP (yield buf) DCNL DCSP  DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP object_body = _object_body() DCNL DCSP else: DCNL DCSP  DCSP object_body = resp.read() DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return (resp_headers, object_body)
def direct_put_object(node, part, account, container, name, contents, content_length=None, etag=None, content_type=None, headers=None, conn_timeout=5, response_timeout=15, resp_chunk_size=None): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP if etag: DCNL DCSP  DCSP headers['ETag'] = etag.strip('"') DCNL DCSP if (content_length is not None): DCNL DCSP  DCSP headers['Content-Length'] = str(content_length) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP headers['Content-Type'] = content_type DCNL DCSP else: DCNL DCSP  DCSP headers['Content-Type'] = 'application/octet-stream' DCNL DCSP if (not contents): DCNL DCSP  DCSP headers['Content-Length'] = '0' DCNL DCSP if isinstance(contents, basestring): DCNL DCSP  DCSP contents = [contents] DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'PUT', path, headers=headers) DCNL DCSP for chunk in contents: DCNL DCSP  DCSP conn.send(chunk) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP PUT DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP return resp.getheader('etag').strip('"')
def direct_post_object(node, part, account, container, name, headers, conn_timeout=5, response_timeout=15): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'POST', path, headers=headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP POST DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason)
def direct_delete_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, headers={}): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'DELETE', path, headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP DELETE DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason)
def retry(func, *args, **kwargs): DCNL  DCSP retries = 5 DCNL DCSP if ('retries' in kwargs): DCNL DCSP  DCSP retries = kwargs['retries'] DCNL DCSP  DCSP del kwargs['retries'] DCNL DCSP error_log = None DCNL DCSP if ('error_log' in kwargs): DCNL DCSP  DCSP error_log = kwargs['error_log'] DCNL DCSP  DCSP del kwargs['error_log'] DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (attempts, func(*args, **kwargs)) DCNL DCSP  DCSP except (socket.error, HTTPException, Timeout) as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except ClientException as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if ((attempts > retries) or (not is_server_error(err.http_status)) or (err.http_status == HTTP_INSUFFICIENT_STORAGE)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP backoff *= 2 DCNL DCSP if (args and ('ip' in args[0])): DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries', http_host=args[0]['ip'], http_port=args[0]['port'], http_device=args[0]['device']) DCNL DCSP else: DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries')
def backward(f, blocksize=4096): DCNL  DCSP f.seek(0, os.SEEK_END) DCNL DCSP if (f.tell() == 0): DCNL DCSP  DCSP return DCNL DCSP last_row = '' DCNL DCSP while (f.tell() != 0): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP blocksize = f.tell() DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP block = f.read(blocksize) DCNL DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP rows = block.split('\n') DCNL DCSP  DCSP rows[(-1)] = (rows[(-1)] + last_row) DCNL DCSP  DCSP while rows: DCNL DCSP  DCSP  DCSP last_row = rows.pop((-1)) DCNL DCSP  DCSP  DCSP if (rows and last_row): DCNL DCSP  DCSP  DCSP  DCSP (yield last_row) DCNL DCSP (yield last_row)
def config_true_value(value): DCNL  DCSP return ((value is True) or (isinstance(value, basestring) and (value.lower() in TRUE_VALUES)))
def load_libc_function(func_name, log_error=True): DCNL  DCSP try: DCNL DCSP  DCSP libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True) DCNL DCSP  DCSP return getattr(libc, func_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if log_error: DCNL DCSP  DCSP  DCSP logging.warn(_('Unable DCSP to DCSP locate DCSP %s DCSP in DCSP libc. DCSP  DCSP Leaving DCSP as DCSP a DCSP no-op.'), func_name) DCNL DCSP  DCSP return noop_libc_function
def get_param(req, name, default=None): DCNL  DCSP value = req.params.get(name, default) DCNL DCSP if (value and (not isinstance(value, unicode))): DCNL DCSP  DCSP value.decode('utf8') DCNL DCSP return value
def fallocate(fd, size): DCNL  DCSP global _sys_fallocate DCNL DCSP if (_sys_fallocate is None): DCNL DCSP  DCSP _sys_fallocate = FallocateWrapper() DCNL DCSP if (size < 0): DCNL DCSP  DCSP size = 0 DCNL DCSP ret = _sys_fallocate(fd, 1, 0, ctypes.c_uint64(size)) DCNL DCSP err = ctypes.get_errno() DCNL DCSP if (ret and (err not in (0, errno.ENOSYS, errno.EOPNOTSUPP, errno.EINVAL))): DCNL DCSP  DCSP raise OSError(err, ('Unable DCSP to DCSP fallocate(%s)' % size))
def fsync(fd): DCNL  DCSP if hasattr(fcntl, 'F_FULLSYNC'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fcntl.fcntl(fd, fcntl.F_FULLSYNC) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise OSError(e.errno, ('Unable DCSP to DCSP F_FULLSYNC(%s)' % fd)) DCNL DCSP else: DCNL DCSP  DCSP os.fsync(fd)
def fdatasync(fd): DCNL  DCSP try: DCNL DCSP  DCSP os.fdatasync(fd) DCNL DCSP except AttributeError: DCNL DCSP  DCSP fsync(fd)
def drop_buffer_cache(fd, offset, length): DCNL  DCSP global _posix_fadvise DCNL DCSP if (_posix_fadvise is None): DCNL DCSP  DCSP _posix_fadvise = load_libc_function('posix_fadvise64') DCNL DCSP ret = _posix_fadvise(fd, ctypes.c_uint64(offset), ctypes.c_uint64(length), 4) DCNL DCSP if (ret != 0): DCNL DCSP  DCSP logging.warn(('posix_fadvise64(%s, DCSP %s, DCSP %s, DCSP 4) DCSP -> DCSP %s' % (fd, offset, length, ret)))
def normalize_timestamp(timestamp): DCNL  DCSP return ('%016.05f' % float(timestamp))
def mkdirs(path): DCNL  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if ((err.errno != errno.EEXIST) or (not os.path.isdir(path))): DCNL DCSP  DCSP  DCSP  DCSP raise
def renamer(old, new): DCNL  DCSP try: DCNL DCSP  DCSP mkdirs(os.path.dirname(new)) DCNL DCSP  DCSP os.rename(old, new) DCNL DCSP except OSError: DCNL DCSP  DCSP mkdirs(os.path.dirname(new)) DCNL DCSP  DCSP os.rename(old, new)
def split_path(path, minsegs=1, maxsegs=None, rest_with_last=False): DCNL  DCSP if (not maxsegs): DCNL DCSP  DCSP maxsegs = minsegs DCNL DCSP if (minsegs > maxsegs): DCNL DCSP  DCSP raise ValueError(('minsegs DCSP > DCSP maxsegs: DCSP %d DCSP > DCSP %d' % (minsegs, maxsegs))) DCNL DCSP if rest_with_last: DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > maxsegs) or ('' in segs[1:minsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP path: DCSP %s' % quote(path))) DCNL DCSP else: DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > (maxsegs + 1)) or ('' in segs[1:minsegs]) or ((count == (maxsegs + 1)) and segs[maxsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP path: DCSP %s' % quote(path))) DCNL DCSP segs = segs[1:maxsegs] DCNL DCSP segs.extend(([None] * ((maxsegs - 1) - len(segs)))) DCNL DCSP return segs
def validate_device_partition(device, partition): DCNL  DCSP invalid_device = False DCNL DCSP invalid_partition = False DCNL DCSP if ((not device) or ('/' in device) or (device in ['.', '..'])): DCNL DCSP  DCSP invalid_device = True DCNL DCSP if ((not partition) or ('/' in partition) or (partition in ['.', '..'])): DCNL DCSP  DCSP invalid_partition = True DCNL DCSP if invalid_device: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP device: DCSP %s' % quote((device or '')))) DCNL DCSP elif invalid_partition: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP partition: DCSP %s' % quote((partition or ''))))
def timing_stats(**dec_kwargs): DCNL  DCSP def decorating_func(func): DCNL DCSP  DCSP method = func.func_name DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _timing_stats(ctrl, *args, **kwargs): DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP resp = func(ctrl, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (is_success(resp.status_int) or is_redirection(resp.status_int) or (resp.status_int == HTTP_NOT_FOUND)): DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.errors.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP return _timing_stats DCNL DCSP return decorating_func
def get_logger(conf, name=None, log_to_console=False, log_route=None, fmt='%(server)s DCSP %(message)s'): DCNL  DCSP if (not conf): DCNL DCSP  DCSP conf = {} DCNL DCSP if (name is None): DCNL DCSP  DCSP name = conf.get('log_name', 'swift') DCNL DCSP if (not log_route): DCNL DCSP  DCSP log_route = name DCNL DCSP logger = logging.getLogger(log_route) DCNL DCSP logger.propagate = False DCNL DCSP formatter = SwiftLogFormatter(fmt) DCNL DCSP if (not hasattr(get_logger, 'handler4logger')): DCNL DCSP  DCSP get_logger.handler4logger = {} DCNL DCSP if (logger in get_logger.handler4logger): DCNL DCSP  DCSP logger.removeHandler(get_logger.handler4logger[logger]) DCNL DCSP facility = getattr(SysLogHandler, conf.get('log_facility', 'LOG_LOCAL0'), SysLogHandler.LOG_LOCAL0) DCNL DCSP udp_host = conf.get('log_udp_host') DCNL DCSP if udp_host: DCNL DCSP  DCSP udp_port = int(conf.get('log_udp_port', logging.handlers.SYSLOG_UDP_PORT)) DCNL DCSP  DCSP handler = SysLogHandler(address=(udp_host, udp_port), facility=facility) DCNL DCSP else: DCNL DCSP  DCSP log_address = conf.get('log_address', '/dev/log') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP handler = SysLogHandler(address=log_address, facility=facility) DCNL DCSP  DCSP except socket.error as e: DCNL DCSP  DCSP  DCSP if (e.errno not in [errno.ENOTSOCK, errno.ENOENT]): DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP handler = SysLogHandler(facility=facility) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP logger.addHandler(handler) DCNL DCSP get_logger.handler4logger[logger] = handler DCNL DCSP if (log_to_console or hasattr(get_logger, 'console_handler4logger')): DCNL DCSP  DCSP if (not hasattr(get_logger, 'console_handler4logger')): DCNL DCSP  DCSP  DCSP get_logger.console_handler4logger = {} DCNL DCSP  DCSP if (logger in get_logger.console_handler4logger): DCNL DCSP  DCSP  DCSP logger.removeHandler(get_logger.console_handler4logger[logger]) DCNL DCSP  DCSP console_handler = logging.StreamHandler(sys.__stderr__) DCNL DCSP  DCSP console_handler.setFormatter(formatter) DCNL DCSP  DCSP logger.addHandler(console_handler) DCNL DCSP  DCSP get_logger.console_handler4logger[logger] = console_handler DCNL DCSP logger.setLevel(getattr(logging, conf.get('log_level', 'INFO').upper(), logging.INFO)) DCNL DCSP statsd_host = conf.get('log_statsd_host') DCNL DCSP if statsd_host: DCNL DCSP  DCSP statsd_port = int(conf.get('log_statsd_port', 8125)) DCNL DCSP  DCSP base_prefix = conf.get('log_statsd_metric_prefix', '') DCNL DCSP  DCSP default_sample_rate = float(conf.get('log_statsd_default_sample_rate', 1)) DCNL DCSP  DCSP sample_rate_factor = float(conf.get('log_statsd_sample_rate_factor', 1)) DCNL DCSP  DCSP statsd_client = StatsdClient(statsd_host, statsd_port, base_prefix, name, default_sample_rate, sample_rate_factor) DCNL DCSP  DCSP logger.statsd_client = statsd_client DCNL DCSP else: DCNL DCSP  DCSP logger.statsd_client = None DCNL DCSP adapted_logger = LogAdapter(logger, name) DCNL DCSP other_handlers = conf.get('log_custom_handlers', None) DCNL DCSP if other_handlers: DCNL DCSP  DCSP log_custom_handlers = [s.strip() for s in other_handlers.split(',') if s.strip()] DCNL DCSP  DCSP for hook in log_custom_handlers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (mod, fnc) = hook.rsplit('.', 1) DCNL DCSP  DCSP  DCSP  DCSP logger_hook = getattr(__import__(mod, fromlist=[fnc]), fnc) DCNL DCSP  DCSP  DCSP  DCSP logger_hook(conf, name, log_to_console, log_route, fmt, logger, adapted_logger) DCNL DCSP  DCSP  DCSP except (AttributeError, ImportError): DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ('Error DCSP calling DCSP custom DCSP handler DCSP [%s]' % hook) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ('Invalid DCSP custom DCSP handler DCSP format DCSP [%s]' % hook) DCNL DCSP return adapted_logger
def get_hub(): DCNL  DCSP try: DCNL DCSP  DCSP import select DCNL DCSP  DCSP if hasattr(select, 'poll'): DCNL DCSP  DCSP  DCSP return 'poll' DCNL DCSP  DCSP return 'selects' DCNL DCSP except ImportError: DCNL DCSP  DCSP return None
def drop_privileges(user): DCNL  DCSP user = pwd.getpwnam(user) DCNL DCSP if (os.geteuid() == 0): DCNL DCSP  DCSP os.setgroups([]) DCNL DCSP os.setgid(user[3]) DCNL DCSP os.setuid(user[2]) DCNL DCSP os.environ['HOME'] = user[5] DCNL DCSP try: DCNL DCSP  DCSP os.setsid() DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP os.chdir('/') DCNL DCSP os.umask(18)
def capture_stdio(logger, **kwargs): DCNL  DCSP sys.excepthook = (lambda *exc_info: logger.critical(_('UNCAUGHT DCSP EXCEPTION'), exc_info=exc_info)) DCNL DCSP stdio_files = [sys.stdin, sys.stdout, sys.stderr] DCNL DCSP console_fds = [h.stream.fileno() for (_junk, h) in getattr(get_logger, 'console_handler4logger', {}).items()] DCNL DCSP stdio_files = [f for f in stdio_files if (f.fileno() not in console_fds)] DCNL DCSP with open(os.devnull, 'r+b') as nullfile: DCNL DCSP  DCSP for f in stdio_files: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f.flush() DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.dup2(nullfile.fileno(), f.fileno()) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if kwargs.pop('capture_stdout', True): DCNL DCSP  DCSP sys.stdout = LoggerFileObject(logger) DCNL DCSP if kwargs.pop('capture_stderr', True): DCNL DCSP  DCSP sys.stderr = LoggerFileObject(logger)
def parse_options(parser=None, once=False, test_args=None): DCNL  DCSP if (not parser): DCNL DCSP  DCSP parser = OptionParser(usage='%prog DCSP CONFIG DCSP [options]') DCNL DCSP parser.add_option('-v', '--verbose', default=False, action='store_true', help='log DCSP to DCSP console') DCNL DCSP if once: DCNL DCSP  DCSP parser.add_option('-o', '--once', default=False, action='store_true', help='only DCSP run DCSP one DCSP pass DCSP of DCSP daemon') DCNL DCSP (options, args) = parser.parse_args(args=test_args) DCNL DCSP if (not args): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print _('Error: DCSP missing DCSP config DCSP file DCSP argument') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP config = os.path.abspath(args.pop(0)) DCNL DCSP if (not os.path.exists(config)): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print (_('Error: DCSP unable DCSP to DCSP locate DCSP %s') % config) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP extra_args = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP if (arg in options.__dict__): DCNL DCSP  DCSP  DCSP setattr(options, arg, True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra_args.append(arg) DCNL DCSP options = vars(options) DCNL DCSP if extra_args: DCNL DCSP  DCSP options['extra_args'] = extra_args DCNL DCSP return (config, options)
def whataremyips(): DCNL  DCSP addresses = [] DCNL DCSP for interface in netifaces.interfaces(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iface_data = netifaces.ifaddresses(interface) DCNL DCSP  DCSP  DCSP for family in iface_data: DCNL DCSP  DCSP  DCSP  DCSP if (family not in (netifaces.AF_INET, netifaces.AF_INET6)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP for address in iface_data[family]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP addresses.append(address['addr']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return addresses
def storage_directory(datadir, partition, hash): DCNL  DCSP return os.path.join(datadir, str(partition), hash[(-3):], hash)
def hash_path(account, container=None, object=None, raw_digest=False): DCNL  DCSP if (object and (not container)): DCNL DCSP  DCSP raise ValueError('container DCSP is DCSP required DCSP if DCSP object DCSP is DCSP provided') DCNL DCSP paths = [account] DCNL DCSP if container: DCNL DCSP  DCSP paths.append(container) DCNL DCSP if object: DCNL DCSP  DCSP paths.append(object) DCNL DCSP if raw_digest: DCNL DCSP  DCSP return md5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).digest() DCNL DCSP else: DCNL DCSP  DCSP return md5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).hexdigest()
@contextmanager DCNL def lock_path(directory, timeout=10): DCNL  DCSP mkdirs(directory) DCNL DCSP lockpath = ('%s/.lock' % directory) DCNL DCSP fd = os.open(lockpath, (os.O_WRONLY | os.O_CREAT)) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, lockpath): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fd, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yield True) DCNL DCSP finally: DCNL DCSP  DCSP os.close(fd)
@contextmanager DCNL def lock_file(filename, timeout=10, append=False, unlink=True): DCNL  DCSP flags = (os.O_CREAT | os.O_RDWR) DCNL DCSP if append: DCNL DCSP  DCSP flags |= os.O_APPEND DCNL DCSP  DCSP mode = 'a+' DCNL DCSP else: DCNL DCSP  DCSP mode = 'r+' DCNL DCSP fd = os.open(filename, flags) DCNL DCSP file_obj = os.fdopen(fd, mode) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, filename): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fd, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yield file_obj) DCNL DCSP finally: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file_obj.close() DCNL DCSP  DCSP except UnboundLocalError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if unlink: DCNL DCSP  DCSP  DCSP os.unlink(filename)
def lock_parent_directory(filename, timeout=10): DCNL  DCSP return lock_path(os.path.dirname(filename), timeout=timeout)
def get_time_units(time_amount): DCNL  DCSP time_unit = 's' DCNL DCSP if (time_amount > 60): DCNL DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP time_unit = 'm' DCNL DCSP  DCSP if (time_amount > 60): DCNL DCSP  DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP  DCSP time_unit = 'h' DCNL DCSP return (time_amount, time_unit)
def compute_eta(start_time, current_value, final_value): DCNL  DCSP elapsed = (time.time() - start_time) DCNL DCSP completion = ((float(current_value) / final_value) or 1e-05) DCNL DCSP return get_time_units((((1.0 / completion) * elapsed) - elapsed))
def iter_devices_partitions(devices_dir, item_type): DCNL  DCSP devices = listdir(devices_dir) DCNL DCSP shuffle(devices) DCNL DCSP devices_partitions = [] DCNL DCSP for device in devices: DCNL DCSP  DCSP partitions = listdir(os.path.join(devices_dir, device, item_type)) DCNL DCSP  DCSP shuffle(partitions) DCNL DCSP  DCSP devices_partitions.append((device, iter(partitions))) DCNL DCSP yielded = True DCNL DCSP while yielded: DCNL DCSP  DCSP yielded = False DCNL DCSP  DCSP for (device, partitions) in devices_partitions: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yield (device, partitions.next())) DCNL DCSP  DCSP  DCSP  DCSP yielded = True DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP pass
def unlink_older_than(path, mtime): DCNL  DCSP if os.path.exists(path): DCNL DCSP  DCSP for fname in listdir(path): DCNL DCSP  DCSP  DCSP fpath = os.path.join(path, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (os.path.getmtime(fpath) < mtime): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(fpath) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass
def item_from_env(env, item_name): DCNL  DCSP item = env.get(item_name, None) DCNL DCSP if (item is None): DCNL DCSP  DCSP logging.error(('ERROR: DCSP %s DCSP could DCSP not DCSP be DCSP found DCSP in DCSP env!' % item_name)) DCNL DCSP return item
def cache_from_env(env): DCNL  DCSP return item_from_env(env, 'swift.cache')
def readconf(conffile, section_name=None, log_name=None, defaults=None, raw=False): DCNL  DCSP if (defaults is None): DCNL DCSP  DCSP defaults = {} DCNL DCSP if raw: DCNL DCSP  DCSP c = RawConfigParser(defaults) DCNL DCSP else: DCNL DCSP  DCSP c = ConfigParser(defaults) DCNL DCSP if hasattr(conffile, 'readline'): DCNL DCSP  DCSP c.readfp(conffile) DCNL DCSP elif (not c.read(conffile)): DCNL DCSP  DCSP print (_('Unable DCSP to DCSP read DCSP config DCSP file DCSP %s') % conffile) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if section_name: DCNL DCSP  DCSP if c.has_section(section_name): DCNL DCSP  DCSP  DCSP conf = dict(c.items(section_name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print (_('Unable DCSP to DCSP find DCSP %s DCSP config DCSP section DCSP in DCSP %s') % (section_name, conffile)) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP if (log_name is not None): DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = section_name DCNL DCSP else: DCNL DCSP  DCSP conf = {} DCNL DCSP  DCSP for s in c.sections(): DCNL DCSP  DCSP  DCSP conf.update({s: dict(c.items(s))}) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP conf['__file__'] = conffile DCNL DCSP return conf
def write_pickle(obj, dest, tmp=None, pickle_protocol=0): DCNL  DCSP if (tmp is None): DCNL DCSP  DCSP tmp = os.path.dirname(dest) DCNL DCSP (fd, tmppath) = mkstemp(dir=tmp, suffix='.tmp') DCNL DCSP with os.fdopen(fd, 'wb') as fo: DCNL DCSP  DCSP pickle.dump(obj, fo, pickle_protocol) DCNL DCSP  DCSP fo.flush() DCNL DCSP  DCSP os.fsync(fd) DCNL DCSP  DCSP renamer(tmppath, dest)
def search_tree(root, glob_match, ext): DCNL  DCSP found_files = [] DCNL DCSP for path in glob.glob(os.path.join(root, glob_match)): DCNL DCSP  DCSP if path.endswith(ext): DCNL DCSP  DCSP  DCSP found_files.append(path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (root, dirs, files) in os.walk(path): DCNL DCSP  DCSP  DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if file.endswith(ext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found_files.append(os.path.join(root, file)) DCNL DCSP return sorted(found_files)
def write_file(path, contents): DCNL  DCSP (dirname, name) = os.path.split(path) DCNL DCSP if (not os.path.exists(dirname)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(dirname) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.EACCES): DCNL DCSP  DCSP  DCSP  DCSP sys.exit(('Unable DCSP to DCSP create DCSP %s. DCSP  DCSP Running DCSP as DCSP non-root?' % dirname)) DCNL DCSP with open(path, 'w') as f: DCNL DCSP  DCSP f.write(('%s' % contents))
def remove_file(path): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass
def audit_location_generator(devices, datadir, mount_check=True, logger=None): DCNL  DCSP device_dir = listdir(devices) DCNL DCSP shuffle(device_dir) DCNL DCSP for device in device_dir: DCNL DCSP  DCSP if (mount_check and (not os.path.ismount(os.path.join(devices, device)))): DCNL DCSP  DCSP  DCSP if logger: DCNL DCSP  DCSP  DCSP  DCSP logger.debug(_('Skipping DCSP %s DCSP as DCSP it DCSP is DCSP not DCSP mounted'), device) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP datadir_path = os.path.join(devices, device, datadir) DCNL DCSP  DCSP if (not os.path.exists(datadir_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP partitions = listdir(datadir_path) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_path = os.path.join(datadir_path, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isdir(part_path)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = listdir(part_path) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_path = os.path.join(part_path, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(suff_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = listdir(suff_path) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_path = os.path.join(suff_path, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(hash_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fname in sorted(listdir(hash_path), reverse=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP path = os.path.join(hash_path, fname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield (path, device, partition))
def ratelimit_sleep(running_time, max_rate, incr_by=1, rate_buffer=5): DCNL  DCSP if ((not max_rate) or (incr_by <= 0)): DCNL DCSP  DCSP return running_time DCNL DCSP clock_accuracy = 1000.0 DCNL DCSP now = (time.time() * clock_accuracy) DCNL DCSP time_per_request = (clock_accuracy * (float(incr_by) / max_rate)) DCNL DCSP if ((now - running_time) > (rate_buffer * clock_accuracy)): DCNL DCSP  DCSP running_time = now DCNL DCSP elif ((running_time - now) > time_per_request): DCNL DCSP  DCSP eventlet.sleep(((running_time - now) / clock_accuracy)) DCNL DCSP return (running_time + time_per_request)
def urlparse(url): DCNL  DCSP return ModifiedParseResult(*stdlib_urlparse(url))
def human_readable(value): DCNL  DCSP value = float(value) DCNL DCSP index = (-1) DCNL DCSP suffixes = 'KMGTPEZY' DCNL DCSP while ((value >= 1024) and ((index + 1) < len(suffixes))): DCNL DCSP  DCSP index += 1 DCNL DCSP  DCSP value = round((value / 1024)) DCNL DCSP if (index == (-1)): DCNL DCSP  DCSP return ('%d' % value) DCNL DCSP return ('%d%si' % (round(value), suffixes[index]))
def dump_recon_cache(cache_dict, cache_file, logger, lock_timeout=2): DCNL  DCSP try: DCNL DCSP  DCSP with lock_file(cache_file, lock_timeout, unlink=False) as cf: DCNL DCSP  DCSP  DCSP cache_entry = {} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP existing_entry = cf.readline() DCNL DCSP  DCSP  DCSP  DCSP if existing_entry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cache_entry = json.loads(existing_entry) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (cache_key, cache_value) in cache_dict.items(): DCNL DCSP  DCSP  DCSP  DCSP cache_entry[cache_key] = cache_value DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with NamedTemporaryFile(dir=os.path.dirname(cache_file), delete=False) as tf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tf.write((json.dumps(cache_entry) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP os.rename(tf.name, cache_file) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(tf.name) DCNL DCSP  DCSP  DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP except (Exception, Timeout): DCNL DCSP  DCSP logger.exception(_('Exception DCSP dumping DCSP recon DCSP cache'))
def streq_const_time(s1, s2): DCNL  DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
def public(func): DCNL  DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
def rsync_ip(ip): DCNL  DCSP try: DCNL DCSP  DCSP socket.inet_pton(socket.AF_INET6, ip) DCNL DCSP except socket.error: DCNL DCSP  DCSP return ip DCNL DCSP else: DCNL DCSP  DCSP return ('[%s]' % ip)
def get_valid_utf8_str(str_or_unicode): DCNL  DCSP if isinstance(str_or_unicode, unicode): DCNL DCSP  DCSP (str_or_unicode, _len) = utf8_encoder(str_or_unicode, 'replace') DCNL DCSP (valid_utf8_str, _len) = utf8_decoder(str_or_unicode, 'replace') DCNL DCSP return valid_utf8_str.encode('utf-8')
def list_from_csv(comma_separated_str): DCNL  DCSP if comma_separated_str: DCNL DCSP  DCSP return [v.strip() for v in comma_separated_str.split(',') if v.strip()] DCNL DCSP return []
def csv_append(csv_string, item): DCNL  DCSP if csv_string: DCNL DCSP  DCSP return ','.join((csv_string, item)) DCNL DCSP else: DCNL DCSP  DCSP return item
def reiterate(iterable): DCNL  DCSP if isinstance(iterable, (list, tuple)): DCNL DCSP  DCSP return iterable DCNL DCSP else: DCNL DCSP  DCSP iterator = iter(iterable) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chunk = '' DCNL DCSP  DCSP  DCSP while (not chunk): DCNL DCSP  DCSP  DCSP  DCSP chunk = next(iterator) DCNL DCSP  DCSP  DCSP return itertools.chain([chunk], iterator) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return []
def lookup_cname(domain): DCNL  DCSP try: DCNL DCSP  DCSP answer = dns.resolver.query(domain, 'CNAME').rrset DCNL DCSP  DCSP ttl = answer.ttl DCNL DCSP  DCSP result = answer.items[0].to_text() DCNL DCSP  DCSP result = result.rstrip('.') DCNL DCSP  DCSP return (ttl, result) DCNL DCSP except (DNSException, NXDOMAIN, NoAnswer): DCNL DCSP  DCSP return (0, None)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return TempAuth(app, conf) DCNL DCSP return auth_filter
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return KeystoneAuth(app, conf) DCNL DCSP return auth_filter
def filter_factory(global_conf, **local_conf): DCNL  DCSP def account_quota_filter(app): DCNL DCSP  DCSP return AccountQuotaMiddleware(app) DCNL DCSP return account_quota_filter
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return (lambda app: TempURL(app, conf))
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def limit_filter(app): DCNL DCSP  DCSP return RateLimitMiddleware(app, conf) DCNL DCSP return limit_filter
def quote(value, safe='/'): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP value = value.encode('utf-8') DCNL DCSP return urllib_quote(value, safe)
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def staticweb_filter(app): DCNL DCSP  DCSP return StaticWeb(app, conf) DCNL DCSP return staticweb_filter
def parse_input(raw_data): DCNL  DCSP try: DCNL DCSP  DCSP parsed_data = json.loads(raw_data) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPBadRequest('Manifest DCSP must DCSP be DCSP valid DCSP json.') DCNL DCSP req_keys = set(['path', 'etag', 'size_bytes']) DCNL DCSP try: DCNL DCSP  DCSP for seg_dict in parsed_data: DCNL DCSP  DCSP  DCSP if ((set(seg_dict.keys()) != req_keys) or ('/' not in seg_dict['path'].lstrip('/'))): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPBadRequest('Invalid DCSP SLO DCSP Manifest DCSP File') DCNL DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP raise HTTPBadRequest('Invalid DCSP SLO DCSP Manifest DCSP File') DCNL DCSP return parsed_data
def _parse_attrs(header): DCNL  DCSP attributes = {} DCNL DCSP attrs = '' DCNL DCSP if ('; DCSP ' in header): DCNL DCSP  DCSP (header, attrs) = header.split('; DCSP ', 1) DCNL DCSP m = True DCNL DCSP while m: DCNL DCSP  DCSP m = ATTRIBUTES_RE.match(attrs) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP attrs = attrs[len(m.group(0)):] DCNL DCSP  DCSP  DCSP attributes[m.group(1)] = m.group(2).strip('"') DCNL DCSP return (header, attributes)
def _iter_requests(wsgi_input, boundary): DCNL  DCSP boundary = ('--' + boundary) DCNL DCSP if (wsgi_input.readline().strip() != boundary): DCNL DCSP  DCSP raise FormInvalid('invalid DCSP starting DCSP boundary') DCNL DCSP boundary = ('\r\n' + boundary) DCNL DCSP input_buffer = '' DCNL DCSP done = False DCNL DCSP while (not done): DCNL DCSP  DCSP it = _IterRequestsFileLikeObject(wsgi_input, boundary, input_buffer) DCNL DCSP  DCSP (yield it) DCNL DCSP  DCSP done = it.no_more_files DCNL DCSP  DCSP input_buffer = it.input_buffer
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return (lambda app: FormPost(app, conf))
def clean_acl(name, value): DCNL  DCSP name = name.lower() DCNL DCSP values = [] DCNL DCSP for raw_value in value.split(','): DCNL DCSP  DCSP raw_value = raw_value.strip() DCNL DCSP  DCSP if raw_value: DCNL DCSP  DCSP  DCSP if (':' not in raw_value): DCNL DCSP  DCSP  DCSP  DCSP values.append(raw_value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (first, second) = (v.strip() for v in raw_value.split(':', 1)) DCNL DCSP  DCSP  DCSP  DCSP if ((not first) or (first[0] != '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.append(raw_value) DCNL DCSP  DCSP  DCSP  DCSP elif (first in ('.r', '.ref', '.referer', '.referrer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('write' in name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Referrers DCSP not DCSP allowed DCSP in DCSP write DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP negate = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (second and (second[0] == '-')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP negate = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP second = second[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (second and (second != '*') and (second[0] == '*')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP second = second[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not second) or (second == '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP host/domain DCSP value DCSP after DCSP referrer DCSP designation DCSP in DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.append(('.r:%s%s' % (((negate and '-') or ''), second))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP designator DCSP %s DCSP in DCSP ACL: DCSP %s' % (repr(first), repr(raw_value)))) DCNL DCSP return ','.join(values)
def parse_acl(acl_string): DCNL  DCSP referrers = [] DCNL DCSP groups = [] DCNL DCSP if acl_string: DCNL DCSP  DCSP for value in acl_string.split(','): DCNL DCSP  DCSP  DCSP if value.startswith('.r:'): DCNL DCSP  DCSP  DCSP  DCSP referrers.append(value[len('.r:'):]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups.append(value) DCNL DCSP return (referrers, groups)
def referrer_allowed(referrer, referrer_acl): DCNL  DCSP allow = False DCNL DCSP if referrer_acl: DCNL DCSP  DCSP rhost = (urlparse((referrer or '')).hostname or 'unknown') DCNL DCSP  DCSP for mhost in referrer_acl: DCNL DCSP  DCSP  DCSP if (mhost[0] == '-'): DCNL DCSP  DCSP  DCSP  DCSP mhost = mhost[1:] DCNL DCSP  DCSP  DCSP  DCSP if ((mhost == rhost) or ((mhost[0] == '.') and rhost.endswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allow = False DCNL DCSP  DCSP  DCSP elif ((mhost == '*') or (mhost == rhost) or ((mhost[0] == '.') and rhost.endswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP allow = True DCNL DCSP return allow
def get_response_body(data_format, data_dict, error_list): DCNL  DCSP if (data_format == 'text/plain'): DCNL DCSP  DCSP output = '' DCNL DCSP  DCSP for key in sorted(data_dict.keys()): DCNL DCSP  DCSP  DCSP output += ('%s: DCSP %s\n' % (key, data_dict[key])) DCNL DCSP  DCSP output += 'Errors:\n' DCNL DCSP  DCSP output += '\n'.join([('%s, DCSP %s' % (name, status)) for (name, status) in error_list]) DCNL DCSP  DCSP return output DCNL DCSP if (data_format == 'application/json'): DCNL DCSP  DCSP data_dict['Errors'] = error_list DCNL DCSP  DCSP return json.dumps(data_dict) DCNL DCSP if data_format.endswith('/xml'): DCNL DCSP  DCSP output = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>\n<delete>\n' DCNL DCSP  DCSP for key in sorted(data_dict.keys()): DCNL DCSP  DCSP  DCSP xml_key = key.replace(' DCSP ', '_').lower() DCNL DCSP  DCSP  DCSP output += ('<%s>%s</%s>\n' % (xml_key, data_dict[key], xml_key)) DCNL DCSP  DCSP output += '<errors>\n' DCNL DCSP  DCSP output += '\n'.join([('<object><name>%s</name><status>%s</status></object>' % (saxutils.escape(name), status)) for (name, status) in error_list]) DCNL DCSP  DCSP output += '</errors>\n</delete>\n' DCNL DCSP  DCSP return output DCNL DCSP raise HTTPNotAcceptable('Invalid DCSP output DCSP type')
def setup_env(): DCNL  DCSP try: DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_NOFILE, (MAX_DESCRIPTORS, MAX_DESCRIPTORS)) DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_DATA, (MAX_MEMORY, MAX_MEMORY)) DCNL DCSP except ValueError: DCNL DCSP  DCSP print _('WARNING: DCSP Unable DCSP to DCSP increase DCSP file DCSP descriptor DCSP limit. DCSP  DCSP Running DCSP as DCSP non-root?') DCNL DCSP os.environ['PYTHON_EGG_CACHE'] = '/tmp'
def command(func): DCNL  DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP rv = func(*a, **kw) DCNL DCSP  DCSP return (1 if rv else 0) DCNL DCSP return wrapped
def watch_server_pids(server_pids, interval=1, **kwargs): DCNL  DCSP status = {} DCNL DCSP start = time.time() DCNL DCSP end = (start + interval) DCNL DCSP server_pids = dict(server_pids) DCNL DCSP while True: DCNL DCSP  DCSP for (server, pids) in server_pids.items(): DCNL DCSP  DCSP  DCSP for pid in pids: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.waitpid(pid, os.WNOHANG) DCNL DCSP  DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.errno not in (errno.ECHILD, errno.ESRCH)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP status[server] = server.get_running_pids(**kwargs) DCNL DCSP  DCSP  DCSP for pid in pids: DCNL DCSP  DCSP  DCSP  DCSP if (pid not in status[server]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (server, pid)) DCNL DCSP  DCSP  DCSP server_pids[server] = status[server] DCNL DCSP  DCSP if (not [p for (server, pids) in status.items() for p in pids]): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (time.time() > end): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(0.1)
def _datetime_property(header): DCNL  DCSP def getter(self): DCNL DCSP  DCSP value = self.headers.get(header, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parts = parsedate(self.headers[header])[:7] DCNL DCSP  DCSP  DCSP  DCSP date = datetime(*(parts + (UTC,))) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP if (date.year < 1970): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Somehow DCSP an DCSP invalid DCSP year') DCNL DCSP  DCSP  DCSP return date DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (float, int, long)): DCNL DCSP  DCSP  DCSP self.headers[header] = time.strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT', time.gmtime(value)) DCNL DCSP  DCSP elif isinstance(value, datetime): DCNL DCSP  DCSP  DCSP self.headers[header] = value.strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header DCSP as DCSP a DCSP datetime, DCSP set DCSP it DCSP with DCSP a DCSP datetime, DCSP int, DCSP or DCSP str' % header))
def _header_property(header): DCNL  DCSP def getter(self): DCNL DCSP  DCSP return self.headers.get(header, None) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header' % header))
def _header_int_property(header): DCNL  DCSP def getter(self): DCNL DCSP  DCSP val = self.headers.get(header, None) DCNL DCSP  DCSP if (val is not None): DCNL DCSP  DCSP  DCSP val = int(val) DCNL DCSP  DCSP return val DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header DCSP as DCSP an DCSP int' % header))
def _resp_status_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP return ('%s DCSP %s' % (self.status_int, self.title)) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (int, long)): DCNL DCSP  DCSP  DCSP self.status_int = value DCNL DCSP  DCSP  DCSP self.explanation = self.title = RESPONSE_REASONS[value][0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP  DCSP value = value.encode('utf-8') DCNL DCSP  DCSP  DCSP self.status_int = int(value.split(' DCSP ', 1)[0]) DCNL DCSP  DCSP  DCSP self.explanation = self.title = value.split(' DCSP ', 1)[1] DCNL DCSP return property(getter, setter, doc="Retrieve DCSP and DCSP set DCSP the DCSP Response DCSP status, DCSP e.g. DCSP '200 DCSP OK'")
def _resp_body_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP if (not self._body): DCNL DCSP  DCSP  DCSP if (not self._app_iter): DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP self._body = ''.join(self._app_iter) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP return self._body DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP value = value.encode('utf-8') DCNL DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP self.content_length = len(value) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP self._body = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP Response DCSP body DCSP str')
def _resp_etag_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP etag = self.headers.get('etag', None) DCNL DCSP  DCSP if etag: DCNL DCSP  DCSP  DCSP etag = etag.replace('"', '') DCNL DCSP  DCSP return etag DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP self.headers['etag'] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.headers['etag'] = ('"%s"' % value) DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP Etag DCSP header')
def _resp_content_type_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP if ('content-type' in self.headers): DCNL DCSP  DCSP  DCSP return self.headers.get('content-type').split(';')[0] DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers['content-type'] = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP Content-Type DCSP header')
def _resp_charset_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP if ('; DCSP charset=' in self.headers['content-type']): DCNL DCSP  DCSP  DCSP return self.headers['content-type'].split('; DCSP charset=')[1] DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if ('content-type' in self.headers): DCNL DCSP  DCSP  DCSP self.headers['content-type'] = self.headers['content-type'].split(';')[0] DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP self.headers['content-type'] += ('; DCSP charset=' + value) DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP charset')
def _resp_app_iter_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP return self._app_iter DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP self.content_length = sum(map(len, value)) DCNL DCSP  DCSP elif (value is not None): DCNL DCSP  DCSP  DCSP self.content_length = None DCNL DCSP  DCSP  DCSP self._body = None DCNL DCSP  DCSP self._app_iter = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP app_iter')
def _req_fancy_property(cls, header, even_if_nonexistent=False): DCNL  DCSP def getter(self): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((header in self.headers) or even_if_nonexistent): DCNL DCSP  DCSP  DCSP  DCSP return cls(self.headers.get(header)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environ, DCSP as DCSP a DCSP %s DCSP object' % (header, cls.__name__)))
def _req_environ_property(environ_field): DCNL  DCSP def getter(self): DCNL DCSP  DCSP return self.environ.get(environ_field, None) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP self.environ[environ_field] = value.encode('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.environ[environ_field] = value DCNL DCSP return property(getter, setter, doc=('Get DCSP and DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environment' % environ_field))
def _req_body_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP body = self.environ['wsgi.input'].read() DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(body) DCNL DCSP  DCSP return body DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(value) DCNL DCSP  DCSP self.environ['CONTENT_LENGTH'] = str(len(value)) DCNL DCSP return property(getter, setter, doc='Get DCSP and DCSP set DCSP the DCSP request DCSP body DCSP str')
def _host_url_property(): DCNL  DCSP def getter(self): DCNL DCSP  DCSP if ('HTTP_HOST' in self.environ): DCNL DCSP  DCSP  DCSP host = self.environ['HTTP_HOST'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP host = ('%s:%s' % (self.environ['SERVER_NAME'], self.environ['SERVER_PORT'])) DCNL DCSP  DCSP scheme = self.environ.get('wsgi.url_scheme', 'http') DCNL DCSP  DCSP if ((scheme == 'http') and host.endswith(':80')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP elif ((scheme == 'https') and host.endswith(':443')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP return ('%s://%s' % (scheme, host)) DCNL DCSP return property(getter, doc='Get DCSP url DCSP for DCSP request/response DCSP up DCSP to DCSP path')
def wsgify(func): DCNL  DCSP argspec = inspect.getargspec(func) DCNL DCSP if (argspec.args and (argspec.args[0] == 'self')): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _wsgify_self(self, env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, Request(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_self DCNL DCSP else: DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _wsgify_bare(env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(Request(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_bare
def tiers_for_dev(dev): DCNL  DCSP t1 = dev['region'] DCNL DCSP t2 = dev['zone'] DCNL DCSP t3 = '{ip}:{port}'.format(ip=dev.get('ip'), port=dev.get('port')) DCNL DCSP t4 = dev['id'] DCNL DCSP return ((t1,), (t1, t2), (t1, t2, t3), (t1, t2, t3, t4))
def build_tier_tree(devices): DCNL  DCSP tier2children = defaultdict(set) DCNL DCSP for dev in devices: DCNL DCSP  DCSP for tier in tiers_for_dev(dev): DCNL DCSP  DCSP  DCSP if (len(tier) > 1): DCNL DCSP  DCSP  DCSP  DCSP tier2children[tier[0:(-1)]].add(tier) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tier2children[()].add(tier) DCNL DCSP return tier2children
def sanitize_timeout(timeout): DCNL  DCSP if (timeout > (((30 * 24) * 60) * 60)): DCNL DCSP  DCSP timeout += time.time() DCNL DCSP return timeout
def quarantine_db(object_file, server_type): DCNL  DCSP object_dir = os.path.dirname(object_file) DCNL DCSP quarantine_dir = os.path.abspath(os.path.join(object_dir, '..', '..', '..', '..', 'quarantined', (server_type + 's'), os.path.basename(object_dir))) DCNL DCSP try: DCNL DCSP  DCSP renamer(object_dir, quarantine_dir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP quarantine_dir = ('%s-%s' % (quarantine_dir, uuid.uuid4().hex)) DCNL DCSP  DCSP renamer(object_dir, quarantine_dir)
def roundrobin_datadirs(datadirs): DCNL  DCSP def walk_datadir(datadir, node_id): DCNL DCSP  DCSP partitions = os.listdir(datadir) DCNL DCSP  DCSP random.shuffle(partitions) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_dir = os.path.join(datadir, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isdir(part_dir)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = os.listdir(part_dir) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_dir = os.path.join(part_dir, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(suff_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = os.listdir(suff_dir) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_dir = os.path.join(suff_dir, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(hash_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP object_file = os.path.join(hash_dir, (hsh + '.db')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(object_file): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield (partition, object_file, node_id)) DCNL DCSP its = [walk_datadir(datadir, node_id) for (datadir, node_id) in datadirs] DCNL DCSP while its: DCNL DCSP  DCSP for it in its: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yield it.next()) DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP its.remove(it)
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False): DCNL  DCSP if isinstance(path, unicode): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP path = path.encode('utf-8') DCNL DCSP  DCSP except UnicodeError as e: DCNL DCSP  DCSP  DCSP logging.exception(_('Error DCSP encoding DCSP to DCSP UTF-8: DCSP %s'), e.message) DCNL DCSP path = quote((((('/' + device) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaddr, port, method, path, headers, query_string, ssl)
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False): DCNL  DCSP if (not port): DCNL DCSP  DCSP port = (443 if ssl else 80) DCNL DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP else: DCNL DCSP  DCSP conn = BufferedHTTPConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP if query_string: DCNL DCSP  DCSP path += ('?' + query_string) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest(method, path, skip_host=(headers and ('Host' in headers))) DCNL DCSP if headers: DCNL DCSP  DCSP for (header, value) in headers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheader(header, str(value)) DCNL DCSP conn.endheaders() DCNL DCSP return conn
def run_daemon(klass, conf_file, section_name='', once=False, **kwargs): DCNL  DCSP if (section_name is ''): DCNL DCSP  DCSP section_name = sub('([a-z])([A-Z])', '\\1-\\2', klass.__name__).lower() DCNL DCSP conf = utils.readconf(conf_file, section_name, log_name=kwargs.get('log_name')) DCNL DCSP once = (once or (not utils.config_true_value(conf.get('daemonize', 'true')))) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = utils.get_logger(conf, conf.get('log_name', section_name), log_to_console=kwargs.pop('verbose', False), log_route=section_name) DCNL DCSP if utils.config_true_value(conf.get('disable_fallocate', 'no')): DCNL DCSP  DCSP utils.disable_fallocate() DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP eventlet_debug = utils.config_true_value(conf.get('eventlet_debug', 'no')) DCNL DCSP eventlet.debug.hub_exceptions(eventlet_debug) DCNL DCSP try: DCNL DCSP  DCSP klass(conf).run(once=once, **kwargs) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP logger.info('User DCSP quit') DCNL DCSP logger.info('Exited')
def dict_factory(crs, row): DCNL  DCSP return dict(((col[0], row[idx]) for (idx, col) in enumerate(crs.description)))
def chexor(old, name, timestamp): DCNL  DCSP if (name is None): DCNL DCSP  DCSP raise Exception('name DCSP is DCSP None!') DCNL DCSP new = hashlib.md5(('%s-%s' % (name, timestamp)).encode('utf8')).hexdigest() DCNL DCSP return ('%032x' % (int(old, 16) ^ int(new, 16)))
def get_db_connection(path, timeout=30, okay_to_create=False): DCNL  DCSP try: DCNL DCSP  DCSP connect_time = time.time() DCNL DCSP  DCSP conn = sqlite3.connect(path, check_same_thread=False, factory=GreenDBConnection, timeout=timeout) DCNL DCSP  DCSP if ((path != ':memory:') and (not okay_to_create)): DCNL DCSP  DCSP  DCSP stat = os.stat(path) DCNL DCSP  DCSP  DCSP if ((stat.st_size == 0) and (stat.st_ctime >= connect_time)): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(path) DCNL DCSP  DCSP  DCSP  DCSP raise DatabaseConnectionError(path, 'DB DCSP file DCSP created DCSP by DCSP connect?') DCNL DCSP  DCSP conn.row_factory = sqlite3.Row DCNL DCSP  DCSP conn.text_factory = str DCNL DCSP  DCSP conn.execute('PRAGMA DCSP synchronous DCSP = DCSP NORMAL') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP count_changes DCSP = DCSP OFF') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP temp_store DCSP = DCSP MEMORY') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP journal_mode DCSP = DCSP DELETE') DCNL DCSP  DCSP conn.create_function('chexor', 3, chexor) DCNL DCSP except sqlite3.DatabaseError: DCNL DCSP  DCSP import traceback DCNL DCSP  DCSP raise DatabaseConnectionError(path, traceback.format_exc(), timeout=timeout) DCNL DCSP return conn
def read_metadata(fd): DCNL  DCSP metadata = '' DCNL DCSP key = 0 DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP metadata += getxattr(fd, ('%s%s' % (METADATA_KEY, (key or '')))) DCNL DCSP  DCSP  DCSP key += 1 DCNL DCSP except IOError: DCNL DCSP  DCSP pass DCNL DCSP return pickle.loads(metadata)
def write_metadata(fd, metadata): DCNL  DCSP metastr = pickle.dumps(metadata, PICKLE_PROTOCOL) DCNL DCSP key = 0 DCNL DCSP while metastr: DCNL DCSP  DCSP setxattr(fd, ('%s%s' % (METADATA_KEY, (key or ''))), metastr[:254]) DCNL DCSP  DCSP metastr = metastr[254:] DCNL DCSP  DCSP key += 1
def app_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return ObjectController(conf)
def quarantine_renamer(device_path, corrupted_file_path): DCNL  DCSP from_dir = dirname(corrupted_file_path) DCNL DCSP to_dir = join(device_path, 'quarantined', 'objects', basename(from_dir)) DCNL DCSP invalidate_hash(dirname(from_dir)) DCNL DCSP try: DCNL DCSP  DCSP renamer(from_dir, to_dir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP to_dir = ('%s-%s' % (to_dir, uuid.uuid4().hex)) DCNL DCSP  DCSP renamer(from_dir, to_dir) DCNL DCSP return to_dir
def hash_suffix(path, reclaim_age): DCNL  DCSP md5 = hashlib.md5() DCNL DCSP try: DCNL DCSP  DCSP path_contents = sorted(os.listdir(path)) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno in (errno.ENOTDIR, errno.ENOENT)): DCNL DCSP  DCSP  DCSP raise PathNotDir() DCNL DCSP  DCSP raise DCNL DCSP for hsh in path_contents: DCNL DCSP  DCSP hsh_path = join(path, hsh) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP files = os.listdir(hsh_path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.ENOTDIR): DCNL DCSP  DCSP  DCSP  DCSP partition_path = dirname(path) DCNL DCSP  DCSP  DCSP  DCSP objects_path = dirname(partition_path) DCNL DCSP  DCSP  DCSP  DCSP device_path = dirname(objects_path) DCNL DCSP  DCSP  DCSP  DCSP quar_path = quarantine_renamer(device_path, hsh_path) DCNL DCSP  DCSP  DCSP  DCSP logging.exception((_('Quarantined DCSP %s DCSP to DCSP %s DCSP because DCSP it DCSP is DCSP not DCSP a DCSP directory') % (hsh_path, quar_path))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (len(files) == 1): DCNL DCSP  DCSP  DCSP if files[0].endswith('.ts'): DCNL DCSP  DCSP  DCSP  DCSP ts = files[0].rsplit('.', 1)[0] DCNL DCSP  DCSP  DCSP  DCSP if ((time.time() - float(ts)) > reclaim_age): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, files[0])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(files[0]) DCNL DCSP  DCSP elif files: DCNL DCSP  DCSP  DCSP files.sort(reverse=True) DCNL DCSP  DCSP  DCSP meta = data = tomb = None DCNL DCSP  DCSP  DCSP for filename in list(files): DCNL DCSP  DCSP  DCSP  DCSP if ((not meta) and filename.endswith('.meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP meta = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not data) and filename.endswith('.data')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not tomb) and filename.endswith('.ts')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tomb = filename DCNL DCSP  DCSP  DCSP  DCSP if ((filename < tomb) or (filename < data) or (filename.endswith('.meta') and (filename < meta))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(filename) DCNL DCSP  DCSP if (not files): DCNL DCSP  DCSP  DCSP os.rmdir(hsh_path) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP md5.update(filename) DCNL DCSP try: DCNL DCSP  DCSP os.rmdir(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP return md5.hexdigest()
def invalidate_hash(suffix_dir): DCNL  DCSP suffix = os.path.basename(suffix_dir) DCNL DCSP partition_dir = os.path.dirname(suffix_dir) DCNL DCSP hashes_file = join(partition_dir, HASH_FILE) DCNL DCSP with lock_path(partition_dir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP  DCSP hashes = pickle.load(fp) DCNL DCSP  DCSP  DCSP if ((suffix in hashes) and (not hashes[suffix])): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP hashes[suffix] = None DCNL DCSP  DCSP write_pickle(hashes, hashes_file, partition_dir, PICKLE_PROTOCOL)
def get_hashes(partition_dir, recalculate=[], do_listdir=False, reclaim_age=ONE_WEEK): DCNL  DCSP hashed = 0 DCNL DCSP hashes_file = join(partition_dir, HASH_FILE) DCNL DCSP modified = False DCNL DCSP force_rewrite = False DCNL DCSP hashes = {} DCNL DCSP mtime = (-1) DCNL DCSP try: DCNL DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP hashes = pickle.load(fp) DCNL DCSP  DCSP mtime = os.path.getmtime(hashes_file) DCNL DCSP except Exception: DCNL DCSP  DCSP do_listdir = True DCNL DCSP  DCSP force_rewrite = True DCNL DCSP if do_listdir: DCNL DCSP  DCSP for suff in os.listdir(partition_dir): DCNL DCSP  DCSP  DCSP if (len(suff) == 3): DCNL DCSP  DCSP  DCSP  DCSP hashes.setdefault(suff, None) DCNL DCSP  DCSP modified = True DCNL DCSP hashes.update(((hash_, None) for hash_ in recalculate)) DCNL DCSP for (suffix, hash_) in hashes.items(): DCNL DCSP  DCSP if (not hash_): DCNL DCSP  DCSP  DCSP suffix_dir = join(partition_dir, suffix) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hashes[suffix] = hash_suffix(suffix_dir, reclaim_age) DCNL DCSP  DCSP  DCSP  DCSP hashed += 1 DCNL DCSP  DCSP  DCSP except PathNotDir: DCNL DCSP  DCSP  DCSP  DCSP del hashes[suffix] DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP logging.exception(_('Error DCSP hashing DCSP suffix')) DCNL DCSP  DCSP  DCSP modified = True DCNL DCSP if modified: DCNL DCSP  DCSP with lock_path(partition_dir): DCNL DCSP  DCSP  DCSP if (force_rewrite or (not os.path.exists(hashes_file)) or (os.path.getmtime(hashes_file) == mtime)): DCNL DCSP  DCSP  DCSP  DCSP write_pickle(hashes, hashes_file, partition_dir, PICKLE_PROTOCOL) DCNL DCSP  DCSP  DCSP  DCSP return (hashed, hashes) DCNL DCSP  DCSP return get_hashes(partition_dir, recalculate, do_listdir, reclaim_age) DCNL DCSP else: DCNL DCSP  DCSP return (hashed, hashes)
def tpool_reraise(func, *args, **kwargs): DCNL  DCSP def inner(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except BaseException as err: DCNL DCSP  DCSP  DCSP return err DCNL DCSP resp = tpool.execute(inner) DCNL DCSP if isinstance(resp, BaseException): DCNL DCSP  DCSP raise resp DCNL DCSP return resp
def app_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return AccountController(conf)
def is_localized(node): DCNL  DCSP if isinstance(node.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(node.parent.node, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (node.parent.node.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def is_log_callfunc(n): DCNL  DCSP if isinstance(n.parent, compiler.ast.Mod): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.node.getChildNodes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.node.getChildNodes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def is_log_i18n_msg_with_mod(n): DCNL  DCSP if (not isinstance(n.parent.parent, compiler.ast.Mod)): DCNL DCSP  DCSP return False DCNL DCSP n = n.parent.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.node.getChildNodes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.node.getChildNodes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def is_wrong_i18n_format(n): DCNL  DCSP if isinstance(n.parent, compiler.ast.Mod): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (n.parent.node.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
def Resource(controller, faults=None, deserializers=None, serializers=None): DCNL  DCSP xml_deserializer = wsgi.XMLDeserializer(attributes.get_attr_metadata()) DCNL DCSP default_deserializers = {'application/xml': xml_deserializer, 'application/json': wsgi.JSONDeserializer()} DCNL DCSP xml_serializer = wsgi.XMLDictSerializer(attributes.get_attr_metadata()) DCNL DCSP default_serializers = {'application/xml': xml_serializer, 'application/json': wsgi.JSONDictSerializer()} DCNL DCSP format_types = {'xml': 'application/xml', 'json': 'application/json'} DCNL DCSP action_status = dict(create=201, delete=204) DCNL DCSP default_deserializers.update((deserializers or {})) DCNL DCSP default_serializers.update((serializers or {})) DCNL DCSP deserializers = default_deserializers DCNL DCSP serializers = default_serializers DCNL DCSP faults = (faults or {}) DCNL DCSP @webob.dec.wsgify(RequestClass=Request) DCNL DCSP def resource(request): DCNL DCSP  DCSP route_args = request.environ.get('wsgiorg.routing_args') DCNL DCSP  DCSP if route_args: DCNL DCSP  DCSP  DCSP args = route_args[1].copy() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP args.pop('controller', None) DCNL DCSP  DCSP fmt = args.pop('format', None) DCNL DCSP  DCSP action = args.pop('action', None) DCNL DCSP  DCSP content_type = format_types.get(fmt, request.best_match_content_type()) DCNL DCSP  DCSP deserializer = deserializers.get(content_type) DCNL DCSP  DCSP serializer = serializers.get(content_type) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if request.body: DCNL DCSP  DCSP  DCSP  DCSP args['body'] = deserializer.deserialize(request.body)['body'] DCNL DCSP  DCSP  DCSP method = getattr(controller, action) DCNL DCSP  DCSP  DCSP result = method(request=request, **args) DCNL DCSP  DCSP except (exceptions.QuantumException, netaddr.AddrFormatError) as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP body = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP kwargs = {'body': body, 'content_type': content_type} DCNL DCSP  DCSP  DCSP for fault in faults: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(e, fault): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise faults[fault](**kwargs) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP e.body = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP e.content_type = content_type DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP msg = _('Request DCSP Failed: DCSP internal DCSP server DCSP error DCSP while DCSP processing DCSP your DCSP request.') DCNL DCSP  DCSP  DCSP body = serializer.serialize({'QuantumError': msg}) DCNL DCSP  DCSP  DCSP kwargs = {'body': body, 'content_type': content_type} DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP status = action_status.get(action, 200) DCNL DCSP  DCSP body = serializer.serialize(result) DCNL DCSP  DCSP if (status == 204): DCNL DCSP  DCSP  DCSP content_type = '' DCNL DCSP  DCSP  DCSP body = None DCNL DCSP  DCSP return webob.Response(request=request, status=status, content_type=content_type, body=body) DCNL DCSP return resource
def _verify_dict_keys(expected_keys, target_dict, strict=True): DCNL  DCSP if (not isinstance(target_dict, dict)): DCNL DCSP  DCSP msg = (_("Invalid DCSP input. DCSP '%(target_dict)s' DCSP must DCSP be DCSP a DCSP dictionary DCSP with DCSP keys: DCSP %(expected_keys)s") % dict(target_dict=target_dict, expected_keys=expected_keys)) DCNL DCSP  DCSP return msg DCNL DCSP expected_keys = set(expected_keys) DCNL DCSP provided_keys = set(target_dict.keys()) DCNL DCSP predicate = (expected_keys.__eq__ if strict else expected_keys.issubset) DCNL DCSP if (not predicate(provided_keys)): DCNL DCSP  DCSP msg = (_("Validation DCSP of DCSP dictionary's DCSP keys DCSP failed.Expected DCSP keys: DCSP %(expected_keys)s DCSP Provided DCSP keys: DCSP %(provided_keys)s") % locals()) DCNL DCSP  DCSP return msg
def _validate_ip_pools(data, valid_values=None): DCNL  DCSP if (not isinstance(data, list)): DCNL DCSP  DCSP msg = (_("Invalid DCSP data DCSP format DCSP for DCSP IP DCSP pool: DCSP '%s'") % data) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP return msg DCNL DCSP expected_keys = ['start', 'end'] DCNL DCSP for ip_pool in data: DCNL DCSP  DCSP msg = _verify_dict_keys(expected_keys, ip_pool) DCNL DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP for k in expected_keys: DCNL DCSP  DCSP  DCSP msg = _validate_ip_address(ip_pool[k]) DCNL DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP  DCSP return msg
def convert_kvp_str_to_list(data): DCNL  DCSP kvp = [x.strip() for x in data.split('=', 1)] DCNL DCSP if ((len(kvp) == 2) and kvp[0]): DCNL DCSP  DCSP return kvp DCNL DCSP msg = (_("'%s' DCSP is DCSP not DCSP of DCSP the DCSP form DCSP <key>=[value]") % data) DCNL DCSP raise q_exc.InvalidInput(error_message=msg)
def convert_kvp_list_to_dict(kvp_list): DCNL  DCSP if (kvp_list == ['True']): DCNL DCSP  DCSP return {} DCNL DCSP kvp_map = {} DCNL DCSP for kvp_str in kvp_list: DCNL DCSP  DCSP (key, value) = convert_kvp_str_to_list(kvp_str) DCNL DCSP  DCSP kvp_map.setdefault(key, set()) DCNL DCSP  DCSP kvp_map[key].add(value) DCNL DCSP return dict(((x, list(y)) for (x, y) in kvp_map.iteritems()))
def get_filters(request, attr_info, skips=[]): DCNL  DCSP res = {} DCNL DCSP for (key, values) in request.GET.dict_of_lists().iteritems(): DCNL DCSP  DCSP if (key in skips): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP values = [v for v in values if v] DCNL DCSP  DCSP key_attr_info = attr_info.get(key, {}) DCNL DCSP  DCSP if ('convert_list_to' in key_attr_info): DCNL DCSP  DCSP  DCSP values = key_attr_info['convert_list_to'](values) DCNL DCSP  DCSP elif ('convert_to' in key_attr_info): DCNL DCSP  DCSP  DCSP convert_to = key_attr_info['convert_to'] DCNL DCSP  DCSP  DCSP values = [convert_to(v) for v in values] DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP res[key] = values DCNL DCSP return res
def get_limit_and_marker(request): DCNL  DCSP max_limit = _get_pagination_max_limit() DCNL DCSP limit = _get_limit_param(request, max_limit) DCNL DCSP if (max_limit > 0): DCNL DCSP  DCSP limit = (min(max_limit, limit) or max_limit) DCNL DCSP if (not limit): DCNL DCSP  DCSP return (None, None) DCNL DCSP marker = request.GET.get('marker', None) DCNL DCSP return (limit, marker)
def _get_limit_param(request, max_limit): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', 0)) DCNL DCSP  DCSP if (limit >= 0): DCNL DCSP  DCSP  DCSP return limit DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP msg = _("Limit DCSP must DCSP be DCSP an DCSP integer DCSP 0 DCSP or DCSP greater DCSP and DCSP not DCSP '%d'") DCNL DCSP raise exceptions.BadRequest(resource='limit', msg=msg)
def list_args(request, arg): DCNL  DCSP return [v for v in request.GET.getall(arg) if v]
def get_sorts(request, attr_info): DCNL  DCSP sort_keys = list_args(request, 'sort_key') DCNL DCSP sort_dirs = list_args(request, 'sort_dir') DCNL DCSP if (len(sort_keys) != len(sort_dirs)): DCNL DCSP  DCSP msg = _('The DCSP number DCSP of DCSP sort_keys DCSP and DCSP sort_dirs DCSP must DCSP be DCSP same') DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP valid_dirs = [constants.SORT_DIRECTION_ASC, constants.SORT_DIRECTION_DESC] DCNL DCSP absent_keys = [x for x in sort_keys if (x not in attr_info)] DCNL DCSP if absent_keys: DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP invalid DCSP attribute DCSP for DCSP sort_keys') % absent_keys) DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP invalid_dirs = [x for x in sort_dirs if (x not in valid_dirs)] DCNL DCSP if invalid_dirs: DCNL DCSP  DCSP msg = (_("%(invalid_dirs)s DCSP is DCSP invalid DCSP value DCSP for DCSP sort_dirs, DCSP valid DCSP value DCSP is DCSP '%(asc)s' DCSP and DCSP '%(desc)s'") % {'invalid_dirs': invalid_dirs, 'asc': constants.SORT_DIRECTION_ASC, 'desc': constants.SORT_DIRECTION_DESC}) DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP return zip(sort_keys, [(x == constants.SORT_DIRECTION_ASC) for x in sort_dirs])
def plugin_aware_extension_middleware_factory(global_config, **local_config): DCNL  DCSP def _factory(app): DCNL DCSP  DCSP ext_mgr = PluginAwareExtensionManager.get_instance() DCNL DCSP  DCSP return ExtensionMiddleware(app, ext_mgr=ext_mgr) DCNL DCSP return _factory
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_code, int) and (not isinstance(check_exit_code, bool)) and (_returncode != check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def set_rules(rules): DCNL  DCSP global _rules DCNL DCSP _rules = rules
def reset(): DCNL  DCSP global _rules DCNL DCSP _rules = None
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL  DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def _parse_list_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
def _parse_tokenize(rule): DCNL  DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
def reducer(*tokens): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def _parse_text_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
def parse_rule(rule): DCNL  DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
def _thread_done(gt, *args, **kwargs): DCNL  DCSP kwargs['group'].thread_done(kwargs['thread'])
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('quantum.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def periodic_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def run_server(application, port): DCNL  DCSP sock = eventlet.listen(('0.0.0.0', port)) DCNL DCSP eventlet.wsgi.server(sock, application)
def create_consumers(dispatcher, prefix, topic_details): DCNL  DCSP connection = rpc.create_connection(new=True) DCNL DCSP for (topic, operation) in topic_details: DCNL DCSP  DCSP topic_name = topics.get_topic_name(prefix, topic, operation) DCNL DCSP  DCSP connection.create_consumer(topic_name, dispatcher, fanout=True) DCNL DCSP connection.consume_in_thread() DCNL DCSP return connection
def replace_file(file_name, data): DCNL  DCSP base_dir = os.path.dirname(os.path.abspath(file_name)) DCNL DCSP tmp_file = tempfile.NamedTemporaryFile('w+', dir=base_dir, delete=False) DCNL DCSP tmp_file.write(data) DCNL DCSP tmp_file.close() DCNL DCSP os.chmod(tmp_file.name, 420) DCNL DCSP os.rename(tmp_file.name, file_name)
def setup_conf(): DCNL  DCSP opts = [cfg.BoolOpt('ovs_all_ports', default=False, help=_('True DCSP to DCSP delete DCSP all DCSP ports DCSP on DCSP all DCSP the DCSP OpenvSwitch DCSP bridges. DCSP False DCSP to DCSP delete DCSP ports DCSP created DCSP by DCSP Quantum DCSP on DCSP integration DCSP and DCSP external DCSP network DCSP bridges.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_cli_opts(opts) DCNL DCSP conf.register_opts(l3_agent.L3NATAgent.OPTS) DCNL DCSP conf.register_opts(interface.OPTS) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP return conf
def collect_quantum_ports(bridges, root_helper): DCNL  DCSP ports = [] DCNL DCSP for bridge in bridges: DCNL DCSP  DCSP ovs = ovs_lib.OVSBridge(bridge, root_helper) DCNL DCSP  DCSP ports += [port.port_name for port in ovs.get_vif_ports()] DCNL DCSP return ports
def delete_quantum_ports(ports, root_helper): DCNL  DCSP for port in ports: DCNL DCSP  DCSP if ip_lib.device_exists(port): DCNL DCSP  DCSP  DCSP device = ip_lib.IPDevice(port, root_helper) DCNL DCSP  DCSP  DCSP device.link.delete() DCNL DCSP  DCSP  DCSP LOG.info(_('Delete DCSP %s'), port)
def main(): DCNL  DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP configuration_bridges = set([conf.ovs_integration_bridge, conf.external_network_bridge]) DCNL DCSP ovs_bridges = set(ovs_lib.get_bridges(conf.AGENT.root_helper)) DCNL DCSP available_configuration_bridges = (configuration_bridges & ovs_bridges) DCNL DCSP if conf.ovs_all_ports: DCNL DCSP  DCSP bridges = ovs_bridges DCNL DCSP else: DCNL DCSP  DCSP bridges = available_configuration_bridges DCNL DCSP ports = collect_quantum_ports(available_configuration_bridges, conf.AGENT.root_helper) DCNL DCSP for bridge in bridges: DCNL DCSP  DCSP LOG.info(_('Cleaning DCSP %s'), bridge) DCNL DCSP  DCSP ovs = ovs_lib.OVSBridge(bridge, conf.AGENT.root_helper) DCNL DCSP  DCSP ovs.delete_ports(all_ports=conf.ovs_all_ports) DCNL DCSP delete_quantum_ports(ports, conf.AGENT.root_helper) DCNL DCSP LOG.info(_('OVS DCSP cleanup DCSP completed DCSP successfully'))
def setup_conf(): DCNL  DCSP opts = [cfg.StrOpt('dhcp_driver', default='quantum.agent.linux.dhcp.Dnsmasq', help=_('The DCSP driver DCSP used DCSP to DCSP manage DCSP the DCSP DHCP DCSP server.')), cfg.BoolOpt('force', default=False, help=_('Delete DCSP the DCSP namespace DCSP by DCSP removing DCSP all DCSP devices.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_opts(opts) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP conf.register_opts(dhcp.OPTS) DCNL DCSP return conf
def kill_dhcp(conf, namespace): DCNL  DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP network_id = namespace.replace(dhcp_agent.NS_PREFIX, '') DCNL DCSP null_delegate = NullDelegate() DCNL DCSP dhcp_driver = importutils.import_object(conf.dhcp_driver, conf, FakeNetwork(network_id), root_helper, null_delegate) DCNL DCSP if dhcp_driver.active: DCNL DCSP  DCSP dhcp_driver.disable()
def eligible_for_deletion(conf, namespace, force=False): DCNL  DCSP if (not re.match(NS_MANGLING_PATTERN, namespace)): DCNL DCSP  DCSP return False DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP return (force or ip.namespace_is_empty())
def destroy_namespace(conf, namespace, force=False): DCNL  DCSP try: DCNL DCSP  DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP  DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP kill_dhcp(conf, namespace) DCNL DCSP  DCSP  DCSP if ip.netns.exists(namespace): DCNL DCSP  DCSP  DCSP  DCSP for device in ip.get_devices(exclude_loopback=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unplug_device(conf, device) DCNL DCSP  DCSP ip.garbage_collect_namespace() DCNL DCSP except Exception as e: DCNL DCSP  DCSP LOG.exception(_('Error DCSP unable DCSP to DCSP destroy DCSP namespace: DCSP %s'), namespace)
def main(): DCNL  DCSP eventlet.monkey_patch() DCNL DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP candidates = [ns for ns in ip_lib.IPWrapper.get_namespaces(root_helper) if eligible_for_deletion(conf, ns, conf.force)] DCNL DCSP if candidates: DCNL DCSP  DCSP eventlet.sleep(2) DCNL DCSP  DCSP for namespace in candidates: DCNL DCSP  DCSP  DCSP destroy_namespace(conf, namespace, conf.force)
def build_filter(class_name, *args): DCNL  DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
def load_filters(filters_path): DCNL  DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
def match_filter(filter_list, userargs): DCNL  DCSP found_filter = None DCNL DCSP for f in filter_list: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if isinstance(f, filters.ExecCommandFilter): DCNL DCSP  DCSP  DCSP  DCSP leaf_filters = [fltr for fltr in filter_list if (not isinstance(fltr, filters.ExecCommandFilter))] DCNL DCSP  DCSP  DCSP  DCSP args = f.exec_args(userargs) DCNL DCSP  DCSP  DCSP  DCSP if ((not args) or (not match_filter(leaf_filters, args))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not os.access(f.exec_path, os.X_OK)): DCNL DCSP  DCSP  DCSP  DCSP if (not found_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP found_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP return found_filter
def get_resource_and_action(action): DCNL  DCSP data = action.split(':', 1)[0].split('_', 1) DCNL DCSP return (('%ss' % data[(-1)]), (data[0] != 'get'))
def _is_attribute_explicitly_set(attribute_name, resource, target): DCNL  DCSP return (('default' in resource[attribute_name]) and (attribute_name in target) and (target[attribute_name] is not attributes.ATTR_NOT_SPECIFIED) and (target[attribute_name] != resource[attribute_name]['default']))
def _build_target(action, original_target, plugin, context): DCNL  DCSP target = original_target.copy() DCNL DCSP (resource, _a) = get_resource_and_action(action) DCNL DCSP hierarchy_info = attributes.RESOURCE_HIERARCHY_MAP.get(resource, None) DCNL DCSP if (hierarchy_info and plugin): DCNL DCSP  DCSP parent_resource = hierarchy_info['parent'][:(-1)] DCNL DCSP  DCSP parent_id = hierarchy_info['identified_by'] DCNL DCSP  DCSP f = getattr(plugin, ('get_%s' % parent_resource)) DCNL DCSP  DCSP data = f(context, target[parent_id], fields=['tenant_id']) DCNL DCSP  DCSP target[('%s_tenant_id' % parent_resource)] = data['tenant_id'] DCNL DCSP return target
def _build_match_rule(action, target): DCNL  DCSP match_rule = policy.RuleCheck('rule', action) DCNL DCSP (resource, is_write) = get_resource_and_action(action) DCNL DCSP if is_write: DCNL DCSP  DCSP res_map = attributes.RESOURCE_ATTRIBUTE_MAP DCNL DCSP  DCSP if (resource in res_map): DCNL DCSP  DCSP  DCSP for attribute_name in res_map[resource]: DCNL DCSP  DCSP  DCSP  DCSP if _is_attribute_explicitly_set(attribute_name, res_map[resource], target): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attribute = res_map[resource][attribute_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('enforce_policy' in attribute) and is_write): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.RuleCheck('rule', ('%s:%s' % (action, attribute_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match_rule = policy.AndCheck([match_rule, attr_rule]) DCNL DCSP return match_rule
def check(context, action, target, plugin=None): DCNL  DCSP init() DCNL DCSP real_target = _build_target(action, target, plugin, context) DCNL DCSP match_rule = _build_match_rule(action, real_target) DCNL DCSP credentials = context.to_dict() DCNL DCSP return policy.check(match_rule, real_target, credentials)
def enforce(context, action, target, plugin=None): DCNL  DCSP init() DCNL DCSP real_target = _build_target(action, target, plugin, context) DCNL DCSP match_rule = _build_match_rule(action, real_target) DCNL DCSP credentials = context.to_dict() DCNL DCSP return policy.check(match_rule, real_target, credentials, exceptions.PolicyNotAuthorized, action=action)
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.debug(_('Reloading DCSP cached DCSP file DCSP %s'), filename) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def find_config_file(options, config_file): DCNL  DCSP fix_path = (lambda p: os.path.abspath(os.path.expanduser(p))) DCNL DCSP if options.get('config_file'): DCNL DCSP  DCSP if os.path.exists(options['config_file']): DCNL DCSP  DCSP  DCSP return fix_path(options['config_file']) DCNL DCSP dir_to_common = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP root = os.path.join(dir_to_common, '..', '..', '..', '..') DCNL DCSP config_file_dirs = [fix_path(os.path.join(os.getcwd(), 'etc')), fix_path(os.path.join('~', '.quantum-venv', 'etc', 'quantum')), fix_path('~'), os.path.join(cfg.CONF.state_path, 'etc'), os.path.join(cfg.CONF.state_path, 'etc', 'quantum'), fix_path(os.path.join('~', '.local', 'etc', 'quantum')), '/usr/etc/quantum', '/usr/local/etc/quantum', '/etc/quantum/', '/etc'] DCNL DCSP if ('plugin' in options): DCNL DCSP  DCSP config_file_dirs = [os.path.join(x, 'quantum', 'plugins', options['plugin']) for x in config_file_dirs] DCNL DCSP if os.path.exists(os.path.join(root, 'plugins')): DCNL DCSP  DCSP plugins = [fix_path(os.path.join(root, 'plugins', p, 'etc')) for p in os.listdir(os.path.join(root, 'plugins'))] DCNL DCSP  DCSP plugins = [p for p in plugins if os.path.isdir(p)] DCNL DCSP  DCSP config_file_dirs.extend(plugins) DCNL DCSP for cfg_dir in config_file_dirs: DCNL DCSP  DCSP cfg_file = os.path.join(cfg_dir, config_file) DCNL DCSP  DCSP if os.path.exists(cfg_file): DCNL DCSP  DCSP  DCSP return cfg_file
def parse_mappings(mapping_list, unique_values=True): DCNL  DCSP mappings = {} DCNL DCSP for mapping in mapping_list: DCNL DCSP  DCSP mapping = mapping.strip() DCNL DCSP  DCSP if (not mapping): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP split_result = mapping.split(':') DCNL DCSP  DCSP if (len(split_result) != 2): DCNL DCSP  DCSP  DCSP raise ValueError((_("Invalid DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP key = split_result[0].strip() DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP key DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP value = split_result[1].strip() DCNL DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP value DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP if (key in mappings): DCNL DCSP  DCSP  DCSP raise ValueError((_("Key DCSP %(key)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP unique") % locals())) DCNL DCSP  DCSP if (unique_values and (value in mappings.itervalues())): DCNL DCSP  DCSP  DCSP raise ValueError((_("Value DCSP %(value)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP unique") % locals())) DCNL DCSP  DCSP mappings[key] = value DCNL DCSP return mappings
def compare_elements(a, b): DCNL  DCSP if (a is None): DCNL DCSP  DCSP a = [] DCNL DCSP if (b is None): DCNL DCSP  DCSP b = [] DCNL DCSP return (set(a) == set(b))
def get_topic_name(prefix, table, operation): DCNL  DCSP return ('%s-%s-%s' % (prefix, table, operation))
def setup_logging(conf): DCNL  DCSP product_name = 'quantum' DCNL DCSP logging.setup(product_name) DCNL DCSP log_root = logging.getLogger(product_name).logger DCNL DCSP LOG.info(_('Logging DCSP enabled!'))
def load_paste_app(app_name): DCNL  DCSP config_path = os.path.abspath(cfg.CONF.find_file(cfg.CONF.api_paste_config)) DCNL DCSP LOG.info(_('Config DCSP paste DCSP file: DCSP %s'), config_path) DCNL DCSP try: DCNL DCSP  DCSP app = deploy.loadapp(('config:%s' % config_path), name=app_name) DCNL DCSP except (LookupError, ImportError): DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP load DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(config_path)s.') % locals()) DCNL DCSP  DCSP LOG.exception(msg) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return app
def create_agent_config_map(config): DCNL  DCSP try: DCNL DCSP  DCSP bridge_mappings = q_utils.parse_mappings(config.OVS.bridge_mappings) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP raise ValueError((_('Parsing DCSP bridge_mappings DCSP failed: DCSP %s.') % e)) DCNL DCSP kwargs = dict(integ_br=config.OVS.integration_bridge, tun_br=config.OVS.tunnel_bridge, local_ip=config.OVS.local_ip, bridge_mappings=bridge_mappings, root_helper=config.AGENT.root_helper, polling_interval=config.AGENT.polling_interval, enable_tunneling=config.OVS.enable_tunneling) DCNL DCSP if (kwargs['enable_tunneling'] and (not kwargs['local_ip'])): DCNL DCSP  DCSP msg = _('Tunnelling DCSP cannot DCSP be DCSP enabled DCSP without DCSP a DCSP valid DCSP local_ip.') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP return kwargs
def sync_vlan_allocations(network_vlan_ranges): DCNL  DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = dict() DCNL DCSP  DCSP allocs = session.query(ovs_models_v2.VlanAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP if (alloc.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[alloc.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[alloc.physical_network].add(alloc) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_ids = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_ids |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for alloc in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_ids.remove(alloc.vlan_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': alloc.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc) DCNL DCSP  DCSP  DCSP  DCSP del allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_id in sorted(vlan_ids): DCNL DCSP  DCSP  DCSP  DCSP alloc = ovs_models_v2.VlanAllocation(physical_network, vlan_id) DCNL DCSP  DCSP  DCSP  DCSP session.add(alloc) DCNL DCSP  DCSP for allocs in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': alloc.vlan_id, 'physical_network': alloc.physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc)
def sync_tunnel_allocations(tunnel_id_ranges): DCNL  DCSP tunnel_ids = set() DCNL DCSP for tunnel_id_range in tunnel_id_ranges: DCNL DCSP  DCSP (tun_min, tun_max) = tunnel_id_range DCNL DCSP  DCSP if (((tun_max + 1) - tun_min) > 1000000): DCNL DCSP  DCSP  DCSP LOG.error(_('Skipping DCSP unreasonable DCSP tunnel DCSP ID DCSP range DCSP %(tun_min)s:%(tun_max)s'), locals()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tunnel_ids |= set(xrange(tun_min, (tun_max + 1))) DCNL DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocs = session.query(ovs_models_v2.TunnelAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tunnel_ids.remove(alloc.tunnel_id) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP tunnel DCSP %s DCSP from DCSP pool'), alloc.tunnel_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc) DCNL DCSP  DCSP for tunnel_id in sorted(tunnel_ids): DCNL DCSP  DCSP  DCSP alloc = ovs_models_v2.TunnelAllocation(tunnel_id) DCNL DCSP  DCSP  DCSP session.add(alloc)
def get_port_from_device(port_id): DCNL  DCSP LOG.debug(_('get_port_with_securitygroups() DCSP called:port_id=%s'), port_id) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter((models_v2.Port.id == port_id)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict[ext_sg.SECURITYGROUPS] = [sg_id for (port, sg_id) in port_and_sgs if sg_id] DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
def get16ByteUUID(uuid): DCNL  DCSP return hashlib.md5(uuid).hexdigest()[:16]
def make_net_dict(net_id, net_name, ports): DCNL  DCSP res = {const.NET_ID: net_id, const.NET_NAME: net_name} DCNL DCSP res[const.NET_PORTS] = ports DCNL DCSP return res
def make_port_dict(port_id, port_state, net_id, attachment): DCNL  DCSP res = {const.PORT_ID: port_id, const.PORT_STATE: port_state} DCNL DCSP res[const.NET_ID] = net_id DCNL DCSP res[const.ATTACHMENT] = attachment DCNL DCSP return res
def get_all_nexusport_bindings(): DCNL  DCSP LOG.debug(_('get_all_nexusport_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(nexus_models_v2.NexusPortBinding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL  DCSP LOG.debug(_('get_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).filter_by(port_id=port_id).filter_by(instance_id=instance_id).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
def get_nexusvlan_binding(vlan_id, switch_ip): DCNL  DCSP LOG.debug(_('get_nexusvlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
def add_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL  DCSP LOG.debug(_('add_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP binding = nexus_models_v2.NexusPortBinding(port_id, vlan_id, switch_ip, instance_id) DCNL DCSP session.add(binding) DCNL DCSP session.flush() DCNL DCSP return binding
def remove_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL  DCSP LOG.debug(_('remove_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).filter_by(port_id=port_id).filter_by(instance_id=instance_id).all() DCNL DCSP  DCSP for bind in binding: DCNL DCSP  DCSP  DCSP session.delete(bind) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_nexusport_binding(port_id, new_vlan_id): DCNL  DCSP LOG.debug(_('update_nexusport_binding DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(port_id=port_id).one() DCNL DCSP  DCSP if new_vlan_id: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = new_vlan_id DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound()
def get_nexusvm_binding(vlan_id, instance_id): DCNL  DCSP LOG.debug(_('get_nexusvm_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(instance_id=instance_id).filter_by(vlan_id=vlan_id).first() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
def get_port_vlan_switch_binding(port_id, vlan_id, switch_ip): DCNL  DCSP LOG.debug(_('get_port_vlan_switch_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(port_id=port_id).filter_by(switch_ip=switch_ip).filter_by(vlan_id=vlan_id).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
def create_vlanids(): DCNL  DCSP LOG.debug(_('create_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).one() DCNL DCSP except exc.MultipleResultsFound: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP end = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= end): DCNL DCSP  DCSP  DCSP vlanid = network_models_v2.VlanID(start) DCNL DCSP  DCSP  DCSP session.add(vlanid) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
def get_all_vlanids(): DCNL  DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(network_models_v2.VlanID).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def is_vlanid_used(vlan_id): DCNL  DCSP LOG.debug(_('is_vlanid_used() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id)
def release_vlanid(vlan_id): DCNL  DCSP LOG.debug(_('release_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP vlanid['vlan_used'] = False DCNL DCSP  DCSP session.merge(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id) DCNL DCSP return
def delete_vlanid(vlan_id): DCNL  DCSP LOG.debug(_('delete_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP session.delete(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def reserve_vlanid(): DCNL  DCSP LOG.debug(_('reserve_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.query(network_models_v2.VlanID).filter_by(vlan_used=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFound DCNL DCSP  DCSP rvlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=rvlan['vlan_id']).one() DCNL DCSP  DCSP rvlanid['vlan_used'] = True DCNL DCSP  DCSP session.merge(rvlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_id'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
def get_all_vlanids_used(): DCNL  DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(network_models_v2.VlanID).filter_by(vlan_used=True).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_all_vlan_bindings(): DCNL  DCSP LOG.debug(_('get_all_vlan_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(network_models_v2.Vlan_Binding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_vlan_binding(netid): DCNL  DCSP LOG.debug(_('get_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
def add_vlan_binding(vlanid, vlanname, netid): DCNL  DCSP LOG.debug(_('add_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(vlan_id=vlanid).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBindingAlreadyExists(vlan_id=vlanid, network_id=netid) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP binding = network_models_v2.Vlan_Binding(vlanid, vlanname, netid) DCNL DCSP  DCSP session.add(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding
def remove_vlan_binding(netid): DCNL  DCSP LOG.debug(_('remove_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP session.delete(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL  DCSP LOG.debug(_('update_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP if newvlanid: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = newvlanid DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binding['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
def get_all_qoss(tenant_id): DCNL  DCSP LOG.debug(_('get_all_qoss() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qoss = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return qoss DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_qos(tenant_id, qos_id): DCNL  DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
def add_qos(tenant_id, qos_name, qos_desc): DCNL  DCSP LOG.debug(_('add_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_name=qos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreadyExists(qos_name=qos_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP qos = network_models_v2.QoS(tenant_id, qos_name, qos_desc) DCNL DCSP  DCSP session.add(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos
def remove_qos(tenant_id, qos_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP session.delete(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP if new_qos_name: DCNL DCSP  DCSP  DCSP qos['qos_name'] = new_qos_name DCNL DCSP  DCSP session.merge(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
def get_all_credentials(tenant_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP creds = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return creds DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_credential(tenant_id, credential_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
def get_credential_name(tenant_id, credential_name): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNameNotFound(credential_name=credential_name, tenant_id=tenant_id)
def add_credential(tenant_id, credential_name, user_name, password): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP raise c_exc.CredentialAlreadyExists(credential_name=credential_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP cred = network_models_v2.Credential(tenant_id, credential_name, user_name, password) DCNL DCSP  DCSP session.add(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred
def remove_credential(tenant_id, credential_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP session.delete(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP cred['user_name'] = new_user_name DCNL DCSP  DCSP if new_password: DCNL DCSP  DCSP  DCSP cred['password'] = new_password DCNL DCSP  DCSP session.merge(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
def initialize(): DCNL  DCSP db.configure_db()
def create_vlanids(): DCNL  DCSP LOG.debug(_('create_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).one() DCNL DCSP except exc.MultipleResultsFound: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP end = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= end): DCNL DCSP  DCSP  DCSP vlanid = l2network_models.VlanID(start) DCNL DCSP  DCSP  DCSP session.add(vlanid) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
def get_all_vlanids(): DCNL  DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(l2network_models.VlanID).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def is_vlanid_used(vlan_id): DCNL  DCSP LOG.debug(_('is_vlanid_used() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id)
def release_vlanid(vlan_id): DCNL  DCSP LOG.debug(_('release_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP vlanid['vlan_used'] = False DCNL DCSP  DCSP session.merge(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id) DCNL DCSP return
def delete_vlanid(vlan_id): DCNL  DCSP LOG.debug(_('delete_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP session.delete(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def reserve_vlanid(): DCNL  DCSP LOG.debug(_('reserve_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.query(l2network_models.VlanID).filter_by(vlan_used=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFound DCNL DCSP  DCSP rvlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=rvlan['vlan_id']).one() DCNL DCSP  DCSP rvlanid['vlan_used'] = True DCNL DCSP  DCSP session.merge(rvlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_id'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
def get_all_vlanids_used(): DCNL  DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(l2network_models.VlanID).filter_by(vlan_used=True).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_all_vlan_bindings(): DCNL  DCSP LOG.debug(_('get_all_vlan_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(l2network_models.VlanBinding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_vlan_binding(netid): DCNL  DCSP LOG.debug(_('get_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
def add_vlan_binding(vlanid, vlanname, netid): DCNL  DCSP LOG.debug(_('add_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(vlan_id=vlanid).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBindingAlreadyExists(vlan_id=vlanid, network_id=netid) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP binding = l2network_models.VlanBinding(vlanid, vlanname, netid) DCNL DCSP  DCSP session.add(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding
def remove_vlan_binding(netid): DCNL  DCSP LOG.debug(_('remove_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP session.delete(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL  DCSP LOG.debug(_('update_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP if newvlanid: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = newvlanid DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binding['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
def get_all_qoss(tenant_id): DCNL  DCSP LOG.debug(_('get_all_qoss() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qoss = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return qoss DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_qos(tenant_id, qos_id): DCNL  DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
def add_qos(tenant_id, qos_name, qos_desc): DCNL  DCSP LOG.debug(_('add_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_name=qos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreadyExists(qos_name=qos_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP qos = l2network_models.QoS(tenant_id, qos_name, qos_desc) DCNL DCSP  DCSP session.add(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos
def remove_qos(tenant_id, qos_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP session.delete(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP if new_qos_name: DCNL DCSP  DCSP  DCSP qos['qos_name'] = new_qos_name DCNL DCSP  DCSP session.merge(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
def get_all_credentials(tenant_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP creds = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return creds DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
def get_credential(tenant_id, credential_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
def get_credential_name(tenant_id, credential_name): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNameNotFound(credential_name=credential_name, tenant_id=tenant_id)
def add_credential(tenant_id, credential_name, user_name, password): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP raise c_exc.CredentialAlreadyExists(credential_name=credential_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP cred = l2network_models.Credential(tenant_id, credential_name, user_name, password) DCNL DCSP  DCSP session.add(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred
def remove_credential(tenant_id, credential_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP session.delete(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP cred['user_name'] = new_user_name DCNL DCSP  DCSP if new_password: DCNL DCSP  DCSP  DCSP cred['password'] = new_password DCNL DCSP  DCSP session.merge(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
def configure_db(options): DCNL  DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP _ENGINE = create_engine(options['sql_connection'], echo=False, echo_pool=True, pool_recycle=3600) DCNL DCSP  DCSP register_models()
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
def register_models(): DCNL  DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metadata.create_all(_ENGINE)
def unregister_models(): DCNL  DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metadata.drop_all(_ENGINE)
def get_view_builder(req): DCNL  DCSP base_url = req.application_url DCNL DCSP return ViewBuilder(base_url)
def get_view_builder(req): DCNL  DCSP base_url = req.application_url DCNL DCSP return ViewBuilder(base_url)
def nos_unknown_host_cb(host, fingerprint): DCNL  DCSP return True
def create_network(context, net_id, vlan): DCNL  DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = BrocadeNetwork(id=net_id, vlan=vlan) DCNL DCSP  DCSP session.add(net) DCNL DCSP return net
def delete_network(context, net_id): DCNL  DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = session.query(BrocadeNetwork).filter_by(id=net_id).first() DCNL DCSP  DCSP if (net is not None): DCNL DCSP  DCSP  DCSP session.delete(net)
def get_network(context, net_id, fields=None): DCNL  DCSP session = context.session DCNL DCSP return session.query(BrocadeNetwork).filter_by(id=net_id).first()
def get_networks(context, filters=None, fields=None): DCNL  DCSP session = context.session DCNL DCSP try: DCNL DCSP  DCSP nets = session.query(BrocadeNetwork).all() DCNL DCSP  DCSP return nets DCNL DCSP except sa.exc.SQLAlchemyError: DCNL DCSP  DCSP return None
def create_port(context, port_id, network_id, physical_interface, vlan_id, tenant_id, admin_state_up): DCNL  DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = BrocadePort(port_id=port_id, network_id=network_id, physical_interface=physical_interface, vlan_id=vlan_id, admin_state_up=admin_state_up, tenant_id=tenant_id) DCNL DCSP  DCSP session.add(port) DCNL DCSP return port
def get_port(context, port_id): DCNL  DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP return port
def get_ports(context, network_id=None): DCNL  DCSP session = context.session DCNL DCSP ports = session.query(BrocadePort).filter_by(network_id=network_id).all() DCNL DCSP return ports
def delete_port(context, port_id): DCNL  DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP  DCSP if (port is not None): DCNL DCSP  DCSP  DCSP session.delete(port)
def get_port_from_device(session, port_id): DCNL  DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP return port
def update_port_state(context, port_id, admin_state_up): DCNL  DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP session.query(BrocadePort).filter_by(port_id=port_id).update({'admin_state_up': admin_state_up})
def save_config(conf_path, logical_config, socket_path=None): DCNL  DCSP data = [] DCNL DCSP data.extend(_build_global(logical_config, socket_path=socket_path)) DCNL DCSP data.extend(_build_defaults(logical_config)) DCNL DCSP data.extend(_build_frontend(logical_config)) DCNL DCSP data.extend(_build_backend(logical_config)) DCNL DCSP utils.replace_file(conf_path, '\n'.join(data))
def _get_server_health_option(config): DCNL  DCSP for monitor in config['healthmonitors']: DCNL DCSP  DCSP if ((monitor['status'] == ACTIVE) and monitor['admin_state_up']): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return ('', []) DCNL DCSP server_addon = (' DCSP check DCSP inter DCSP %(delay)ds DCSP fall DCSP %(max_retries)d' % monitor) DCNL DCSP opts = [('timeout DCSP check DCSP %ds' % monitor['timeout'])] DCNL DCSP if (monitor['type'] in (constants.HEALTH_MONITOR_HTTP, constants.HEALTH_MONITOR_HTTPS)): DCNL DCSP  DCSP opts.append(('option DCSP httpchk DCSP %(http_method)s DCSP %(url_path)s' % monitor)) DCNL DCSP  DCSP opts.append(('http-check DCSP expect DCSP rstatus DCSP %s' % '|'.join(_expand_expected_codes(monitor['expected_codes'])))) DCNL DCSP if (monitor['type'] == constants.HEALTH_MONITOR_HTTPS): DCNL DCSP  DCSP opts.append('option DCSP ssl-hello-chk') DCNL DCSP return (server_addon, opts)
def _expand_expected_codes(codes): DCNL  DCSP retval = set() DCNL DCSP for code in codes.replace(',', ' DCSP ').split(' DCSP '): DCNL DCSP  DCSP code = code.strip() DCNL DCSP  DCSP if (not code): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ('-' in code): DCNL DCSP  DCSP  DCSP (low, hi) = code.split('-')[:2] DCNL DCSP  DCSP  DCSP retval.update((str(i) for i in xrange(int(low), (int(hi) + 1)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP retval.add(code) DCNL DCSP return retval
def sg_label(sg_id, sg_name): DCNL  DCSP return (((PREFIX + str(sg_id)) + '_') + sg_name)
def chain_names(sg_id, sg_name): DCNL  DCSP prefix = sg_label(sg_id, sg_name) DCNL DCSP in_chain_name = (prefix + SUFFIX_IN) DCNL DCSP out_chain_name = (prefix + SUFFIX_OUT) DCNL DCSP return {'in': in_chain_name, 'out': out_chain_name}
def parse_config(): DCNL  DCSP if cfg.CONF.metadata_dhcp_host_route: DCNL DCSP  DCSP LOG.warning(_('The DCSP metadata_dhcp_host_route DCSP is DCSP now DCSP obsolete, DCSP and DCSP will DCSP have DCSP no DCSP effect. DCSP Instead, DCSP please DCSP set DCSP the DCSP enable_isolated_metadata DCSP option DCSP in DCSP dhcp_agent.ini')) DCNL DCSP nvp_conf = config.ClusterConfigOptions(cfg.CONF) DCNL DCSP cluster_names = config.register_cluster_groups(nvp_conf) DCNL DCSP nvp_conf.log_opt_values(LOG, logging.DEBUG) DCNL DCSP clusters_options = [] DCNL DCSP for cluster_name in cluster_names: DCNL DCSP  DCSP clusters_options.append({'name': cluster_name, 'default_tz_uuid': nvp_conf[cluster_name].default_tz_uuid, 'nvp_cluster_uuid': nvp_conf[cluster_name].nvp_cluster_uuid, 'nova_zone_id': nvp_conf[cluster_name].nova_zone_id, 'nvp_controller_connection': nvp_conf[cluster_name].nvp_controller_connection, 'default_l3_gw_service_uuid': nvp_conf[cluster_name].default_l3_gw_service_uuid, 'default_l2_gw_service_uuid': nvp_conf[cluster_name].default_l2_gw_service_uuid, 'default_interface_name': nvp_conf[cluster_name].default_interface_name}) DCNL DCSP LOG.debug(_('Cluster DCSP options:%s'), clusters_options) DCNL DCSP if (not cfg.CONF.api_extensions_path): DCNL DCSP  DCSP cfg.CONF.set_override('api_extensions_path', 'quantum/plugins/nicira/nicira_nvp_plugin/extensions') DCNL DCSP if (cfg.CONF.NVP.enable_metadata_access_network and (not cfg.CONF.allow_overlapping_ips)): DCNL DCSP  DCSP LOG.warn(_('Overlapping DCSP IPs DCSP must DCSP be DCSP enabled DCSP in DCSP order DCSP to DCSP setup DCSP the DCSP metadata DCSP access DCSP network. DCSP Metadata DCSP access DCSP in DCSP routed DCSP mode DCSP will DCSP not DCSP work DCSP with DCSP this DCSP configuration')) DCNL DCSP return (cfg.CONF.NVP, clusters_options)
def _retrieve_extra_groups(conf, key=None, delimiter=':'): DCNL  DCSP results = [] DCNL DCSP for parsed_file in cfg.CONF._cparser.parsed: DCNL DCSP  DCSP for parsed_item in parsed_file.keys(): DCNL DCSP  DCSP  DCSP if (parsed_item not in cfg.CONF): DCNL DCSP  DCSP  DCSP  DCSP items = (key and parsed_item.split(delimiter)) DCNL DCSP  DCSP  DCSP  DCSP if ((not key) or (key == items[0])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(parsed_item) DCNL DCSP return results
def register_cluster_groups(conf): DCNL  DCSP cluster_names = [] DCNL DCSP cluster_tags = _retrieve_extra_groups(conf, 'CLUSTER') DCNL DCSP for tag in cluster_tags: DCNL DCSP  DCSP cluster_name = tag.split(':')[1] DCNL DCSP  DCSP conf.register_opts(cluster_opts, tag, cluster_name) DCNL DCSP  DCSP cluster_names.append(cluster_name) DCNL DCSP return cluster_names
def get_cluster_version(cluster): DCNL  DCSP uri = '/ws.v1/control-cluster/node?_page_length=1&fields=uuid' DCNL DCSP try: DCNL DCSP  DCSP res = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (res['result_count'] == 0): DCNL DCSP  DCSP return None DCNL DCSP node_uuid = res['results'][0]['uuid'] DCNL DCSP uri = ('/ws.v1/control-cluster/node/%s/status' % node_uuid) DCNL DCSP try: DCNL DCSP  DCSP res = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP version_parts = res['version'].split('.') DCNL DCSP version = ('%s.%s' % tuple(version_parts[:2])) DCNL DCSP LOG.info(_('NVP DCSP controller DCSP cluster DCSP version: DCSP %s'), version) DCNL DCSP return version
def do_single_request(*args, **kwargs): DCNL  DCSP cluster = kwargs['cluster'] DCNL DCSP try: DCNL DCSP  DCSP req = cluster.api_client.request(*args) DCNL DCSP except NvpApiClient.ResourceNotFound: DCNL DCSP  DCSP raise exception.NotFound() DCNL DCSP return req
def do_multi_request(*args, **kwargs): DCNL  DCSP results = [] DCNL DCSP clusters = kwargs['clusters'] DCNL DCSP for x in clusters: DCNL DCSP  DCSP LOG.debug(_('Issuing DCSP request DCSP to DCSP cluster: DCSP %s'), x.name) DCNL DCSP  DCSP rv = x.api_client.request(*args) DCNL DCSP  DCSP results.append(rv) DCNL DCSP return results
def find_port_and_cluster(clusters, port_id): DCNL  DCSP for c in clusters: DCNL DCSP  DCSP query = ('/ws.v1/lswitch/*/lport?uuid=%s&fields=*' % port_id) DCNL DCSP  DCSP LOG.debug(_("Looking DCSP for DCSP lswitch DCSP with DCSP port DCSP id DCSP '%(port_id)s' DCSP on: DCSP %(c)s"), locals()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = do_single_request(HTTP_GET, query, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.error(_('get_port_cluster_and_url, DCSP exception: DCSP %s'), str(e)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP return (None, None)
def create_l2_gw_service(cluster, tenant_id, display_name, devices): DCNL  DCSP tags = [{'tag': tenant_id, 'scope': 'os_tid'}] DCNL DCSP gateways = [{'transport_node_uuid': device['id'], 'device_id': device['interface_name'], 'type': 'L2Gateway'} for device in devices] DCNL DCSP gwservice_obj = {'display_name': _check_and_truncate_name(display_name), 'tags': tags, 'gateways': gateways, 'type': 'L2GatewayServiceConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loads(do_single_request('POST', _build_uri_path(GWSERVICE_RESOURCE), json.dumps(gwservice_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occured DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
def create_lrouter(cluster, tenant_id, display_name, nexthop): DCNL  DCSP tags = [{'tag': tenant_id, 'scope': 'os_tid'}] DCNL DCSP display_name = _check_and_truncate_name(display_name) DCNL DCSP lrouter_obj = {'display_name': display_name, 'tags': tags, 'routing_config': {'default_route_next_hop': {'gateway_ip_address': nexthop, 'type': 'RouterNextHop'}, 'type': 'SingleDefaultRouteImplicitRoutingConfig'}, 'type': 'LogicalRouterConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loads(do_single_request(HTTP_POST, _build_uri_path(LROUTER_RESOURCE), json.dumps(lrouter_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occured DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
def get_all_networks(cluster, tenant_id, networks): DCNL  DCSP uri = ('/ws.v1/lswitch?fields=*&tag=%s&tag_scope=os_tid' % tenant_id) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (not resp_obj): DCNL DCSP  DCSP return [] DCNL DCSP networks_result = copy(networks) DCNL DCSP return networks_result
def get_port_by_display_name(clusters, lswitch, display_name): DCNL  DCSP query = ('/ws.v1/lswitch/%s/lport?display_name=%s&fields=*' % (lswitch, display_name)) DCNL DCSP LOG.debug(_("Looking DCSP for DCSP port DCSP with DCSP display_name DCSP '%(display_name)s' DCSP on: DCSP %(lswitch)s"), locals()) DCNL DCSP for c in clusters: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res_obj = do_single_request(HTTP_GET, query, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loads(res_obj) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP LOG.error(_('Port DCSP or DCSP Network DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP raise exception.PortNotFound(port_id=display_name, net_id=lswitch)
def get_port_by_quantum_tag(cluster, lswitch_uuid, quantum_port_id): DCNL  DCSP uri = _build_uri_path(LSWITCHPORT_RESOURCE, parent_resource_id=lswitch_uuid, fields='uuid', filters={'tag': quantum_port_id, 'tag_scope': 'q_port_id'}) DCNL DCSP LOG.debug((_("Looking DCSP for DCSP port DCSP with DCSP q_port_id DCSP tag DCSP '%(quantum_port_id)s' DCSP on: DCSP '%(lswitch_uuid)s'") % {'quantum_port_id': quantum_port_id, 'lswitch_uuid': lswitch_uuid})) DCNL DCSP try: DCNL DCSP  DCSP res_obj = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occurred DCSP while DCSP querying DCSP NVP DCSP ports')) DCNL DCSP  DCSP raise DCNL DCSP res = json.loads(res_obj) DCNL DCSP num_results = len(res['results']) DCNL DCSP if (num_results >= 1): DCNL DCSP  DCSP if (num_results > 1): DCNL DCSP  DCSP  DCSP LOG.warn((_("Found DCSP '%(num_ports)d' DCSP ports DCSP with DCSP q_port_id DCSP tag: DCSP '%(quantum_port_id)s'. DCSP Only DCSP 1 DCSP was DCSP expected.") % {'num_ports': num_results, 'quantum_port_id': quantum_port_id})) DCNL DCSP  DCSP return res['results'][0]
def create_lport(cluster, lswitch_uuid, tenant_id, quantum_port_id, display_name, device_id, admin_status_enabled, mac_address=None, fixed_ips=None, port_security_enabled=None, security_profiles=None, queue_id=None): DCNL  DCSP hashed_device_id = hashlib.sha1(device_id).hexdigest() DCNL DCSP display_name = _check_and_truncate_name(display_name) DCNL DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=[dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id), dict(scope='vm_id', tag=hashed_device_id)]) DCNL DCSP _configure_extensions(lport_obj, mac_address, fixed_ips, port_security_enabled, security_profiles, queue_id) DCNL DCSP path = _build_uri_path(LSWITCHPORT_RESOURCE, parent_resource_id=lswitch_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_POST, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP switch DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Created DCSP logical DCSP port DCSP %(result)s DCSP on DCSP logical DCSP swtich DCSP %(uuid)s'), {'result': result['uuid'], 'uuid': lswitch_uuid}) DCNL DCSP return result
def create_router_lport(cluster, lrouter_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL  DCSP tags = [dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id)] DCNL DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=tags, ip_addresses=ip_addresses, type='LogicalRouterPortConfig') DCNL DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, parent_resource_id=lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_POST, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Created DCSP logical DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': result['uuid'], 'lrouter_uuid': lrouter_uuid}) DCNL DCSP return result
def update_router_lport(cluster, lrouter_uuid, lrouter_port_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL  DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=[dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id)], ip_addresses=ip_addresses, type='LogicalRouterPortConfig') DCNL DCSP for key in lport_obj.keys(): DCNL DCSP  DCSP if (lport_obj[key] is None): DCNL DCSP  DCSP  DCSP del lport_obj[key] DCNL DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, lrouter_port_uuid, parent_resource_id=lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_PUT, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP or DCSP router DCSP port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Updated DCSP logical DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': lrouter_port_uuid, 'lrouter_uuid': lrouter_uuid}) DCNL DCSP return result
def delete_router_lport(cluster, lrouter_uuid, lport_uuid): DCNL  DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, lport_uuid, lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP do_single_request(HTTP_DELETE, path, cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP LOG.debug(_('Delete DCSP logical DCSP router DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': lport_uuid, 'lrouter_uuid': lrouter_uuid})
def find_router_gw_port(context, cluster, router_id): DCNL  DCSP results = query_lrouter_lports(cluster, router_id, relations='LogicalPortAttachment') DCNL DCSP for lport in results: DCNL DCSP  DCSP if ('_relations' in lport): DCNL DCSP  DCSP  DCSP attachment = lport['_relations'].get('LogicalPortAttachment') DCNL DCSP  DCSP  DCSP if (attachment and (attachment.get('type') == 'L3GatewayAttachment')): DCNL DCSP  DCSP  DCSP  DCSP return lport
def plug_router_port_attachment(cluster, router_id, port_id, attachment_uuid, nvp_attachment_type, attachment_vlan=None): DCNL  DCSP uri = _build_uri_path(LROUTERPORT_RESOURCE, port_id, router_id, is_attachment=True) DCNL DCSP attach_obj = {} DCNL DCSP attach_obj['type'] = nvp_attachment_type DCNL DCSP if (nvp_attachment_type == 'PatchAttachment'): DCNL DCSP  DCSP attach_obj['peer_port_uuid'] = attachment_uuid DCNL DCSP elif (nvp_attachment_type == 'L3GatewayAttachment'): DCNL DCSP  DCSP attach_obj['l3_gateway_service_uuid'] = attachment_uuid DCNL DCSP  DCSP if attachment_vlan: DCNL DCSP  DCSP  DCSP attach_obj['vlan_id'] = attachment_vlan DCNL DCSP else: DCNL DCSP  DCSP raise Exception(_("Invalid DCSP NVP DCSP attachment DCSP type DCSP '%s'"), nvp_attachment_type) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_PUT, uri, json.dumps(attach_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.exception(_('Router DCSP Port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.Conflict as e: DCNL DCSP  DCSP LOG.exception(_('Conflict DCSP while DCSP setting DCSP router DCSP port DCSP attachment')) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP plug DCSP attachment DCSP into DCSP logical DCSP router DCSP port')) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP return result
def get_port_status(cluster, lswitch_id, port_id): DCNL  DCSP try: DCNL DCSP  DCSP r = do_single_request(HTTP_GET, ('/ws.v1/lswitch/%s/lport/%s/status' % (lswitch_id, port_id)), cluster=cluster) DCNL DCSP  DCSP r = json.loads(r) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise exception.PortNotFound(port_id=port_id, net_id=lswitch_id) DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (r['link_status_up'] is True): DCNL DCSP  DCSP return constants.PORT_STATUS_ACTIVE DCNL DCSP else: DCNL DCSP  DCSP return constants.PORT_STATUS_DOWN
def plug_l2_gw_service(cluster, lswitch_id, lport_id, gateway_id, vlan_id=None): DCNL  DCSP att_obj = {'type': 'L2GatewayAttachment', 'l2_gateway_service_uuid': gateway_id} DCNL DCSP if vlan_id: DCNL DCSP  DCSP att_obj['vlan_id'] = vlan_id DCNL DCSP return _plug_interface(cluster, lswitch_id, lport_id, att_obj)
def plug_interface(cluster, lswitch_id, port, type, attachment=None): DCNL  DCSP lport_obj = {} DCNL DCSP if attachment: DCNL DCSP  DCSP lport_obj['vif_uuid'] = attachment DCNL DCSP lport_obj['type'] = type DCNL DCSP return _plug_interface(cluster, lswitch_id, port, lport_obj)
def format_exception(etype, e, execption_locals, request=None): DCNL  DCSP msg = [('Error. DCSP %s DCSP exception: DCSP %s.' % (etype, e))] DCNL DCSP if request: DCNL DCSP  DCSP msg.append(('request=[%s]' % request)) DCNL DCSP  DCSP if request.body: DCNL DCSP  DCSP  DCSP msg.append(('request.body=[%s]' % str(request.body))) DCNL DCSP l = dict(((k, v) for (k, v) in execption_locals if (k != 'request'))) DCNL DCSP msg.append(('locals=[%s]' % str(l))) DCNL DCSP return ' DCSP '.join(msg)
def do_request(*args, **kwargs): DCNL  DCSP res = do_single_request(*args, **kwargs) DCNL DCSP if res: DCNL DCSP  DCSP return json.loads(res) DCNL DCSP return res
def mk_body(**kwargs): DCNL  DCSP return json.dumps(kwargs, ensure_ascii=False)
def set_tenant_id_tag(tenant_id, taglist=None): DCNL  DCSP new_taglist = [] DCNL DCSP if taglist: DCNL DCSP  DCSP new_taglist = [x for x in taglist if (x['scope'] != TENANT_ID_SCOPE)] DCNL DCSP new_taglist.append(dict(scope=TENANT_ID_SCOPE, tag=tenant_id)) DCNL DCSP return new_taglist
def check_cluster_connectivity(cluster): DCNL  DCSP try: DCNL DCSP  DCSP resp = do_single_request(HTTP_GET, '/ws.v1/control-cluster', cluster=cluster) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = ('Failed DCSP to DCSP connect DCSP to DCSP cluster DCSP %s: DCSP %s' % (cluster, str(e))) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP return json.loads(resp)
def _validate_device_list(data, valid_values=None): DCNL  DCSP if (not data): DCNL DCSP  DCSP msg = _('Cannot DCSP create DCSP a DCSP gateway DCSP with DCSP an DCSP empty DCSP device DCSP list') DCNL DCSP  DCSP return msg DCNL DCSP try: DCNL DCSP  DCSP for device in data: DCNL DCSP  DCSP  DCSP err_msg = attributes._validate_dict(device, key_specs={DEVICE_ID_ATTR: {'type:regex': attributes.UUID_PATTERN, 'required': True}, IFACE_NAME_ATTR: {'type:string': None, 'required': False}}) DCNL DCSP  DCSP  DCSP if err_msg: DCNL DCSP  DCSP  DCSP  DCSP return err_msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP provided DCSP data DCSP are DCSP not DCSP iterable') % _validate_device_list.__name__)
def _get_my_ip(): DCNL  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP (addr, _port) = csock.getsockname() DCNL DCSP csock.close() DCNL DCSP return addr
def get_port_from_device(port_id): DCNL  DCSP LOG.debug(_('get_port_with_securitygroups() DCSP called:port_id=%s'), port_id) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter((models_v2.Port.id == port_id)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict[ext_sg.SECURITYGROUPS] = [sg_id for (port, sg_id) in port_and_sgs if sg_id] DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
def sync_network_states(network_vlan_ranges): DCNL  DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = dict() DCNL DCSP  DCSP states = session.query(l2network_models_v2.NetworkState).all() DCNL DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP if (state.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[state.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[state.physical_network].add(state) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_ids = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_ids |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for state in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_ids.remove(state.vlan_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not state.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': state.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.delete(state) DCNL DCSP  DCSP  DCSP  DCSP del allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_id in sorted(vlan_ids): DCNL DCSP  DCSP  DCSP  DCSP state = l2network_models_v2.NetworkState(physical_network, vlan_id) DCNL DCSP  DCSP  DCSP  DCSP session.add(state) DCNL DCSP  DCSP for states in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP  DCSP if (not state.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': state.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(state)
def get_network_state(physical_network, vlan_id): DCNL  DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP state = session.query(l2network_models_v2.NetworkState).filter_by(physical_network=physical_network, vlan_id=vlan_id).one() DCNL DCSP  DCSP return state DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return None
def get_port_from_device(device): DCNL  DCSP LOG.debug(_('get_port_from_device() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter(models_v2.Port.id.startswith(device)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict['security_groups'] = [] DCNL DCSP for (port_in_db, sg_id) in port_and_sgs: DCNL DCSP  DCSP if sg_id: DCNL DCSP  DCSP  DCSP port_dict['security_groups'].append(sg_id) DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
def set_port_status(port_id, status): DCNL  DCSP LOG.debug(_('set_port_status DCSP as DCSP %s DCSP called'), status) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP port = session.query(models_v2.Port).filter_by(id=port_id).one() DCNL DCSP  DCSP port['status'] = status DCNL DCSP  DCSP session.merge(port) DCNL DCSP  DCSP session.flush() DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.PortNotFound(port_id=port_id)
@event.listens_for(ServiceRouterBinding.resource_type, 'set', retval=True) DCNL def validate_resource_type(target, value, oldvalue, initiator): DCNL  DCSP maxlen = ServiceRouterBinding.resource_type.property.columns[0].type.length DCNL DCSP if (len(value) > maxlen): DCNL DCSP  DCSP raise AttributeException(resource_type=value, maxlen=maxlen) DCNL DCSP return value
def parse_service_definition_opt(): DCNL  DCSP results = [] DCNL DCSP svc_def_opt = cfg.CONF.DEFAULT_SERVICETYPE.service_definition DCNL DCSP try: DCNL DCSP  DCSP for svc_def_str in svc_def_opt: DCNL DCSP  DCSP  DCSP split = svc_def_str.split(':') DCNL DCSP  DCSP  DCSP svc_def = {'service_class': split[0], 'plugin': split[1]} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_def['driver'] = split[2] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Default DCSP service DCSP type DCSP - DCSP no DCSP driver DCSP for DCSP service DCSP %(service_class)s DCSP and DCSP plugin DCSP %(plugin)s'), svc_def) DCNL DCSP  DCSP  DCSP results.append(svc_def) DCNL DCSP  DCSP return results DCNL DCSP except (TypeError, IndexError): DCNL DCSP  DCSP raise q_exc.InvalidConfigurationOption(opt_name='service_definition', opt_value=svc_def_opt)
def paginate_query(query, model, limit, sorts, marker_obj=None): DCNL  DCSP if (not sorts): DCNL DCSP  DCSP return query DCNL DCSP assert (not (limit and (len((set(dict(sorts).keys()) & set(model.__table__.primary_key.columns.keys()))) == 0))) DCNL DCSP for (sort_key, sort_direction) in sorts: DCNL DCSP  DCSP sort_dir_func = (sqlalchemy.asc if sort_direction else sqlalchemy.desc) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP msg = (_('%s DCSP is DCSP invalid DCSP attribute DCSP for DCSP sort_key') % sort_key) DCNL DCSP  DCSP  DCSP raise q_exc.BadRequest(resource=model.__tablename__, msg=msg) DCNL DCSP  DCSP if isinstance(sort_key_attr.property, RelationshipProperty): DCNL DCSP  DCSP  DCSP msg = (_("The DCSP attribute DCSP '%(attr)s' DCSP is DCSP reference DCSP to DCSP other DCSP resource, DCSP can't DCSP used DCSP by DCSP sort DCSP '%(resource)s'") % {'attr': sort_key, 'resource': model.__tablename__}) DCNL DCSP  DCSP  DCSP raise q_exc.BadRequest(resource=model.__tablename__, msg=msg) DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if marker_obj: DCNL DCSP  DCSP marker_values = [getattr(marker_obj, sort[0]) for sort in sorts] DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for (i, sort) in enumerate(sorts): DCNL DCSP  DCSP  DCSP crit_attrs = [(getattr(model, sorts[j][0]) == marker_values[j]) for j in xrange(i)] DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort[0]) DCNL DCSP  DCSP  DCSP if sort[1]: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if limit: DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def run_migrations_offline(): DCNL  DCSP context.configure(url=quantum_config.DATABASE.sql_connection) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations(active_plugin=quantum_config.core_plugin, options=build_options())
def run_migrations_online(): DCNL  DCSP engine = create_engine(quantum_config.DATABASE.sql_connection, poolclass=pool.NullPool) DCNL DCSP connection = engine.connect() DCNL DCSP context.configure(connection=connection, target_metadata=target_metadata) DCNL DCSP try: DCNL DCSP  DCSP with context.begin_transaction(): DCNL DCSP  DCSP  DCSP context.run_migrations(active_plugin=quantum_config.core_plugin, options=build_options()) DCNL DCSP finally: DCNL DCSP  DCSP connection.close()
def upgrade(active_plugin=None, options=None): DCNL  DCSP pass
def downgrade(active_plugin=None, options=None): DCNL  DCSP pass
def configure_db(): DCNL  DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP sql_connection = cfg.CONF.DATABASE.sql_connection DCNL DCSP  DCSP if (not sql_connection): DCNL DCSP  DCSP  DCSP LOG.warn(_(("Option DCSP 'sql_connection' DCSP not DCSP specified DCSP in DCSP any DCSP config DCSP file DCSP - DCSP using DCSP default DCSP value DCSP '%s'" % SQL_CONNECTION_DEFAULT))) DCNL DCSP  DCSP  DCSP sql_connection = SQL_CONNECTION_DEFAULT DCNL DCSP  DCSP connection_dict = sql.engine.url.make_url(sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': 3600, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [MySQLPingListener()] DCNL DCSP  DCSP  DCSP if ((MySQLdb is not None) and cfg.CONF.DATABASE.sql_dbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP pool_args = {'db': connection_dict.database, 'passwd': (connection_dict.password or ''), 'host': connection_dict.host, 'user': connection_dict.username, 'min_size': cfg.CONF.DATABASE.sql_min_pool_size, 'max_size': cfg.CONF.DATABASE.sql_max_pool_size, 'max_idle': cfg.CONF.DATABASE.sql_idle_timeout} DCNL DCSP  DCSP  DCSP  DCSP pool = db_pool.ConnectionPool(MySQLdb, **pool_args) DCNL DCSP  DCSP  DCSP  DCSP def creator(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP conn = pool.create() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(conn, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (_1, _2, conn) = conn DCNL DCSP  DCSP  DCSP  DCSP  DCSP return conn DCNL DCSP  DCSP  DCSP  DCSP engine_args['creator'] = creator DCNL DCSP  DCSP  DCSP if ((MySQLdb is None) and cfg.CONF.DATABASE.sql_dbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_('Eventlet DCSP connection DCSP pooling DCSP will DCSP not DCSP work DCSP without DCSP python-mysqldb!')) DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqliteForeignKeysListener()] DCNL DCSP  DCSP  DCSP if (sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = create_engine(sql_connection, **engine_args) DCNL DCSP  DCSP sql.event.listen(_ENGINE, 'checkin', greenthread_yield) DCNL DCSP  DCSP if (not register_models()): DCNL DCSP  DCSP  DCSP if cfg.CONF.DATABASE.reconnect_interval: DCNL DCSP  DCSP  DCSP  DCSP remaining = cfg.CONF.DATABASE.sql_max_retries DCNL DCSP  DCSP  DCSP  DCSP reconnect_interval = cfg.CONF.DATABASE.reconnect_interval DCNL DCSP  DCSP  DCSP  DCSP retry_registration(remaining, reconnect_interval)
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
def register_models(base=BASE): DCNL  DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP try: DCNL DCSP  DCSP base.metadata.create_all(_ENGINE) DCNL DCSP except sql.exc.OperationalError as e: DCNL DCSP  DCSP LOG.info(_('Database DCSP registration DCSP exception: DCSP %s'), e) DCNL DCSP  DCSP return False DCNL DCSP return True
def unregister_models(base=BASE): DCNL  DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP base.metadata.drop_all(_ENGINE)
def greenthread_yield(dbapi_con, con_record): DCNL  DCSP greenthread.sleep(0)
def pipeline_factory(loader, global_conf, **local_conf): DCNL  DCSP pipeline = local_conf[cfg.CONF.auth_strategy] DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
def _validate_servicetype_ref(data, valid_values=None): DCNL  DCSP svc_type_id = data DCNL DCSP svctype_mgr = servicetype_db.ServiceTypeManager.get_instance() DCNL DCSP try: DCNL DCSP  DCSP svctype_mgr.get_service_type(context.get_admin_context(), svc_type_id) DCNL DCSP except servicetype_db.ServiceTypeNotFound: DCNL DCSP  DCSP return (_("The DCSP service DCSP type DCSP '%s' DCSP does DCSP not DCSP exist") % svc_type_id)
def _validate_service_defs(data, valid_values=None): DCNL  DCSP try: DCNL DCSP  DCSP if (len(data) == 0): DCNL DCSP  DCSP  DCSP return _('No DCSP service DCSP type DCSP definition DCSP was DCSP provided. DCSP At DCSP least DCSP a DCSP service DCSP type DCSP definition DCSP must DCSP be DCSP provided') DCNL DCSP  DCSP f_name = _validate_service_defs.__name__ DCNL DCSP  DCSP for svc_def in data: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_def_copy = svc_def.copy() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP svc_name = svc_def_copy.pop(SERVICE_ATTR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP plugin_name = svc_def_copy.pop(PLUGIN_ATTR) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Required DCSP attributes DCSP missing DCSP in DCSP service DCSP definition: DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_name not in constants.ALLOWED_SERVICES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Service DCSP name DCSP '%s' DCSP unspecified DCSP or DCSP invalid") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (not plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Plugin DCSP name DCSP not DCSP specified DCSP in DCSP service DCSP definition DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP svc_plugin = manager.QuantumManager.get_service_plugins().get(svc_name) DCNL DCSP  DCSP  DCSP  DCSP if (not svc_plugin): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("No DCSP plugin DCSP for DCSP service DCSP '%s'") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_plugin.get_plugin_name() != plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Plugin DCSP name DCSP '%s' DCSP is DCSP not DCSP correct DCSP ") % plugin_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP driver = svc_def_copy.get(DRIVER_ATTR) DCNL DCSP  DCSP  DCSP  DCSP if driver: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = attributes._validate_string(driver) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP  DCSP del svc_def_copy[DRIVER_ATTR] DCNL DCSP  DCSP  DCSP  DCSP if len(svc_def_copy): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Unparseable DCSP attributes DCSP found DCSP in DCSP service DCSP definition DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Exception DCSP while DCSP parsing DCSP service DCSP definition:%s'), svc_def) DCNL DCSP  DCSP  DCSP  DCSP msg = (_('Was DCSP expecting DCSP a DCSP dict DCSP for DCSP service DCSP definition, DCSP found DCSP the DCSP following: DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP provided DCSP data DCSP are DCSP not DCSP iterable') % _validate_service_defs.__name__)
def _ofc(id): DCNL  DCSP return ('ofc-%s' % id)
def record_messages(connection, topic, output): DCNL  DCSP def process_event(body): DCNL DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP pickle.dump(body, output) DCNL DCSP connection.declare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass
def monitor_messages(connection, topic): DCNL  DCSP def process_event(msg): DCNL DCSP  DCSP body = msg['args']['data'] DCNL DCSP  DCSP if ('resource_id' in body): DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s/%-15s: DCSP %s' % (body.get('timestamp'), body.get('resource_id'), body.get('event_type'), body.get('counter_volume'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type'))) DCNL DCSP connection.declare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass
def send_messages(connection, topic, input): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP body = pickle.load(input) DCNL DCSP  DCSP except EOFError: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP connection.topic_send(topic, body)
@blueprint.route('/meters') DCNL def list_meters_all(): DCNL  DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
@blueprint.route('/resources/<resource>/meters') DCNL def list_meters_by_resource(resource): DCNL  DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(resource=resource, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
@blueprint.route('/users/<user>/meters') DCNL def list_meters_by_user(user): DCNL  DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(user=user, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
@blueprint.route('/projects/<project>/meters') DCNL def list_meters_by_project(project): DCNL  DCSP check_authorized_project(project) DCNL DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(project=project, metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
@blueprint.route('/sources/<source>/meters') DCNL def list_meters_by_source(source): DCNL  DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(source=source, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
def _list_resources(source=None, user=None, project=None): DCNL  DCSP rq = flask.request DCNL DCSP q_ts = _get_query_timestamps(rq.args) DCNL DCSP resources = rq.storage_conn.get_resources(source=source, user=user, project=project, start_timestamp=q_ts['start_timestamp'], end_timestamp=q_ts['end_timestamp'], metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(resources=[r.as_dict() for r in resources])
@blueprint.route('/projects/<project>/resources') DCNL def list_resources_by_project(project): DCNL  DCSP check_authorized_project(project) DCNL DCSP return _list_resources(project=project)
@blueprint.route('/resources') DCNL def list_all_resources(): DCNL  DCSP return _list_resources(project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/sources/<source>') DCNL def get_source(source): DCNL  DCSP return flask.jsonify(flask.request.sources.get(source, {}))
@blueprint.route('/sources/<source>/resources') DCNL def list_resources_by_source(source): DCNL  DCSP return _list_resources(source=source, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/users/<user>/resources') DCNL def list_resources_by_user(user): DCNL  DCSP return _list_resources(user=user, project=acl.get_limited_to_project(flask.request.headers))
def _list_users(source=None): DCNL  DCSP if acl.get_limited_to_project(flask.request.headers): DCNL DCSP  DCSP users = [flask.request.headers.get('X-User-id')] DCNL DCSP else: DCNL DCSP  DCSP users = flask.request.storage_conn.get_users(source=source) DCNL DCSP return flask.jsonify(users=list(users))
@blueprint.route('/users') DCNL def list_all_users(): DCNL  DCSP return _list_users()
@blueprint.route('/sources/<source>/users') DCNL def list_users_by_source(source): DCNL  DCSP return _list_users(source=source)
def _list_projects(source=None): DCNL  DCSP project = acl.get_limited_to_project(flask.request.headers) DCNL DCSP if project: DCNL DCSP  DCSP if source: DCNL DCSP  DCSP  DCSP if (project in flask.request.storage_conn.get_projects(source=source)): DCNL DCSP  DCSP  DCSP  DCSP projects = [project] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP projects = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP projects = [project] DCNL DCSP else: DCNL DCSP  DCSP projects = flask.request.storage_conn.get_projects(source=source) DCNL DCSP return flask.jsonify(projects=list(projects))
@blueprint.route('/projects') DCNL def list_all_projects(): DCNL  DCSP return _list_projects()
@blueprint.route('/sources/<source>/projects') DCNL def list_projects_by_source(source): DCNL  DCSP return _list_projects(source=source)
def _list_samples(meter, project=None, resource=None, source=None, user=None): DCNL  DCSP q_ts = _get_query_timestamps(flask.request.args) DCNL DCSP f = storage.SampleFilter(user=user, project=project, source=source, meter=meter, resource=resource, start=q_ts['start_timestamp'], end=q_ts['end_timestamp'], metaquery=_get_metaquery(flask.request.args)) DCNL DCSP samples = flask.request.storage_conn.get_samples(f) DCNL DCSP jsonified = flask.jsonify(events=[s.as_dict() for s in samples]) DCNL DCSP if request_wants_html(): DCNL DCSP  DCSP return flask.templating.render_template('list_event.html', user=user, project=project, source=source, meter=meter, resource=resource, events=jsonified) DCNL DCSP return jsonified
@blueprint.route('/projects/<project>/meters/<meter>') DCNL def list_samples_by_project(project, meter): DCNL  DCSP check_authorized_project(project) DCNL DCSP return _list_samples(project=project, meter=meter)
@blueprint.route('/resources/<resource>/meters/<meter>') DCNL def list_samples_by_resource(resource, meter): DCNL  DCSP return _list_samples(resource=resource, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/sources/<source>/meters/<meter>') DCNL def list_samples_by_source(source, meter): DCNL  DCSP return _list_samples(source=source, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/users/<user>/meters/<meter>') DCNL def list_samples_by_user(user, meter): DCNL  DCSP return _list_samples(user=user, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/resources/<resource>/meters/<meter>/duration') DCNL def compute_duration_by_resource(resource, meter): DCNL  DCSP q_ts = _get_query_timestamps(flask.request.args) DCNL DCSP start_timestamp = q_ts['start_timestamp'] DCNL DCSP end_timestamp = q_ts['end_timestamp'] DCNL DCSP f = storage.SampleFilter(meter=meter, project=acl.get_limited_to_project(flask.request.headers), resource=resource, start=q_ts['query_start'], end=q_ts['query_end']) DCNL DCSP stats = flask.request.storage_conn.get_meter_statistics(f) DCNL DCSP (min_ts, max_ts) = (stats.duration_start, stats.duration_end) DCNL DCSP LOG.debug('start_timestamp DCSP %s, DCSP end_timestamp DCSP %s, DCSP min_ts DCSP %s, DCSP max_ts DCSP %s', start_timestamp, end_timestamp, min_ts, max_ts) DCNL DCSP if (start_timestamp and min_ts and (min_ts < start_timestamp)): DCNL DCSP  DCSP min_ts = start_timestamp DCNL DCSP  DCSP LOG.debug('clamping DCSP min DCSP timestamp DCSP to DCSP range') DCNL DCSP if (end_timestamp and max_ts and (max_ts > end_timestamp)): DCNL DCSP  DCSP max_ts = end_timestamp DCNL DCSP  DCSP LOG.debug('clamping DCSP max DCSP timestamp DCSP to DCSP range') DCNL DCSP if (min_ts and max_ts and (min_ts <= max_ts)): DCNL DCSP  DCSP duration = timeutils.delta_seconds(min_ts, max_ts) DCNL DCSP else: DCNL DCSP  DCSP min_ts = max_ts = duration = None DCNL DCSP return flask.jsonify(start_timestamp=min_ts, end_timestamp=max_ts, duration=duration)
@blueprint.route('/resources/<resource>/meters/<meter>/volume/max') DCNL def compute_max_resource_volume(resource, meter): DCNL  DCSP return _get_statistics('max', meter=meter, resource=resource, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/resources/<resource>/meters/<meter>/volume/sum') DCNL def compute_resource_volume_sum(resource, meter): DCNL  DCSP return _get_statistics('sum', meter=meter, resource=resource, project=acl.get_limited_to_project(flask.request.headers))
@blueprint.route('/projects/<project>/meters/<meter>/volume/max') DCNL def compute_project_volume_max(project, meter): DCNL  DCSP check_authorized_project(project) DCNL DCSP return _get_statistics('max', project=project, meter=meter)
@blueprint.route('/projects/<project>/meters/<meter>/volume/sum') DCNL def compute_project_volume_sum(project, meter): DCNL  DCSP check_authorized_project(project) DCNL DCSP return _get_statistics('sum', meter=meter, project=project)
def _sanitize_query(q): DCNL  DCSP auth_project = acl.get_limited_to_project(pecan.request.headers) DCNL DCSP if auth_project: DCNL DCSP  DCSP proj_q = [i for i in q if (i.field == 'project_id')] DCNL DCSP  DCSP for i in proj_q: DCNL DCSP  DCSP  DCSP if ((auth_project != i.value) or (i.op != 'eq')): DCNL DCSP  DCSP  DCSP  DCSP errstr = ('Not DCSP Authorized DCSP to DCSP access DCSP project DCSP %s DCSP %s' % (i.op, i.value)) DCNL DCSP  DCSP  DCSP  DCSP raise wsme.exc.ClientSideError(errstr) DCNL DCSP  DCSP if (not proj_q): DCNL DCSP  DCSP  DCSP q.append(Query(field='project_id', op='eq', value=auth_project)) DCNL DCSP return q
def _get_query_timestamps(args={}): DCNL  DCSP search_offset = int(args.get('search_offset', 0)) DCNL DCSP start_timestamp = args.get('start_timestamp') DCNL DCSP if start_timestamp: DCNL DCSP  DCSP start_timestamp = timeutils.parse_isotime(start_timestamp) DCNL DCSP  DCSP start_timestamp = start_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP query_start = (start_timestamp - datetime.timedelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP query_start = None DCNL DCSP end_timestamp = args.get('end_timestamp') DCNL DCSP if end_timestamp: DCNL DCSP  DCSP end_timestamp = timeutils.parse_isotime(end_timestamp) DCNL DCSP  DCSP end_timestamp = end_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP query_end = (end_timestamp + datetime.timedelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP query_end = None DCNL DCSP return {'query_start': query_start, 'query_end': query_end, 'start_timestamp': start_timestamp, 'end_timestamp': end_timestamp, 'search_offset': search_offset}
def _flatten_metadata(metadata): DCNL  DCSP if metadata: DCNL DCSP  DCSP return dict(((k, unicode(v)) for (k, v) in metadata.iteritems() if (type(v) not in set([list, dict, set])))) DCNL DCSP return {}
def register_opts(conf): DCNL  DCSP conf.register_opts(auth_token.opts, group=OPT_GROUP_NAME) DCNL DCSP auth_token.CONF = conf
def install(app, conf): DCNL  DCSP return auth_token.AuthProtocol(app, conf=dict(conf.get(OPT_GROUP_NAME)))
def get_limited_to_project(headers): DCNL  DCSP global _ENFORCER DCNL DCSP if (not _ENFORCER): DCNL DCSP  DCSP _ENFORCER = policy.Enforcer() DCNL DCSP if (not _ENFORCER.enforce('context_is_admin', {}, {'roles': headers.get('X-Roles', '').split(',')})): DCNL DCSP  DCSP return headers.get('X-Tenant-Id')
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP if kwargs: DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root and (os.geteuid() != 0)): DCNL DCSP  DCSP if (not root_helper): DCNL DCSP  DCSP  DCSP raise NoRootWrapSpecified(message='Command DCSP requested DCSP root, DCSP but DCSP did DCSP not DCSP specify DCSP a DCSP root DCSP helper.') DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fds = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fds = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=close_fds, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def trycmd(*args, **kwargs): DCNL  DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
def _is_in_group(opt, group): DCNL  DCSP for (key, value) in group._opts.items(): DCNL DCSP  DCSP if (value['opt'] == opt): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def _sanitize_default(s): DCNL  DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.gethostname()): DCNL DCSP  DCSP return 'ceilometer' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def install(domain): DCNL  DCSP gettext.install(domain, localedir=os.environ.get((domain.upper() + '_LOCALEDIR')), unicode=True)
def get_lazy_gettext(domain): DCNL  DCSP def _lazy_gettext(msg): DCNL DCSP  DCSP 'Create DCSP and DCSP return DCSP a DCSP Message DCSP object.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Message DCSP encapsulates DCSP a DCSP string DCSP so DCSP that DCSP we DCSP can DCSP translate DCSP it DCSP later DCSP when\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needed.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return Message(msg, domain) DCNL DCSP return _lazy_gettext
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP _load_log_config(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def getLazyLogger(name='unknown', version='unknown'): DCNL  DCSP return LazyAdapter(name, version)
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %s') % rule)) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def _parse_list_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (not or_list): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
def _parse_tokenize(rule): DCNL  DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
def reducer(*tokens): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def _parse_text_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
def parse_rule(rule): DCNL  DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
def _thread_done(gt, *args, **kwargs): DCNL  DCSP kwargs['group'].thread_done(kwargs['thread'])
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def synchronized_with_prefix(lock_file_prefix): DCNL  DCSP return functools.partial(synchronized, lock_file_prefix=lock_file_prefix)
def set_defaults(sql_connection, sqlite_db, max_pool_size=None, max_overflow=None, pool_timeout=None): DCNL  DCSP cfg.set_defaults(database_opts, connection=sql_connection) DCNL DCSP cfg.set_defaults(sqlite_db_opts, sqlite_db=sqlite_db) DCNL DCSP if (max_pool_size is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, max_pool_size=max_pool_size) DCNL DCSP if (max_overflow is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, max_overflow=max_overflow) DCNL DCSP if (pool_timeout is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, pool_timeout=pool_timeout)
def get_session(autocommit=True, expire_on_commit=False, sqlite_fk=False, slave_session=False): DCNL  DCSP global _MAKER DCNL DCSP global _SLAVE_MAKER DCNL DCSP maker = _MAKER DCNL DCSP if slave_session: DCNL DCSP  DCSP maker = _SLAVE_MAKER DCNL DCSP if (maker is None): DCNL DCSP  DCSP engine = get_engine(sqlite_fk=sqlite_fk, slave_engine=slave_session) DCNL DCSP  DCSP maker = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP if slave_session: DCNL DCSP  DCSP _SLAVE_MAKER = maker DCNL DCSP else: DCNL DCSP  DCSP _MAKER = maker DCNL DCSP session = maker() DCNL DCSP return session
def _raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL  DCSP def get_columns_from_uniq_cons_or_name(columns): DCNL DCSP  DCSP uniqbase = 'uniq_' DCNL DCSP  DCSP if (not columns.startswith(uniqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.index('_') + 1):columns.rindex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqbase):].split('0')[1:] DCNL DCSP if (engine_name not in ['mysql', 'sqlite', 'postgresql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
def _raise_if_deadlock_error(operational_error, engine_name): DCNL  DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeadlock(operational_error)
def get_engine(sqlite_fk=False, slave_engine=False): DCNL  DCSP global _ENGINE DCNL DCSP global _SLAVE_ENGINE DCNL DCSP engine = _ENGINE DCNL DCSP db_uri = CONF.database.connection DCNL DCSP if slave_engine: DCNL DCSP  DCSP engine = _SLAVE_ENGINE DCNL DCSP  DCSP db_uri = CONF.database.slave_connection DCNL DCSP if (engine is None): DCNL DCSP  DCSP engine = create_engine(db_uri, sqlite_fk=sqlite_fk) DCNL DCSP if slave_engine: DCNL DCSP  DCSP _SLAVE_ENGINE = engine DCNL DCSP else: DCNL DCSP  DCSP _ENGINE = engine DCNL DCSP return engine
def _synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
def _add_regexp_listener(dbapi_con, con_record): DCNL  DCSP def regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(six.text_type(item)) is not None) DCNL DCSP dbapi_con.create_function('regexp', 2, regexp)
def _greenthread_yield(dbapi_con, con_record): DCNL  DCSP greenthread.sleep(0)
def _ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def _is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def create_engine(sql_connection, sqlite_fk=False): DCNL  DCSP _assert_matching_drivers() DCNL DCSP connection_dict = sqlalchemy.engine.url.make_url(sql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.database.idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP if (CONF.database.connection_debug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP elif (CONF.database.connection_debug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if sqlite_fk: DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqliteForeignKeysListener()] DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.database.connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP else: DCNL DCSP  DCSP if (CONF.database.max_pool_size is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_size'] = CONF.database.max_pool_size DCNL DCSP  DCSP if (CONF.database.max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.database.max_overflow DCNL DCSP  DCSP if (CONF.database.pool_timeout is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_timeout'] = CONF.database.pool_timeout DCNL DCSP engine = sqlalchemy.create_engine(sql_connection, **engine_args) DCNL DCSP sqlalchemy.event.listen(engine, 'checkin', _greenthread_yield) DCNL DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'checkout', _ping_listener) DCNL DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if (not CONF.sqlite_synchronous): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', _synchronous_switch_listener) DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', _add_regexp_listener) DCNL DCSP if (CONF.database.connection_trace and (engine.dialect.dbapi.__name__ == 'MySQLdb')): DCNL DCSP  DCSP _patch_mysqldb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not _is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.database.max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.database.retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not _is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, query_cls=Query)
def _patch_mysqldb_with_stacktrace_comments(): DCNL  DCSP import MySQLdb.cursors DCNL DCSP import traceback DCNL DCSP old_mysql_do_query = MySQLdb.cursors.BaseCursor._do_query DCNL DCSP def _do_query(self, q): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, method, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.endswith('session.py') and (method == '_do_query')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('api.py') and (method == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('utils.py') and (method == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('exception.py') and (method == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.endswith('db/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP index = file.rfind('ceilometer') DCNL DCSP  DCSP  DCSP if (index == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Method:%s() DCSP Line:%s DCSP | DCSP ' % (file[index:], line, method, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qq = ('%s DCSP /* DCSP %s DCSP */' % (q, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qq = q DCNL DCSP  DCSP old_mysql_do_query(self, qq) DCNL DCSP setattr(MySQLdb.cursors.BaseCursor, '_do_query', _do_query)
def _assert_matching_drivers(): DCNL  DCSP if (CONF.database.slave_connection == ''): DCNL DCSP  DCSP return DCNL DCSP normal = sqlalchemy.engine.url.make_url(CONF.database.connection) DCNL DCSP slave = sqlalchemy.engine.url.make_url(CONF.database.slave_connection) DCNL DCSP assert (normal.drivername == slave.drivername)
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in range(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in range(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def _get_drivers(): DCNL  DCSP global drivers DCNL DCSP if (drivers is None): DCNL DCSP  DCSP drivers = [] DCNL DCSP  DCSP for notification_driver in CONF.list_notifier_drivers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP drivers.append(importutils.import_module(notification_driver)) DCNL DCSP  DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP  DCSP drivers.append(ImportFailureNotifier(e)) DCNL DCSP return drivers
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP drivers.append(importutils.import_module(notification_driver)) DCNL DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP drivers.append(ImportFailureNotifier(e)) DCNL DCSP else: DCNL DCSP  DCSP drivers.append(notification_driver)
def remove_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP removed = False DCNL DCSP if (notification_driver in drivers): DCNL DCSP  DCSP drivers.remove(notification_driver) DCNL DCSP  DCSP removed = True DCNL DCSP else: DCNL DCSP  DCSP for driver in drivers: DCNL DCSP  DCSP  DCSP if (_object_name(driver) == notification_driver): DCNL DCSP  DCSP  DCSP  DCSP drivers.remove(driver) DCNL DCSP  DCSP  DCSP  DCSP removed = True DCNL DCSP if (not removed): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP remove; DCSP %s DCSP is DCSP not DCSP in DCSP list' % notification_driver))
def notify(context, message): DCNL  DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, message) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP driver DCSP %(driver)s."), locals())
def _reset_drivers(): DCNL  DCSP global drivers DCNL DCSP drivers = None
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('ceilometer.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, namespace, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, namespace, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), six.text_type(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP cls_name = str(failure.__class__.__name__) DCNL DCSP mod_name = str(failure.__class__.__module__) DCNL DCSP if (cls_name.endswith(_REMOTE_POSTFIX) and mod_name.endswith(_REMOTE_POSTFIX)): DCNL DCSP  DCSP cls_name = cls_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP  DCSP mod_name = mod_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP data = {'class': cls_name, 'module': mod_name, 'message': six.text_type(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (not queues): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def read_cached_file(filename, force_reload=False): DCNL  DCSP global _FILE_CACHE DCNL DCSP if (force_reload and (filename in _FILE_CACHE)): DCNL DCSP  DCSP del _FILE_CACHE[filename] DCNL DCSP reloaded = False DCNL DCSP mtime = os.path.getmtime(filename) DCNL DCSP cache_info = _FILE_CACHE.setdefault(filename, {}) DCNL DCSP if ((not cache_info) or (mtime > cache_info.get('mtime', 0))): DCNL DCSP  DCSP LOG.debug((_('Reloading DCSP cached DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP reloaded = True DCNL DCSP return (reloaded, cache_info['data'])
def delete_if_exists(path): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def notify(context, message): DCNL  DCSP if (not _notification_manager): DCNL DCSP  DCSP _load_notification_manager() DCNL DCSP if (not _pipeline_manager): DCNL DCSP  DCSP _load_pipeline_manager() DCNL DCSP _notification_manager.map(_process_notification_for_ext, context=(context or req_context.get_admin_context()), notification=message)
def setup_pipeline(transformer_manager): DCNL  DCSP cfg_file = cfg.CONF.pipeline_cfg_file DCNL DCSP if (not os.path.exists(cfg_file)): DCNL DCSP  DCSP cfg_file = cfg.CONF.find_file(cfg_file) DCNL DCSP LOG.debug('Pipeline DCSP config DCSP file: DCSP %s', cfg_file) DCNL DCSP with open(cfg_file) as fap: DCNL DCSP  DCSP data = fap.read() DCNL DCSP pipeline_cfg = yaml.safe_load(data) DCNL DCSP LOG.info('Pipeline DCSP config: DCSP %s', pipeline_cfg) DCNL DCSP return PipelineManager(pipeline_cfg, transformer_manager)
def recursive_keypairs(d): DCNL  DCSP for (name, value) in sorted(d.iteritems()): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP for (subname, subvalue) in recursive_keypairs(value): DCNL DCSP  DCSP  DCSP  DCSP (yield (('%s:%s' % (name, subname)), subvalue)) DCNL DCSP  DCSP elif isinstance(value, (tuple, list)): DCNL DCSP  DCSP  DCSP (yield (name, list(map((lambda x: unicode(x).encode('utf-8')), value)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield (name, value))
def dt_to_decimal(utc): DCNL  DCSP decimal.getcontext().prec = 30 DCNL DCSP return (decimal.Decimal(str(calendar.timegm(utc.utctimetuple()))) + (decimal.Decimal(str(utc.microsecond)) / decimal.Decimal('1000000.0')))
def decimal_to_dt(dec): DCNL  DCSP if (dec is None): DCNL DCSP  DCSP return None DCNL DCSP integer = int(dec) DCNL DCSP micro = ((dec - decimal.Decimal(integer)) * decimal.Decimal(1000000)) DCNL DCSP daittyme = datetime.datetime.utcfromtimestamp(integer) DCNL DCSP return daittyme.replace(microsecond=int(round(micro)))
def sanitize_timestamp(timestamp): DCNL  DCSP if (not timestamp): DCNL DCSP  DCSP return timestamp DCNL DCSP if (not isinstance(timestamp, datetime.datetime)): DCNL DCSP  DCSP timestamp = timeutils.parse_isotime(timestamp) DCNL DCSP return timeutils.normalize_time(timestamp)
def get_metadata_from_object(instance): DCNL  DCSP metadata = {'display_name': instance.name, 'name': getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', u''), 'instance_type': (instance.flavor['id'] if instance.flavor else None), 'host': instance.hostId, 'image_ref': (instance.image['id'] if instance.image else None)} DCNL DCSP if (instance.image and instance.image.get('links')): DCNL DCSP  DCSP metadata['image_ref_url'] = instance.image['links'][0]['href'] DCNL DCSP else: DCNL DCSP  DCSP metadata['image_ref_url'] = None DCNL DCSP for name in INSTANCE_PROPERTIES: DCNL DCSP  DCSP metadata[name] = getattr(instance, name, u'') DCNL DCSP return metadata
def initialize_gatherer(gatherer=None): DCNL  DCSP global _gatherer DCNL DCSP if (gatherer is not None): DCNL DCSP  DCSP LOG.debug(_('using DCSP provided DCSP stats DCSP gatherer DCSP %r'), gatherer) DCNL DCSP  DCSP _gatherer = gatherer DCNL DCSP if (_gatherer is None): DCNL DCSP  DCSP LOG.debug(_('making DCSP a DCSP new DCSP stats DCSP gatherer')) DCNL DCSP  DCSP mgr = extension.ExtensionManager(namespace='ceilometer.poll.compute', invoke_on_load=True) DCNL DCSP  DCSP _gatherer = DeletedInstanceStatsGatherer(mgr) DCNL DCSP return _gatherer
def _instance_name(instance): DCNL  DCSP return getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', None)
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def reverse_timestamp(dt): DCNL  DCSP epoch = datetime.datetime(1970, 1, 1) DCNL DCSP td = (dt - epoch) DCNL DCSP ts = ((td.microseconds + ((td.seconds + ((td.days * 24) * 3600)) * 100000)) / 100000) DCNL DCSP return (9223372036854775807 - ts)
def make_query(user=None, project=None, meter=None, resource=None, source=None, start=None, end=None, require_meter=True, query_only=False): DCNL  DCSP q = [] DCNL DCSP if user: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'user_id', DCSP =, DCSP 'binary:%s')" % user)) DCNL DCSP if project: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'project_id', DCSP =, DCSP 'binary:%s')" % project)) DCNL DCSP if resource: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'resource_id', DCSP =, DCSP 'binary:%s')" % resource)) DCNL DCSP if source: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'source', DCSP =, DCSP 'binary:%s')" % source)) DCNL DCSP (start_row, end_row) = ('', '') DCNL DCSP rts_start = (str((reverse_timestamp(start) + 1)) if start else '') DCNL DCSP rts_end = (str((reverse_timestamp(end) + 1)) if end else '') DCNL DCSP if meter: DCNL DCSP  DCSP (start_row, end_row) = _make_rowkey_scan(meter, rts_start, rts_end) DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP else: DCNL DCSP  DCSP if rts_start: DCNL DCSP  DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP <=, DCSP 'binary:%s')" % rts_start)) DCNL DCSP  DCSP if rts_end: DCNL DCSP  DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP >=, DCSP 'binary:%s')" % rts_end)) DCNL DCSP sample_filter = None DCNL DCSP if len(q): DCNL DCSP  DCSP sample_filter = ' DCSP AND DCSP '.join(q) DCNL DCSP if query_only: DCNL DCSP  DCSP return sample_filter DCNL DCSP else: DCNL DCSP  DCSP return (sample_filter, start_row, end_row)
def make_query_from_filter(sample_filter, require_meter=True): DCNL  DCSP return make_query(sample_filter.user, sample_filter.project, sample_filter.meter, sample_filter.resource, sample_filter.source, sample_filter.start, sample_filter.end, require_meter)
def _make_rowkey_scan(meter, rts_start=None, rts_end=None): DCNL  DCSP if (not rts_start): DCNL DCSP  DCSP rts_start = chr(127) DCNL DCSP end_row = ('%s_%s' % (meter, rts_start)) DCNL DCSP start_row = ('%s_%s' % (meter, rts_end)) DCNL DCSP return (start_row, end_row)
def _load_hbase_list(d, prefix): DCNL  DCSP ret = [] DCNL DCSP prefix = ('f:%s_' % prefix) DCNL DCSP for key in (k for k in d if k.startswith(prefix)): DCNL DCSP  DCSP ret.append(key[len(prefix):]) DCNL DCSP return ret
def make_query_from_filter(query, sample_filter, require_meter=True): DCNL  DCSP if sample_filter.meter: DCNL DCSP  DCSP query = query.filter((Meter.counter_name == sample_filter.meter)) DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP query = query.filter(Meter.sources.any(id=sample_filter.source)) DCNL DCSP if sample_filter.start: DCNL DCSP  DCSP ts_start = sample_filter.start DCNL DCSP  DCSP query = query.filter((Meter.timestamp >= ts_start)) DCNL DCSP if sample_filter.end: DCNL DCSP  DCSP ts_end = sample_filter.end DCNL DCSP  DCSP query = query.filter((Meter.timestamp < ts_end)) DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP query = query.filter_by(user_id=sample_filter.user) DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP query = query.filter_by(project_id=sample_filter.project) DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP query = query.filter_by(resource_id=sample_filter.resource) DCNL DCSP if sample_filter.metaquery: DCNL DCSP  DCSP raise NotImplementedError('metaquery DCSP not DCSP implemented') DCNL DCSP return query
def register_opts(conf): DCNL  DCSP p = get_engine(conf) DCNL DCSP p.register_opts(conf)
def get_engine(conf): DCNL  DCSP if conf.database_connection: DCNL DCSP  DCSP conf.set_override('connection', conf.database_connection, group='database') DCNL DCSP engine_name = urlparse.urlparse(conf.database.connection).scheme DCNL DCSP LOG.debug('looking DCSP for DCSP %r DCSP driver DCSP in DCSP %r', engine_name, STORAGE_ENGINE_NAMESPACE) DCNL DCSP mgr = driver.DriverManager(STORAGE_ENGINE_NAMESPACE, engine_name, invoke_on_load=True) DCNL DCSP return mgr.driver
def get_connection(conf): DCNL  DCSP engine = get_engine(conf) DCNL DCSP engine.register_opts(conf) DCNL DCSP db = engine.get_connection(conf) DCNL DCSP return db
def iter_period(start, end, period): DCNL  DCSP period_start = start DCNL DCSP increment = datetime.timedelta(seconds=period) DCNL DCSP for i in xrange(int(math.ceil((timeutils.delta_seconds(start, end) / float(period))))): DCNL DCSP  DCSP next_start = (period_start + increment) DCNL DCSP  DCSP (yield (period_start, next_start)) DCNL DCSP  DCSP period_start = next_start
def make_timestamp_range(start, end): DCNL  DCSP ts_range = {} DCNL DCSP if start: DCNL DCSP  DCSP ts_range['$gte'] = start DCNL DCSP if end: DCNL DCSP  DCSP ts_range['$lt'] = end DCNL DCSP return ts_range
def make_query_from_filter(sample_filter, require_meter=True): DCNL  DCSP q = {} DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP q['user_id'] = sample_filter.user DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP q['project_id'] = sample_filter.project DCNL DCSP if sample_filter.meter: DCNL DCSP  DCSP q['counter_name'] = sample_filter.meter DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP ts_range = make_timestamp_range(sample_filter.start, sample_filter.end) DCNL DCSP if ts_range: DCNL DCSP  DCSP q['timestamp'] = ts_range DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP q['resource_id'] = sample_filter.resource DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP q['source'] = sample_filter.source DCNL DCSP q.update(dict(((('resource_%s' % k), v) for (k, v) in sample_filter.metaquery.iteritems()))) DCNL DCSP return q
def require_map_reduce(conn): DCNL  DCSP try: DCNL DCSP  DCSP import spidermonkey DCNL DCSP except BaseException: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from ming import mim DCNL DCSP  DCSP  DCSP if (hasattr(conn, 'conn') and isinstance(conn.conn, mim.Connection)): DCNL DCSP  DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP  DCSP raise testtools.testcase.TestSkipped('requires DCSP spidermonkey') DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP raise testtools.testcase.TestSkipped('requires DCSP mim')
def register_opts(config): DCNL  DCSP config.register_opts(METER_PUBLISH_OPTS, group='publisher_rpc')
def compute_signature(message, secret): DCNL  DCSP digest_maker = hmac.new(secret, '', hashlib.sha256) DCNL DCSP for (name, value) in utils.recursive_keypairs(message): DCNL DCSP  DCSP if (name == 'message_signature'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP digest_maker.update(name) DCNL DCSP  DCSP digest_maker.update(unicode(value).encode('utf-8')) DCNL DCSP return digest_maker.hexdigest()
def verify_signature(message, secret): DCNL  DCSP old_sig = message.get('message_signature') DCNL DCSP new_sig = compute_signature(message, secret) DCNL DCSP return (new_sig == old_sig)
def meter_message_from_counter(counter, secret, source): DCNL  DCSP msg = {'source': source, 'counter_name': counter.name, 'counter_type': counter.type, 'counter_unit': counter.unit, 'counter_volume': counter.volume, 'user_id': counter.user_id, 'project_id': counter.project_id, 'resource_id': counter.resource_id, 'timestamp': counter.timestamp, 'resource_metadata': counter.resource_metadata, 'message_id': str(uuid.uuid1())} DCNL DCSP msg['message_signature'] = compute_signature(msg, secret) DCNL DCSP return msg
def get_publisher(url, namespace='ceilometer.publisher'): DCNL  DCSP parse_result = urlparse.urlparse(url) DCNL DCSP loaded_driver = driver.DriverManager(namespace, parse_result.scheme) DCNL DCSP return loaded_driver.driver(parse_result)
def get_client(host, port=None, timeout=None, use_ssl=False, username=None, password=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_upload=False, insecure=False): DCNL  DCSP if (auth_url or os.getenv('OS_AUTH_URL')): DCNL DCSP  DCSP force_strategy = 'keystone' DCNL DCSP else: DCNL DCSP  DCSP force_strategy = None DCNL DCSP creds = {'username': (username or os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME'))), 'password': (password or os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD'))), 'tenant': (tenant or os.getenv('OS_AUTH_TENANT', os.getenv('OS_TENANT_NAME'))), 'auth_url': (auth_url or os.getenv('OS_AUTH_URL')), 'strategy': (force_strategy or auth_strategy or os.getenv('OS_AUTH_STRATEGY', 'noauth')), 'region': (region or os.getenv('OS_REGION_NAME'))} DCNL DCSP if ((creds['strategy'] == 'keystone') and (not creds['auth_url'])): DCNL DCSP  DCSP msg = '--os_auth_url DCSP option DCSP or DCSP OS_AUTH_URL DCSP environment DCSP variable DCSP required DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enabled\n' DCNL DCSP  DCSP raise exception.ClientConfigurationError(msg) DCNL DCSP return CacheClient(host=host, port=port, timeout=timeout, use_ssl=use_ssl, auth_tok=(auth_token or os.getenv('OS_TOKEN')), creds=creds, insecure=insecure)
def _make_namespaced_xattr_key(key, namespace='user'): DCNL  DCSP namespaced_key = '.'.join([namespace, key]) DCNL DCSP return namespaced_key
def get_xattr(path, key, **kwargs): DCNL  DCSP namespaced_key = _make_namespaced_xattr_key(key) DCNL DCSP try: DCNL DCSP  DCSP return xattr.getxattr(path, namespaced_key) DCNL DCSP except IOError: DCNL DCSP  DCSP if ('default' in kwargs): DCNL DCSP  DCSP  DCSP return kwargs['default'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def set_xattr(path, key, value): DCNL  DCSP namespaced_key = _make_namespaced_xattr_key(key) DCNL DCSP xattr.setxattr(path, namespaced_key, str(value))
def inc_xattr(path, key, n=1): DCNL  DCSP count = int(get_xattr(path, key)) DCNL DCSP count += n DCNL DCSP set_xattr(path, key, str(count))
def create_resource(): DCNL  DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def redact_loc(image_meta): DCNL  DCSP if ('location' in image_meta): DCNL DCSP  DCSP tmp_image_meta = copy.copy(image_meta) DCNL DCSP  DCSP del tmp_image_meta['location'] DCNL DCSP  DCSP return tmp_image_meta DCNL DCSP return image_meta
def create_resource(): DCNL  DCSP deserializer = ImageDeserializer() DCNL DCSP serializer = ImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def load_custom_properties(): DCNL  DCSP filename = 'schema-image.json' DCNL DCSP match = CONF.find_file(filename) DCNL DCSP if match: DCNL DCSP  DCSP schema_file = open(match) DCNL DCSP  DCSP schema_data = schema_file.read() DCNL DCSP  DCSP return json.loads(schema_data) DCNL DCSP else: DCNL DCSP  DCSP msg = _('Could DCSP not DCSP find DCSP schema DCSP properties DCSP file DCSP %s. DCSP Continuing DCSP without DCSP custom DCSP properties') DCNL DCSP  DCSP LOG.warn((msg % filename)) DCNL DCSP  DCSP return {}
def create_resource(custom_properties=None): DCNL  DCSP schema = get_schema(custom_properties) DCNL DCSP deserializer = RequestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ImagesController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
def create_resource(): DCNL  DCSP deserializer = RequestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageMembersController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
def create_resource(): DCNL  DCSP deserializer = RequestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageDataController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
def create_resource(): DCNL  DCSP serializer = ResponseSerializer() DCNL DCSP controller = Controller() DCNL DCSP return wsgi.Resource(controller, serializer=serializer)
def create_resource(): DCNL  DCSP deserializer = CachedImageDeserializer() DCNL DCSP serializer = CachedImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def image_send_notification(bytes_written, expected_size, image_meta, request, notifier): DCNL  DCSP try: DCNL DCSP  DCSP context = request.context DCNL DCSP  DCSP payload = {'bytes_sent': bytes_written, 'image_id': image_meta['id'], 'owner_id': image_meta['owner'], 'receiver_tenant_id': context.tenant, 'receiver_user_id': context.user, 'destination_ip': request.remote_addr} DCNL DCSP  DCSP if (bytes_written != expected_size): DCNL DCSP  DCSP  DCSP notify = notifier.error DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP notify = notifier.info DCNL DCSP  DCSP notify('image.send', payload) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('An DCSP error DCSP occurred DCSP during DCSP image.send DCSP notification: DCSP %(err)s') % locals()) DCNL DCSP  DCSP LOG.error(msg)
def is_image_mutable(context, image): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image.owner is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image.owner == context.owner)
def is_member_mutable(context, member): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP return (member.member_id == context.owner)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(product_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP LOG.error(_('Max DCSP serialization DCSP depth DCSP exceeded DCSP on DCSP object: DCSP %d DCSP %s'), level, value) DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(): DCNL  DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def set_rules(rules): DCNL  DCSP global _rules DCNL DCSP _rules = rules
def reset(): DCNL  DCSP global _rules DCNL DCSP _rules = None
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL  DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def _parse_list_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
def _parse_tokenize(rule): DCNL  DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
def reducer(*tokens): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def _parse_text_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
def parse_rule(rule): DCNL  DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('glance.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def handle_unauthenticated(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except exception.NotAuthenticated: DCNL DCSP  DCSP  DCSP self._authenticate(force_reauth=True) DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapped
def handle_redirects(func): DCNL  DCSP MAX_REDIRECTS = 5 DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, method, url, body, headers): DCNL DCSP  DCSP for _ in xrange(MAX_REDIRECTS): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, method, url, body, headers) DCNL DCSP  DCSP  DCSP except exception.RedirectException as redirect: DCNL DCSP  DCSP  DCSP  DCSP if (redirect.url is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvalidRedirect() DCNL DCSP  DCSP  DCSP  DCSP url = redirect.url DCNL DCSP  DCSP raise exception.MaxRedirectsExceeded(redirects=MAX_REDIRECTS) DCNL DCSP return wrapped
def get_bind_addr(default_port=None): DCNL  DCSP return (CONF.bind_host, (CONF.bind_port or default_port))
def get_socket(default_port): DCNL  DCSP bind_addr = get_bind_addr(default_port) DCNL DCSP address_family = [addr[0] for addr in socket.getaddrinfo(bind_addr[0], bind_addr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (addr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP cert_file = CONF.cert_file DCNL DCSP key_file = CONF.key_file DCNL DCSP use_ssl = (cert_file or key_file) DCNL DCSP if (use_ssl and ((not cert_file) or (not key_file))): DCNL DCSP  DCSP raise RuntimeError(_('When DCSP running DCSP server DCSP in DCSP SSL DCSP mode, DCSP you DCSP must DCSP specify DCSP both DCSP a DCSP cert_file DCSP and DCSP key_file DCSP option DCSP value DCSP in DCSP your DCSP configuration DCSP file')) DCNL DCSP def wrap_ssl(sock): DCNL DCSP  DCSP ssl_kwargs = {'server_side': True, 'certfile': cert_file, 'keyfile': key_file, 'cert_reqs': ssl.CERT_NONE} DCNL DCSP  DCSP if CONF.ca_file: DCNL DCSP  DCSP  DCSP ssl_kwargs['ca_certs'] = CONF.ca_file DCNL DCSP  DCSP  DCSP ssl_kwargs['cert_reqs'] = ssl.CERT_REQUIRED DCNL DCSP  DCSP return ssl.wrap_socket(sock, **ssl_kwargs) DCNL DCSP sock = None DCNL DCSP retry_until = (time.time() + 30) DCNL DCSP while ((not sock) and (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = eventlet.listen(bind_addr, backlog=CONF.backlog, family=address_family) DCNL DCSP  DCSP  DCSP if use_ssl: DCNL DCSP  DCSP  DCSP  DCSP sock = wrap_ssl(sock) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP eventlet.sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise RuntimeError((_('Could DCSP not DCSP bind DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP 30 DCSP seconds') % bind_addr)) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, CONF.tcp_keepidle) DCNL DCSP return sock
def chunkreadable(iter, chunk_size=65536): DCNL  DCSP return (chunkiter(iter, chunk_size) if hasattr(iter, 'read') else iter)
def chunkiter(fp, chunk_size=65536): DCNL  DCSP while True: DCNL DCSP  DCSP chunk = fp.read(chunk_size) DCNL DCSP  DCSP if chunk: DCNL DCSP  DCSP  DCSP (yield chunk) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
def cooperative_iter(iter): DCNL  DCSP try: DCNL DCSP  DCSP for chunk in iter: DCNL DCSP  DCSP  DCSP sleep(0) DCNL DCSP  DCSP  DCSP (yield chunk) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('Error: DCSP cooperative_iter DCSP exception DCSP %s') % err) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise
def cooperative_read(fd): DCNL  DCSP def readfn(*args): DCNL DCSP  DCSP result = fd.read(*args) DCNL DCSP  DCSP sleep(0) DCNL DCSP  DCSP return result DCNL DCSP return readfn
def image_meta_to_http_headers(image_meta): DCNL  DCSP headers = {} DCNL DCSP for (k, v) in image_meta.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP if (k == 'properties'): DCNL DCSP  DCSP  DCSP  DCSP for (pk, pv) in v.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (pv is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP headers[('x-image-meta-property-%s' % pk.lower())] = unicode(pv) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP headers[('x-image-meta-%s' % k.lower())] = unicode(v) DCNL DCSP return headers
def add_features_to_http_headers(features, headers): DCNL  DCSP if features: DCNL DCSP  DCSP for (k, v) in features.items(): DCNL DCSP  DCSP  DCSP if (k.lower() in FEATURE_BLACKLIST): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupportedHeaderFeature(feature=k) DCNL DCSP  DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP  DCSP headers[k.lower()] = unicode(v)
def get_image_meta_from_headers(response): DCNL  DCSP result = {} DCNL DCSP properties = {} DCNL DCSP if hasattr(response, 'getheaders'): DCNL DCSP  DCSP headers = response.getheaders() DCNL DCSP else: DCNL DCSP  DCSP headers = response.headers.items() DCNL DCSP for (key, value) in headers: DCNL DCSP  DCSP key = str(key.lower()) DCNL DCSP  DCSP if key.startswith('x-image-meta-property-'): DCNL DCSP  DCSP  DCSP field_name = key[len('x-image-meta-property-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP properties[field_name] = (value or None) DCNL DCSP  DCSP elif key.startswith('x-image-meta-'): DCNL DCSP  DCSP  DCSP field_name = key[len('x-image-meta-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP result[field_name] = (value or None) DCNL DCSP result['properties'] = properties DCNL DCSP if ('size' in result): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result['size'] = int(result['size']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise exception.Invalid DCNL DCSP for key in ('is_public', 'deleted', 'protected'): DCNL DCSP  DCSP if (key in result): DCNL DCSP  DCSP  DCSP result[key] = bool_from_string(result[key]) DCNL DCSP return result
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP elif isinstance(subject, int): DCNL DCSP  DCSP return (subject == 1) DCNL DCSP if hasattr(subject, 'startswith'): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', '1', 'yes', 'y')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def mutating(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, req, *args, **kwargs): DCNL DCSP  DCSP if req.context.read_only: DCNL DCSP  DCSP  DCSP msg = _('Read-only DCSP access') DCNL DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP raise exc.HTTPForbidden(msg, request=req, content_type='text/plain') DCNL DCSP  DCSP return func(self, req, *args, **kwargs) DCNL DCSP return wrapped
def urlsafe_encrypt(key, plaintext, blocksize=16): DCNL  DCSP def pad(text): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Pads DCSP text DCSP to DCSP be DCSP encrypted\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP pad_length = (blocksize - (len(text) % blocksize)) DCNL DCSP  DCSP sr = random.StrongRandom() DCNL DCSP  DCSP pad = ''.join((chr(sr.randint(1, 255)) for i in range((pad_length - 1)))) DCNL DCSP  DCSP return ((text + chr(0)) + pad) DCNL DCSP init_vector = Random.get_random_bytes(16) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, init_vector) DCNL DCSP padded = cypher.encrypt(pad(str(plaintext))) DCNL DCSP return base64.urlsafe_b64encode((init_vector + padded))
def urlsafe_decrypt(key, ciphertext): DCNL  DCSP ciphertext = base64.urlsafe_b64decode(str(ciphertext)) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, ciphertext[:16]) DCNL DCSP padded = cypher.decrypt(ciphertext[16:]) DCNL DCSP return padded[:padded.rfind(chr(0))]
def get_endpoint(service_catalog, service_type='image', endpoint_region=None, endpoint_type='publicURL'): DCNL  DCSP endpoint = None DCNL DCSP for service in service_catalog: DCNL DCSP  DCSP s_type = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s_type = service['type'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP msg = (_('Encountered DCSP service DCSP with DCSP no DCSP "type": DCSP %s') % s_type) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (s_type == service_type): DCNL DCSP  DCSP  DCSP for ep in service['endpoints']: DCNL DCSP  DCSP  DCSP  DCSP if ((endpoint_region is None) or (endpoint_region == ep['region'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (endpoint is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.RegionAmbiguity(region=endpoint_region) DCNL DCSP  DCSP  DCSP  DCSP  DCSP endpoint = ep DCNL DCSP if (endpoint and endpoint.get(endpoint_type)): DCNL DCSP  DCSP return endpoint[endpoint_type] DCNL DCSP else: DCNL DCSP  DCSP raise exception.NoServiceEndpoint()
def setup_logging(): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP if os.path.exists(CONF.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unable DCSP to DCSP locate DCSP specified DCSP logging DCSP config DCSP file: DCSP %s' % CONF.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if CONF.debug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif CONF.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(CONF.log_format, CONF.log_date_format) DCNL DCSP if CONF.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.handlers.SysLogHandler, CONF.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invalid DCSP syslog DCSP facility')) DCNL DCSP  DCSP handler = logging.handlers.SysLogHandler(address='/dev/log', facility=facility) DCNL DCSP elif CONF.log_file: DCNL DCSP  DCSP logfile = CONF.log_file DCNL DCSP  DCSP if CONF.log_dir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(CONF.log_dir, logfile) DCNL DCSP  DCSP handler = logging.handlers.WatchedFileHandler(logfile) DCNL DCSP else: DCNL DCSP  DCSP handler = logging.StreamHandler(sys.stdout) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP root_logger.addHandler(handler)
def _get_deployment_flavor(): DCNL  DCSP flavor = CONF.paste_deploy.flavor DCNL DCSP return ('' if (not flavor) else ('-' + flavor))
def _get_deployment_config_file(): DCNL  DCSP path = CONF.paste_deploy.config_file DCNL DCSP if (not path): DCNL DCSP  DCSP path = _get_paste_config_path() DCNL DCSP if (not path): DCNL DCSP  DCSP msg = ('Unable DCSP to DCSP locate DCSP paste DCSP config DCSP file DCSP for DCSP %s.' % CONF.prog) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return os.path.abspath(path)
def load_paste_app(app_name=None): DCNL  DCSP if (app_name is None): DCNL DCSP  DCSP app_name = CONF.prog DCNL DCSP app_name += _get_deployment_flavor() DCNL DCSP conf_file = _get_deployment_config_file() DCNL DCSP try: DCNL DCSP  DCSP logger = logging.getLogger(__name__) DCNL DCSP  DCSP logger.debug(_('Loading DCSP %(app_name)s DCSP from DCSP %(conf_file)s'), {'conf_file': conf_file, 'app_name': app_name}) DCNL DCSP  DCSP app = deploy.loadapp(('config:%s' % conf_file), name=app_name) DCNL DCSP  DCSP if CONF.debug: DCNL DCSP  DCSP  DCSP CONF.log_opt_values(logger, logging.DEBUG) DCNL DCSP  DCSP return app DCNL DCSP except (LookupError, ImportError) as e: DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP load DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(conf_file)s.\nGot: DCSP %(e)r') % locals()) DCNL DCSP  DCSP logger.error(msg) DCNL DCSP  DCSP raise RuntimeError(msg)
def make_member_list(members, **attr_map): DCNL  DCSP def _fetch_memb(memb, attr_map): DCNL DCSP  DCSP return dict([(k, memb[v]) for (k, v) in attr_map.items() if (v in memb.keys())]) DCNL DCSP return [_fetch_memb(memb, attr_map) for memb in members]
def create_resource(): DCNL  DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def make_image_dict(image): DCNL  DCSP def _fetch_attrs(d, attrs): DCNL DCSP  DCSP return dict([(a, d[a]) for a in attrs if (a in d.keys())]) DCNL DCSP properties = dict(((p['name'], p['value']) for p in image['properties'] if (not p['deleted']))) DCNL DCSP image_dict = _fetch_attrs(image, glance.db.IMAGE_ATTRS) DCNL DCSP image_dict['properties'] = properties DCNL DCSP _limit_locations(image_dict) DCNL DCSP return image_dict
def create_resource(): DCNL  DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
def configure_registry_client(): DCNL  DCSP global _CLIENT_KWARGS, _CLIENT_HOST, _CLIENT_PORT, _METADATA_ENCRYPTION_KEY DCNL DCSP try: DCNL DCSP  DCSP (host, port) = (CONF.registry_host, CONF.registry_port) DCNL DCSP except cfg.ConfigFileValueError: DCNL DCSP  DCSP msg = _('Configuration DCSP option DCSP was DCSP not DCSP valid') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BadRegistryConnectionConfiguration(msg) DCNL DCSP except IndexError: DCNL DCSP  DCSP msg = _('Could DCSP not DCSP find DCSP required DCSP configuration DCSP option') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BadRegistryConnectionConfiguration(msg) DCNL DCSP _CLIENT_HOST = host DCNL DCSP _CLIENT_PORT = port DCNL DCSP _METADATA_ENCRYPTION_KEY = CONF.metadata_encryption_key DCNL DCSP _CLIENT_KWARGS = {'use_ssl': (CONF.registry_client_protocol.lower() == 'https'), 'key_file': CONF.registry_client_key_file, 'cert_file': CONF.registry_client_cert_file, 'ca_file': CONF.registry_client_ca_file, 'insecure': CONF.registry_client_insecure, 'timeout': CONF.registry_client_timeout}
def register_models(engine): DCNL  DCSP models = (Image, ImageProperty, ImageMember) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
def unregister_models(engine): DCNL  DCSP models = (Image, ImageProperty) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.drop_all(engine)
def from_migration_import(module_name, fromlist): DCNL  DCSP module_path = ('glance.db.sqlalchemy.migrate_repo.versions.%s' % module_name) DCNL DCSP module = __import__(module_path, globals(), locals(), fromlist, (-1)) DCNL DCSP return [getattr(module, item) for item in fromlist]
def get_images_table(meta): DCNL  DCSP (get_images_table,) = from_migration_import('008_add_image_members_table', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (get_image_properties_table,) = from_migration_import('008_add_image_members_table', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
def get_image_members_table(meta): DCNL  DCSP (get_image_members_table,) = from_migration_import('008_add_image_members_table', ['get_image_members_table']) DCNL DCSP images = get_image_members_table(meta) DCNL DCSP return images
def get_images_table(meta): DCNL  DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), Column('owner', String(255)), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (get_image_properties_table,) = from_migration_import('006_key_to_name', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
def _sanitize(migrate_engine, table): DCNL  DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP qry = session.query(table.c.image_id, table.c.member).group_by(table.c.image_id, table.c.member).having((func.count() > 1)) DCNL DCSP for (image_id, member) in qry: DCNL DCSP  DCSP d = table.delete().where(and_((table.c.deleted == True), (table.c.image_id == image_id), (table.c.member == member))) DCNL DCSP  DCSP d.execute() DCNL DCSP session.close()
def migrate_location_credentials(migrate_engine, to_quoted): DCNL  DCSP if (not CONF.metadata_encryption_key): DCNL DCSP  DCSP msg = _("'metadata_encryption_key' DCSP was DCSP not DCSP specified DCSP in DCSP the DCSP config DCSP file DCSP or DCSP a DCSP config DCSP file DCSP was DCSP not DCSP specified. DCSP This DCSP means DCSP that DCSP this DCSP migration DCSP is DCSP a DCSP NOOP.") DCNL DCSP  DCSP LOG.info(msg) DCNL DCSP  DCSP return DCNL DCSP meta = sqlalchemy.schema.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP images_table = sqlalchemy.Table('images', meta, autoload=True) DCNL DCSP images = list(images_table.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fixed_uri = fix_uri_credentials(image['location'], to_quoted) DCNL DCSP  DCSP  DCSP images_table.update().where((images_table.c.id == image['id'])).values(location=fixed_uri).execute() DCNL DCSP  DCSP except exception.Invalid: DCNL DCSP  DCSP  DCSP msg = _('Failed DCSP to DCSP decrypt DCSP location DCSP value DCSP for DCSP image DCSP %s') DCNL DCSP  DCSP  DCSP LOG.warn((msg % image['id']))
def fix_uri_credentials(uri, to_quoted): DCNL  DCSP if (not uri): DCNL DCSP  DCSP return DCNL DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_quoted: DCNL DCSP  DCSP location.parse_uri = types.MethodType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_credstring = types.MethodType(legacy__get_credstring, location) DCNL DCSP decrypted_uri = None DCNL DCSP try: DCNL DCSP  DCSP decrypted_uri = decrypt_location(uri) DCNL DCSP except (TypeError, ValueError) as e: DCNL DCSP  DCSP raise exception.Invalid(str(e)) DCNL DCSP location.parse_uri(decrypted_uri) DCNL DCSP return encrypt_location(location.get_uri())
def legacy_parse_uri(self, uri): DCNL  DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specified DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP need DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invalid DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BadStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creds, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creds, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP  DCSP netloc = path[0:path.find('/')].strip('/') DCNL DCSP  DCSP path = path[path.find('/'):].strip('/') DCNL DCSP if creds: DCNL DCSP  DCSP cred_parts = creds.split(':') DCNL DCSP  DCSP if (len(cred_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Badly DCSP formed DCSP credentials DCSP '%(creds)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BadStoreUri() DCNL DCSP  DCSP elif (len(cred_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(cred_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = cred_parts[0] DCNL DCSP  DCSP key = cred_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except IndexError: DCNL DCSP  DCSP reason = (_('Badly DCSP formed DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BadStoreUri()
def get_images_table(meta): DCNL  DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
def get_images_table(meta): DCNL  DCSP (get_images_table,) = from_migration_import('004_add_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (get_images_table,) = from_migration_import('004_add_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP image_properties = Table('image_properties', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('image_id', Integer(), ForeignKey('images.id'), nullable=False, index=True), Column('name', String(255), nullable=False), Column('value', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), UniqueConstraint('image_id', 'name'), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return image_properties
def get_images_table(meta): DCNL  DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), Column('min_disk', Integer(), default=0), Column('min_ram', Integer(), default=0), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (define_image_properties_table,) = from_migration_import('008_add_image_members_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
def get_images_table(meta): DCNL  DCSP (get_images_table,) = from_migration_import('007_add_owner', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (get_image_properties_table,) = from_migration_import('007_add_owner', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
def get_images_table(meta): DCNL  DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
def get_images_table(meta): DCNL  DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
def get_image_properties_table(meta): DCNL  DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
def upgrade(migrate_engine): DCNL  DCSP meta.bind = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP dialect = migrate_engine.url.get_dialect().name DCNL DCSP if (dialect == 'sqlite'): DCNL DCSP  DCSP _upgrade_sqlite(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _upgrade_other(t_images, t_image_members, t_image_properties, dialect)
def downgrade(migrate_engine): DCNL  DCSP meta.bind = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP dialect = migrate_engine.url.get_dialect().name DCNL DCSP if (dialect == 'sqlite'): DCNL DCSP  DCSP _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _downgrade_sqlite(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _downgrade_other(t_images, t_image_members, t_image_properties, dialect)
def _upgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL  DCSP sql_commands = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP disk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_disk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for command in sql_commands: DCNL DCSP  DCSP meta.bind.execute(command) DCNL DCSP _sqlite_table_swap(t_image_members, t_image_properties, t_images)
def _downgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL  DCSP sql_commands = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP disk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_disk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP  DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for command in sql_commands: DCNL DCSP  DCSP meta.bind.execute(command) DCNL DCSP _sqlite_table_swap(t_image_members, t_image_properties, t_images)
def _upgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL  DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.drop() DCNL DCSP t_images.c.id.alter(sqlalchemy.String(36), primary_key=True) DCNL DCSP t_image_members.c.image_id.alter(sqlalchemy.String(36)) DCNL DCSP t_image_properties.c.image_id.alter(sqlalchemy.String(36)) DCNL DCSP _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
def _downgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL  DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.drop() DCNL DCSP t_images.c.id.alter(sqlalchemy.Integer(), primary_key=True) DCNL DCSP t_image_members.c.image_id.alter(sqlalchemy.Integer()) DCNL DCSP t_image_properties.c.image_id.alter(sqlalchemy.Integer()) DCNL DCSP _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
def _get_table(table_name, metadata): DCNL  DCSP return sqlalchemy.Table(table_name, metadata, autoload=True)
def _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect): DCNL  DCSP foreign_keys = [] DCNL DCSP if t_image_members.foreign_keys: DCNL DCSP  DCSP img_members_fk_name = list(t_image_members.foreign_keys)[0].name DCNL DCSP  DCSP if (dialect == 'mysql'): DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_id], [t_images.c.id], name=img_members_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_id], [t_images.c.id]) DCNL DCSP  DCSP foreign_keys.append(fk1) DCNL DCSP if t_image_properties.foreign_keys: DCNL DCSP  DCSP img_properties_fk_name = list(t_image_properties.foreign_keys)[0].name DCNL DCSP  DCSP if (dialect == 'mysql'): DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_id], [t_images.c.id], name=img_properties_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_id], [t_images.c.id]) DCNL DCSP  DCSP foreign_keys.append(fk2) DCNL DCSP return foreign_keys
def _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties): DCNL  DCSP images = list(t_images.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP old_id = image['id'] DCNL DCSP  DCSP new_id = uuidutils.generate_uuid() DCNL DCSP  DCSP t_images.update().where((t_images.c.id == old_id)).values(id=new_id).execute() DCNL DCSP  DCSP t_image_members.update().where((t_image_members.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where((t_image_properties.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where(and_(or_((t_image_properties.c.name == 'kernel_id'), (t_image_properties.c.name == 'ramdisk_id')), (t_image_properties.c.value == old_id))).values(value=new_id).execute()
def _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties): DCNL  DCSP images = list(t_images.select().execute()) DCNL DCSP new_id = 1 DCNL DCSP for image in images: DCNL DCSP  DCSP old_id = image['id'] DCNL DCSP  DCSP t_images.update().where((t_images.c.id == old_id)).values(id=new_id).execute() DCNL DCSP  DCSP t_image_members.update().where((t_image_members.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where((t_image_properties.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where(and_(or_((t_image_properties.c.name == 'kernel_id'), (t_image_properties.c.name == 'ramdisk_id')), (t_image_properties.c.value == old_id))).values(value=new_id).execute() DCNL DCSP  DCSP new_id += 1
def migrate_location_credentials(migrate_engine, to_quoted): DCNL  DCSP meta = sqlalchemy.schema.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP images_table = sqlalchemy.Table('images', meta, autoload=True) DCNL DCSP images = list(images_table.select(images_table.c.location.startswith('swift')).execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP fixed_uri = fix_uri_credentials(image['location'], to_quoted) DCNL DCSP  DCSP images_table.update().where((images_table.c.id == image['id'])).values(location=fixed_uri).execute()
def fix_uri_credentials(uri, to_quoted): DCNL  DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_quoted: DCNL DCSP  DCSP location.parse_uri = types.MethodType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_credstring = types.MethodType(legacy__get_credstring, location) DCNL DCSP location.parse_uri(uri) DCNL DCSP return location.get_uri()
def legacy_parse_uri(self, uri): DCNL  DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specified DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP need DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invalid DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BadStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creds, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creds, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP  DCSP netloc = path[0:path.find('/')].strip('/') DCNL DCSP  DCSP path = path[path.find('/'):].strip('/') DCNL DCSP if creds: DCNL DCSP  DCSP cred_parts = creds.split(':') DCNL DCSP  DCSP if (len(cred_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Badly DCSP formed DCSP credentials DCSP '%(creds)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BadStoreUri() DCNL DCSP  DCSP elif (len(cred_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(cred_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = cred_parts[0] DCNL DCSP  DCSP key = cred_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except IndexError: DCNL DCSP  DCSP reason = (_('Badly DCSP formed DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BadStoreUri()
def db_version(): DCNL  DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP return versioning_api.db_version(sql_connection, repo_path) DCNL DCSP except versioning_exceptions.DatabaseNotControlledError as e: DCNL DCSP  DCSP msg = _('database DCSP is DCSP not DCSP under DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
def upgrade(version=None): DCNL  DCSP db_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP version_str = (version or 'latest') DCNL DCSP LOG.info((_('Upgrading DCSP database DCSP to DCSP version DCSP %s') % version_str)) DCNL DCSP return versioning_api.upgrade(sql_connection, repo_path, version)
def downgrade(version): DCNL  DCSP db_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP LOG.info((_('Downgrading DCSP database DCSP to DCSP version DCSP %s') % version)) DCNL DCSP return versioning_api.downgrade(sql_connection, repo_path, version)
def version_control(version=None): DCNL  DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control(version) DCNL DCSP except versioning_exceptions.DatabaseAlreadyControlledError as e: DCNL DCSP  DCSP msg = _('database DCSP is DCSP already DCSP under DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
def _version_control(version): DCNL  DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP if (version is None): DCNL DCSP  DCSP version = versioning_repository.Repository(repo_path).latest DCNL DCSP return versioning_api.version_control(sql_connection, repo_path, version)
def db_sync(version=None, current_version=None): DCNL  DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control((current_version or 0)) DCNL DCSP except versioning_exceptions.DatabaseAlreadyControlledError as e: DCNL DCSP  DCSP pass DCNL DCSP if (current_version is None): DCNL DCSP  DCSP current_version = int(db_version()) DCNL DCSP if ((version is not None) and (int(version) < current_version)): DCNL DCSP  DCSP downgrade(version=version) DCNL DCSP elif ((version is None) or (int(version) > current_version)): DCNL DCSP  DCSP upgrade(version=version)
def get_migrate_repo_path(): DCNL  DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP msg = ('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s' % ex) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP raise sqlalchemy.exc.DisconnectionError(msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def setup_db_env(): DCNL  DCSP global sa_logger, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL, _CONNECTION DCNL DCSP _IDLE_TIMEOUT = CONF.sql_idle_timeout DCNL DCSP _MAX_RETRIES = CONF.sql_max_retries DCNL DCSP _RETRY_INTERVAL = CONF.sql_retry_interval DCNL DCSP _CONNECTION = CONF.sql_connection DCNL DCSP sa_logger = logging.getLogger('sqlalchemy.engine') DCNL DCSP if CONF.debug: DCNL DCSP  DCSP sa_logger.setLevel(logging.DEBUG)
def configure_db(): DCNL  DCSP setup_db_env() DCNL DCSP get_engine()
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP get_engine() DCNL DCSP  DCSP get_maker(autocommit, expire_on_commit) DCNL DCSP  DCSP assert _MAKER DCNL DCSP session = _MAKER() DCNL DCSP return session
def get_engine(): DCNL  DCSP 'May DCSP assign DCSP _ENGINE DCSP if DCSP not DCSP already DCSP assigned' DCNL DCSP global _ENGINE, sa_logger, _CONNECTION, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP tries = _MAX_RETRIES DCNL DCSP  DCSP retry_interval = _RETRY_INTERVAL DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(_CONNECTION) DCNL DCSP  DCSP engine_args = {'pool_recycle': _IDLE_TIMEOUT, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE = sqlalchemy.create_engine(_CONNECTION, **engine_args) DCNL DCSP  DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP  DCSP _ENGINE.connect = wrap_db_error(_ENGINE.connect) DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP msg = (_('Error DCSP configuring DCSP registry DCSP database DCSP with DCSP supplied DCSP sql_connection. DCSP Got DCSP error: DCSP %s') % err) DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sa_logger = logging.getLogger('sqlalchemy.engine') DCNL DCSP  DCSP if CONF.debug: DCNL DCSP  DCSP  DCSP sa_logger.setLevel(logging.DEBUG) DCNL DCSP  DCSP if CONF.db_auto_create: DCNL DCSP  DCSP  DCSP LOG.info(_('auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP  DCSP  DCSP models.register_models(_ENGINE) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP migration.version_control() DCNL DCSP  DCSP  DCSP except exception.DatabaseMigrationError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info(_('not DCSP auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP return _ENGINE
def get_maker(autocommit=True, expire_on_commit=False): DCNL  DCSP 'May DCSP assign DCSP __MAKER DCSP if DCSP not DCSP already DCSP assigned' DCNL DCSP global _MAKER, _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP _MAKER = sa_orm.sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER
def is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def wrap_db_error(f): DCNL  DCSP def _wrap(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP except sqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining_attempts = _MAX_RETRIES DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('SQL DCSP connection DCSP failed. DCSP %d DCSP attempts DCSP left.'), remaining_attempts) DCNL DCSP  DCSP  DCSP  DCSP remaining_attempts -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(_RETRY_INTERVAL) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP except sqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((remaining_attempts == 0) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP except sqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except sqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP raise DCNL DCSP _wrap.func_name = f.func_name DCNL DCSP return _wrap
def image_create(context, values): DCNL  DCSP return _image_update(context, values, None, False)
def image_update(context, image_id, values, purge_props=False): DCNL  DCSP return _image_update(context, values, image_id, purge_props)
def image_destroy(context, image_id): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP image_ref = _image_get(context, image_id, session=session) DCNL DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP _image_locations_set(image_ref.id, [], session) DCNL DCSP  DCSP image_ref.delete(session=session) DCNL DCSP  DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP  DCSP image_property_delete(context, prop_ref, session=session) DCNL DCSP  DCSP members = _image_member_find(context, session, image_id=image_id) DCNL DCSP  DCSP for memb_ref in members: DCNL DCSP  DCSP  DCSP _image_member_delete(context, memb_ref, session) DCNL DCSP return _normalize_locations(image_ref)
def _image_get(context, image_id, session=None, force_show_deleted=False): DCNL  DCSP session = (session or get_session()) DCNL DCSP try: DCNL DCSP  DCSP query = session.query(models.Image).options(sa_orm.joinedload(models.Image.properties)).options(sa_orm.joinedload(models.Image.locations)).filter_by(id=image_id) DCNL DCSP  DCSP if ((not force_show_deleted) and (not _can_show_deleted(context))): DCNL DCSP  DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP  DCSP image = query.one() DCNL DCSP except sa_orm.exc.NoResultFound: DCNL DCSP  DCSP raise exception.NotFound(('No DCSP image DCSP found DCSP with DCSP ID DCSP %s' % image_id)) DCNL DCSP if (not is_image_visible(context, image)): DCNL DCSP  DCSP raise exception.Forbidden('Image DCSP not DCSP visible DCSP to DCSP you') DCNL DCSP return image
def is_image_mutable(context, image): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
def is_image_sharable(context, image, **kwargs): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP membership = kwargs['membership'] DCNL DCSP  DCSP if (membership is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
def is_image_visible(context, image, status=None): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner, status=status) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sa_sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sa_sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def image_get_all(context, filters=None, marker=None, limit=None, sort_key='created_at', sort_dir='desc', member_status='accepted'): DCNL  DCSP filters = (filters or {}) DCNL DCSP session = get_session() DCNL DCSP query = session.query(models.Image).options(sa_orm.joinedload(models.Image.properties)).options(sa_orm.joinedload(models.Image.locations)) DCNL DCSP if (('is_public' in filters) and (filters['is_public'] is None)): DCNL DCSP  DCSP del filters['is_public'] DCNL DCSP if (not context.is_admin): DCNL DCSP  DCSP visibility_filters = [(models.Image.is_public == True)] DCNL DCSP  DCSP if (context.owner is not None): DCNL DCSP  DCSP  DCSP if (member_status == 'all'): DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extend([(models.Image.owner == context.owner), models.Image.members.any(member=context.owner, deleted=False)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extend([(models.Image.owner == context.owner), models.Image.members.any(member=context.owner, deleted=False, status=member_status)]) DCNL DCSP  DCSP query = query.filter(sa_sql.or_(*visibility_filters)) DCNL DCSP if ('visibility' in filters): DCNL DCSP  DCSP visibility = filters.pop('visibility') DCNL DCSP  DCSP if (visibility == 'public'): DCNL DCSP  DCSP  DCSP query = query.filter((models.Image.is_public == True)) DCNL DCSP  DCSP  DCSP filters['is_public'] = True DCNL DCSP  DCSP elif (visibility == 'private'): DCNL DCSP  DCSP  DCSP filters['is_public'] = False DCNL DCSP  DCSP  DCSP if ((not context.is_admin) and (context.owner is not None)): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((models.Image.owner == context.owner)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter(models.Image.members.any(member=context.owner, deleted=False)) DCNL DCSP showing_deleted = False DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters.pop('changes-since')) DCNL DCSP  DCSP query = query.filter((models.Image.updated_at > changes_since)) DCNL DCSP  DCSP showing_deleted = True DCNL DCSP if ('deleted' in filters): DCNL DCSP  DCSP deleted_filter = filters.pop('deleted') DCNL DCSP  DCSP query = query.filter_by(deleted=deleted_filter) DCNL DCSP  DCSP showing_deleted = deleted_filter DCNL DCSP  DCSP if (not deleted_filter): DCNL DCSP  DCSP  DCSP query = query.filter((models.Image.status != 'killed')) DCNL DCSP for (k, v) in filters.pop('properties', {}).items(): DCNL DCSP  DCSP query = query.filter(models.Image.properties.any(name=k, value=v, deleted=False)) DCNL DCSP for (k, v) in filters.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP key = k DCNL DCSP  DCSP  DCSP if (k.endswith('_min') or k.endswith('_max')): DCNL DCSP  DCSP  DCSP  DCSP key = key[0:(-4)] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = int(v) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = _('Unable DCSP to DCSP filter DCSP on DCSP a DCSP range DCSP with DCSP a DCSP non-numeric DCSP value.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvalidFilterRangeValue(msg) DCNL DCSP  DCSP  DCSP if k.endswith('_min'): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) >= v)) DCNL DCSP  DCSP  DCSP elif k.endswith('_max'): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) <= v)) DCNL DCSP  DCSP  DCSP elif hasattr(models.Image, key): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) == v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP query = query.filter(models.Image.properties.any(name=key, value=v)) DCNL DCSP marker_image = None DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_image = _image_get(context, marker, force_show_deleted=showing_deleted) DCNL DCSP query = paginate_query(query, models.Image, limit, [sort_key, 'created_at', 'id'], marker=marker_image, sort_dir=sort_dir) DCNL DCSP return [_normalize_locations(image.to_dict()) for image in query.all()]
def _drop_protected_attrs(model_class, values): DCNL  DCSP for attr in model_class.__protected_attributes__: DCNL DCSP  DCSP if (attr in values): DCNL DCSP  DCSP  DCSP del values[attr]
def validate_image(values): DCNL  DCSP status = values.get('status') DCNL DCSP status = values.get('status', None) DCNL DCSP if (not status): DCNL DCSP  DCSP msg = 'Image DCSP status DCSP is DCSP required.' DCNL DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP if (status not in STATUSES): DCNL DCSP  DCSP msg = ("Invalid DCSP image DCSP status DCSP '%s' DCSP for DCSP image." % status) DCNL DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP return values
def _image_update(context, values, image_id, purge_props=False): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP properties = values.pop('properties', {}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP locations = values.pop('locations') DCNL DCSP  DCSP  DCSP locations_provided = True DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP locations_provided = False DCNL DCSP  DCSP if image_id: DCNL DCSP  DCSP  DCSP image_ref = _image_get(context, image_id, session=session) DCNL DCSP  DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (values.get('size') is not None): DCNL DCSP  DCSP  DCSP  DCSP values['size'] = int(values['size']) DCNL DCSP  DCSP  DCSP if ('min_ram' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_ram'] = int((values['min_ram'] or 0)) DCNL DCSP  DCSP  DCSP if ('min_disk' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_disk'] = int((values['min_disk'] or 0)) DCNL DCSP  DCSP  DCSP values['is_public'] = bool(values.get('is_public', False)) DCNL DCSP  DCSP  DCSP values['protected'] = bool(values.get('protected', False)) DCNL DCSP  DCSP  DCSP image_ref = models.Image() DCNL DCSP  DCSP if (('owner' in values) and (not values['owner'])): DCNL DCSP  DCSP  DCSP values['owner'] = None DCNL DCSP  DCSP if image_id: DCNL DCSP  DCSP  DCSP _drop_protected_attrs(models.Image, values) DCNL DCSP  DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP image_ref.update(values) DCNL DCSP  DCSP values = validate_image(image_ref.to_dict()) DCNL DCSP  DCSP _update_values(image_ref, values) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_ref.save(session=session) DCNL DCSP  DCSP except sqlalchemy.exc.IntegrityError: DCNL DCSP  DCSP  DCSP raise exception.Duplicate(('Image DCSP ID DCSP %s DCSP already DCSP exists!' % values['id'])) DCNL DCSP  DCSP _set_properties_for_image(context, image_ref, properties, purge_props, session) DCNL DCSP if locations_provided: DCNL DCSP  DCSP _image_locations_set(image_ref.id, locations, session) DCNL DCSP return image_get(context, image_ref.id)
def _set_properties_for_image(context, image_ref, properties, purge_props=False, session=None): DCNL  DCSP orig_properties = {} DCNL DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP orig_properties[prop_ref.name] = prop_ref DCNL DCSP for (name, value) in properties.iteritems(): DCNL DCSP  DCSP prop_values = {'image_id': image_ref.id, 'name': name, 'value': value} DCNL DCSP  DCSP if (name in orig_properties): DCNL DCSP  DCSP  DCSP prop_ref = orig_properties[name] DCNL DCSP  DCSP  DCSP _image_property_update(context, prop_ref, prop_values, session=session) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_property_create(context, prop_values, session=session) DCNL DCSP if purge_props: DCNL DCSP  DCSP for key in orig_properties.keys(): DCNL DCSP  DCSP  DCSP if (key not in properties): DCNL DCSP  DCSP  DCSP  DCSP prop_ref = orig_properties[key] DCNL DCSP  DCSP  DCSP  DCSP image_property_delete(context, prop_ref, session=session)
def image_property_create(context, values, session=None): DCNL  DCSP prop_ref = models.ImageProperty() DCNL DCSP return _image_property_update(context, prop_ref, values, session=session)
def _image_property_update(context, prop_ref, values, session=None): DCNL  DCSP _drop_protected_attrs(models.ImageProperty, values) DCNL DCSP values['deleted'] = False DCNL DCSP prop_ref.update(values) DCNL DCSP prop_ref.save(session=session) DCNL DCSP return prop_ref
def image_property_delete(context, prop_ref, session=None): DCNL  DCSP prop_ref.delete(session=session) DCNL DCSP return prop_ref
def image_member_create(context, values, session=None): DCNL  DCSP memb_ref = models.ImageMember() DCNL DCSP _image_member_update(context, memb_ref, values, session=session) DCNL DCSP return _image_member_format(memb_ref)
def _image_member_format(member_ref): DCNL  DCSP return {'id': member_ref['id'], 'image_id': member_ref['image_id'], 'member': member_ref['member'], 'can_share': member_ref['can_share'], 'status': member_ref['status'], 'created_at': member_ref['created_at'], 'updated_at': member_ref['updated_at']}
def image_member_update(context, memb_id, values): DCNL  DCSP session = get_session() DCNL DCSP memb_ref = _image_member_get(context, memb_id, session) DCNL DCSP _image_member_update(context, memb_ref, values, session) DCNL DCSP return _image_member_format(memb_ref)
def _image_member_update(context, memb_ref, values, session=None): DCNL  DCSP _drop_protected_attrs(models.ImageMember, values) DCNL DCSP values['deleted'] = False DCNL DCSP values.setdefault('can_share', False) DCNL DCSP memb_ref.update(values) DCNL DCSP memb_ref.save(session=session) DCNL DCSP return memb_ref
def image_member_delete(context, memb_id, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP member_ref = _image_member_get(context, memb_id, session) DCNL DCSP _image_member_delete(context, member_ref, session)
def _image_member_get(context, memb_id, session): DCNL  DCSP query = session.query(models.ImageMember) DCNL DCSP query = query.filter_by(id=memb_id) DCNL DCSP return query.one()
def image_member_find(context, image_id=None, member=None, status=None): DCNL  DCSP session = get_session() DCNL DCSP members = _image_member_find(context, session, image_id, member, status) DCNL DCSP return [_image_member_format(m) for m in members]
def _can_show_deleted(context): DCNL  DCSP if hasattr(context, 'show_deleted'): DCNL DCSP  DCSP return context.show_deleted DCNL DCSP if (not hasattr(context, 'get')): DCNL DCSP  DCSP return False DCNL DCSP return context.get('deleted', False)
def image_tag_create(context, image_id, value, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP tag_ref = models.ImageTag(image_id=image_id, value=value) DCNL DCSP tag_ref.save(session=session) DCNL DCSP return tag_ref['value']
def image_tag_delete(context, image_id, value, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP query = session.query(models.ImageTag).filter_by(image_id=image_id).filter_by(value=value).filter_by(deleted=False) DCNL DCSP try: DCNL DCSP  DCSP tag_ref = query.one() DCNL DCSP except sa_orm.exc.NoResultFound: DCNL DCSP  DCSP raise exception.NotFound() DCNL DCSP tag_ref.delete(session=session)
def image_tag_get_all(context, image_id, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP tags = session.query(models.ImageTag).filter_by(image_id=image_id).filter_by(deleted=False).order_by(sqlalchemy.asc(models.ImageTag.created_at)).all() DCNL DCSP return [tag['value'] for tag in tags]
def is_image_mutable(context, image): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
def is_image_sharable(context, image, **kwargs): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP member = kwargs['membership'] DCNL DCSP  DCSP if (member is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
def is_image_visible(context, image, status=None): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (status == 'all'): DCNL DCSP  DCSP  DCSP status = None DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner, status=status) DCNL DCSP  DCSP if (len(members) > 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def add_cli_options(): DCNL  DCSP CONF.unregister_opt(sql_connection_opt) DCNL DCSP CONF.register_cli_opt(sql_connection_opt)
def http_response_iterator(conn, response, size): DCNL  DCSP chunk = response.read(size) DCNL DCSP while chunk: DCNL DCSP  DCSP (yield chunk) DCNL DCSP  DCSP chunk = response.read(size) DCNL DCSP conn.close()
def get_bucket(conn, bucket_id): DCNL  DCSP bucket = conn.get_bucket(bucket_id) DCNL DCSP if (not bucket): DCNL DCSP  DCSP msg = (_('Could DCSP not DCSP find DCSP bucket DCSP with DCSP ID DCSP %(bucket_id)s') % locals()) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise exception.NotFound(msg) DCNL DCSP return bucket
def create_bucket_if_missing(bucket, s3_conn): DCNL  DCSP from boto.exception import S3ResponseError DCNL DCSP try: DCNL DCSP  DCSP s3_conn.get_bucket(bucket) DCNL DCSP except S3ResponseError as e: DCNL DCSP  DCSP if (e.status == httplib.NOT_FOUND): DCNL DCSP  DCSP  DCSP if CONF.s3_store_create_bucket_on_put: DCNL DCSP  DCSP  DCSP  DCSP location = get_s3_location(CONF.s3_store_host) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3_conn.create_bucket(bucket, location=location) DCNL DCSP  DCSP  DCSP  DCSP except S3ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Failed DCSP to DCSP add DCSP bucket DCSP to DCSP S3.\nGot DCSP error DCSP from DCSP S3: DCSP %(e)s') % locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise glance.store.BackendException(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = (_('The DCSP bucket DCSP %(bucket)s DCSP does DCSP not DCSP exist DCSP in DCSP S3. DCSP Please DCSP set DCSP the DCSP s3_store_create_bucket_on_put DCSP option DCSP to DCSP add DCSP bucket DCSP to DCSP S3 DCSP automatically.') % locals()) DCNL DCSP  DCSP  DCSP  DCSP raise glance.store.BackendException(msg)
def get_key(bucket, obj): DCNL  DCSP key = bucket.get_key(obj) DCNL DCSP if ((not key) or (not key.exists())): DCNL DCSP  DCSP msg = (_('Could DCSP not DCSP find DCSP key DCSP %(obj)s DCSP in DCSP bucket DCSP %(bucket)s') % locals()) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise exception.NotFound(msg) DCNL DCSP return key
def get_location_from_uri(uri): DCNL  DCSP pieces = urlparse.urlparse(uri) DCNL DCSP if (pieces.scheme not in SCHEME_TO_CLS_MAP.keys()): DCNL DCSP  DCSP raise exception.UnknownScheme(pieces.scheme) DCNL DCSP scheme_info = SCHEME_TO_CLS_MAP[pieces.scheme] DCNL DCSP return Location(pieces.scheme, uri=uri, store_location_class=scheme_info['location_class'])
def register_scheme_map(scheme_map): DCNL  DCSP for (k, v) in scheme_map.items(): DCNL DCSP  DCSP if (k not in SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP  DCSP LOG.debug('Registering DCSP scheme DCSP %s DCSP with DCSP %s', k, v) DCNL DCSP  DCSP  DCSP SCHEME_TO_CLS_MAP[k] = v
def create_stores(): DCNL  DCSP store_count = 0 DCNL DCSP store_classes = set() DCNL DCSP for store_entry in CONF.known_stores: DCNL DCSP  DCSP store_entry = store_entry.strip() DCNL DCSP  DCSP if (not store_entry): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP store_cls = _get_store_class(store_entry) DCNL DCSP  DCSP store_instance = store_cls() DCNL DCSP  DCSP schemes = store_instance.get_schemes() DCNL DCSP  DCSP if (not schemes): DCNL DCSP  DCSP  DCSP raise BackendException(('Unable DCSP to DCSP register DCSP store DCSP %s. DCSP No DCSP schemes DCSP associated DCSP with DCSP it.' % store_cls)) DCNL DCSP  DCSP elif (store_cls not in store_classes): DCNL DCSP  DCSP  DCSP LOG.debug('Registering DCSP store DCSP %s DCSP with DCSP schemes DCSP %s', store_cls, schemes) DCNL DCSP  DCSP  DCSP store_classes.add(store_cls) DCNL DCSP  DCSP  DCSP scheme_map = {} DCNL DCSP  DCSP  DCSP for scheme in schemes: DCNL DCSP  DCSP  DCSP  DCSP loc_cls = store_instance.get_store_location_class() DCNL DCSP  DCSP  DCSP  DCSP scheme_map[scheme] = {'store_class': store_cls, 'location_class': loc_cls} DCNL DCSP  DCSP  DCSP location.register_scheme_map(scheme_map) DCNL DCSP  DCSP  DCSP store_count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.debug('Store DCSP %s DCSP already DCSP registered', store_cls) DCNL DCSP return store_count
def get_store_from_scheme(context, scheme, loc=None): DCNL  DCSP if (scheme not in location.SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP raise exception.UnknownScheme(scheme=scheme) DCNL DCSP scheme_info = location.SCHEME_TO_CLS_MAP[scheme] DCNL DCSP store = scheme_info['store_class'](context, loc) DCNL DCSP return store
def get_store_from_uri(context, uri, loc=None): DCNL  DCSP scheme = uri[0:(uri.find('/') - 1)] DCNL DCSP store = get_store_from_scheme(context, scheme, loc) DCNL DCSP return store
def get_from_backend(context, uri, **kwargs): DCNL  DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get(loc)
def get_size_from_backend(context, uri): DCNL  DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get_size(loc)
def delete_from_backend(context, uri, **kwargs): DCNL  DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP try: DCNL DCSP  DCSP return store.delete(loc) DCNL DCSP except NotImplementedError: DCNL DCSP  DCSP raise exception.StoreDeleteNotSupported
def get_store_from_location(uri): DCNL  DCSP loc = location.get_location_from_uri(uri) DCNL DCSP return loc.store_name
def safe_delete_from_backend(uri, context, image_id, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP return delete_from_backend(context, uri, **kwargs) DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP msg = _('Failed DCSP to DCSP delete DCSP image DCSP in DCSP store DCSP at DCSP URI: DCSP %s') DCNL DCSP  DCSP LOG.warn((msg % uri)) DCNL DCSP except exception.StoreDeleteNotSupported as e: DCNL DCSP  DCSP LOG.warn(str(e)) DCNL DCSP except UnsupportedBackend: DCNL DCSP  DCSP exc_type = sys.exc_info()[0].__name__ DCNL DCSP  DCSP msg = (_('Failed DCSP to DCSP delete DCSP image DCSP at DCSP %s DCSP from DCSP store DCSP (%s)') % (uri, exc_type)) DCNL DCSP  DCSP LOG.error(msg)
def schedule_delayed_delete_from_backend(uri, image_id, **kwargs): DCNL  DCSP datadir = CONF.scrubber_datadir DCNL DCSP delete_time = (time.time() + CONF.scrub_time) DCNL DCSP file_path = os.path.join(datadir, str(image_id)) DCNL DCSP utils.safe_mkdirs(datadir) DCNL DCSP if os.path.exists(file_path): DCNL DCSP  DCSP msg = (_('Image DCSP id DCSP %(image_id)s DCSP already DCSP queued DCSP for DCSP delete') % {'image_id': image_id}) DCNL DCSP  DCSP raise exception.Duplicate(msg) DCNL DCSP if (CONF.metadata_encryption_key is not None): DCNL DCSP  DCSP uri = crypt.urlsafe_encrypt(CONF.metadata_encryption_key, uri, 64) DCNL DCSP with open(file_path, 'w') as f: DCNL DCSP  DCSP f.write('\n'.join([uri, str(int(delete_time))])) DCNL DCSP os.chmod(file_path, 384) DCNL DCSP os.utime(file_path, (delete_time, delete_time))
def format_image_notification(image): DCNL  DCSP return {'id': image.image_id, 'name': image.name, 'status': image.status, 'created_at': timeutils.isotime(image.created_at), 'updated_at': timeutils.isotime(image.updated_at), 'min_disk': image.min_disk, 'min_ram': image.min_ram, 'protected': image.protected, 'checksum': image.checksum, 'owner': image.owner, 'disk_format': image.disk_format, 'container_format': image.container_format, 'size': image.size, 'is_public': (image.visibility == 'public'), 'properties': dict(image.extra_properties), 'tags': list(image.tags), 'deleted': False, 'deleted_at': None}
def stub_out_registry_and_store_server(stubs, base_dir): DCNL  DCSP class FakeSocket(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def fileno(self): DCNL DCSP  DCSP  DCSP return 42 DCNL DCSP class FakeSendFile(object, ): DCNL DCSP  DCSP def __init__(self, req): DCNL DCSP  DCSP  DCSP self.req = req DCNL DCSP  DCSP def sendfile(self, o, i, offset, nbytes): DCNL DCSP  DCSP  DCSP os.lseek(i, offset, os.SEEK_SET) DCNL DCSP  DCSP  DCSP prev_len = len(self.req.body) DCNL DCSP  DCSP  DCSP self.req.body += os.read(i, nbytes) DCNL DCSP  DCSP  DCSP return (len(self.req.body) - prev_len) DCNL DCSP class FakeGlanceConnection(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.sock = FakeSocket() DCNL DCSP  DCSP  DCSP self.stub_force_sendfile = kwargs.get('stub_force_sendfile', SENDFILE_SUPPORTED) DCNL DCSP  DCSP def connect(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP def close(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP def _clean_url(self, url): DCNL DCSP  DCSP  DCSP return (url.replace('/v1', '', 1) if url.startswith('/v1') else url) DCNL DCSP  DCSP def putrequest(self, method, url): DCNL DCSP  DCSP  DCSP self.req = webob.Request.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP if self.stub_force_sendfile: DCNL DCSP  DCSP  DCSP  DCSP fake_sendfile = FakeSendFile(self.req) DCNL DCSP  DCSP  DCSP  DCSP stubs.Set(sendfile, 'sendfile', fake_sendfile.sendfile) DCNL DCSP  DCSP  DCSP self.req.method = method DCNL DCSP  DCSP def putheader(self, key, value): DCNL DCSP  DCSP  DCSP self.req.headers[key] = value DCNL DCSP  DCSP def endheaders(self): DCNL DCSP  DCSP  DCSP hl = [i.lower() for i in self.req.headers.keys()] DCNL DCSP  DCSP  DCSP assert (not (('content-length' in hl) and ('transfer-encoding' in hl))), 'Content-Length DCSP and DCSP Transfer-Encoding DCSP are DCSP mutually DCSP exclusive' DCNL DCSP  DCSP def send(self, data): DCNL DCSP  DCSP  DCSP self.req.body += data.split('\r\n')[1] DCNL DCSP  DCSP def request(self, method, url, body=None, headers=None): DCNL DCSP  DCSP  DCSP self.req = webob.Request.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP self.req.method = method DCNL DCSP  DCSP  DCSP if headers: DCNL DCSP  DCSP  DCSP  DCSP self.req.headers = headers DCNL DCSP  DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP  DCSP self.req.body = body DCNL DCSP  DCSP def getresponse(self): DCNL DCSP  DCSP  DCSP mapper = routes.Mapper() DCNL DCSP  DCSP  DCSP api = context.UnauthenticatedContextMiddleware(router.API(mapper)) DCNL DCSP  DCSP  DCSP res = self.req.get_response(api) DCNL DCSP  DCSP  DCSP def fake_reader(): DCNL DCSP  DCSP  DCSP  DCSP return res.body DCNL DCSP  DCSP  DCSP setattr(res, 'read', fake_reader) DCNL DCSP  DCSP  DCSP return res DCNL DCSP def fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP DEFAULT_API_PORT = 9292 DCNL DCSP  DCSP if ((client.port == DEFAULT_API_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeGlanceConnection DCNL DCSP  DCSP elif ((client.port == DEFAULT_REGISTRY_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP def fake_image_iter(self): DCNL DCSP  DCSP for i in self.source.app_iter: DCNL DCSP  DCSP  DCSP (yield i) DCNL DCSP def fake_sendable(self, body): DCNL DCSP  DCSP force = getattr(self, 'stub_force_sendfile', None) DCNL DCSP  DCSP if (force is None): DCNL DCSP  DCSP  DCSP return self._stub_orig_sendable(body) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP  DCSP assert glance.common.client.SENDFILE_SUPPORTED DCNL DCSP  DCSP  DCSP return force DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type) DCNL DCSP setattr(glance.common.client.BaseClient, '_stub_orig_sendable', glance.common.client.BaseClient._sendable) DCNL DCSP stubs.Set(glance.common.client.BaseClient, '_sendable', fake_sendable)
def stub_out_registry_server(stubs, **kwargs): DCNL  DCSP def fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP if ((client.port == DEFAULT_REGISTRY_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP def fake_image_iter(self): DCNL DCSP  DCSP for i in self.response.app_iter: DCNL DCSP  DCSP  DCSP (yield i) DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type)
def wait_for_scrub(path): DCNL  DCSP http = httplib2.Http() DCNL DCSP wait_for = 300 DCNL DCSP check_every = 15 DCNL DCSP for _ in xrange((wait_for / check_every)): DCNL DCSP  DCSP time.sleep(check_every) DCNL DCSP  DCSP (response, content) = http.request(path, 'HEAD') DCNL DCSP  DCSP if ((response['x-image-meta-status'] == 'deleted') and (response['x-image-meta-deleted'] == 'True')): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP continue DCNL DCSP else: DCNL DCSP  DCSP self.fail('image DCSP was DCSP never DCSP scrubbed')
def skip_if_disabled(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kwargs): DCNL DCSP  DCSP func.__test__ = False DCNL DCSP  DCSP test_obj = a[0] DCNL DCSP  DCSP message = getattr(test_obj, 'disabled_message', 'Test DCSP disabled') DCNL DCSP  DCSP if getattr(test_obj, 'disabled', False): DCNL DCSP  DCSP  DCSP test_obj.skipTest(message) DCNL DCSP  DCSP func(*a, **kwargs) DCNL DCSP return wrapped
def execute(cmd, raise_error=True, no_venv=False, exec_env=None, expect_exit=True, expected_exitcode=0, context=None): DCNL  DCSP env = os.environ.copy() DCNL DCSP if (exec_env is not None): DCNL DCSP  DCSP for (env_name, env_val) in exec_env.items(): DCNL DCSP  DCSP  DCSP if callable(env_val): DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val(env.get(env_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val DCNL DCSP if (no_venv and ('VIRTUAL_ENV' in env)): DCNL DCSP  DCSP env['PATH'] = env['PATH'].split(os.pathsep, 1)[(-1)] DCNL DCSP  DCSP del env['VIRTUAL_ENV'] DCNL DCSP path_ext = [os.path.join(os.getcwd(), 'bin')] DCNL DCSP executable = cmd.split()[0] DCNL DCSP if os.path.isabs(executable): DCNL DCSP  DCSP path_ext.append(os.path.dirname(executable)) DCNL DCSP env['PATH'] = ((':'.join(path_ext) + ':') + env['PATH']) DCNL DCSP process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) DCNL DCSP if expect_exit: DCNL DCSP  DCSP result = process.communicate() DCNL DCSP  DCSP (out, err) = result DCNL DCSP  DCSP exitcode = process.returncode DCNL DCSP else: DCNL DCSP  DCSP out = '' DCNL DCSP  DCSP err = '' DCNL DCSP  DCSP exitcode = 0 DCNL DCSP if ((exitcode != expected_exitcode) and raise_error): DCNL DCSP  DCSP msg = ('Command DCSP %(cmd)s DCSP did DCSP not DCSP succeed. DCSP Returned DCSP an DCSP exit DCSP code DCSP of DCSP %(exitcode)d.\n\nSTDOUT: DCSP %(out)s\n\nSTDERR: DCSP %(err)s' % locals()) DCNL DCSP  DCSP if context: DCNL DCSP  DCSP  DCSP msg += ('\n\nCONTEXT: DCSP %s' % context) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return (exitcode, out, err)
def find_executable(cmdname): DCNL  DCSP if os.path.isabs(cmdname): DCNL DCSP  DCSP return cmdname DCNL DCSP path = ([os.path.join(os.getcwd(), 'bin')] + os.environ['PATH'].split(os.pathsep)) DCNL DCSP for elem in path: DCNL DCSP  DCSP full_path = os.path.join(elem, cmdname) DCNL DCSP  DCSP if os.access(full_path, os.X_OK): DCNL DCSP  DCSP  DCSP return full_path DCNL DCSP return None
def get_unused_port(): DCNL  DCSP s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP s.bind(('localhost', 0)) DCNL DCSP (addr, port) = s.getsockname() DCNL DCSP s.close() DCNL DCSP return port
def xattr_writes_supported(path): DCNL  DCSP try: DCNL DCSP  DCSP import xattr DCNL DCSP except ImportError: DCNL DCSP  DCSP return False DCNL DCSP def set_xattr(path, key, value): DCNL DCSP  DCSP xattr.setxattr(path, ('user.%s' % key), str(value)) DCNL DCSP fake_filepath = os.path.join(path, 'testing-checkme') DCNL DCSP result = True DCNL DCSP with open(fake_filepath, 'wb') as fake_file: DCNL DCSP  DCSP fake_file.write('XXX') DCNL DCSP  DCSP fake_file.flush() DCNL DCSP try: DCNL DCSP  DCSP set_xattr(fake_filepath, 'hits', '1') DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == errno.EOPNOTSUPP): DCNL DCSP  DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP if os.path.exists(fake_filepath): DCNL DCSP  DCSP  DCSP os.unlink(fake_filepath) DCNL DCSP return result
def stub_out_http_backend(stubs): DCNL  DCSP class FakeHTTPConnection(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def getresponse(self): DCNL DCSP  DCSP  DCSP if len(FAKE_RESPONSE_STACK): DCNL DCSP  DCSP  DCSP  DCSP return FAKE_RESPONSE_STACK.pop() DCNL DCSP  DCSP  DCSP return utils.FakeHTTPResponse() DCNL DCSP  DCSP def request(self, *_args, **_kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def close(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP def fake_get_conn_class(self, *args, **kwargs): DCNL DCSP  DCSP return FakeHTTPConnection DCNL DCSP stubs.Set(Store, '_get_conn_class', fake_get_conn_class)
def stub_out_registry_image_update(stubs): DCNL  DCSP test_stubs.stub_out_registry_server(stubs) DCNL DCSP def fake_image_update(ctx, image_id, values, purge_props=False): DCNL DCSP  DCSP return {'properties': {}} DCNL DCSP stubs.Set(db_api, 'image_update', fake_image_update)
def format_s3_location(user, key, authurl, bucket, obj): DCNL  DCSP scheme = 's3' DCNL DCSP if authurl.startswith('https://'): DCNL DCSP  DCSP scheme = 's3+https' DCNL DCSP  DCSP authurl = authurl[8:] DCNL DCSP elif authurl.startswith('http://'): DCNL DCSP  DCSP authurl = authurl[7:] DCNL DCSP authurl = authurl.strip('/') DCNL DCSP return ('%s://%s:%s@%s/%s/%s' % (scheme, user, key, authurl, bucket, obj))
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL  DCSP if (backend == 'mysql'): DCNL DCSP  DCSP backend = 'mysql+mysqldb' DCNL DCSP elif (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
def get_table(engine, name): DCNL  DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
def get_err_response(code): DCNL  DCSP error_table = {'AccessDenied': (HTTP_FORBIDDEN, 'Access DCSP denied'), 'BucketAlreadyExists': (HTTP_CONFLICT, 'The DCSP requested DCSP bucket DCSP name DCSP is DCSP not DCSP available'), 'BucketNotEmpty': (HTTP_CONFLICT, 'The DCSP bucket DCSP you DCSP tried DCSP to DCSP delete DCSP is DCSP not DCSP empty'), 'InvalidArgument': (HTTP_BAD_REQUEST, 'Invalid DCSP Argument'), 'InvalidBucketName': (HTTP_BAD_REQUEST, 'The DCSP specified DCSP bucket DCSP is DCSP not DCSP valid'), 'InvalidURI': (HTTP_BAD_REQUEST, 'Could DCSP not DCSP parse DCSP the DCSP specified DCSP URI'), 'InvalidDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-MD5 DCSP you DCSP specified DCSP was DCSP invalid'), 'BadDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-Length DCSP you DCSP specified DCSP was DCSP invalid'), 'NoSuchBucket': (HTTP_NOT_FOUND, 'The DCSP specified DCSP bucket DCSP does DCSP not DCSP exist'), 'SignatureDoesNotMatch': (HTTP_FORBIDDEN, 'The DCSP calculated DCSP request DCSP signature DCSP does DCSP not DCSP match DCSP your DCSP provided DCSP one'), 'RequestTimeTooSkewed': (HTTP_FORBIDDEN, 'The DCSP difference DCSP between DCSP the DCSP request DCSP time DCSP and DCSP the DCSP current DCSP time DCSP is DCSP too DCSP large'), 'NoSuchKey': (HTTP_NOT_FOUND, 'The DCSP resource DCSP you DCSP requested DCSP does DCSP not DCSP exist'), 'Unsupported': (HTTP_NOT_IMPLEMENTED, 'The DCSP feature DCSP you DCSP requested DCSP is DCSP not DCSP yet DCSP implemented'), 'MissingContentLength': (HTTP_LENGTH_REQUIRED, 'Length DCSP Required'), 'ServiceUnavailable': (HTTP_SERVICE_UNAVAILABLE, 'Please DCSP reduce DCSP your DCSP request DCSP rate')} DCNL DCSP resp = Response(content_type='text/xml') DCNL DCSP resp.status = error_table[code][0] DCNL DCSP resp.body = ('<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>\r\n<Error>\r\n DCSP  DCSP <Code>%s</Code>\r\n DCSP  DCSP <Message>%s</Message>\r\n</Error>\r\n' % (code, error_table[code][1])) DCNL DCSP return resp
def get_acl(account_name, headers): DCNL  DCSP acl = 'private' DCNL DCSP if ('x-container-read' in headers): DCNL DCSP  DCSP if ((headers['x-container-read'] == '.r:*') or ('.r:*,' in headers['x-container-read']) or (',*,' in headers['x-container-read'])): DCNL DCSP  DCSP  DCSP acl = 'public-read' DCNL DCSP if ('x-container-write' in headers): DCNL DCSP  DCSP if ((headers['x-container-write'] == '.r:*') or ('.r:*,' in headers['x-container-write']) or (',*,' in headers['x-container-write'])): DCNL DCSP  DCSP  DCSP if (acl == 'public-read'): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-write' DCNL DCSP if (acl == 'private'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-read'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-read-write'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>WRITE</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP else: DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP return Response(body=body, content_type='text/plain')
def canonical_string(req): DCNL  DCSP amz_headers = {} DCNL DCSP buf = ('%s\n%s\n%s\n' % (req.method, req.headers.get('Content-MD5', ''), (req.headers.get('Content-Type') or ''))) DCNL DCSP for amz_header in sorted((key.lower() for key in req.headers if key.lower().startswith('x-amz-'))): DCNL DCSP  DCSP amz_headers[amz_header] = req.headers[amz_header] DCNL DCSP if ('x-amz-date' in amz_headers): DCNL DCSP  DCSP buf += '\n' DCNL DCSP elif ('Date' in req.headers): DCNL DCSP  DCSP buf += ('%s\n' % req.headers['Date']) DCNL DCSP for k in sorted((key.lower() for key in amz_headers)): DCNL DCSP  DCSP buf += ('%s:%s\n' % (k, amz_headers[k])) DCNL DCSP path = req.environ.get('RAW_PATH_INFO', req.path) DCNL DCSP if req.query_string: DCNL DCSP  DCSP path += ('?' + req.query_string) DCNL DCSP if ('?' in path): DCNL DCSP  DCSP (path, args) = path.split('?', 1) DCNL DCSP  DCSP qstr = '' DCNL DCSP  DCSP qdict = dict(urlparse.parse_qsl(args, keep_blank_values=True)) DCNL DCSP  DCSP keywords = sorted(['acl', 'delete', 'lifecycle', 'location', 'logging', 'notification', 'partNumber', 'policy', 'requestPayment', 'torrent', 'uploads', 'uploadId', 'versionId', 'versioning', 'versions DCSP ', 'website']) DCNL DCSP  DCSP for key in qdict: DCNL DCSP  DCSP  DCSP if (key in keywords): DCNL DCSP  DCSP  DCSP  DCSP newstr = key DCNL DCSP  DCSP  DCSP  DCSP if qdict[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newstr = (newstr + ('=%s' % qdict[key])) DCNL DCSP  DCSP  DCSP  DCSP if (qstr == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qstr = newstr DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qstr = (qstr + ('&%s' % newstr)) DCNL DCSP  DCSP if (qstr != ''): DCNL DCSP  DCSP  DCSP return ('%s%s?%s' % (buf, path, qstr)) DCNL DCSP return (buf + path)
def swift_acl_translate(acl, group='', user='', xml=False): DCNL  DCSP swift_acl = {} DCNL DCSP swift_acl['public-read'] = [['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['public-read-write'] = [['HTTP_X_CONTAINER_WRITE', '.r:*'], ['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['private'] = [['HTTP_X_CONTAINER_WRITE', '.'], ['HTTP_X_CONTAINER_READ', '.']] DCNL DCSP if xml: DCNL DCSP  DCSP dom = parseString(acl) DCNL DCSP  DCSP acl = 'unknown' DCNL DCSP  DCSP for grant in dom.getElementsByTagName('Grant'): DCNL DCSP  DCSP  DCSP permission = grant.getElementsByTagName('Permission')[0].firstChild.data DCNL DCSP  DCSP  DCSP grantee = grant.getElementsByTagName('Grantee')[0].getAttributeNode('xsi:type').nodeValue DCNL DCSP  DCSP  DCSP if ((permission == 'FULL_CONTROL') and (grantee == 'CanonicalUser') and (acl != 'public-read') and (acl != 'public-read-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'private' DCNL DCSP  DCSP  DCSP elif ((permission == 'READ') and (grantee == 'Group') and (acl != 'public-read-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read' DCNL DCSP  DCSP  DCSP elif ((permission == 'WRITE') and (grantee == 'Group')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'unsupported' DCNL DCSP if (acl == 'authenticated-read'): DCNL DCSP  DCSP return 'Unsupported' DCNL DCSP elif (acl not in swift_acl): DCNL DCSP  DCSP return 'InvalidArgument' DCNL DCSP return swift_acl[acl]
def validate_bucket_name(name): DCNL  DCSP if (('_' in name) or (len(name) < 3) or (len(name) > 63) or (not name[(-1)].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif (('.-' in name) or ('-.' in name) or ('..' in name) or (not name[0].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif re.match('^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$', name): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
def filter_factory(global_conf, **local_conf): DCNL  DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def swift3_filter(app): DCNL DCSP  DCSP return Swift3Middleware(app, conf) DCNL DCSP return swift3_filter
def run_command(cmd, redirect_output=True, check_exit_code=True, cwd=ROOT, die_message=None): DCNL  DCSP if redirect_output: DCNL DCSP  DCSP stdout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stdout = None DCNL DCSP proc = subprocess.Popen(cmd, cwd=cwd, stdout=stdout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_code and (proc.returncode != 0)): DCNL DCSP  DCSP if (die_message is None): DCNL DCSP  DCSP  DCSP die('Command DCSP "%s" DCSP failed.\n%s', ' DCSP '.join(cmd), output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP die(die_message) DCNL DCSP return output
def check_dependencies(): DCNL  DCSP print 'Checking DCSP dependencies...' DCNL DCSP if (not HAS_VIRTUALENV): DCNL DCSP  DCSP print 'Virtual DCSP environment DCSP not DCSP found.' DCNL DCSP  DCSP if HAS_EASY_INSTALL: DCNL DCSP  DCSP  DCSP print 'Installing DCSP virtualenv DCSP via DCSP easy_install...', DCNL DCSP  DCSP  DCSP run_command(['easy_install', 'virtualenv'], die_message='easy_install DCSP failed DCSP to DCSP install DCSP virtualenv\ndevelopment DCSP requires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP tool') DCNL DCSP  DCSP  DCSP if (not run_command(['which', 'virtualenv'])): DCNL DCSP  DCSP  DCSP  DCSP die('ERROR: DCSP virtualenv DCSP not DCSP found DCSP in DCSP path.\n\ndevelopment DCSP  DCSP requires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP package DCSP management DCSP tool DCSP and DCSP ensure DCSP virtualenv DCSP is DCSP in DCSP your DCSP path') DCNL DCSP  DCSP  DCSP print 'virtualenv DCSP installation DCSP done.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP die('easy_install DCSP not DCSP found.\n\nInstall DCSP easy_install DCSP (python-setuptools DCSP in DCSP ubuntu) DCSP or DCSP virtualenv DCSP by DCSP hand, DCSP then DCSP rerun.') DCNL DCSP print 'dependency DCSP check DCSP done.'
def create_virtualenv(venv=VENV): DCNL  DCSP print 'Creating DCSP venv...', DCNL DCSP run_command(['virtualenv', '-q', '--no-site-packages', VENV]) DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_command([WITH_VENV, 'easy_install', 'pip']).strip()): DCNL DCSP  DCSP die('Failed DCSP to DCSP install DCSP pip.') DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP distribute DCSP in DCSP virtualenv...' DCNL DCSP pip_install('distribute>=0.6.24') DCNL DCSP print 'done.'
def split(path, result=None): DCNL  DCSP if (result is None): DCNL DCSP  DCSP result = [] DCNL DCSP (head, tail) = os.path.split(path) DCNL DCSP if (head == ''): DCNL DCSP  DCSP return ([tail] + result) DCNL DCSP if (head == path): DCNL DCSP  DCSP return result DCNL DCSP return split(head, ([tail] + result))
def single_line(text): DCNL  DCSP return re.sub(' DCSP +', ' DCSP ', normalize_newlines(text).replace('\n', '')).strip()
def user_home(request): DCNL  DCSP return shortcuts.redirect(horizon.get_user_home(request.user))
def generate_key(key_length=64): DCNL  DCSP if hasattr(random, 'SystemRandom'): DCNL DCSP  DCSP choice = random.SystemRandom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = random.choice DCNL DCSP return ''.join(map((lambda x: choice((string.digits + string.letters))), range(key_length)))
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL  DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP old_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(old_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_mode & 511)) != '0600'): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.readline() DCNL DCSP  DCSP return key
def horizon(request): DCNL  DCSP context = {'HORIZON_CONFIG': conf.HORIZON_CONFIG, 'True': True, 'False': False} DCNL DCSP return context
def add_message(request, level, message, extra_tags='', fail_silently=False): DCNL  DCSP if request.is_ajax(): DCNL DCSP  DCSP tag = constants.DEFAULT_TAGS[level] DCNL DCSP  DCSP if isinstance(message, SafeData): DCNL DCSP  DCSP  DCSP extra_tags = (extra_tags + ' DCSP safe') DCNL DCSP  DCSP request.horizon['async_messages'].append([tag, force_unicode(message), extra_tags]) DCNL DCSP else: DCNL DCSP  DCSP return _messages.add_message(request, level, message, extra_tags, fail_silently)
def debug(request, message, extra_tags='', fail_silently=False): DCNL  DCSP add_message(request, constants.DEBUG, message, extra_tags=extra_tags, fail_silently=fail_silently)
def info(request, message, extra_tags='', fail_silently=False): DCNL  DCSP add_message(request, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
def success(request, message, extra_tags='', fail_silently=False): DCNL  DCSP add_message(request, constants.SUCCESS, message, extra_tags=extra_tags, fail_silently=fail_silently)
def warning(request, message, extra_tags='', fail_silently=False): DCNL  DCSP add_message(request, constants.WARNING, message, extra_tags=extra_tags, fail_silently=fail_silently)
def error(request, message, extra_tags='', fail_silently=False): DCNL  DCSP add_message(request, constants.ERROR, message, extra_tags=extra_tags, fail_silently=fail_silently)
def _current_component(view_func, dashboard=None, panel=None): DCNL  DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if dashboard: DCNL DCSP  DCSP  DCSP request.horizon['dashboard'] = dashboard DCNL DCSP  DCSP if panel: DCNL DCSP  DCSP  DCSP request.horizon['panel'] = panel DCNL DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP return dec
def require_auth(view_func): DCNL  DCSP from horizon.exceptions import NotAuthenticated DCNL DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthenticated(_('Please DCSP log DCSP in DCSP to DCSP continue.')) DCNL DCSP return dec
def require_perms(view_func, required): DCNL  DCSP from horizon.exceptions import NotAuthorized DCNL DCSP current_perms = getattr(view_func, '_required_perms', set([])) DCNL DCSP view_func._required_perms = (current_perms | set(required)) DCNL DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP if request.user.has_perms(view_func._required_perms): DCNL DCSP  DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthorized((_('You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP %s') % request.path)) DCNL DCSP if required: DCNL DCSP  DCSP return dec DCNL DCSP else: DCNL DCSP  DCSP return view_func
def check_message(keywords, message): DCNL  DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP if set(str(exc_value).split(' DCSP ')).issuperset(set(keywords)): DCNL DCSP  DCSP exc_value._safe_message = message DCNL DCSP  DCSP raise
def handle(request, message=None, redirect=None, ignore=False, escalate=False, log_level=None, force_log=None): DCNL  DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP log_method = getattr(LOG, (log_level or 'exception')) DCNL DCSP force_log = (force_log or os.environ.get('HORIZON_TEST_RUN', False)) DCNL DCSP force_silence = getattr(exc_value, 'silence_logging', False) DCNL DCSP handled = issubclass(exc_type, HandledException) DCNL DCSP wrap = False DCNL DCSP if handled: DCNL DCSP  DCSP (exc_type, exc_value, exc_traceback) = exc_value.wrapped DCNL DCSP  DCSP wrap = True DCNL DCSP if issubclass(exc_type, HorizonException): DCNL DCSP  DCSP message = exc_value DCNL DCSP elif getattr(exc_value, '_safe_message', None): DCNL DCSP  DCSP message = exc_value._safe_message DCNL DCSP elif (message and ('%(exc)s' in message)): DCNL DCSP  DCSP message = (message % {'exc': exc_value}) DCNL DCSP if issubclass(exc_type, UNAUTHORIZED): DCNL DCSP  DCSP if ignore: DCNL DCSP  DCSP  DCSP return NotAuthorized DCNL DCSP  DCSP if ((not force_silence) and (not handled)): DCNL DCSP  DCSP  DCSP log_method(error_color(('Unauthorized: DCSP %s' % exc_value))) DCNL DCSP  DCSP if (not handled): DCNL DCSP  DCSP  DCSP if message: DCNL DCSP  DCSP  DCSP  DCSP message = (_('Unauthorized: DCSP %s') % message) DCNL DCSP  DCSP  DCSP fallback = _('Unauthorized. DCSP Please DCSP try DCSP logging DCSP in DCSP again.') DCNL DCSP  DCSP  DCSP messages.error(request, (message or fallback)) DCNL DCSP  DCSP if escalate: DCNL DCSP  DCSP  DCSP logout(request) DCNL DCSP  DCSP  DCSP raise NotAuthorized DCNL DCSP  DCSP return NotAuthorized DCNL DCSP if issubclass(exc_type, NOT_FOUND): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) and (not handled) and ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_method(error_color(('Not DCSP Found: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) and (not handled)): DCNL DCSP  DCSP  DCSP messages.error(request, (message or exc_value)) DCNL DCSP  DCSP if redirect: DCNL DCSP  DCSP  DCSP raise Http302(redirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return NotFound DCNL DCSP if issubclass(exc_type, RECOVERABLE): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) and (not handled) and ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_method = getattr(LOG, (log_level or 'warning')) DCNL DCSP  DCSP  DCSP log_method(error_color(('Recoverable DCSP error: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) and (not handled)): DCNL DCSP  DCSP  DCSP messages.error(request, (message or exc_value)) DCNL DCSP  DCSP if redirect: DCNL DCSP  DCSP  DCSP raise Http302(redirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return RecoverableError DCNL DCSP if wrap: DCNL DCSP  DCSP raise HandledException([exc_type, exc_value, exc_traceback]) DCNL DCSP raise exc_type, exc_value, exc_traceback
@register.filter DCNL def has_permissions(user, component): DCNL  DCSP return user.has_perms(getattr(component, 'permissions', set()))
@register.inclusion_tag('horizon/_nav_list.html', takes_context=True) DCNL def horizon_main_nav(context): DCNL  DCSP if ('request' not in context): DCNL DCSP  DCSP return {} DCNL DCSP current_dashboard = context['request'].horizon.get('dashboard', None) DCNL DCSP dashboards = [] DCNL DCSP for dash in Horizon.get_dashboards(): DCNL DCSP  DCSP if (callable(dash.nav) and dash.nav(context)): DCNL DCSP  DCSP  DCSP dashboards.append(dash) DCNL DCSP  DCSP elif dash.nav: DCNL DCSP  DCSP  DCSP dashboards.append(dash) DCNL DCSP return {'components': dashboards, 'user': context['request'].user, 'current': current_dashboard, 'request': context['request']}
@register.inclusion_tag('horizon/_subnav_list.html', takes_context=True) DCNL def horizon_dashboard_nav(context): DCNL  DCSP if ('request' not in context): DCNL DCSP  DCSP return {} DCNL DCSP dashboard = context['request'].horizon['dashboard'] DCNL DCSP panel_groups = dashboard.get_panel_groups() DCNL DCSP non_empty_groups = [] DCNL DCSP for group in panel_groups.values(): DCNL DCSP  DCSP allowed_panels = [] DCNL DCSP  DCSP for panel in group: DCNL DCSP  DCSP  DCSP if (callable(panel.nav) and panel.nav(context)): DCNL DCSP  DCSP  DCSP  DCSP allowed_panels.append(panel) DCNL DCSP  DCSP  DCSP elif ((not callable(panel.nav)) and panel.nav): DCNL DCSP  DCSP  DCSP  DCSP allowed_panels.append(panel) DCNL DCSP  DCSP if allowed_panels: DCNL DCSP  DCSP  DCSP non_empty_groups.append((group.name, allowed_panels)) DCNL DCSP return {'components': SortedDict(non_empty_groups), 'user': context['request'].user, 'current': context['request'].horizon['panel'].slug, 'request': context['request']}
@register.inclusion_tag('horizon/common/_progress_bar.html') DCNL def horizon_progress_bar(current_val, max_val): DCNL  DCSP return {'current_val': current_val, 'max_val': max_val}
@register.tag DCNL def jstemplate(parser, token): DCNL  DCSP nodelist = parser.parse(('endjstemplate',)) DCNL DCSP parser.delete_first_token() DCNL DCSP return JSTemplateNode(nodelist)
def vip_create(request, **kwargs): DCNL  DCSP body = {'vip': {'address': kwargs['address'], 'name': kwargs['name'], 'description': kwargs['description'], 'subnet_id': kwargs['subnet_id'], 'protocol_port': kwargs['protocol_port'], 'protocol': kwargs['protocol'], 'pool_id': kwargs['pool_id'], 'session_persistence': kwargs['session_persistence'], 'connection_limit': kwargs['connection_limit'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP vip = quantumclient(request).create_vip(body).get('vip') DCNL DCSP return Vip(vip)
def pool_create(request, **kwargs): DCNL  DCSP body = {'pool': {'name': kwargs['name'], 'description': kwargs['description'], 'subnet_id': kwargs['subnet_id'], 'protocol': kwargs['protocol'], 'lb_method': kwargs['lb_method'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP pool = quantumclient(request).create_pool(body).get('pool') DCNL DCSP return Pool(pool)
def pool_health_monitor_create(request, **kwargs): DCNL  DCSP body = {'health_monitor': {'type': kwargs['type'], 'delay': kwargs['delay'], 'timeout': kwargs['timeout'], 'max_retries': kwargs['max_retries'], 'http_method': kwargs['http_method'], 'url_path': kwargs['url_path'], 'expected_codes': kwargs['expected_codes'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP mon = quantumclient(request).create_health_monitor(body).get('health_monitor') DCNL DCSP body = {'health_monitor': {'id': mon['id']}} DCNL DCSP quantumclient(request).associate_health_monitor(kwargs['pool_id'], body) DCNL DCSP return PoolMonitor(mon)
def member_create(request, **kwargs): DCNL  DCSP body = {'member': {'pool_id': kwargs['pool_id'], 'address': kwargs['address'], 'protocol_port': kwargs['protocol_port'], 'weight': kwargs['weight'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP member = quantumclient(request).create_member(body).get('member') DCNL DCSP return Member(member)
@memoized DCNL def flavor_list(request): DCNL  DCSP return novaclient(request).flavors.list()
def flavor_get_extras(request, flavor_id, raw=False): DCNL  DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP extras = flavor.get_keys() DCNL DCSP if raw: DCNL DCSP  DCSP return extras DCNL DCSP return [FlavorExtraSpec(flavor_id, key, value) for (key, value) in extras.items()]
def flavor_extra_delete(request, flavor_id, keys): DCNL  DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP return flavor.unset_keys(keys)
def flavor_extra_set(request, flavor_id, metadata): DCNL  DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP if (not metadata): DCNL DCSP  DCSP return None DCNL DCSP return flavor.set_keys(metadata)
def server_console_output(request, instance_id, tail_length=None): DCNL  DCSP return novaclient(request).servers.get_console_output(instance_id, length=tail_length)
def server_security_groups(request, instance_id): DCNL  DCSP security_groups = [] DCNL DCSP nclient = novaclient(request) DCNL DCSP (resp, body) = nclient.client.get(('/servers/%s/os-security-groups' % instance_id)) DCNL DCSP if body: DCNL DCSP  DCSP sg_objs = [NovaSecurityGroup(nclient.security_groups, sg, loaded=True) for sg in body.get('security_groups', [])] DCNL DCSP  DCSP security_groups = [SecurityGroup(sg) for sg in sg_objs] DCNL DCSP  DCSP for sg in security_groups: DCNL DCSP  DCSP  DCSP rule_objects = [SecurityGroupRule(rule) for rule in sg.rules] DCNL DCSP  DCSP  DCSP sg.rules = rule_objects DCNL DCSP return security_groups
def volume_list(request, search_opts=None): DCNL  DCSP c_client = cinderclient(request) DCNL DCSP if (c_client is None): DCNL DCSP  DCSP return [] DCNL DCSP return c_client.volumes.list(search_opts=search_opts)
def image_get(request, image_id): DCNL  DCSP return glanceclient(request).images.get(image_id)
def get_ipver_str(ip_version): DCNL  DCSP return IP_VERSION_DICT.get(ip_version, '')
def network_list_for_tenant(request, tenant_id, **params): DCNL  DCSP LOG.debug(('network_list_for_tenant(): DCSP tenant_id=%s, DCSP params=%s' % (tenant_id, params))) DCNL DCSP networks = network_list(request, tenant_id=tenant_id, shared=False, **params) DCNL DCSP networks += network_list(request, shared=True, **params) DCNL DCSP return networks
def network_create(request, **kwargs): DCNL  DCSP LOG.debug(('network_create(): DCSP kwargs DCSP = DCSP %s' % kwargs)) DCNL DCSP body = {'network': kwargs} DCNL DCSP network = quantumclient(request).create_network(body=body).get('network') DCNL DCSP return Network(network)
def subnet_create(request, network_id, cidr, ip_version, **kwargs): DCNL  DCSP LOG.debug(('subnet_create(): DCSP netid=%s, DCSP cidr=%s, DCSP ipver=%d, DCSP kwargs=%s' % (network_id, cidr, ip_version, kwargs))) DCNL DCSP body = {'subnet': {'network_id': network_id, 'ip_version': ip_version, 'cidr': cidr}} DCNL DCSP body['subnet'].update(kwargs) DCNL DCSP subnet = quantumclient(request).create_subnet(body=body).get('subnet') DCNL DCSP return Subnet(subnet)
def port_create(request, network_id, **kwargs): DCNL  DCSP LOG.debug(('port_create(): DCSP netid=%s, DCSP kwargs=%s' % (network_id, kwargs))) DCNL DCSP body = {'port': {'network_id': network_id}} DCNL DCSP body['port'].update(kwargs) DCNL DCSP port = quantumclient(request).create_port(body=body).get('port') DCNL DCSP return Port(port)
def keystoneclient(request, admin=False): DCNL  DCSP user = request.user DCNL DCSP if admin: DCNL DCSP  DCSP if (not user.is_superuser): DCNL DCSP  DCSP  DCSP raise exceptions.NotAuthorized DCNL DCSP  DCSP endpoint_type = 'adminURL' DCNL DCSP else: DCNL DCSP  DCSP endpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP cache_attr = ('_keystoneclient_admin' if admin else KEYSTONE_CLIENT_ATTR) DCNL DCSP if (hasattr(request, cache_attr) and ((not user.token.id) or (getattr(request, cache_attr).auth_token == user.token.id))): DCNL DCSP  DCSP LOG.debug(('Using DCSP cached DCSP client DCSP for DCSP token: DCSP %s' % user.token.id)) DCNL DCSP  DCSP conn = getattr(request, cache_attr) DCNL DCSP else: DCNL DCSP  DCSP endpoint = _get_endpoint_url(request, endpoint_type) DCNL DCSP  DCSP insecure = getattr(settings, 'OPENSTACK_SSL_NO_VERIFY', False) DCNL DCSP  DCSP LOG.debug(('Creating DCSP a DCSP new DCSP keystoneclient DCSP connection DCSP to DCSP %s.' % endpoint)) DCNL DCSP  DCSP kcversion = get_distribution('python-keystoneclient').version DCNL DCSP  DCSP if (kcversion >= '0.2.0'): DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.id, endpoint=endpoint, original_ip=request.environ.get('REMOTE_ADDR', ''), insecure=insecure) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.id, endpoint=endpoint, insecure=insecure) DCNL DCSP  DCSP setattr(request, cache_attr, conn) DCNL DCSP return conn
def token_create_scoped(request, tenant, token): DCNL  DCSP if hasattr(request, '_keystone'): DCNL DCSP  DCSP del request._keystone DCNL DCSP c = keystoneclient(request) DCNL DCSP raw_token = c.tokens.authenticate(tenant_id=tenant, token=token, return_raw=True) DCNL DCSP c.service_catalog = service_catalog.ServiceCatalog(raw_token) DCNL DCSP if request.user.is_superuser: DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='identity', endpoint_type='adminURL') DCNL DCSP else: DCNL DCSP  DCSP endpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='identity', endpoint_type=endpoint_type) DCNL DCSP scoped_token = tokens.Token(tokens.TokenManager, raw_token) DCNL DCSP return scoped_token
def role_list(request): DCNL  DCSP return keystoneclient(request, admin=True).roles.list()
def add_tenant_user_role(request, tenant_id, user_id, role_id): DCNL  DCSP return keystoneclient(request, admin=True).roles.add_user_role(user_id, role_id, tenant_id)
def remove_tenant_user_role(request, tenant_id, user_id, role_id): DCNL  DCSP client = keystoneclient(request, admin=True) DCNL DCSP client.roles.remove_user_role(user_id, role_id, tenant_id)
def remove_tenant_user(request, tenant_id, user_id): DCNL  DCSP client = keystoneclient(request, admin=True) DCNL DCSP roles = client.roles.roles_for_user(user_id, tenant_id) DCNL DCSP for role in roles: DCNL DCSP  DCSP client.roles.remove_user_role(user_id, role.id, tenant_id)
def get_default_role(request): DCNL  DCSP global DEFAULT_ROLE DCNL DCSP default = getattr(settings, 'OPENSTACK_KEYSTONE_DEFAULT_ROLE', None) DCNL DCSP if (default and (DEFAULT_ROLE is None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP roles = keystoneclient(request, admin=True).roles.list() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP roles = [] DCNL DCSP  DCSP  DCSP exceptions.handle(request) DCNL DCSP  DCSP for role in roles: DCNL DCSP  DCSP  DCSP if ((role.id == default) or (role.name == default)): DCNL DCSP  DCSP  DCSP  DCSP DEFAULT_ROLE = role DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return DEFAULT_ROLE
def _objectify(items, container_name): DCNL  DCSP objects = [] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item.get('subdir', None) is not None): DCNL DCSP  DCSP  DCSP object_cls = PseudoFolder DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP object_cls = StorageObject DCNL DCSP  DCSP objects.append(object_cls(item, container_name)) DCNL DCSP return objects
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(): DCNL  DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
def get_version_from_git(pre_version): DCNL  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
def get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def get_int_or_uuid(value): DCNL  DCSP try: DCNL DCSP  DCSP uuid.UUID(value) DCNL DCSP  DCSP return value DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP return int(value)
def openstack(request): DCNL  DCSP context = {} DCNL DCSP context.setdefault('authorized_tenants', []) DCNL DCSP current_dash = request.horizon['dashboard'] DCNL DCSP needs_tenants = getattr(current_dash, 'supports_tenants', False) DCNL DCSP if (request.user.is_authenticated() and needs_tenants): DCNL DCSP  DCSP context['authorized_tenants'] = request.user.authorized_tenants DCNL DCSP available_regions = getattr(settings, 'AVAILABLE_REGIONS', []) DCNL DCSP regions = {'support': (len(available_regions) > 1), 'current': {'endpoint': request.session.get('region_endpoint'), 'name': request.session.get('region_name')}, 'available': [{'endpoint': region[0], 'name': region[1]} for region in available_regions]} DCNL DCSP context['regions'] = regions DCNL DCSP return context
def cinder_todo_format(physical_line): DCNL  DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'CINDER DCSP N101: DCSP Use DCSP TODO(NAME)')
def cinder_except_format(logical_line): DCNL  DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "CINDER DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
def cinder_except_format_assert(logical_line): DCNL  DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'CINDER DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
def cinder_one_import_per_line(logical_line): DCNL  DCSP pos = logical_line.find(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) and ((parts[0] == 'import') or ((parts[0] == 'from') and (parts[2] == 'import'))) and (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yield (pos, 'CINDER DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
def cinder_import_module_only(logical_line): DCNL  DCSP def importModuleCheck(mod, parent=None, added=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP find DCSP module DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valid = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_mod = __import__(parent, globals(), locals(), [mod], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(getattr(parent_mod, mod)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(mod, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(sys.modules[mod]) DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if added: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("CINDER DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("CINDER DCSP N302: DCSP import DCSP only DCSP modules. DCSP '%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not added): DCNL DCSP  DCSP  DCSP  DCSP added = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.append(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importModuleCheck(mod, parent, added) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ("ERROR: DCSP import DCSP '%s' DCSP failed: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(name) DCNL DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.find(mod), 'CINDER DCSP N303: DCSP Invalid DCSP import, DCSP AttributeError DCSP raised') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') and (',' not in logical_line) and ((len(split_line) == 2) or ((len(split_line) == 4) and (split_line[2] == 'as')))): DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP rval = importModuleCheck(mod) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yield rval)
def cinder_import_alphabetical(physical_line, line_number, lines): DCNL  DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('CINDER DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
def cinder_docstring_start_space(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N401: DCSP one DCSP line DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
def cinder_docstring_one_line(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP end = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and end and (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') and physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP a DCSP period')
def cinder_docstring_multiline_end(physical_line): DCNL  DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
def check_l18n(): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N703: DCSP Multiple DCSP positional DCSP placeholders')
def cinder_localization_strings(logical_line, tokens): DCNL  DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
def readlines(filename): DCNL  DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
def add_cinder(): DCNL  DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('cinder')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
def _sanitize_default(s): DCNL  DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'cinder' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
def _translate_snapshot_detail_view(context, snapshot): DCNL  DCSP d = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return d
def _translate_snapshot_summary_view(context, snapshot): DCNL  DCSP d = {} DCNL DCSP d['id'] = snapshot['id'] DCNL DCSP d['created_at'] = snapshot['created_at'] DCNL DCSP d['display_name'] = snapshot['display_name'] DCNL DCSP d['display_description'] = snapshot['display_description'] DCNL DCSP d['volume_id'] = snapshot['volume_id'] DCNL DCSP d['status'] = snapshot['status'] DCNL DCSP d['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metadata'): DCNL DCSP  DCSP metadata = snapshot.get('snapshot_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (snapshot.get('metadata') and isinstance(snapshot.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = snapshot['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
def _translate_attachment_detail_view(_context, vol): DCNL  DCSP d = _translate_attachment_summary_view(_context, vol) DCNL DCSP return d
def _translate_attachment_summary_view(_context, vol): DCNL  DCSP d = {} DCNL DCSP volume_id = vol['id'] DCNL DCSP d['id'] = volume_id DCNL DCSP d['volume_id'] = volume_id DCNL DCSP d['server_id'] = vol['instance_uuid'] DCNL DCSP if vol.get('mountpoint'): DCNL DCSP  DCSP d['device'] = vol['mountpoint'] DCNL DCSP return d
def _translate_volume_detail_view(context, vol, image_id=None): DCNL  DCSP d = _translate_volume_summary_view(context, vol, image_id) DCNL DCSP return d
def _translate_volume_summary_view(context, vol, image_id=None): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availability_zone'] = vol['availability_zone'] DCNL DCSP d['created_at'] = vol['created_at'] DCNL DCSP d['attachments'] = [] DCNL DCSP if (vol['attach_status'] == 'attached'): DCNL DCSP  DCSP attachment = _translate_attachment_detail_view(context, vol) DCNL DCSP  DCSP d['attachments'].append(attachment) DCNL DCSP d['display_name'] = vol['display_name'] DCNL DCSP d['display_description'] = vol['display_description'] DCNL DCSP if (vol['volume_type_id'] and vol.get('volume_type')): DCNL DCSP  DCSP d['volume_type'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['volume_type'] = str(vol['volume_type_id']) DCNL DCSP d['snapshot_id'] = vol['snapshot_id'] DCNL DCSP d['source_volid'] = vol['source_volid'] DCNL DCSP if image_id: DCNL DCSP  DCSP d['image_id'] = image_id DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metadata'): DCNL DCSP  DCSP metadata = vol.get('volume_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (vol.get('metadata') and isinstance(vol.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = vol['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP if vol.get('volume_glance_metadata'): DCNL DCSP  DCSP d['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP d['bootable'] = 'false' DCNL DCSP return d
def remove_invalid_options(context, search_options, allowed_search_options): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(bad_options)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del search_options[opt]
def serializers(**serializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def deserializers(**deserializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def response(code): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
def action_peek_json(body): DCNL  DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
def action_peek_xml(body): DCNL  DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
def action(name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
def extends(*args, **kwargs): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
def _translate_snapshot_detail_view(context, snapshot): DCNL  DCSP d = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return d
def _translate_snapshot_summary_view(context, snapshot): DCNL  DCSP d = {} DCNL DCSP d['id'] = snapshot['id'] DCNL DCSP d['created_at'] = snapshot['created_at'] DCNL DCSP d['name'] = snapshot['display_name'] DCNL DCSP d['description'] = snapshot['display_description'] DCNL DCSP d['volume_id'] = snapshot['volume_id'] DCNL DCSP d['status'] = snapshot['status'] DCNL DCSP d['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metadata'): DCNL DCSP  DCSP metadata = snapshot.get('snapshot_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (snapshot.get('metadata') and isinstance(snapshot.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = snapshot['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
def remove_invalid_options(context, filters, allowed_search_options): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in filters if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%s' DCSP from DCSP query") % bad_options) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del filters[opt]
def _list_hosts(req, service=None): DCNL  DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['cinder.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
def check_host(fn): DCNL  DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
def pipeline_factory(loader, global_conf, **local_conf): DCNL  DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
def get_items(obj): DCNL  DCSP return list(obj.items())
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL  DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
def make_links(parent, selector=None): DCNL  DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL  DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL  DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
def get_pagination_params(request): DCNL  DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
def _get_marker_param(request): DCNL  DCSP return request.GET['marker']
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
def remove_version_from_href(href): DCNL  DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
def unquote_header_value(value): DCNL  DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
def parse_list_header(value): DCNL  DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
def parse_options_header(value): DCNL  DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def build_filter(class_name, *args): DCNL  DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
def load_filters(filters_path): DCNL  DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
def match_filter(filters, userargs, exec_dirs=[]): DCNL  DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def set_brain(brain): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = brain
def reset(): DCNL  DCSP global _BRAIN DCNL DCSP _BRAIN = None
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL  DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL  DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
def int_from_bool_as_string(subject): DCNL  DCSP return ((bool_from_string(subject) and 1) or 0)
def bool_from_string(subject): DCNL  DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def safe_decode(text, incoming=None, errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL  DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('cinder.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None, subsecond=False): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def qemu_img_info(path): DCNL  DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path, run_as_root=True) DCNL DCSP return QemuImgInfo(out)
def convert_image(source, dest, out_format): DCNL  DCSP cmd = ('qemu-img', 'convert', '-O', out_format, source, dest) DCNL DCSP utils.execute(run_as_root=True, *cmd)
def _parse_image_ref(image_href): DCNL  DCSP url = urlparse.urlparse(image_href) DCNL DCSP port = (url.port or 80) DCNL DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP image_id = url.path.split('/')[(-1)] DCNL DCSP use_ssl = (url.scheme == 'https') DCNL DCSP return (image_id, host, port, use_ssl)
def _create_glance_client(context, host, port, use_ssl, version=FLAGS.glance_api_version): DCNL  DCSP if (version is None): DCNL DCSP  DCSP version = FLAGS.glance_api_version DCNL DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = FLAGS.glance_api_insecure DCNL DCSP if (FLAGS.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP endpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), endpoint, **params)
def get_api_servers(): DCNL  DCSP api_servers = [] DCNL DCSP for api_server in FLAGS.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP url = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (url.port or 80) DCNL DCSP  DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (url.scheme == 'https') DCNL DCSP  DCSP api_servers.append((host, port, use_ssl)) DCNL DCSP random.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
def _convert_timestamps_to_datetimes(image_meta): DCNL  DCSP for attr in ['created_at', 'updated_at', 'deleted_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
def _reraise_translated_image_exception(image_id): DCNL  DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_id, exc_value) DCNL DCSP raise new_exc, None, exc_trace
def _reraise_translated_exception(): DCNL  DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
def get_remote_image_service(context, image_href): DCNL  DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_default_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_id, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_id)
def find_config(config_path): DCNL  DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'cinder', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/cinder/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP cinder-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'cinder-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def trycmd(*args, **kwargs): DCNL  DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
def last_completed_audit_period(unit=None): DCNL  DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.volume_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL  DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
def safe_minidom_parse_string(xml_string): DCNL  DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
def xhtml_escape(value): DCNL  DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
def utf8(value): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
def delete_if_exists(pathname): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def get_from_path(items, path): DCNL  DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
def flatten_dict(dict_, flattened=None): DCNL  DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
def partition_dict(dict_, keys): DCNL  DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
def map_dict_keys(dict_, key_map): DCNL  DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
def subset_dict(dict_, keys): DCNL  DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
def check_isinstance(obj, cls): DCNL  DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
def bool_from_str(val): DCNL  DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
def is_valid_boolstr(val): DCNL  DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
def is_valid_ipv4(address): DCNL  DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def monkey_patch(): DCNL  DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
def convert_to_list_dict(lst, label): DCNL  DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
def timefunc(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
def generate_glance_url(): DCNL  DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
@contextlib.contextmanager DCNL def logging_error(message): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
def make_dev_path(dev, partition=None, base='/dev'): DCNL  DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
def total_seconds(td): DCNL  DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
def sanitize_hostname(hostname): DCNL  DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def hash_file(file_like_object): DCNL  DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL  DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
def service_is_up(service): DCNL  DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
def generate_mac_address(): DCNL  DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
def read_file_as_root(file_path): DCNL  DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL  DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
def strcmp_const_time(s1, s2): DCNL  DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
def walk_class_hierarchy(clazz, encountered=None): DCNL  DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def to_bytes(text, default=0): DCNL  DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
def enforce(context, action, target): DCNL  DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
def check_is_admin(roles): DCNL  DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
def periodic_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def _get_my_ip(): DCNL  DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
def register_models(): DCNL  DCSP from sqlalchemy import create_engine DCNL DCSP models = (Backup, Migration, Service, SMBackendConf, SMFlavors, SMVolume, Volume, VolumeMetadata, SnapshotMetadata, VolumeTypeExtraSpecs, VolumeTypes, VolumeGlanceMetadata) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP source_volid = Column('source_volid', String(36)) DCNL DCSP volumes.create_column(source_volid) DCNL DCSP volumes.update().values(source_volid=None).execute()
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP source_volid = Column('source_volid', String(36)) DCNL DCSP volumes.drop_column(source_volid)
def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP volume_types = Table('volume_types', meta, autoload=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoload=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_id, volume_types.c.id, extra_specs.c.volume_type_id] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.drop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP volumes.c.volume_type_id.alter(String(36)) DCNL DCSP volume_types.c.id.alter(String(36)) DCNL DCSP extra_specs.c.volume_type_id.alter(String(36)) DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP new_id = str(uuid.uuid4()) DCNL DCSP  DCSP volumes.update().where((volumes.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP extra_specs.update().where((extra_specs.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP volume_types.update().where((volume_types.c.id == t['id'])).values(id=new_id).execute() DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Created DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP volume_types = Table('volume_types', meta, autoload=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoload=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_id, volume_types.c.id, extra_specs.c.volume_type_id] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.drop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP new_id = 1 DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP volumes.update().where((volumes.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP extra_specs.update().where((extra_specs.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP volume_types.update().where((volume_types.c.id == t['id'])).values(id=new_id).execute() DCNL DCSP  DCSP new_id += 1 DCNL DCSP volumes.c.volume_type_id.alter(Integer) DCNL DCSP volume_types.c.id.alter(Integer) DCNL DCSP extra_specs.c.volume_type_id.alter(Integer) DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Created DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = cinder.exception.wrap_db_error(session.query) DCNL DCSP session.flush = cinder.exception.wrap_db_error(session.flush) DCNL DCSP return session
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def is_admin_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
def is_user_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
def authorize_project_context(context, project_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_user_context(context, user_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_quota_class_context(context, class_name): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def require_admin_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_volume_exists(f): DCNL  DCSP def wrapper(context, volume_id, *args, **kwargs): DCNL DCSP  DCSP db.volume_get(context, volume_id) DCNL DCSP  DCSP return f(context, volume_id, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
def require_snapshot_exists(f): DCNL  DCSP def wrapper(context, snapshot_id, *args, **kwargs): DCNL DCSP  DCSP db.api.snapshot_get(context, snapshot_id) DCNL DCSP  DCSP return f(context, snapshot_id, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
def model_query(context, *args, **kwargs): DCNL  DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
def exact_filter(query, model, filters, legal_keys): DCNL  DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
def _dict_with_extra_specs(inst_type_query): DCNL  DCSP inst_type_dict = dict(inst_type_query) DCNL DCSP extra_specs = dict([(x['key'], x['value']) for x in inst_type_query['extra_specs']]) DCNL DCSP inst_type_dict['extra_specs'] = extra_specs DCNL DCSP return inst_type_dict
def _quota_reservations(session, context, reservations): DCNL  DCSP return model_query(context, models.Reservation, read_deleted='no', session=session).filter(models.Reservation.uuid.in_(reservations)).with_lockmode('update').all()
@require_admin_context DCNL def volume_type_create(context, values): DCNL  DCSP if (not values.get('id')): DCNL DCSP  DCSP values['id'] = str(uuid.uuid4()) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(id=values['name']) DCNL DCSP  DCSP except exception.VolumeTypeNotFoundByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get(context, values['id'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(id=values['id']) DCNL DCSP  DCSP except exception.VolumeTypeNotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP values['extra_specs'] = _metadata_refs(values.get('extra_specs'), models.VolumeTypeExtraSpecs) DCNL DCSP  DCSP  DCSP volume_type_ref = models.VolumeTypes() DCNL DCSP  DCSP  DCSP volume_type_ref.update(values) DCNL DCSP  DCSP  DCSP volume_type_ref.save() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise exception.DBError(e) DCNL DCSP  DCSP return volume_type_ref
@require_context DCNL def volume_type_get_all(context, inactive=False, filters=None): DCNL  DCSP filters = (filters or {}) DCNL DCSP read_deleted = ('yes' if inactive else 'no') DCNL DCSP rows = model_query(context, models.VolumeTypes, read_deleted=read_deleted).options(joinedload('extra_specs')).order_by('name').all() DCNL DCSP result = {} DCNL DCSP for row in rows: DCNL DCSP  DCSP result[row['name']] = _dict_with_extra_specs(row) DCNL DCSP return result
@require_context DCNL def volume_type_get(context, id, session=None): DCNL  DCSP result = model_query(context, models.VolumeTypes, session=session).options(joinedload('extra_specs')).filter_by(id=id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFound(volume_type_id=id) DCNL DCSP return _dict_with_extra_specs(result)
@require_context DCNL def volume_type_get_by_name(context, name, session=None): DCNL  DCSP result = model_query(context, models.VolumeTypes, session=session).options(joinedload('extra_specs')).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFoundByName(volume_type_name=name) DCNL DCSP else: DCNL DCSP  DCSP return _dict_with_extra_specs(result)
@require_context DCNL def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL  DCSP session = get_session() DCNL DCSP query = session.query(models.Volume) DCNL DCSP query = query.filter(or_((models.Volume.deleted_at == None), (models.Volume.deleted_at > begin))) DCNL DCSP if end: DCNL DCSP  DCSP query = query.filter((models.Volume.created_at < end)) DCNL DCSP if project_id: DCNL DCSP  DCSP query = query.filter_by(project_id=project_id) DCNL DCSP return query.all()
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_get(context, volume_id, session=None): DCNL  DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(deleted=False).all()
@require_context DCNL @require_snapshot_exists DCNL def volume_snapshot_glance_metadata_get(context, snapshot_id, session=None): DCNL  DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.query(models.VolumeGlanceMetadata).filter_by(snapshot_id=snapshot_id).filter_by(deleted=False).all()
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_create(context, volume_id, key, value, session=None): DCNL  DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP rows = session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(key=key).filter_by(deleted=False).all() DCNL DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP raise exception.GlanceMetadataExists(key=key, volume_id=volume_id) DCNL DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP vol_glance_metadata.key = key DCNL DCSP  DCSP vol_glance_metadata.value = value DCNL DCSP  DCSP vol_glance_metadata.save(session=session) DCNL DCSP return
@require_context DCNL @require_snapshot_exists DCNL def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id, session=None): DCNL  DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_glance_metadata_get(context, volume_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.snapshot_id = snapshot_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id, session=None): DCNL  DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_glance_metadata_get(context, src_volume_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id, session=None): DCNL  DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_snapshot_glance_metadata_get(context, snapshot_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def service_destroy(context, service_id): DCNL  DCSP return IMPL.service_destroy(context, service_id)
def service_get(context, service_id): DCNL  DCSP return IMPL.service_get(context, service_id)
def service_get_by_host_and_topic(context, host, topic): DCNL  DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
def service_get_all(context, disabled=None): DCNL  DCSP return IMPL.service_get_all(context, disabled)
def service_get_all_by_topic(context, topic): DCNL  DCSP return IMPL.service_get_all_by_topic(context, topic)
def service_get_all_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_by_host(context, host)
def service_get_all_volume_sorted(context): DCNL  DCSP return IMPL.service_get_all_volume_sorted(context)
def service_get_by_args(context, host, binary): DCNL  DCSP return IMPL.service_get_by_args(context, host, binary)
def service_create(context, values): DCNL  DCSP return IMPL.service_create(context, values)
def service_update(context, service_id, values): DCNL  DCSP return IMPL.service_update(context, service_id, values)
def migration_update(context, id, values): DCNL  DCSP return IMPL.migration_update(context, id, values)
def migration_create(context, values): DCNL  DCSP return IMPL.migration_create(context, values)
def migration_get(context, migration_id): DCNL  DCSP return IMPL.migration_get(context, migration_id)
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL  DCSP return IMPL.migration_get_by_instance_and_status(context, instance_uuid, status)
def migration_get_all_unconfirmed(context, confirm_window): DCNL  DCSP return IMPL.migration_get_all_unconfirmed(context, confirm_window)
def iscsi_target_count_by_host(context, host): DCNL  DCSP return IMPL.iscsi_target_count_by_host(context, host)
def iscsi_target_create_safe(context, values): DCNL  DCSP return IMPL.iscsi_target_create_safe(context, values)
def volume_allocate_iscsi_target(context, volume_id, host): DCNL  DCSP return IMPL.volume_allocate_iscsi_target(context, volume_id, host)
def volume_attached(context, volume_id, instance_id, mountpoint): DCNL  DCSP return IMPL.volume_attached(context, volume_id, instance_id, mountpoint)
def volume_create(context, values): DCNL  DCSP return IMPL.volume_create(context, values)
def volume_data_get_for_host(context, host, session=None): DCNL  DCSP return IMPL.volume_data_get_for_host(context, host, session)
def volume_data_get_for_project(context, project_id, session=None): DCNL  DCSP return IMPL.volume_data_get_for_project(context, project_id, session)
def volume_destroy(context, volume_id): DCNL  DCSP return IMPL.volume_destroy(context, volume_id)
def volume_detached(context, volume_id): DCNL  DCSP return IMPL.volume_detached(context, volume_id)
def volume_get(context, volume_id): DCNL  DCSP return IMPL.volume_get(context, volume_id)
def volume_get_all(context, marker, limit, sort_key, sort_dir): DCNL  DCSP return IMPL.volume_get_all(context, marker, limit, sort_key, sort_dir)
def volume_get_all_by_host(context, host): DCNL  DCSP return IMPL.volume_get_all_by_host(context, host)
def volume_get_all_by_instance_uuid(context, instance_uuid): DCNL  DCSP return IMPL.volume_get_all_by_instance_uuid(context, instance_uuid)
def volume_get_all_by_project(context, project_id, marker, limit, sort_key, sort_dir): DCNL  DCSP return IMPL.volume_get_all_by_project(context, project_id, marker, limit, sort_key, sort_dir)
def volume_get_iscsi_target_num(context, volume_id): DCNL  DCSP return IMPL.volume_get_iscsi_target_num(context, volume_id)
def volume_update(context, volume_id, values): DCNL  DCSP return IMPL.volume_update(context, volume_id, values)
def snapshot_create(context, values): DCNL  DCSP return IMPL.snapshot_create(context, values)
def snapshot_destroy(context, snapshot_id): DCNL  DCSP return IMPL.snapshot_destroy(context, snapshot_id)
def snapshot_get(context, snapshot_id): DCNL  DCSP return IMPL.snapshot_get(context, snapshot_id)
def snapshot_get_all(context): DCNL  DCSP return IMPL.snapshot_get_all(context)
def snapshot_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.snapshot_get_all_by_project(context, project_id)
def snapshot_get_all_for_volume(context, volume_id): DCNL  DCSP return IMPL.snapshot_get_all_for_volume(context, volume_id)
def snapshot_update(context, snapshot_id, values): DCNL  DCSP return IMPL.snapshot_update(context, snapshot_id, values)
def snapshot_data_get_for_project(context, project_id, session=None): DCNL  DCSP return IMPL.snapshot_data_get_for_project(context, project_id, session)
def snapshot_metadata_get(context, snapshot_id): DCNL  DCSP return IMPL.snapshot_metadata_get(context, snapshot_id)
def snapshot_metadata_delete(context, snapshot_id, key): DCNL  DCSP IMPL.snapshot_metadata_delete(context, snapshot_id, key)
def snapshot_metadata_update(context, snapshot_id, metadata, delete): DCNL  DCSP IMPL.snapshot_metadata_update(context, snapshot_id, metadata, delete)
def volume_metadata_get(context, volume_id): DCNL  DCSP return IMPL.volume_metadata_get(context, volume_id)
def volume_metadata_delete(context, volume_id, key): DCNL  DCSP IMPL.volume_metadata_delete(context, volume_id, key)
def volume_metadata_update(context, volume_id, metadata, delete): DCNL  DCSP IMPL.volume_metadata_update(context, volume_id, metadata, delete)
def volume_type_create(context, values): DCNL  DCSP return IMPL.volume_type_create(context, values)
def volume_type_get_all(context, inactive=False): DCNL  DCSP return IMPL.volume_type_get_all(context, inactive)
def volume_type_get(context, id): DCNL  DCSP return IMPL.volume_type_get(context, id)
def volume_type_get_by_name(context, name): DCNL  DCSP return IMPL.volume_type_get_by_name(context, name)
def volume_type_destroy(context, id): DCNL  DCSP return IMPL.volume_type_destroy(context, id)
def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL  DCSP return IMPL.volume_get_active_by_window(context, begin, end, project_id)
def volume_type_extra_specs_get(context, volume_type_id): DCNL  DCSP return IMPL.volume_type_extra_specs_get(context, volume_type_id)
def volume_type_extra_specs_delete(context, volume_type_id, key): DCNL  DCSP IMPL.volume_type_extra_specs_delete(context, volume_type_id, key)
def volume_type_extra_specs_update_or_create(context, volume_type_id, extra_specs): DCNL  DCSP IMPL.volume_type_extra_specs_update_or_create(context, volume_type_id, extra_specs)
def volume_glance_metadata_create(context, volume_id, key, value): DCNL  DCSP return IMPL.volume_glance_metadata_create(context, volume_id, key, value)
def volume_glance_metadata_get(context, volume_id): DCNL  DCSP return IMPL.volume_glance_metadata_get(context, volume_id)
def volume_snapshot_glance_metadata_get(context, snapshot_id): DCNL  DCSP return IMPL.volume_snapshot_glance_metadata_get(context, snapshot_id)
def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id): DCNL  DCSP return IMPL.volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id)
def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id): DCNL  DCSP return IMPL.volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id)
def volume_glance_metadata_delete_by_volume(context, volume_id): DCNL  DCSP return IMPL.volume_glance_metadata_delete_by_volume(context, volume_id)
def volume_glance_metadata_delete_by_snapshot(context, snapshot_id): DCNL  DCSP return IMPL.volume_glance_metadata_delete_by_snapshot(context, snapshot_id)
def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id): DCNL  DCSP return IMPL.volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id)
def sm_backend_conf_create(context, values): DCNL  DCSP return IMPL.sm_backend_conf_create(context, values)
def sm_backend_conf_update(context, sm_backend_conf_id, values): DCNL  DCSP return IMPL.sm_backend_conf_update(context, sm_backend_conf_id, values)
def sm_backend_conf_delete(context, sm_backend_conf_id): DCNL  DCSP return IMPL.sm_backend_conf_delete(context, sm_backend_conf_id)
def sm_backend_conf_get(context, sm_backend_conf_id): DCNL  DCSP return IMPL.sm_backend_conf_get(context, sm_backend_conf_id)
def sm_backend_conf_get_by_sr(context, sr_uuid): DCNL  DCSP return IMPL.sm_backend_conf_get_by_sr(context, sr_uuid)
def sm_backend_conf_get_all(context): DCNL  DCSP return IMPL.sm_backend_conf_get_all(context)
def sm_flavor_create(context, values): DCNL  DCSP return IMPL.sm_flavor_create(context, values)
def sm_flavor_update(context, sm_flavor_id, values): DCNL  DCSP return IMPL.sm_flavor_update(context, values)
def sm_flavor_delete(context, sm_flavor_id): DCNL  DCSP return IMPL.sm_flavor_delete(context, sm_flavor_id)
def sm_flavor_get(context, sm_flavor): DCNL  DCSP return IMPL.sm_flavor_get(context, sm_flavor)
def sm_flavor_get_all(context): DCNL  DCSP return IMPL.sm_flavor_get_all(context)
def sm_volume_create(context, values): DCNL  DCSP return IMPL.sm_volume_create(context, values)
def sm_volume_update(context, volume_id, values): DCNL  DCSP return IMPL.sm_volume_update(context, values)
def sm_volume_delete(context, volume_id): DCNL  DCSP return IMPL.sm_volume_delete(context, volume_id)
def sm_volume_get(context, volume_id): DCNL  DCSP return IMPL.sm_volume_get(context, volume_id)
def sm_volume_get_all(context): DCNL  DCSP return IMPL.sm_volume_get_all(context)
def quota_create(context, project_id, resource, limit): DCNL  DCSP return IMPL.quota_create(context, project_id, resource, limit)
def quota_get(context, project_id, resource): DCNL  DCSP return IMPL.quota_get(context, project_id, resource)
def quota_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_get_all_by_project(context, project_id)
def quota_update(context, project_id, resource, limit): DCNL  DCSP return IMPL.quota_update(context, project_id, resource, limit)
def quota_destroy(context, project_id, resource): DCNL  DCSP return IMPL.quota_destroy(context, project_id, resource)
def quota_class_create(context, class_name, resource, limit): DCNL  DCSP return IMPL.quota_class_create(context, class_name, resource, limit)
def quota_class_get(context, class_name, resource): DCNL  DCSP return IMPL.quota_class_get(context, class_name, resource)
def quota_class_get_all_by_name(context, class_name): DCNL  DCSP return IMPL.quota_class_get_all_by_name(context, class_name)
def quota_class_update(context, class_name, resource, limit): DCNL  DCSP return IMPL.quota_class_update(context, class_name, resource, limit)
def quota_class_destroy(context, class_name, resource): DCNL  DCSP return IMPL.quota_class_destroy(context, class_name, resource)
def quota_class_destroy_all_by_name(context, class_name): DCNL  DCSP return IMPL.quota_class_destroy_all_by_name(context, class_name)
def quota_usage_create(context, project_id, resource, in_use, reserved, until_refresh): DCNL  DCSP return IMPL.quota_usage_create(context, project_id, resource, in_use, reserved, until_refresh)
def quota_usage_get(context, project_id, resource): DCNL  DCSP return IMPL.quota_usage_get(context, project_id, resource)
def quota_usage_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_usage_get_all_by_project(context, project_id)
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL  DCSP return IMPL.reservation_create(context, uuid, usage, project_id, resource, delta, expire)
def reservation_get(context, uuid): DCNL  DCSP return IMPL.reservation_get(context, uuid)
def reservation_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.reservation_get_all_by_project(context, project_id)
def reservation_destroy(context, uuid): DCNL  DCSP return IMPL.reservation_destroy(context, uuid)
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL  DCSP return IMPL.quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=project_id)
def reservation_commit(context, reservations, project_id=None): DCNL  DCSP return IMPL.reservation_commit(context, reservations, project_id=project_id)
def reservation_rollback(context, reservations, project_id=None): DCNL  DCSP return IMPL.reservation_rollback(context, reservations, project_id=project_id)
def quota_destroy_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_destroy_all_by_project(context, project_id)
def reservation_expire(context): DCNL  DCSP return IMPL.reservation_expire(context)
def backup_get(context, backup_id): DCNL  DCSP return IMPL.backup_get(context, backup_id)
def backup_get_all(context): DCNL  DCSP return IMPL.backup_get_all(context)
def backup_get_all_by_host(context, host): DCNL  DCSP return IMPL.backup_get_all_by_host(context, host)
def backup_create(context, values): DCNL  DCSP return IMPL.backup_create(context, values)
def backup_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.backup_get_all_by_project(context, project_id)
def backup_update(context, backup_id, values): DCNL  DCSP return IMPL.backup_update(context, backup_id, values)
def backup_destroy(context, backup_id): DCNL  DCSP return IMPL.backup_destroy(context, backup_id)
def volume_update_db(context, volume_id, host): DCNL  DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': host, 'scheduled_at': now} DCNL DCSP return db.volume_update(context, volume_id, values)
def skip_if_fake(func): DCNL  DCSP def _skipper(*args, **kw): DCNL DCSP  DCSP 'Wrapped DCSP skipper DCSP function.' DCNL DCSP  DCSP if FLAGS.fake_tests: DCNL DCSP  DCSP  DCSP raise unittest.SkipTest('Test DCSP cannot DCSP be DCSP run DCSP in DCSP fake DCSP mode') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*args, **kw) DCNL DCSP return _skipper
def wire_HTTPConnection_to_WSGI(host, app): DCNL  DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
def wire_HTTPConnection_to_WSGI(host, app): DCNL  DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
def compare_links(actual, expected): DCNL  DCSP return compare_tree_to_dict(actual, expected, ('rel', 'href', 'type'))
def compare_media_types(actual, expected): DCNL  DCSP return compare_tree_to_dict(actual, expected, ('base', 'type'))
def compare_tree_to_dict(actual, expected, keys): DCNL  DCSP for (elem, data) in zip(actual, expected): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != data.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
def example_decorator(name, function): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.append(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrapped_func
def serialize_args(*args, **kwargs): DCNL  DCSP return serialize_obj((args, kwargs))
def fake_execute_set_repliers(repliers): DCNL  DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL  DCSP return ('', '')
def fake_execute(*cmd_parts, **kwargs): DCNL  DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_code = kwargs.get('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.get('delay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmd_str = ' DCSP '.join((str(part) for part in cmd_parts)) DCNL DCSP LOG.debug(_('Faking DCSP execution DCSP of DCSP cmd DCSP (subprocess): DCSP %s'), cmd_str) DCNL DCSP _fake_execute_log.append(cmd_str) DCNL DCSP reply_handler = fake_execute_default_reply_handler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmd_str): DCNL DCSP  DCSP  DCSP reply_handler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.debug((_('Faked DCSP command DCSP matched DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_handler, basestring): DCNL DCSP  DCSP reply = (reply_handler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_handler(cmd_parts, process_input=process_input, delay_on_retry=delay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_code=check_exit_code) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Faked DCSP command DCSP raised DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stdout = reply[0] DCNL DCSP stderr = reply[1] DCNL DCSP LOG.debug((_("Reply DCSP to DCSP faked DCSP command DCSP is DCSP stdout='%(stdout)s' DCSP stderr='%(stderr)s'") % locals())) DCNL DCSP greenthread.sleep(0) DCNL DCSP return reply
def stub_out(stubs, funcs): DCNL  DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(db, func_name, func)
def stub_out_https_backend(stubs): DCNL  DCSP class FakeHTTPResponse(object, ): DCNL DCSP  DCSP def read(self): DCNL DCSP  DCSP  DCSP return DATA DCNL DCSP def fake_do_request(self, *args, **kwargs): DCNL DCSP  DCSP return (httplib.OK, FakeHTTPResponse())
def generate_random_alphanumeric(length): DCNL  DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))
def generate_random_numeric(length): DCNL  DCSP return ''.join((random.choice(string.digits) for _x in range(length)))
def generate_new_element(items, prefix, numeric=False): DCNL  DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_alphanumeric(8)) DCNL DCSP  DCSP if (candidate not in items): DCNL DCSP  DCSP  DCSP return candidate DCNL DCSP  DCSP LOG.debug(('Random DCSP collision DCSP on DCSP %s' % candidate))
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL  DCSP if (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
def get_table(engine, name): DCNL  DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
def create(context, name, extra_specs={}): DCNL  DCSP try: DCNL DCSP  DCSP type_ref = db.volume_type_create(context, dict(name=name, extra_specs=extra_specs)) DCNL DCSP except exception.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.VolumeTypeCreateFailed(name=name, extra_specs=extra_specs) DCNL DCSP return type_ref
def destroy(context, id): DCNL  DCSP if (id is None): DCNL DCSP  DCSP msg = _('id DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP else: DCNL DCSP  DCSP db.volume_type_destroy(context, id)
def get_all_types(context, inactive=0, search_opts={}): DCNL  DCSP vol_types = db.volume_type_get_all(context, inactive) DCNL DCSP if search_opts: DCNL DCSP  DCSP LOG.debug((_('Searching DCSP by: DCSP %s') % str(search_opts))) DCNL DCSP  DCSP def _check_extra_specs_match(vol_type, searchdict): DCNL DCSP  DCSP  DCSP for (k, v) in searchdict.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if ((k not in vol_type['extra_specs'].keys()) or (vol_type['extra_specs'][k] != v)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP filter_mapping = {'extra_specs': _check_extra_specs_match} DCNL DCSP  DCSP result = {} DCNL DCSP  DCSP for (type_name, type_args) in vol_types.iteritems(): DCNL DCSP  DCSP  DCSP for (opt, values) in search_opts.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP filter_func = filter_mapping[opt] DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if filter_func(type_args, values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result[type_name] = type_args DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP vol_types = result DCNL DCSP return vol_types
def get_volume_type(ctxt, id): DCNL  DCSP if (id is None): DCNL DCSP  DCSP msg = _('id DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.volume_type_get(ctxt, id)
def get_volume_type_by_name(context, name): DCNL  DCSP if (name is None): DCNL DCSP  DCSP msg = _('name DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP return db.volume_type_get_by_name(context, name)
def get_default_volume_type(): DCNL  DCSP name = FLAGS.default_volume_type DCNL DCSP vol_type = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vol_type = get_volume_type_by_name(ctxt, name) DCNL DCSP  DCSP except exception.VolumeTypeNotFoundByName as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('Default DCSP volume DCSP type DCSP is DCSP not DCSP found, DCSP please DCSP check DCSP default_volume_type DCSP config: DCSP %s'), e) DCNL DCSP return vol_type
def notify_usage_exists(context, volume_ref, current_period=False): DCNL  DCSP (begin, end) = utils.last_completed_audit_period() DCNL DCSP if current_period: DCNL DCSP  DCSP audit_start = end DCNL DCSP  DCSP audit_end = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP audit_start = begin DCNL DCSP  DCSP audit_end = end DCNL DCSP extra_usage_info = dict(audit_period_beginning=str(audit_start), audit_period_ending=str(audit_end)) DCNL DCSP notify_about_volume_usage(context, volume_ref, 'exists', extra_usage_info=extra_usage_info)
def wrap_check_policy(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, context, target_obj, *args, **kwargs): DCNL DCSP  DCSP check_policy(context, func.__name__, target_obj) DCNL DCSP  DCSP return func(self, context, target_obj, *args, **kwargs) DCNL DCSP return wrapped
def connect_ec2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL  DCSP from boto_v6.ec2.connection import EC2ConnectionV6 DCNL DCSP return EC2ConnectionV6(aws_access_key_id, aws_secret_access_key, **kwargs)
def excluded(self, filename): DCNL  DCSP basename = os.path.basename(filename) DCNL DCSP return any((pep8.filename_match(filename, self.options.exclude, default=False), pep8.filename_match(basename, self.options.exclude, default=False)))
def input_dir(self, dirname): DCNL  DCSP dirname = dirname.rstrip('/') DCNL DCSP if self.excluded(dirname): DCNL DCSP  DCSP return 0 DCNL DCSP counters = self.options.report.counters DCNL DCSP verbose = self.options.verbose DCNL DCSP filepatterns = self.options.filename DCNL DCSP runner = self.runner DCNL DCSP for (root, dirs, files) in os.walk(dirname): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print ('directory DCSP ' + root) DCNL DCSP  DCSP counters['directories'] += 1 DCNL DCSP  DCSP for subdir in sorted(dirs): DCNL DCSP  DCSP  DCSP if self.excluded(os.path.join(root, subdir)): DCNL DCSP  DCSP  DCSP  DCSP dirs.remove(subdir) DCNL DCSP  DCSP for filename in sorted(files): DCNL DCSP  DCSP  DCSP if (pep8.filename_match(filename, filepatterns) and (not self.excluded(filename))): DCNL DCSP  DCSP  DCSP  DCSP runner(os.path.join(root, filename))
def nova_todo_format(physical_line, tokens): DCNL  DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos) and (len(tokens) == 0)): DCNL DCSP  DCSP return (pos, 'N101: DCSP Use DCSP TODO(NAME)')
def nova_except_format(logical_line): DCNL  DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
def nova_except_format_assert(logical_line): DCNL  DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
def nova_import_rules(logical_line): DCNL  DCSP def is_module_for_sure(mod, search_path=sys.path): DCNL DCSP  DCSP mod = mod.replace('(', '') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mod_name = mod DCNL DCSP  DCSP  DCSP while ('.' in mod_name): DCNL DCSP  DCSP  DCSP  DCSP (pack_name, _sep, mod_name) = mod.partition('.') DCNL DCSP  DCSP  DCSP  DCSP (f, p, d) = imp.find_module(pack_name, search_path) DCNL DCSP  DCSP  DCSP  DCSP search_path = [p] DCNL DCSP  DCSP  DCSP imp.find_module(mod_name, search_path) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP module = __import__(mod) DCNL DCSP  DCSP  DCSP except ImportError as exc: DCNL DCSP  DCSP  DCSP  DCSP missing = str(exc).split()[(-1)] DCNL DCSP  DCSP  DCSP  DCSP if ((missing != mod.split('.')[(-1)]) or ('cannot DCSP import' in str(exc))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(missing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP def is_module(mod): DCNL DCSP  DCSP 'Checks DCSP for DCSP non DCSP module DCSP imports.' DCNL DCSP  DCSP if (mod in modules_cache): DCNL DCSP  DCSP  DCSP return modules_cache[mod] DCNL DCSP  DCSP res = is_module_for_sure(mod) DCNL DCSP  DCSP modules_cache[mod] = res DCNL DCSP  DCSP return res DCNL DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP current_mod = os.path.basename(pep8.current_file) DCNL DCSP if (current_mod[(-3):] == '.py'): DCNL DCSP  DCSP current_mod = current_mod[:(-3)] DCNL DCSP split_line = logical_line.split() DCNL DCSP split_line_len = len(split_line) DCNL DCSP if ((split_line[0] in ('import', 'from')) and (split_line_len > 1) and (not is_import_exception(split_line[1]))): DCNL DCSP  DCSP pos = logical_line.find(',') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP if (split_line[0] == 'from'): DCNL DCSP  DCSP  DCSP  DCSP (yield (pos, 'N301: DCSP one DCSP import DCSP per DCSP line')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP pos = logical_line.find('*') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP (yield (pos, 'N303: DCSP No DCSP wildcard DCSP (*) DCSP import.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((split_line_len in (2, 4, 6)) and (split_line[1] != '__future__')): DCNL DCSP  DCSP  DCSP if (('from' == split_line[0]) and (split_line_len > 3)): DCNL DCSP  DCSP  DCSP  DCSP mod = '.'.join((split_line[1], split_line[3])) DCNL DCSP  DCSP  DCSP  DCSP if is_import_exception(mod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if RE_RELATIVE_IMPORT.search(logical_line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (logical_line.find('.'), ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if (not is_module(mod)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (0, ("N302: DCSP import DCSP only DCSP modules.'%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP if ((current_mod != mod) and (not is_module(mod)) and is_module_for_sure(mod, [current_path])): DCNL DCSP  DCSP  DCSP (yield (0, ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)))
def nova_import_alphabetical(logical_line, blank_lines, previous_logical, indent_level, previous_indent_level): DCNL  DCSP split_line = import_normalize(logical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(previous_logical.strip()).lower().split() DCNL DCSP if ((blank_lines < 1) and (indent_level == previous_indent_level)): DCNL DCSP  DCSP length = [2, 4] DCNL DCSP  DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP  DCSP (yield (0, ('N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1]))))
def nova_import_no_db_in_virt(logical_line, filename): DCNL  DCSP if (('nova/virt' in filename) and (not filename.endswith('fake.py'))): DCNL DCSP  DCSP if logical_line.startswith('from DCSP nova DCSP import DCSP db'): DCNL DCSP  DCSP  DCSP (yield (0, 'N307: DCSP nova.db DCSP import DCSP not DCSP allowed DCSP in DCSP nova/virt/*'))
def is_docstring(physical_line, previous_logical): DCNL  DCSP line = physical_line.lstrip() DCNL DCSP start = max([line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP end = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP if (previous_logical.startswith('def DCSP ') or previous_logical.startswith('class DCSP ')): DCNL DCSP  DCSP if (start is 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (end and (start in ((-1), (len(line) - 4))))
def nova_docstring_start_space(physical_line, previous_logical): DCNL  DCSP if (physical_line.find('N401: DCSP def DCSP foo()') != (-1)): DCNL DCSP  DCSP return DCNL DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'N401: DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
def nova_docstring_one_line(physical_line, previous_logical): DCNL  DCSP line = physical_line.lstrip() DCNL DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP end = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((pos != (-1)) and end and (len(line) > (pos + 4))): DCNL DCSP  DCSP  DCSP if (line[(-5)] not in ['.', '?', '!']): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP punctuation.')
def nova_docstring_multiline_end(physical_line, previous_logical, tokens): DCNL  DCSP ops = [t for (t, _, _, _, _) in tokens if (t == tokenize.OP)] DCNL DCSP if (is_docstring(physical_line, previous_logical) and (len(tokens) > 0) and (len(ops) == 0)): DCNL DCSP  DCSP pos = max((physical_line.find(i) for i in END_DOCSTRING_TRIPLE)) DCNL DCSP  DCSP if (physical_line.strip() not in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP return (pos, 'N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
def nova_docstring_multiline_start(physical_line, previous_logical, tokens): DCNL  DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((len(tokens) == 0) and (pos != (-1)) and (len(physical_line) == (pos + 4))): DCNL DCSP  DCSP  DCSP if (physical_line.strip() in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N404: DCSP multi DCSP line DCSP docstring DCSP should DCSP start DCSP with DCSP a DCSP summary')
def nova_no_cr(physical_line): DCNL  DCSP pos = physical_line.find('\r') DCNL DCSP if ((pos != (-1)) and (pos == (len(physical_line) - 2))): DCNL DCSP  DCSP return (pos, 'N901: DCSP Windows DCSP style DCSP line DCSP endings DCSP not DCSP allowed DCSP in DCSP code')
def check_i18n(): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, line) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_') and (not line.startswith('def DCSP _(msg):'))): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N703: DCSP Multiple DCSP positional DCSP placeholders')
def nova_localization_strings(logical_line, tokens): DCNL  DCSP gen = check_i18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
def nova_is_not(logical_line): DCNL  DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) and (split_line[0] == 'if') and (split_line[1] == 'not') and (split_line[3] == 'is')): DCNL DCSP  DCSP (yield (logical_line.find('not'), "N901: DCSP Use DCSP the DCSP 'is DCSP not' DCSP operator DCSP for DCSP when DCSP testing DCSP for DCSP unequal DCSP identities"))
def nova_not_in(logical_line): DCNL  DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) and (split_line[0] == 'if') and (split_line[1] == 'not') and (split_line[3] == 'in') and (not split_line[2].startswith('('))): DCNL DCSP  DCSP (yield (logical_line.find('not'), "N902: DCSP Use DCSP the DCSP 'not DCSP in' DCSP operator DCSP for DCSP collection DCSP membership DCSP evaluation"))
def readlines(filename): DCNL  DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
def add_nova(): DCNL  DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('nova')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
def once_git_check_commit_title(): DCNL  DCSP subp = subprocess.Popen(['git', 'log', '--no-merges', '--pretty=%s', '-1'], stdout=subprocess.PIPE) DCNL DCSP title = subp.communicate()[0] DCNL DCSP if subp.returncode: DCNL DCSP  DCSP raise Exception(('git DCSP log DCSP failed DCSP with DCSP code DCSP %s' % subp.returncode)) DCNL DCSP git_keywords = '(I[0-9a-f]{8,40})|([Bb]ug|[Ll][Pp])[\\s\\#:]*(\\d+)|([Bb]lue[Pp]rint|[Bb][Pp])[\\s\\#:]*([A-Za-z0-9\\-]+)' DCNL DCSP GIT_REGEX = re.compile(git_keywords) DCNL DCSP error = False DCNL DCSP if ((GIT_REGEX.search(title) is not None) and (len(title.split()) <= 3)): DCNL DCSP  DCSP print ("N801: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP should DCSP provide DCSP an DCSP accurate DCSP description DCSP of DCSP the DCSP change, DCSP not DCSP just DCSP a DCSP reference DCSP to DCSP a DCSP bug DCSP or DCSP blueprint" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP if (len(title.decode('utf-8')) > 72): DCNL DCSP  DCSP print ("N802: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP should DCSP be DCSP under DCSP 50 DCSP chars" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP return error
def _bytes2int(bytes): DCNL  DCSP intgr = 0 DCNL DCSP for byt in bytes: DCNL DCSP  DCSP intgr = ((intgr << 8) + _byte(byt)) DCNL DCSP return intgr
def _parse_network_details(machine_id): DCNL  DCSP logging.debug((_('Received DCSP machine_id DCSP from DCSP vmtools DCSP : DCSP %s') % machine_id[0])) DCNL DCSP network_details = [] DCNL DCSP if (machine_id[1].strip() == '1'): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP for machine_id_str in machine_id[0].split('#'): DCNL DCSP  DCSP  DCSP network_info_list = machine_id_str.split(';') DCNL DCSP  DCSP  DCSP if ((len(network_info_list) % 6) != 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP no_grps = (len(network_info_list) / 6) DCNL DCSP  DCSP  DCSP i = 0 DCNL DCSP  DCSP  DCSP while (i < no_grps): DCNL DCSP  DCSP  DCSP  DCSP k = (i * 6) DCNL DCSP  DCSP  DCSP  DCSP network_details.append((network_info_list[k].strip().lower(), network_info_list[(k + 1)].strip(), network_info_list[(k + 2)].strip(), network_info_list[(k + 3)].strip(), network_info_list[(k + 4)].strip(), network_info_list[(k + 5)].strip().split(','))) DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP logging.debug((_('NIC DCSP information DCSP from DCSP vmtools DCSP : DCSP %s') % network_details)) DCNL DCSP return network_details
def _get_windows_network_adapters(): DCNL  DCSP import win32com.client DCNL DCSP wbem_locator = win32com.client.Dispatch('WbemScripting.SWbemLocator') DCNL DCSP wbem_service = wbem_locator.ConnectServer('.', 'root\\cimv2') DCNL DCSP wbem_network_adapters = wbem_service.InstancesOf('Win32_NetworkAdapter') DCNL DCSP network_adapters = [] DCNL DCSP for adapter in wbem_network_adapters: DCNL DCSP  DCSP if ((adapter.NetConnectionStatus == 2) or (adapter.NetConnectionStatus == 7)): DCNL DCSP  DCSP  DCSP adapter_name = adapter.NetConnectionID DCNL DCSP  DCSP  DCSP mac_address = adapter.MacAddress.lower() DCNL DCSP  DCSP  DCSP config = adapter.associators_('Win32_NetworkAdapterSetting', 'Win32_NetworkAdapterConfiguration')[0] DCNL DCSP  DCSP  DCSP ip_address = '' DCNL DCSP  DCSP  DCSP subnet_mask = '' DCNL DCSP  DCSP  DCSP if config.IPEnabled: DCNL DCSP  DCSP  DCSP  DCSP ip_address = config.IPAddress[0] DCNL DCSP  DCSP  DCSP  DCSP subnet_mask = config.IPSubnet[0] DCNL DCSP  DCSP  DCSP network_adapters.append({'name': adapter_name, 'mac-address': mac_address, 'ip-address': ip_address, 'subnet-mask': subnet_mask}) DCNL DCSP return network_adapters
def _get_linux_network_adapters(): DCNL  DCSP import fcntl DCNL DCSP max_bytes = 8096 DCNL DCSP arch = platform.architecture()[0] DCNL DCSP if (arch == ARCH_32_BIT): DCNL DCSP  DCSP offset1 = 32 DCNL DCSP  DCSP offset2 = 32 DCNL DCSP elif (arch == ARCH_64_BIT): DCNL DCSP  DCSP offset1 = 16 DCNL DCSP  DCSP offset2 = 40 DCNL DCSP else: DCNL DCSP  DCSP raise OSError((_('Unknown DCSP architecture: DCSP %s') % arch)) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP names = array.array('B', ('\x00' * max_bytes)) DCNL DCSP outbytes = struct.unpack('iL', fcntl.ioctl(sock.fileno(), 35090, struct.pack('iL', max_bytes, names.buffer_info()[0])))[0] DCNL DCSP adapter_names = [names.tostring()[n_cnt:(n_cnt + offset1)].split('\x00', 1)[0] for n_cnt in xrange(0, outbytes, offset2)] DCNL DCSP network_adapters = [] DCNL DCSP for adapter_name in adapter_names: DCNL DCSP  DCSP ip_address = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35093, struct.pack('256s', adapter_name))[20:24]) DCNL DCSP  DCSP subnet_mask = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35099, struct.pack('256s', adapter_name))[20:24]) DCNL DCSP  DCSP raw_mac_address = ('%012x' % _bytes2int(fcntl.ioctl(sock.fileno(), 35111, struct.pack('256s', adapter_name))[18:24])) DCNL DCSP  DCSP mac_address = ':'.join([raw_mac_address[m_counter:(m_counter + 2)] for m_counter in range(0, len(raw_mac_address), 2)]).lower() DCNL DCSP  DCSP network_adapters.append({'name': adapter_name, 'mac-address': mac_address, 'ip-address': ip_address, 'subnet-mask': subnet_mask}) DCNL DCSP return network_adapters
def _get_adapter_name_and_ip_address(network_adapters, mac_address): DCNL  DCSP adapter_name = None DCNL DCSP ip_address = None DCNL DCSP for network_adapter in network_adapters: DCNL DCSP  DCSP if (network_adapter['mac-address'] == mac_address.lower()): DCNL DCSP  DCSP  DCSP adapter_name = network_adapter['name'] DCNL DCSP  DCSP  DCSP ip_address = network_adapter['ip-address'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return (adapter_name, ip_address)
def _get_win_adapter_name_and_ip_address(mac_address): DCNL  DCSP network_adapters = _get_windows_network_adapters() DCNL DCSP return _get_adapter_name_and_ip_address(network_adapters, mac_address)
def _get_linux_adapter_name_and_ip_address(mac_address): DCNL  DCSP network_adapters = _get_linux_network_adapters() DCNL DCSP return _get_adapter_name_and_ip_address(network_adapters, mac_address)
def _execute(cmd_list, process_input=None, check_exit_code=True): DCNL  DCSP cmd = ' DCSP '.join(cmd_list) DCNL DCSP logging.debug((_("Executing DCSP command: DCSP '%s'") % cmd)) DCNL DCSP env = os.environ.copy() DCNL DCSP obj = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) DCNL DCSP result = None DCNL DCSP if (process_input is not None): DCNL DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP else: DCNL DCSP  DCSP result = obj.communicate() DCNL DCSP obj.stdin.close() DCNL DCSP if obj.returncode: DCNL DCSP  DCSP logging.debug((_('Result DCSP was DCSP %s') % obj.returncode)) DCNL DCSP  DCSP if (check_exit_code and (obj.returncode != 0)): DCNL DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=obj.returncode, stdout=stdout, stderr=stderr, cmd=cmd) DCNL DCSP time.sleep(0.1) DCNL DCSP return result
def _windows_set_networking(): DCNL  DCSP program_files = os.environ.get('PROGRAMFILES') DCNL DCSP program_files_x86 = os.environ.get('PROGRAMFILES(X86)') DCNL DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsd.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsd.exe') DCNL DCSP elif os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP elif (program_files_x86 and os.path.exists(os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe'))): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmd = [(('"' + vmware_tools_bin) + '"'), '--cmd', 'machine.id.get'] DCNL DCSP  DCSP for network_detail in _parse_network_details(_execute(cmd, check_exit_code=False)): DCNL DCSP  DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP  DCSP name_and_ip = _get_win_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP  DCSP if (adapter_name and (not (ip_address == current_ip_address))): DCNL DCSP  DCSP  DCSP  DCSP cmd = ['netsh', 'interface', 'ip', 'set', 'address', ('name="%s"' % adapter_name), 'source=static', ip_address, subnet_mask, gateway, '1'] DCNL DCSP  DCSP  DCSP  DCSP _execute(cmd) DCNL DCSP  DCSP  DCSP  DCSP for dns_server in dns_servers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if dns_server: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cmd = ['netsh', 'interface', 'ip', 'add', 'dns', ('name="%s"' % adapter_name), dns_server] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _execute(cmd) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installed'))
def _set_rhel_networking(network_details=None): DCNL  DCSP network_details = (network_details or []) DCNL DCSP all_dns_servers = [] DCNL DCSP for network_detail in network_details: DCNL DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP all_dns_servers.extend(dns_servers) DCNL DCSP  DCSP name_and_ip = _get_linux_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP if (adapter_name and (not (ip_address == current_ip_address))): DCNL DCSP  DCSP  DCSP interface_file_name = ('/etc/sysconfig/network-scripts/ifcfg-%s' % adapter_name) DCNL DCSP  DCSP  DCSP os.remove(interface_file_name) DCNL DCSP  DCSP  DCSP _execute(['touch', interface_file_name]) DCNL DCSP  DCSP  DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP  DCSP  DCSP interface_file.write(('\nDEVICE=%s' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write('\nUSERCTL=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nONBOOT=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nBOOTPROTO=static') DCNL DCSP  DCSP  DCSP interface_file.write(('\nBROADCAST=%s' % broadcast)) DCNL DCSP  DCSP  DCSP interface_file.write('\nNETWORK=') DCNL DCSP  DCSP  DCSP interface_file.write(('\nGATEWAY=%s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nNETMASK=%s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nIPADDR=%s' % ip_address)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nMACADDR=%s' % mac_address)) DCNL DCSP  DCSP  DCSP interface_file.close() DCNL DCSP if all_dns_servers: DCNL DCSP  DCSP dns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(dns_file_name) DCNL DCSP  DCSP _execute(['touch', dns_file_name]) DCNL DCSP  DCSP dns_file = open(dns_file_name, 'w') DCNL DCSP  DCSP dns_file.write('; DCSP generated DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP unique_entries = _filter_duplicates(all_dns_servers) DCNL DCSP  DCSP for dns_server in unique_entries: DCNL DCSP  DCSP  DCSP dns_file.write(('\nnameserver DCSP %s' % dns_server)) DCNL DCSP  DCSP dns_file.close() DCNL DCSP _execute(['/sbin/service', 'network', 'restart'])
def _set_ubuntu_networking(network_details=None): DCNL  DCSP network_details = (network_details or []) DCNL DCSP all_dns_servers = [] DCNL DCSP interface_file_name = '/etc/network/interfaces' DCNL DCSP os.remove(interface_file_name) DCNL DCSP _execute(['touch', interface_file_name]) DCNL DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP for (device, network_detail) in enumerate(network_details): DCNL DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP all_dns_servers.extend(dns_servers) DCNL DCSP  DCSP name_and_ip = _get_linux_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP if adapter_name: DCNL DCSP  DCSP  DCSP interface_file.write(('\nauto DCSP %s' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\niface DCSP %s DCSP inet DCSP static' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nbroadcast DCSP %s' % broadcast)) DCNL DCSP  DCSP  DCSP interface_file.write(('\ngateway DCSP %s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nnetmask DCSP %s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\naddress DCSP %s\n' % ip_address)) DCNL DCSP  DCSP logging.debug(_('Successfully DCSP configured DCSP NIC DCSP %(device)d DCSP with DCSP NIC DCSP info DCSP %(detail)s'), {'device': device, 'detail': network_detail}) DCNL DCSP interface_file.close() DCNL DCSP if all_dns_servers: DCNL DCSP  DCSP dns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(dns_file_name) DCNL DCSP  DCSP _execute(['touch', dns_file_name]) DCNL DCSP  DCSP dns_file = open(dns_file_name, 'w') DCNL DCSP  DCSP dns_file.write('; DCSP generated DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP unique_entries = _filter_duplicates(all_dns_servers) DCNL DCSP  DCSP for dns_server in unique_entries: DCNL DCSP  DCSP  DCSP dns_file.write(('\nnameserver DCSP %s' % dns_server)) DCNL DCSP  DCSP dns_file.close() DCNL DCSP logging.debug(_('Restarting DCSP networking....\n')) DCNL DCSP _execute(['/etc/init.d/networking', 'restart'])
def _linux_set_networking(): DCNL  DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists('/usr/sbin/vmtoolsd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmtoolsd' DCNL DCSP elif os.path.exists('/usr/bin/vmtoolsd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmtoolsd' DCNL DCSP elif os.path.exists('/usr/sbin/vmware-guestd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmware-guestd' DCNL DCSP elif os.path.exists('/usr/bin/vmware-guestd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmware-guestd' DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmd = [vmware_tools_bin, '--cmd', 'machine.id.get'] DCNL DCSP  DCSP network_details = _parse_network_details(_execute(cmd, check_exit_code=False)) DCNL DCSP  DCSP if (platform.dist()[0] == 'Ubuntu'): DCNL DCSP  DCSP  DCSP _set_ubuntu_networking(network_details) DCNL DCSP  DCSP elif (platform.dist()[0] == 'redhat'): DCNL DCSP  DCSP  DCSP _set_rhel_networking(network_details) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.warn((_("Distro DCSP '%s' DCSP not DCSP supported") % platform.dist()[0])) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installed'))
def call_xenapi(xenapi, method, *args): DCNL  DCSP return xenapi._session.call_xenapi(method, *args)
def find_orphaned_instances(xenapi): DCNL  DCSP ctxt = context.get_admin_context(read_deleted='only') DCNL DCSP orphaned_instances = [] DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP uuid = vm_rec['other_config']['nova_uuid'] DCNL DCSP  DCSP  DCSP instance = db.api.instance_get_by_uuid(ctxt, uuid) DCNL DCSP  DCSP except (KeyError, exception.InstanceNotFound): DCNL DCSP  DCSP  DCSP print_xen_object('INFO: DCSP Ignoring DCSP VM', vm_rec, indent_level=0) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP is_active_and_deleting = ((instance.vm_state == 'active') and (instance.task_state == 'deleting')) DCNL DCSP  DCSP is_zombie_vm = ((instance.vm_state != 'active') and timeutils.is_older_than(instance.updated_at, CONF.zombie_instance_updated_at_window)) DCNL DCSP  DCSP if (is_active_and_deleting or is_zombie_vm): DCNL DCSP  DCSP  DCSP orphaned_instances.append((vm_ref, vm_rec, instance)) DCNL DCSP return orphaned_instances
def cleanup_instance(xenapi, instance, vm_ref, vm_rec): DCNL  DCSP xenapi._vmops._destroy(instance, vm_ref)
def _get_applicable_vm_recs(xenapi): DCNL  DCSP for vm_ref in call_xenapi(xenapi, 'VM.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_rec = call_xenapi(xenapi, 'VM.get_record', vm_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (vm_rec['is_a_template'] or vm_rec['is_control_domain']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yield (vm_ref, vm_rec))
def print_xen_object(obj_type, obj, indent_level=0, spaces_per_indent=4): DCNL  DCSP if (not CONF.verbose): DCNL DCSP  DCSP return DCNL DCSP uuid = obj['uuid'] DCNL DCSP try: DCNL DCSP  DCSP name_label = obj['name_label'] DCNL DCSP except KeyError: DCNL DCSP  DCSP name_label = '' DCNL DCSP msg = ("%(obj_type)s DCSP (%(uuid)s) DCSP '%(name_label)s'" % locals()) DCNL DCSP indent = ((' DCSP ' * spaces_per_indent) * indent_level) DCNL DCSP print ''.join([indent, msg])
def _find_vdis_connected_to_vm(xenapi, connected_vdi_uuids): DCNL  DCSP def _is_null_ref(ref): DCNL DCSP  DCSP return (ref == 'OpaqueRef:NULL') DCNL DCSP def _add_vdi_and_parents_to_connected(vdi_rec, indent_level): DCNL DCSP  DCSP indent_level += 1 DCNL DCSP  DCSP vdi_and_parent_uuids = [] DCNL DCSP  DCSP cur_vdi_rec = vdi_rec DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP cur_vdi_uuid = cur_vdi_rec['uuid'] DCNL DCSP  DCSP  DCSP print_xen_object('VDI', vdi_rec, indent_level=indent_level) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(cur_vdi_uuid) DCNL DCSP  DCSP  DCSP vdi_and_parent_uuids.append(cur_vdi_uuid) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parent_vdi_uuid = vdi_rec['sm_config']['vhd-parent'] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP parent_vdi_uuid = None DCNL DCSP  DCSP  DCSP if (parent_vdi_uuid and (parent_vdi_uuid != cur_vdi_uuid)): DCNL DCSP  DCSP  DCSP  DCSP indent_level += 1 DCNL DCSP  DCSP  DCSP  DCSP cur_vdi_ref = call_xenapi(xenapi, 'VDI.get_by_uuid', parent_vdi_uuid) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cur_vdi_rec = call_xenapi(xenapi, 'VDI.get_record', cur_vdi_ref) DCNL DCSP  DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP indent_level = 0 DCNL DCSP  DCSP print_xen_object('VM', vm_rec, indent_level=indent_level) DCNL DCSP  DCSP vbd_refs = vm_rec['VBDs'] DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbd_rec = call_xenapi(xenapi, 'VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP indent_level = 1 DCNL DCSP  DCSP  DCSP print_xen_object('VBD', vbd_rec, indent_level=indent_level) DCNL DCSP  DCSP  DCSP vbd_vdi_ref = vbd_rec['VDI'] DCNL DCSP  DCSP  DCSP if _is_null_ref(vbd_vdi_ref): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vdi_rec = call_xenapi(xenapi, 'VDI.get_record', vbd_vdi_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP _add_vdi_and_parents_to_connected(vdi_rec, indent_level)
def _find_all_vdis_and_system_vdis(xenapi, all_vdi_uuids, connected_vdi_uuids): DCNL  DCSP def _system_owned(vdi_rec): DCNL DCSP  DCSP vdi_name = vdi_rec['name_label'] DCNL DCSP  DCSP return (vdi_name.startswith('USB') or vdi_name.endswith('.iso') or (vdi_rec['type'] == 'system')) DCNL DCSP for vdi_ref in call_xenapi(xenapi, 'VDI.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vdi_rec = call_xenapi(xenapi, 'VDI.get_record', vdi_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vdi_uuid = vdi_rec['uuid'] DCNL DCSP  DCSP all_vdi_uuids.add(vdi_uuid) DCNL DCSP  DCSP if _system_owned(vdi_rec): DCNL DCSP  DCSP  DCSP print_xen_object('SYSTEM DCSP VDI', vdi_rec, indent_level=0) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(vdi_uuid) DCNL DCSP  DCSP elif (not vdi_rec['managed']): DCNL DCSP  DCSP  DCSP print_xen_object('UNMANAGED DCSP VDI', vdi_rec, indent_level=0) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(vdi_uuid)
def find_orphaned_vdi_uuids(xenapi): DCNL  DCSP connected_vdi_uuids = set() DCNL DCSP _find_vdis_connected_to_vm(xenapi, connected_vdi_uuids) DCNL DCSP all_vdi_uuids = set() DCNL DCSP _find_all_vdis_and_system_vdis(xenapi, all_vdi_uuids, connected_vdi_uuids) DCNL DCSP orphaned_vdi_uuids = (all_vdi_uuids - connected_vdi_uuids) DCNL DCSP return orphaned_vdi_uuids
def list_orphaned_vdis(vdi_uuids): DCNL  DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP VDI DCSP (%s)' % vdi_uuid) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print vdi_uuid
def clean_orphaned_vdis(xenapi, vdi_uuids): DCNL  DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP VDI DCSP (%s)' % vdi_uuid) DCNL DCSP  DCSP vdi_ref = call_xenapi(xenapi, 'VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP call_xenapi(xenapi, 'VDI.destroy', vdi_ref) DCNL DCSP  DCSP except XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Skipping DCSP %s: DCSP %s' % (vdi_uuid, exc))
def list_orphaned_instances(orphaned_instances): DCNL  DCSP for (vm_ref, vm_rec, orphaned_instance) in orphaned_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP INSTANCE DCSP (%s)' % orphaned_instance.name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print orphaned_instance.name
def clean_orphaned_instances(xenapi, orphaned_instances): DCNL  DCSP for (vm_ref, vm_rec, instance) in orphaned_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP INSTANCE DCSP (%s)' % instance.name) DCNL DCSP  DCSP cleanup_instance(xenapi, instance, vm_ref, vm_rec)
def main(): DCNL  DCSP args = CONF(args=sys.argv[1:], usage=(('%(prog)s DCSP [options] DCSP --command={' + '|'.join(ALLOWED_COMMANDS)) + '}')) DCNL DCSP command = CONF.command DCNL DCSP if ((not command) or (command not in ALLOWED_COMMANDS)): DCNL DCSP  DCSP CONF.print_usage() DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if (CONF.zombie_instance_updated_at_window < CONF.resize_confirm_window): DCNL DCSP  DCSP raise Exception('`zombie_instance_updated_at_window` DCSP has DCSP to DCSP be DCSP longer DCSP than DCSP `resize_confirm_window`.') DCNL DCSP xenapi = xenapi_driver.XenAPIDriver(virtapi.VirtAPI()) DCNL DCSP if (command == 'list-vdis'): DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print 'Connected DCSP VDIs:\n' DCNL DCSP  DCSP orphaned_vdi_uuids = find_orphaned_vdi_uuids(xenapi) DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print '\nOrphaned DCSP VDIs:\n' DCNL DCSP  DCSP list_orphaned_vdis(orphaned_vdi_uuids) DCNL DCSP elif (command == 'clean-vdis'): DCNL DCSP  DCSP orphaned_vdi_uuids = find_orphaned_vdi_uuids(xenapi) DCNL DCSP  DCSP clean_orphaned_vdis(xenapi, orphaned_vdi_uuids) DCNL DCSP elif (command == 'list-instances'): DCNL DCSP  DCSP orphaned_instances = find_orphaned_instances(xenapi) DCNL DCSP  DCSP list_orphaned_instances(orphaned_instances) DCNL DCSP elif (command == 'clean-instances'): DCNL DCSP  DCSP orphaned_instances = find_orphaned_instances(xenapi) DCNL DCSP  DCSP clean_orphaned_instances(xenapi, orphaned_instances) DCNL DCSP elif (command == 'test'): DCNL DCSP  DCSP doctest.testmod() DCNL DCSP else: DCNL DCSP  DCSP print ("Unknown DCSP command DCSP '%s'" % command) DCNL DCSP  DCSP sys.exit(1)
def _sanitize_default(s): DCNL  DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.getfqdn()): DCNL DCSP  DCSP return 'nova' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
def execute_get_output(*command): DCNL  DCSP devnull = open(os.devnull, 'w') DCNL DCSP command = map(str, command) DCNL DCSP proc = subprocess.Popen(command, close_fds=True, stdout=subprocess.PIPE, stderr=devnull) DCNL DCSP devnull.close() DCNL DCSP return proc.stdout.read().strip()
def execute(*command): DCNL  DCSP devnull = open(os.devnull, 'w') DCNL DCSP command = map(str, command) DCNL DCSP proc = subprocess.Popen(command, close_fds=True, stdout=subprocess.PIPE, stderr=devnull) DCNL DCSP devnull.close()
def validate_exists(args, key, default=None): DCNL  DCSP if (key in args): DCNL DCSP  DCSP if (len(args[key]) == 0): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP is DCSP too DCSP short.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (not ARGUMENT_PATTERN.match(args[key])): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP contains DCSP invalid DCSP characters.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (args[key][0] == '-'): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP starts DCSP with DCSP a DCSP hyphen.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP return args[key] DCNL DCSP elif (default is not None): DCNL DCSP  DCSP return default DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP required.') % key))
def validate_bool(args, key, default=None): DCNL  DCSP value = validate_exists(args, key, default) DCNL DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP return True DCNL DCSP elif (value.lower() == 'false'): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_("Argument DCSP %(key)s DCSP may DCSP not DCSP take DCSP value DCSP %(value)s. DCSP Valid DCSP values DCSP are DCSP ['true', DCSP 'false'].") % {'key': key, 'value': value}))
def exists(args, key): DCNL  DCSP if (key in args): DCNL DCSP  DCSP return args[key] DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP required.') % key))
def optional(args, key): DCNL  DCSP return (((key in args) and args[key]) or None)
def vbd_unplug_with_retry(session, vbd): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.xenapi.VBD.unplug(vbd) DCNL DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP successful DCSP first DCSP time.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if ((len(e.details) > 0) and (e.details[0] == 'DEVICE_DETACH_REJECTED')): DCNL DCSP  DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP rejected: DCSP retrying...')) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP elif ((len(e.details) > 0) and (e.details[0] == 'DEVICE_ALREADY_DETACHED')): DCNL DCSP  DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP successful DCSP eventually.')) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logging.error(_('Ignoring DCSP XenAPI.Failure DCSP in DCSP VBD.unplug: DCSP %s'), e) DCNL DCSP  DCSP  DCSP  DCSP return
def _record_exists(arg_dict): DCNL  DCSP cmd = ['xenstore-exists', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (e.stderr == ''): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP raise DCNL DCSP return True
@jsonify DCNL def read_record(self, arg_dict): DCNL  DCSP cmd = ['xenstore-read', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP  DCSP return result.strip() DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not arg_dict.get('ignore_missing_path', False)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (not _record_exists(arg_dict)): DCNL DCSP  DCSP  DCSP return 'None' DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP  DCSP return result.strip()
@jsonify DCNL def write_record(self, arg_dict): DCNL  DCSP cmd = ['xenstore-write', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict), arg_dict['value']] DCNL DCSP _run_command(cmd) DCNL DCSP return arg_dict['value']
@jsonify DCNL def list_records(self, arg_dict): DCNL  DCSP dirpath = ('/local/domain/%(dom_id)s/%(path)s' % arg_dict) DCNL DCSP cmd = ['xenstore-ls', dirpath.rstrip('/')] DCNL DCSP try: DCNL DCSP  DCSP (ret, recs) = _run_command(cmd) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not _record_exists(arg_dict)): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP (ret, recs) = _run_command(cmd) DCNL DCSP base_path = arg_dict['path'] DCNL DCSP paths = _paths_from_ls(recs) DCNL DCSP ret = {} DCNL DCSP for path in paths: DCNL DCSP  DCSP if base_path: DCNL DCSP  DCSP  DCSP arg_dict['path'] = ('%s/%s' % (base_path, path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP arg_dict['path'] = path DCNL DCSP  DCSP rec = read_record(self, arg_dict) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP val = json.loads(rec) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP val = rec DCNL DCSP  DCSP ret[path] = val DCNL DCSP return ret
@jsonify DCNL def delete_record(self, arg_dict): DCNL  DCSP cmd = ['xenstore-rm', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP (ret, result) = _run_command(cmd) DCNL DCSP return result
def _paths_from_ls(recs): DCNL  DCSP ret = {} DCNL DCSP last_nm = '' DCNL DCSP level = 0 DCNL DCSP path = [] DCNL DCSP ret = [] DCNL DCSP for ln in recs.splitlines(): DCNL DCSP  DCSP (nm, val) = ln.rstrip().split(' DCSP = DCSP ') DCNL DCSP  DCSP barename = nm.lstrip() DCNL DCSP  DCSP this_level = (len(nm) - len(barename)) DCNL DCSP  DCSP if (this_level == 0): DCNL DCSP  DCSP  DCSP ret.append(barename) DCNL DCSP  DCSP  DCSP level = 0 DCNL DCSP  DCSP  DCSP path = [] DCNL DCSP  DCSP elif (this_level == level): DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP elif (this_level > level): DCNL DCSP  DCSP  DCSP path.append(last_nm) DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP elif (this_level < level): DCNL DCSP  DCSP  DCSP path = path[:this_level] DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP last_nm = barename DCNL DCSP return ret
def _run_command(cmd): DCNL  DCSP logging.info(' DCSP '.join(cmd)) DCNL DCSP pipe = subprocess.PIPE DCNL DCSP proc = subprocess.Popen(cmd, stdin=pipe, stdout=pipe, stderr=pipe, close_fds=True) DCNL DCSP (out, err) = proc.communicate() DCNL DCSP if (proc.returncode is not os.EX_OK): DCNL DCSP  DCSP raise XenstoreError(cmd, proc.returncode, err, out) DCNL DCSP return (proc.returncode, out)
def make_subprocess(cmdline, stdout=False, stderr=False, stdin=False, universal_newlines=False): DCNL  DCSP cmdline = cmdline.encode('ascii') DCNL DCSP logging.info(("Running DCSP cmd DCSP '%s'" % cmdline)) DCNL DCSP kwargs = {} DCNL DCSP kwargs['stdout'] = ((stdout and subprocess.PIPE) or None) DCNL DCSP kwargs['stderr'] = ((stderr and subprocess.PIPE) or None) DCNL DCSP kwargs['stdin'] = ((stdin and subprocess.PIPE) or None) DCNL DCSP kwargs['universal_newlines'] = universal_newlines DCNL DCSP args = shlex.split(cmdline) DCNL DCSP logging.info(("Running DCSP args DCSP '%s'" % args)) DCNL DCSP proc = subprocess.Popen(args, **kwargs) DCNL DCSP return proc
def finish_subprocess(proc, cmdline, ok_exit_codes=None): DCNL  DCSP if (ok_exit_codes is None): DCNL DCSP  DCSP ok_exit_codes = [0] DCNL DCSP (out, err) = proc.communicate() DCNL DCSP ret = proc.returncode DCNL DCSP if (ret not in ok_exit_codes): DCNL DCSP  DCSP raise Exception(("'%(cmdline)s' DCSP returned DCSP non-zero DCSP exit DCSP code: DCSP retcode=%(ret)i, DCSP out='%(out)s', DCSP stderr='%(err)s'" % locals())) DCNL DCSP return (out, err)
def make_staging_area(sr_path): DCNL  DCSP staging_path = tempfile.mkdtemp(dir=sr_path) DCNL DCSP return staging_path
def cleanup_staging_area(staging_path): DCNL  DCSP if os.path.exists(staging_path): DCNL DCSP  DCSP shutil.rmtree(staging_path)
def _handle_old_style_images(staging_path): DCNL  DCSP file_num = 0 DCNL DCSP for filename in ('snap.vhd', 'image.vhd', 'base.vhd'): DCNL DCSP  DCSP path = os.path.join(staging_path, filename) DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP _rename(path, os.path.join(staging_path, ('%d.vhd' % file_num))) DCNL DCSP  DCSP  DCSP file_num += 1
def _assert_vhd_not_hidden(path): DCNL  DCSP query_cmd = ('vhd-util DCSP query DCSP -n DCSP %(path)s DCSP -f' % locals()) DCNL DCSP query_proc = make_subprocess(query_cmd, stdout=True, stderr=True) DCNL DCSP (out, err) = finish_subprocess(query_proc, query_cmd) DCNL DCSP for line in out.splitlines(): DCNL DCSP  DCSP if line.startswith('hidden'): DCNL DCSP  DCSP  DCSP value = line.split(':')[1].strip() DCNL DCSP  DCSP  DCSP if (value == '1'): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('VHD DCSP %(path)s DCSP is DCSP marked DCSP as DCSP hidden DCSP without DCSP child' % locals()))
def _validate_footer_timestamp(vdi_path): DCNL  DCSP check_cmd = ('vhd-util DCSP check DCSP -n DCSP %(vdi_path)s DCSP -p' % locals()) DCNL DCSP check_proc = make_subprocess(check_cmd, stdout=True, stderr=True) DCNL DCSP (out, err) = finish_subprocess(check_proc, check_cmd, ok_exit_codes=[0, 22]) DCNL DCSP first_line = out.splitlines()[0].strip() DCNL DCSP if ('primary DCSP footer DCSP invalid' in first_line): DCNL DCSP  DCSP raise Exception(("VDI DCSP '%(vdi_path)s' DCSP has DCSP timestamp DCSP in DCSP the DCSP future, DCSP ensure DCSP source DCSP and DCSP destination DCSP host DCSP machines DCSP have DCSP time DCSP set DCSP correctly" % locals())) DCNL DCSP elif (check_proc.returncode != 0): DCNL DCSP  DCSP raise Exception(("Unexpected DCSP output DCSP '%(out)s' DCSP from DCSP vhd-util" % locals()))
def _validate_vdi_chain(vdi_path): DCNL  DCSP def get_parent_path(path): DCNL DCSP  DCSP query_cmd = ('vhd-util DCSP query DCSP -n DCSP %(path)s DCSP -p' % locals()) DCNL DCSP  DCSP query_proc = make_subprocess(query_cmd, stdout=True, stderr=True) DCNL DCSP  DCSP (out, err) = finish_subprocess(query_proc, query_cmd, ok_exit_codes=[0, 22]) DCNL DCSP  DCSP first_line = out.splitlines()[0].strip() DCNL DCSP  DCSP if first_line.endswith('.vhd'): DCNL DCSP  DCSP  DCSP return first_line DCNL DCSP  DCSP elif ('has DCSP no DCSP parent' in first_line): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif ('query DCSP failed' in first_line): DCNL DCSP  DCSP  DCSP raise Exception(("VDI DCSP '%(path)s' DCSP not DCSP present DCSP which DCSP breaks DCSP the DCSP VDI DCSP chain, DCSP bailing DCSP out" % locals())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(("Unexpected DCSP output DCSP '%(out)s' DCSP from DCSP vhd-util" % locals())) DCNL DCSP cur_path = vdi_path DCNL DCSP while cur_path: DCNL DCSP  DCSP _validate_footer_timestamp(cur_path) DCNL DCSP  DCSP cur_path = get_parent_path(cur_path)
def _validate_sequenced_vhds(staging_path): DCNL  DCSP seq_num = 0 DCNL DCSP filenames = os.listdir(staging_path) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP if (not filename.endswith('.vhd')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (filename == 'swap.vhd'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vhd_path = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP if (not os.path.exists(vhd_path)): DCNL DCSP  DCSP  DCSP raise Exception(('Corrupt DCSP image. DCSP Expected DCSP seq DCSP number: DCSP %d. DCSP Files: DCSP %s' % (seq_num, filenames))) DCNL DCSP  DCSP seq_num += 1
def import_vhds(sr_path, staging_path, uuid_stack): DCNL  DCSP _handle_old_style_images(staging_path) DCNL DCSP _validate_sequenced_vhds(staging_path) DCNL DCSP files_to_move = [] DCNL DCSP seq_num = 0 DCNL DCSP while True: DCNL DCSP  DCSP orig_vhd_path = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP if (not os.path.exists(orig_vhd_path)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vhd_uuid = uuid_stack.pop() DCNL DCSP  DCSP vhd_path = os.path.join(staging_path, ('%s.vhd' % vhd_uuid)) DCNL DCSP  DCSP _rename(orig_vhd_path, vhd_path) DCNL DCSP  DCSP if (seq_num == 0): DCNL DCSP  DCSP  DCSP leaf_vhd_path = vhd_path DCNL DCSP  DCSP  DCSP leaf_vhd_uuid = vhd_uuid DCNL DCSP  DCSP files_to_move.append(vhd_path) DCNL DCSP  DCSP seq_num += 1 DCNL DCSP parent_path = None DCNL DCSP for vhd_path in reversed(files_to_move): DCNL DCSP  DCSP if parent_path: DCNL DCSP  DCSP  DCSP modify_cmd = ('vhd-util DCSP modify DCSP -n DCSP %(vhd_path)s DCSP -p DCSP %(parent_path)s' % locals()) DCNL DCSP  DCSP  DCSP modify_proc = make_subprocess(modify_cmd, stderr=True) DCNL DCSP  DCSP  DCSP finish_subprocess(modify_proc, modify_cmd) DCNL DCSP  DCSP parent_path = vhd_path DCNL DCSP _assert_vhd_not_hidden(leaf_vhd_path) DCNL DCSP _validate_vdi_chain(leaf_vhd_path) DCNL DCSP for orig_path in files_to_move: DCNL DCSP  DCSP new_path = os.path.join(sr_path, os.path.basename(orig_path)) DCNL DCSP  DCSP _rename(orig_path, new_path) DCNL DCSP imported_vhds = dict(root=dict(uuid=leaf_vhd_uuid)) DCNL DCSP return imported_vhds
def prepare_staging_area(sr_path, staging_path, vdi_uuids, seq_num=0): DCNL  DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP source = os.path.join(sr_path, ('%s.vhd' % vdi_uuid)) DCNL DCSP  DCSP link_name = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP _link(source, link_name) DCNL DCSP  DCSP seq_num += 1
def create_tarball(fileobj, path, callback=None): DCNL  DCSP tar_cmd = ('tar DCSP -zc DCSP --directory=%(path)s DCSP .' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmd, stdout=True, stderr=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = tar_proc.stdout.read(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP if fileobj: DCNL DCSP  DCSP  DCSP fileobj.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmd)
def extract_tarball(fileobj, path, callback=None): DCNL  DCSP tar_cmd = ('tar DCSP -zx DCSP --directory=%(path)s' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmd, stderr=True, stdin=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = fileobj.read(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP tar_proc.stdin.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmd)
def register_plugin_calls(*funcs): DCNL  DCSP wrapped_dict = {} DCNL DCSP for func in funcs: DCNL DCSP  DCSP wrapped_dict[func.__name__] = _handle_serialization(func) DCNL DCSP XenAPIPlugin.dispatch(wrapped_dict)
def serializers(**serializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def deserializers(**deserializers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def response(code): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
def action_peek_json(body): DCNL  DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
def action_peek_xml(body): DCNL  DCSP dom = xmlutil.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
def action(name): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
def extends(*args, **kwargs): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
def get_items(obj): DCNL  DCSP return list(obj.items())
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL  DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
def make_links(parent, selector=None): DCNL  DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL  DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
def safe_minidom_parse_string(xml_string): DCNL  DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except (sax.SAXParseException, ValueError, expat.ExpatError, LookupError) as e: DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=str(e))
def wrap_errors(fn): DCNL  DCSP def wrapped(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError() DCNL DCSP return wrapped
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL  DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
def status_from_state(vm_state, task_state='default'): DCNL  DCSP task_map = _STATE_MAP.get(vm_state, dict(default='UNKNOWN')) DCNL DCSP status = task_map.get(task_state, task_map['default']) DCNL DCSP if (status == 'UNKNOWN'): DCNL DCSP  DCSP LOG.error((_('status DCSP is DCSP UNKNOWN DCSP from DCSP vm_state=%(vm_state)s DCSP task_state=%(task_state)s. DCSP Bad DCSP upgrade DCSP or DCSP db DCSP corrupted?') % locals())) DCNL DCSP return status
def vm_state_from_status(status): DCNL  DCSP for (state, task_map) in _STATE_MAP.iteritems(): DCNL DCSP  DCSP status_string = task_map.get('default') DCNL DCSP  DCSP if (status.lower() == status_string.lower()): DCNL DCSP  DCSP  DCSP return state
def get_pagination_params(request): DCNL  DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
def _get_marker_param(request): DCNL  DCSP return request.GET['marker']
def limited(items, request, max_limit=CONF.osapi_max_limit): DCNL  DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
def get_limit_and_marker(request, max_limit=CONF.osapi_max_limit): DCNL  DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP marker = params.get('marker') DCNL DCSP return (limit, marker)
def limited_by_marker(items, request, max_limit=CONF.osapi_max_limit): DCNL  DCSP (limit, marker) = get_limit_and_marker(request, max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
def get_id_from_href(href): DCNL  DCSP return urlparse.urlsplit(('%s' % href)).path.split('/')[(-1)]
def remove_version_from_href(href): DCNL  DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
def get_networks_for_instance(context, instance): DCNL  DCSP nw_info = compute_utils.get_nw_info_for_instance(instance) DCNL DCSP return get_networks_for_instance_from_nw_info(nw_info)
def raise_http_conflict_for_instance_invalid_state(exc, action): DCNL  DCSP attr = exc.kwargs.get('attr') DCNL DCSP state = exc.kwargs.get('state') DCNL DCSP if (attr and state): DCNL DCSP  DCSP msg = _("Cannot DCSP '%(action)s' DCSP while DCSP instance DCSP is DCSP in DCSP %(attr)s DCSP %(state)s") DCNL DCSP else: DCNL DCSP  DCSP msg = _("Instance DCSP is DCSP in DCSP an DCSP invalid DCSP state DCSP for DCSP '%(action)s'") DCNL DCSP raise webob.exc.HTTPConflict(explanation=(msg % locals()))
def _translate_keys(cons): DCNL  DCSP pool = cons['pool'] DCNL DCSP info = {'id': cons['id'], 'console_type': pool['console_type']} DCNL DCSP return dict(console=info)
def _translate_detail_keys(cons): DCNL  DCSP pool = cons['pool'] DCNL DCSP info = {'id': cons['id'], 'console_type': pool['console_type'], 'password': cons['password'], 'instance_name': cons['instance_name'], 'port': cons['port'], 'host': pool['public_hostname']} DCNL DCSP return dict(console=info)
def remove_invalid_options(context, search_options, allowed_search_options): DCNL  DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP unk_opt_str = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(unk_opt_str)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP search_options.pop(opt, None)
def _unquote_domain(domain): DCNL  DCSP return urllib.unquote(domain).replace('%2E', '.')
def _translate_volume_detail_view(context, vol): DCNL  DCSP d = _translate_volume_summary_view(context, vol) DCNL DCSP return d
def _translate_volume_summary_view(context, vol): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availabilityZone'] = vol['availability_zone'] DCNL DCSP d['createdAt'] = vol['created_at'] DCNL DCSP if (vol['attach_status'] == 'attached'): DCNL DCSP  DCSP d['attachments'] = [_translate_attachment_detail_view(vol['id'], vol['instance_uuid'], vol['mountpoint'])] DCNL DCSP else: DCNL DCSP  DCSP d['attachments'] = [{}] DCNL DCSP d['displayName'] = vol['display_name'] DCNL DCSP d['displayDescription'] = vol['display_description'] DCNL DCSP if (vol['volume_type_id'] and vol.get('volume_type')): DCNL DCSP  DCSP d['volumeType'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['volumeType'] = vol['volume_type_id'] DCNL DCSP d['snapshotId'] = vol['snapshot_id'] DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metadata'): DCNL DCSP  DCSP metadata = vol.get('volume_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
def _translate_attachment_detail_view(volume_id, instance_uuid, mountpoint): DCNL  DCSP d = _translate_attachment_summary_view(volume_id, instance_uuid, mountpoint) DCNL DCSP return d
def _translate_attachment_summary_view(volume_id, instance_uuid, mountpoint): DCNL  DCSP d = {} DCNL DCSP d['id'] = volume_id DCNL DCSP d['volumeId'] = volume_id DCNL DCSP d['serverId'] = instance_uuid DCNL DCSP if mountpoint: DCNL DCSP  DCSP d['device'] = mountpoint DCNL DCSP return d
def _translate_snapshot_detail_view(context, vol): DCNL  DCSP d = _translate_snapshot_summary_view(context, vol) DCNL DCSP return d
def _translate_snapshot_summary_view(context, vol): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['volumeId'] = vol['volume_id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['volume_size'] DCNL DCSP d['createdAt'] = vol['created_at'] DCNL DCSP d['displayName'] = vol['display_name'] DCNL DCSP d['displayDescription'] = vol['display_description'] DCNL DCSP return d
def get_host_from_body(fn): DCNL  DCSP def wrapped(self, req, id, body, *args, **kwargs): DCNL DCSP  DCSP if ((len(body) == 1) and ('host' in body)): DCNL DCSP  DCSP  DCSP host = body['host'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exc.HTTPBadRequest DCNL DCSP  DCSP return fn(self, req, id, host, *args, **kwargs) DCNL DCSP return wrapped
def _filter_keys(item, keys): DCNL  DCSP return dict(((k, v) for (k, v) in item.iteritems() if (k in keys)))
def _translate_interface_attachment_view(port_info): DCNL  DCSP return {'net_id': port_info['network_id'], 'port_id': port_info['id'], 'mac_addr': port_info['mac_address'], 'port_state': port_info['status'], 'fixed_ips': port_info.get('fixed_ips', None)}
def _translate_vif_summary_view(_context, vif): DCNL  DCSP d = {} DCNL DCSP d['id'] = vif['uuid'] DCNL DCSP d['mac_address'] = vif['address'] DCNL DCSP return d
def unquote_header_value(value): DCNL  DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
def parse_list_header(value): DCNL  DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
def parse_options_header(value): DCNL  DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
def ec2_error(req, request_id, code, message): DCNL  DCSP LOG.error((_('%(code)s: DCSP %(message)s') % locals())) DCNL DCSP resp = webob.Response() DCNL DCSP resp.status = 400 DCNL DCSP resp.headers['Content-Type'] = 'text/xml' DCNL DCSP resp.body = str(('<?xml DCSP version="1.0"?>\n<Response><Errors><Error><Code>%s</Code><Message>%s</Message></Error></Errors><RequestID>%s</RequestID></Response>' % (utils.xhtml_escape(utils.utf8(code)), utils.xhtml_escape(utils.utf8(message)), utils.xhtml_escape(utils.utf8(request_id))))) DCNL DCSP return resp
def image_type(image_type): DCNL  DCSP if (image_type == 'kernel'): DCNL DCSP  DCSP return 'aki' DCNL DCSP if (image_type == 'ramdisk'): DCNL DCSP  DCSP return 'ari' DCNL DCSP if (image_type not in ['aki', 'ari']): DCNL DCSP  DCSP return 'ami' DCNL DCSP return image_type
@memoize DCNL def id_to_glance_id(context, image_id): DCNL  DCSP return db.s3_image_get(context, image_id)['uuid']
@memoize DCNL def glance_id_to_id(context, glance_id): DCNL  DCSP if (glance_id is None): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP return db.s3_image_get_by_uuid(context, glance_id)['id'] DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP return db.s3_image_create(context, glance_id)['id']
def ec2_id_to_id(ec2_id): DCNL  DCSP try: DCNL DCSP  DCSP return int(ec2_id.split('-')[(-1)], 16) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidEc2Id(ec2_id=ec2_id)
def image_ec2_id(image_id, image_type='ami'): DCNL  DCSP template = (image_type + '-%08x') DCNL DCSP try: DCNL DCSP  DCSP return id_to_ec2_id(image_id, template=template) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 'ami-00000000'
def get_ip_info_for_instance(context, instance): DCNL  DCSP info_cache = (instance['info_cache'] or {}) DCNL DCSP cached_nwinfo = info_cache.get('network_info') DCNL DCSP if (not cached_nwinfo): DCNL DCSP  DCSP cached_nwinfo = [] DCNL DCSP nw_info = network_model.NetworkInfo.hydrate(cached_nwinfo) DCNL DCSP return get_ip_info_for_instance_from_nw_info(nw_info)
def id_to_ec2_id(instance_id, template='i-%08x'): DCNL  DCSP return (template % int(instance_id))
def id_to_ec2_inst_id(instance_id): DCNL  DCSP if (instance_id is None): DCNL DCSP  DCSP return None DCNL DCSP elif uuidutils.is_uuid_like(instance_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_instance_uuid(ctxt, instance_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id) DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(instance_id)
def ec2_inst_id_to_uuid(context, ec2_id): DCNL  DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_instance_uuid_from_int_id(context, int_id)
def id_to_ec2_snap_id(snapshot_id): DCNL  DCSP if uuidutils.is_uuid_like(snapshot_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_snapshot_uuid(ctxt, snapshot_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id, 'snap-%08x') DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(snapshot_id, 'snap-%08x')
def id_to_ec2_vol_id(volume_id): DCNL  DCSP if uuidutils.is_uuid_like(volume_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_volume_uuid(ctxt, volume_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id, 'vol-%08x') DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(volume_id, 'vol-%08x')
def ec2_vol_id_to_uuid(ec2_id): DCNL  DCSP ctxt = context.get_admin_context() DCNL DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_volume_uuid_from_int_id(ctxt, int_id)
def is_ec2_timestamp_expired(request, expires=None): DCNL  DCSP query_time = None DCNL DCSP timestamp = request.get('Timestamp') DCNL DCSP expiry_time = request.get('Expires') DCNL DCSP def parse_strtime(strtime): DCNL DCSP  DCSP if _ms_time_regex.match(strtime): DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%dT%H:%M:%S.%fZ' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%dT%H:%M:%SZ' DCNL DCSP  DCSP return timeutils.parse_strtime(strtime, time_format) DCNL DCSP try: DCNL DCSP  DCSP if (timestamp and expiry_time): DCNL DCSP  DCSP  DCSP msg = _('Request DCSP must DCSP include DCSP either DCSP Timestamp DCSP or DCSP Expires, DCSP but DCSP cannot DCSP contain DCSP both') DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise exception.InvalidRequest(msg) DCNL DCSP  DCSP elif expiry_time: DCNL DCSP  DCSP  DCSP query_time = parse_strtime(expiry_time) DCNL DCSP  DCSP  DCSP return timeutils.is_older_than(query_time, (-1)) DCNL DCSP  DCSP elif timestamp: DCNL DCSP  DCSP  DCSP query_time = parse_strtime(timestamp) DCNL DCSP  DCSP  DCSP if (query_time and expires): DCNL DCSP  DCSP  DCSP  DCSP return (timeutils.is_older_than(query_time, expires) or timeutils.is_newer_than(query_time, expires)) DCNL DCSP  DCSP return False DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.audit(_('Timestamp DCSP is DCSP invalid.')) DCNL DCSP  DCSP return True
def ec2_snap_id_to_uuid(ec2_id): DCNL  DCSP ctxt = context.get_admin_context() DCNL DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_snapshot_uuid_from_int_id(ctxt, int_id)
def _try_convert(value): DCNL  DCSP def _negative_zero(value): DCNL DCSP  DCSP epsilon = 1e-07 DCNL DCSP  DCSP return (0 if (abs(value) < epsilon) else value) DCNL DCSP if (len(value) == 0): DCNL DCSP  DCSP return '' DCNL DCSP if (value == 'None'): DCNL DCSP  DCSP return None DCNL DCSP lowered_value = value.lower() DCNL DCSP if (lowered_value == 'true'): DCNL DCSP  DCSP return True DCNL DCSP if (lowered_value == 'false'): DCNL DCSP  DCSP return False DCNL DCSP for (prefix, base) in [('0x', 16), ('0b', 2), ('0', 8), ('', 10)]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if lowered_value.startswith((prefix, ('-' + prefix))): DCNL DCSP  DCSP  DCSP  DCSP return int(lowered_value, base) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return _negative_zero(float(value)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value
def dict_from_dotted_str(items): DCNL  DCSP args = {} DCNL DCSP for (key, value) in items: DCNL DCSP  DCSP parts = key.split('.') DCNL DCSP  DCSP key = str(camelcase_to_underscore(parts[0])) DCNL DCSP  DCSP if (isinstance(value, str) or isinstance(value, unicode)): DCNL DCSP  DCSP  DCSP value = _try_convert(value) DCNL DCSP  DCSP  DCSP if (len(parts) > 1): DCNL DCSP  DCSP  DCSP  DCSP d = args.get(key, {}) DCNL DCSP  DCSP  DCSP  DCSP args[key] = d DCNL DCSP  DCSP  DCSP  DCSP for k in parts[1:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP k = camelcase_to_underscore(k) DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = d.get(k, {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP d[k] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = v DCNL DCSP  DCSP  DCSP  DCSP d[camelcase_to_underscore(parts[(-1)])] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args[key] = value DCNL DCSP return args
def _state_description(vm_state, _shutdown_terminate): DCNL  DCSP name = _STATE_DESCRIPTION_MAP.get(vm_state, vm_state) DCNL DCSP return {'code': inst_state.name_to_code(name), 'name': name}
def _parse_block_device_mapping(bdm): DCNL  DCSP ebs = bdm.pop('ebs', None) DCNL DCSP if ebs: DCNL DCSP  DCSP ec2_id = ebs.pop('snapshot_id', None) DCNL DCSP  DCSP if ec2_id: DCNL DCSP  DCSP  DCSP if ec2_id.startswith('snap-'): DCNL DCSP  DCSP  DCSP  DCSP bdm['snapshot_id'] = ec2utils.ec2_snap_id_to_uuid(ec2_id) DCNL DCSP  DCSP  DCSP elif ec2_id.startswith('vol-'): DCNL DCSP  DCSP  DCSP  DCSP bdm['volume_id'] = ec2utils.ec2_vol_id_to_uuid(ec2_id) DCNL DCSP  DCSP  DCSP ebs.setdefault('delete_on_termination', True) DCNL DCSP  DCSP bdm.update(ebs) DCNL DCSP return bdm
def _format_block_device_mapping(bdm): DCNL  DCSP keys = (('deviceName', 'device_name'), ('virtualName', 'virtual_name')) DCNL DCSP item = {} DCNL DCSP for (name, k) in keys: DCNL DCSP  DCSP if (k in bdm): DCNL DCSP  DCSP  DCSP item[name] = bdm[k] DCNL DCSP if bdm.get('no_device'): DCNL DCSP  DCSP item['noDevice'] = True DCNL DCSP if (('snapshot_id' in bdm) or ('volume_id' in bdm)): DCNL DCSP  DCSP ebs_keys = (('snapshotId', 'snapshot_id'), ('snapshotId', 'volume_id'), ('volumeSize', 'volume_size'), ('deleteOnTermination', 'delete_on_termination')) DCNL DCSP  DCSP ebs = {} DCNL DCSP  DCSP for (name, k) in ebs_keys: DCNL DCSP  DCSP  DCSP if (k in bdm): DCNL DCSP  DCSP  DCSP  DCSP if (k == 'snapshot_id'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.id_to_ec2_snap_id(bdm[k]) DCNL DCSP  DCSP  DCSP  DCSP elif (k == 'volume_id'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.id_to_ec2_vol_id(bdm[k]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = bdm[k] DCNL DCSP  DCSP assert ('snapshotId' in ebs) DCNL DCSP  DCSP item['ebs'] = ebs DCNL DCSP return item
def _format_mappings(properties, result): DCNL  DCSP mappings = [{'virtualName': m['virtual'], 'deviceName': m['device']} for m in _properties_get_mappings(properties) if block_device.is_swap_or_ephemeral(m['virtual'])] DCNL DCSP block_device_mapping = [_format_block_device_mapping(bdm) for bdm in properties.get('block_device_mapping', [])] DCNL DCSP for bdm in block_device_mapping: DCNL DCSP  DCSP for i in range(len(mappings)): DCNL DCSP  DCSP  DCSP if (bdm['deviceName'] == mappings[i]['deviceName']): DCNL DCSP  DCSP  DCSP  DCSP del mappings[i] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP mappings.append(bdm) DCNL DCSP mappings = [bdm for bdm in mappings if (not bdm.get('noDevice', False))] DCNL DCSP if mappings: DCNL DCSP  DCSP result['blockDeviceMapping'] = mappings
def _database_to_isoformat(datetimeobj): DCNL  DCSP return (datetimeobj.strftime('%Y-%m-%dT%H:%M:%S.%f')[:(-3)] + 'Z')
def convert_password(context, password): DCNL  DCSP password = (password or '') DCNL DCSP meta = {} DCNL DCSP for i in xrange(CHUNKS): DCNL DCSP  DCSP meta[('password_%d' % i)] = password[:CHUNK_LENGTH] DCNL DCSP  DCSP password = password[CHUNK_LENGTH:] DCNL DCSP return meta
def pipeline_factory(loader, global_conf, **local_conf): DCNL  DCSP pipeline = local_conf[CONF.auth_strategy] DCNL DCSP if (not CONF.api_rate_limit): DCNL DCSP  DCSP limit_name = (CONF.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
def validate_url_path(val): DCNL  DCSP if (not validate_str()(val)): DCNL DCSP  DCSP return False DCNL DCSP return (VALIDATE_PATH_RE.match(val).end() == len(val))
def validate_user_data(user_data): DCNL  DCSP try: DCNL DCSP  DCSP user_data = base64.b64decode(user_data) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True
def validate(args, validator): DCNL  DCSP for key in validator: DCNL DCSP  DCSP if (key not in args): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP f = validator[key] DCNL DCSP  DCSP assert callable(f) DCNL DCSP  DCSP if (not f(args[key])): DCNL DCSP  DCSP  DCSP LOG.debug(_('%(key)s DCSP with DCSP value DCSP %(value)s DCSP failed DCSP validator DCSP %(name)s'), {'key': key, 'value': args[key], 'name': f.__name__}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_code, int) and (not isinstance(check_exit_code, bool)) and (_returncode != check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def is_uuid_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL  DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
def get_context_from_function_and_args(function, args, kwargs): DCNL  DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(product_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
def build_filter(class_name, *args): DCNL  DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
def load_filters(filters_path): DCNL  DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
def match_filter(filters, userargs, exec_dirs=[]): DCNL  DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL  DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
def canonicalize_emails(changelog, mapping): DCNL  DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
def write_git_changelog(): DCNL  DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
def generate_authors(): DCNL  DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
def get_cmdclass(): DCNL  DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
def _get_revno(git_dir): DCNL  DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
def _get_version_from_git(pre_version): DCNL  DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
def _get_version_from_pkg_info(package_name): DCNL  DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
def get_version(package_name, pre_version=None): DCNL  DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
def parse_host_port(address, default_port=None): DCNL  DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
def set_rules(rules): DCNL  DCSP global _rules DCNL DCSP _rules = rules
def reset(): DCNL  DCSP global _rules DCNL DCSP _rules = None
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL  DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
def _parse_check(rule): DCNL  DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
def _parse_list_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
def _parse_tokenize(rule): DCNL  DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
def reducer(*tokens): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
def _parse_text_rule(rule): DCNL  DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
def parse_rule(rule): DCNL  DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
def register(name, func=None): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
def validate_args(fn, *args, **kwargs): DCNL  DCSP argspec = inspect.getargspec(fn) DCNL DCSP num_defaults = len((argspec.defaults or [])) DCNL DCSP required_args = argspec.args[:(len(argspec.args) - num_defaults)] DCNL DCSP def isbound(method): DCNL DCSP  DCSP return (getattr(method, 'im_self', None) is not None) DCNL DCSP if isbound(fn): DCNL DCSP  DCSP required_args.pop(0) DCNL DCSP missing = [arg for arg in required_args if (arg not in kwargs)] DCNL DCSP missing = missing[len(args):] DCNL DCSP if missing: DCNL DCSP  DCSP raise MissingArgs(missing)
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL  DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
def set_defaults(sql_connection, sqlite_db): DCNL  DCSP cfg.set_defaults(sql_opts, sql_connection=sql_connection, sqlite_db=sqlite_db)
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
def raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL  DCSP def get_columns_from_uniq_cons_or_name(columns): DCNL DCSP  DCSP uniqbase = 'uniq_' DCNL DCSP  DCSP if (not columns.startswith(uniqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.index('_') + 1):columns.rindex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqbase):].split('_x_') DCNL DCSP if (engine_name not in ['mysql', 'sqlite', 'postgresql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
def raise_if_deadlock_error(operational_error, engine_name): DCNL  DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeadlock(operational_error)
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = create_engine(CONF.sql_connection) DCNL DCSP return _ENGINE
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
def add_regexp_listener(dbapi_con, con_record): DCNL  DCSP def regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(unicode(item)) is not None) DCNL DCSP dbapi_con.create_function('regexp', 2, regexp)
def greenthread_yield(dbapi_con, con_record): DCNL  DCSP greenthread.sleep(0)
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL  DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def is_db_connection_error(args): DCNL  DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def create_engine(sql_connection): DCNL  DCSP connection_dict = sqlalchemy.engine.url.make_url(sql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP if (CONF.sql_connection_debug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP elif (CONF.sql_connection_debug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP else: DCNL DCSP  DCSP engine_args['pool_size'] = CONF.sql_max_pool_size DCNL DCSP  DCSP if (CONF.sql_max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.sql_max_overflow DCNL DCSP engine = sqlalchemy.create_engine(sql_connection, **engine_args) DCNL DCSP sqlalchemy.event.listen(engine, 'checkin', greenthread_yield) DCNL DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'checkout', ping_listener) DCNL DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if (not CONF.sqlite_synchronous): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', add_regexp_listener) DCNL DCSP if (CONF.sql_connection_trace and (engine.dialect.dbapi.__name__ == 'MySQLdb')): DCNL DCSP  DCSP patch_mysqldb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.sql_max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.sql_retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, query_cls=Query)
def patch_mysqldb_with_stacktrace_comments(): DCNL  DCSP import MySQLdb.cursors DCNL DCSP import traceback DCNL DCSP old_mysql_do_query = MySQLdb.cursors.BaseCursor._do_query DCNL DCSP def _do_query(self, q): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, method, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.endswith('session.py') and (method == '_do_query')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('api.py') and (method == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('utils.py') and (method == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('exception.py') and (method == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.endswith('db/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP index = file.rfind('nova') DCNL DCSP  DCSP  DCSP if (index == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Method:%s() DCSP Line:%s DCSP | DCSP ' % (file[index:], line, method, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qq = ('%s DCSP /* DCSP %s DCSP */' % (q, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qq = q DCNL DCSP  DCSP old_mysql_do_query(self, qq) DCNL DCSP setattr(MySQLdb.cursors.BaseCursor, '_do_query', _do_query)
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL  DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
def notify(context, message): DCNL  DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def notify(_context, message): DCNL  DCSP pass
def notify(_context, message): DCNL  DCSP NOTIFICATIONS.append(message)
def notify(_context, message): DCNL  DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('nova.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
def notify_decorator(name, fn): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
def notify(context, publisher_id, event_type, priority, payload): DCNL  DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
def _get_drivers(): DCNL  DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
def add_driver(notification_driver): DCNL  DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
def _reset_drivers(): DCNL  DCSP global _drivers DCNL DCSP _drivers = None
def notify(context, message): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
def _get_queue_arguments(conf): DCNL  DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def create_connection(conf, new=True): DCNL  DCSP return Connection()
def check_serialize(msg): DCNL  DCSP json.dumps(msg)
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def fanout_cast(conf, context, topic, msg): DCNL  DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
def create_connection(conf, new=True): DCNL  DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
def multicall(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def call(conf, context, topic, msg, timeout=None): DCNL  DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
def cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast(conf, context, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL  DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
def notify(conf, context, topic, msg, envelope): DCNL  DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
def unpack_context(conf, msg): DCNL  DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
def pack_context(msg, context): DCNL  DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
def _add_unique_id(msg): DCNL  DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
def create_connection(conf, new, connection_pool): DCNL  DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
def call(conf, context, topic, msg, timeout, connection_pool): DCNL  DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
def cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL  DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL  DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL  DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
def create_connection(new=True): DCNL  DCSP return _get_impl().create_connection(CONF, new=new)
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
def cast(context, topic, msg): DCNL  DCSP return _get_impl().cast(CONF, context, topic, msg)
def fanout_cast(context, topic, msg): DCNL  DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL  DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
def notify(context, topic, msg, envelope=False): DCNL  DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
def cleanup(): DCNL  DCSP return _get_impl().cleanup()
def cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
def fanout_cast_to_server(context, server_params, topic, msg): DCNL  DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
def queue_get_for(context, topic, host): DCNL  DCSP return (('%s.%s' % (topic, host)) if host else topic)
def _get_impl(): DCNL  DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
def serialize_remote_exception(failure_info, log_failure=True): DCNL  DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
def client_exceptions(*exceptions): DCNL  DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def version_is_compatible(imp_version, version): DCNL  DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
def _serialize(data): DCNL  DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
def _deserialize(data): DCNL  DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
def unflatten_envelope(packenv): DCNL  DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL  DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
def multicall(conf, *args, **kwargs): DCNL  DCSP return _multi_send(_call, *args, **kwargs)
def call(conf, *args, **kwargs): DCNL  DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
def cast(conf, *args, **kwargs): DCNL  DCSP _multi_send(_cast, *args, **kwargs)
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL  DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
def notify(conf, context, topic, msg, envelope): DCNL  DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
def cleanup(): DCNL  DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
def ensure_tree(path): DCNL  DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def import_class(import_str): DCNL  DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
def import_object(import_str, *args, **kwargs): DCNL  DCSP return import_class(import_str)(*args, **kwargs)
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL  DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
def import_module(import_str): DCNL  DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
def try_import(import_str, default=None): DCNL  DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
def isotime(at=None): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
def parse_isotime(timestr): DCNL  DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL  DCSP return datetime.datetime.strptime(timestr, fmt)
def normalize_time(timestamp): DCNL  DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
def is_older_than(before, seconds): DCNL  DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
def is_newer_than(after, seconds): DCNL  DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
def utcnow_ts(): DCNL  DCSP return calendar.timegm(utcnow().timetuple())
def utcnow(): DCNL  DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
def iso8601_from_timestamp(timestamp): DCNL  DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL  DCSP utcnow.override_time = override_time
def advance_time_delta(timedelta): DCNL  DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
def advance_time_seconds(seconds): DCNL  DCSP advance_time_delta(datetime.timedelta(0, seconds))
def clear_time_override(): DCNL  DCSP utcnow.override_time = None
def marshall_now(now=None): DCNL  DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
def unmarshall_time(tyme): DCNL  DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
def delta_seconds(before, after): DCNL  DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
def is_soon(dt, window): DCNL  DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
def basedir_def(*args): DCNL  DCSP return os.path.join('$pybasedir', *args)
def bindir_def(*args): DCNL  DCSP return os.path.join('$bindir', *args)
def state_path_def(*args): DCNL  DCSP return os.path.join('$state_path', *args)
def basedir_rel(*args): DCNL  DCSP return os.path.join(CONF.pybasedir, *args)
def bindir_rel(*args): DCNL  DCSP return os.path.join(CONF.bindir, *args)
def state_path_rel(*args): DCNL  DCSP return os.path.join(CONF.state_path, *args)
def send_api_fault(url, status, exception): DCNL  DCSP if (not CONF.notify_api_faults): DCNL DCSP  DCSP return DCNL DCSP payload = {'url': url, 'exception': str(exception), 'status': status} DCNL DCSP publisher_id = notifier_api.publisher_id('api') DCNL DCSP notifier_api.notify(None, publisher_id, 'api.fault', notifier_api.ERROR, payload)
def send_update(context, old_instance, new_instance, service=None, host=None): DCNL  DCSP if ((not CONF.notify_on_any_change) and (not CONF.notify_on_state_change)): DCNL DCSP  DCSP return DCNL DCSP update_with_state_change = False DCNL DCSP old_vm_state = old_instance['vm_state'] DCNL DCSP new_vm_state = new_instance['vm_state'] DCNL DCSP old_task_state = old_instance['task_state'] DCNL DCSP new_task_state = new_instance['task_state'] DCNL DCSP if (old_vm_state != new_vm_state): DCNL DCSP  DCSP update_with_state_change = True DCNL DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_and_task_state') and (old_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP update_with_state_change = True DCNL DCSP if update_with_state_change: DCNL DCSP  DCSP send_update_with_states(context, new_instance, old_vm_state, new_vm_state, old_task_state, new_task_state, service, host) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _send_instance_update_notification(context, new_instance, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP send DCSP state DCSP update DCSP notification'), instance=new_instance)
def send_update_with_states(context, instance, old_vm_state, new_vm_state, old_task_state, new_task_state, service='compute', host=None, verify_states=False): DCNL  DCSP if (not CONF.notify_on_state_change): DCNL DCSP  DCSP return DCNL DCSP fire_update = True DCNL DCSP if verify_states: DCNL DCSP  DCSP fire_update = False DCNL DCSP  DCSP if (old_vm_state != new_vm_state): DCNL DCSP  DCSP  DCSP fire_update = True DCNL DCSP  DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_and_task_state') and (old_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP  DCSP fire_update = True DCNL DCSP if fire_update: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _send_instance_update_notification(context, instance, old_vm_state=old_vm_state, old_task_state=old_task_state, new_vm_state=new_vm_state, new_task_state=new_task_state, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP send DCSP state DCSP update DCSP notification'), instance=instance)
def _send_instance_update_notification(context, instance, old_vm_state=None, old_task_state=None, new_vm_state=None, new_task_state=None, service='compute', host=None): DCNL  DCSP payload = info_from_instance(context, instance, None, None) DCNL DCSP if (not new_vm_state): DCNL DCSP  DCSP new_vm_state = instance['vm_state'] DCNL DCSP if (not new_task_state): DCNL DCSP  DCSP new_task_state = instance['task_state'] DCNL DCSP states_payload = {'old_state': old_vm_state, 'state': new_vm_state, 'old_task_state': old_task_state, 'new_task_state': new_task_state} DCNL DCSP payload.update(states_payload) DCNL DCSP (audit_start, audit_end) = audit_period_bounds(current_period=True) DCNL DCSP payload['audit_period_beginning'] = audit_start DCNL DCSP payload['audit_period_ending'] = audit_end DCNL DCSP bw = bandwidth_usage(instance, audit_start) DCNL DCSP payload['bandwidth'] = bw DCNL DCSP publisher_id = notifier_api.publisher_id(service, host) DCNL DCSP notifier_api.notify(context, publisher_id, 'compute.instance.update', notifier_api.INFO, payload)
def audit_period_bounds(current_period=False): DCNL  DCSP (begin, end) = utils.last_completed_audit_period() DCNL DCSP if current_period: DCNL DCSP  DCSP audit_start = end DCNL DCSP  DCSP audit_end = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP audit_start = begin DCNL DCSP  DCSP audit_end = end DCNL DCSP return (audit_start, audit_end)
def bandwidth_usage(instance_ref, audit_start, ignore_missing_network_data=True): DCNL  DCSP admin_context = nova.context.get_admin_context(read_deleted='yes') DCNL DCSP if (instance_ref.get('info_cache') and (instance_ref['info_cache'].get('network_info') is not None)): DCNL DCSP  DCSP cached_info = instance_ref['info_cache']['network_info'] DCNL DCSP  DCSP nw_info = network_model.NetworkInfo.hydrate(cached_info) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nw_info = network.API().get_instance_nw_info(admin_context, instance_ref) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP get DCSP nw_info'), instance=instance_ref) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if ignore_missing_network_data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP macs = [vif['address'] for vif in nw_info] DCNL DCSP uuids = [instance_ref['uuid']] DCNL DCSP bw_usages = db.bw_usage_get_by_uuids(admin_context, uuids, audit_start) DCNL DCSP bw_usages = [b for b in bw_usages if (b.mac in macs)] DCNL DCSP bw = {} DCNL DCSP for b in bw_usages: DCNL DCSP  DCSP label = ('net-name-not-found-%s' % b['mac']) DCNL DCSP  DCSP for vif in nw_info: DCNL DCSP  DCSP  DCSP if (vif['address'] == b['mac']): DCNL DCSP  DCSP  DCSP  DCSP label = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP bw[label] = dict(bw_in=b.bw_in, bw_out=b.bw_out) DCNL DCSP return bw
def image_meta(system_metadata): DCNL  DCSP image_meta = {} DCNL DCSP for (md_key, md_value) in system_metadata.iteritems(): DCNL DCSP  DCSP if md_key.startswith('image_'): DCNL DCSP  DCSP  DCSP image_meta[md_key[6:]] = md_value DCNL DCSP return image_meta
def info_from_instance(context, instance_ref, network_info, system_metadata, **kw): DCNL  DCSP def null_safe_str(s): DCNL DCSP  DCSP return (str(s) if s else '') DCNL DCSP image_ref_url = glance.generate_image_url(instance_ref['image_ref']) DCNL DCSP instance_type = instance_types.extract_instance_type(instance_ref) DCNL DCSP instance_type_name = instance_type.get('name', '') DCNL DCSP if (system_metadata is None): DCNL DCSP  DCSP system_metadata = utils.metadata_to_dict(instance_ref['system_metadata']) DCNL DCSP instance_info = dict(tenant_id=instance_ref['project_id'], user_id=instance_ref['user_id'], instance_id=instance_ref['uuid'], display_name=instance_ref['display_name'], reservation_id=instance_ref['reservation_id'], hostname=instance_ref['hostname'], instance_type=instance_type_name, instance_type_id=instance_ref['instance_type_id'], architecture=instance_ref['architecture'], memory_mb=instance_ref['memory_mb'], disk_gb=(instance_ref['root_gb'] + instance_ref['ephemeral_gb']), vcpus=instance_ref['vcpus'], root_gb=instance_ref['root_gb'], ephemeral_gb=instance_ref['ephemeral_gb'], host=instance_ref['host'], availability_zone=instance_ref['availability_zone'], created_at=str(instance_ref['created_at']), deleted_at=null_safe_str(instance_ref.get('terminated_at')), launched_at=null_safe_str(instance_ref.get('launched_at')), image_ref_url=image_ref_url, os_type=instance_ref['os_type'], kernel_id=instance_ref['kernel_id'], ramdisk_id=instance_ref['ramdisk_id'], state=instance_ref['vm_state'], state_description=null_safe_str(instance_ref.get('task_state')), access_ip_v4=instance_ref['access_ip_v4'], access_ip_v6=instance_ref['access_ip_v6']) DCNL DCSP if (network_info is not None): DCNL DCSP  DCSP fixed_ips = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP for ip in vif.fixed_ips(): DCNL DCSP  DCSP  DCSP  DCSP ip['label'] = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP fixed_ips.append(ip) DCNL DCSP  DCSP instance_info['fixed_ips'] = fixed_ips DCNL DCSP image_meta_props = image_meta(system_metadata) DCNL DCSP instance_info['image_meta'] = image_meta_props DCNL DCSP instance_info['metadata'] = instance_ref['metadata'] DCNL DCSP instance_info.update(kw) DCNL DCSP return instance_info
def generate_glance_url(): DCNL  DCSP return ('%s://%s:%d' % (CONF.glance_protocol, CONF.glance_host, CONF.glance_port))
def generate_image_url(image_ref): DCNL  DCSP return ('%s/images/%s' % (generate_glance_url(), image_ref))
def _parse_image_ref(image_href): DCNL  DCSP o = urlparse.urlparse(image_href) DCNL DCSP port = (o.port or 80) DCNL DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP image_id = o.path.split('/')[(-1)] DCNL DCSP use_ssl = (o.scheme == 'https') DCNL DCSP return (image_id, host, port, use_ssl)
def _create_glance_client(context, host, port, use_ssl, version=1): DCNL  DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = CONF.glance_api_insecure DCNL DCSP if (CONF.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP endpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), endpoint, **params)
def get_api_servers(): DCNL  DCSP api_servers = [] DCNL DCSP for api_server in CONF.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP o = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (o.port or 80) DCNL DCSP  DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (o.scheme == 'https') DCNL DCSP  DCSP api_servers.append((host, port, use_ssl)) DCNL DCSP random.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
def _convert_timestamps_to_datetimes(image_meta): DCNL  DCSP for attr in ['created_at', 'updated_at', 'deleted_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
def _reraise_translated_image_exception(image_id): DCNL  DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_id, exc_value) DCNL DCSP raise new_exc, None, exc_trace
def _reraise_translated_exception(): DCNL  DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
def get_remote_image_service(context, image_href): DCNL  DCSP LOG.debug((_('fetching DCSP image DCSP %s DCSP from DCSP glance') % image_href)) DCNL DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_default_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_id, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_id)
def _cleanse_dict(original): DCNL  DCSP return dict(((k, v) for (k, v) in original.iteritems() if (not ('_pass' in k))))
def wrap_exception(notifier=None, publisher_id=None, event_type=None, level=None): DCNL  DCSP def inner(f): DCNL DCSP  DCSP def wrapped(self, context, *args, **kw): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(self, context, *args, **kw) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if notifier: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payload = dict(exception=e) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP call_dict = safe_utils.getcallargs(f, *args, **kw) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleansed = _cleanse_dict(call_dict) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payload.update({'args': cleansed}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = level DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_level): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = notifier.ERROR DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = event_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = f.__name__ DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP notifier.notify(context, publisher_id, temp_type, temp_level, payload) DCNL DCSP  DCSP return functools.wraps(f)(wrapped) DCNL DCSP return inner
def is_user_context(context): DCNL  DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
def require_admin_context(ctxt): DCNL  DCSP if (not ctxt.is_admin): DCNL DCSP  DCSP raise exception.AdminRequired()
def require_context(ctxt): DCNL  DCSP if ((not ctxt.is_admin) and (not is_user_context(ctxt))): DCNL DCSP  DCSP raise exception.NotAuthorized()
def authorize_project_context(context, project_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_user_context(context, user_id): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def authorize_quota_class_context(context, class_name): DCNL  DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
def add_hook(name): DCNL  DCSP def outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP manager = _HOOKS.setdefault(name, HookManager(name)) DCNL DCSP  DCSP  DCSP manager.run_pre(name, args, kwargs) DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP manager.run_post(name, rv, args, kwargs) DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return outer
def reset(): DCNL  DCSP _HOOKS.clear()
def _get_my_ip(): DCNL  DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
def qemu_img_info(path): DCNL  DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP return QemuImgInfo() DCNL DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path) DCNL DCSP return QemuImgInfo(out)
def convert_image(source, dest, out_format, run_as_root=False): DCNL  DCSP cmd = ('qemu-img', 'convert', '-O', out_format, source, dest) DCNL DCSP utils.execute(run_as_root=run_as_root, *cmd)
def get_injected_network_template(network_info, use_ipv6=CONF.use_ipv6, template=CONF.injected_network_template): DCNL  DCSP if (network_info is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(network_info, 'legacy'): DCNL DCSP  DCSP network_info = network_info.legacy() DCNL DCSP nets = [] DCNL DCSP ifc_num = (-1) DCNL DCSP have_injected_networks = False DCNL DCSP for (network_ref, mapping) in network_info: DCNL DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP if (not network_ref['injected']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP have_injected_networks = True DCNL DCSP  DCSP address = mapping['ips'][0]['ip'] DCNL DCSP  DCSP netmask = mapping['ips'][0]['netmask'] DCNL DCSP  DCSP address_v6 = None DCNL DCSP  DCSP gateway_v6 = None DCNL DCSP  DCSP netmask_v6 = None DCNL DCSP  DCSP if use_ipv6: DCNL DCSP  DCSP  DCSP address_v6 = mapping['ip6s'][0]['ip'] DCNL DCSP  DCSP  DCSP netmask_v6 = mapping['ip6s'][0]['netmask'] DCNL DCSP  DCSP  DCSP gateway_v6 = mapping['gateway_v6'] DCNL DCSP  DCSP net_info = {'name': ('eth%d' % ifc_num), 'address': address, 'netmask': netmask, 'gateway': mapping['gateway'], 'broadcast': mapping['broadcast'], 'dns': ' DCSP '.join(mapping['dns']), 'address_v6': address_v6, 'gateway_v6': gateway_v6, 'netmask_v6': netmask_v6} DCNL DCSP  DCSP nets.append(net_info) DCNL DCSP if (have_injected_networks is False): DCNL DCSP  DCSP return None DCNL DCSP if (not template): DCNL DCSP  DCSP return None DCNL DCSP _late_load_cheetah() DCNL DCSP ifc_template = open(template).read() DCNL DCSP return str(Template(ifc_template, searchList=[{'interfaces': nets, 'use_ipv6': use_ipv6}]))
def build_pxe_config(deployment_id, deployment_key, deployment_iscsi_iqn, deployment_aki_path, deployment_ari_path, aki_path, ari_path): DCNL  DCSP LOG.debug((_('Building DCSP PXE DCSP config DCSP for DCSP deployment DCSP %s.') % deployment_id)) DCNL DCSP pxe_options = {'deployment_id': deployment_id, 'deployment_key': deployment_key, 'deployment_iscsi_iqn': deployment_iscsi_iqn, 'deployment_aki_path': deployment_aki_path, 'deployment_ari_path': deployment_ari_path, 'aki_path': aki_path, 'ari_path': ari_path, 'pxe_append_params': CONF.baremetal.pxe_append_params} DCNL DCSP cheetah = _get_cheetah() DCNL DCSP pxe_config = str(cheetah(open(CONF.baremetal.pxe_config_template).read(), searchList=[{'pxe_options': pxe_options, 'ROOT': '${ROOT}'}])) DCNL DCSP return pxe_config
def get_image_dir_path(instance): DCNL  DCSP return os.path.join(CONF.instances_path, instance['name'])
def get_image_file_path(instance): DCNL  DCSP return os.path.join(CONF.instances_path, instance['name'], 'disk')
def get_pxe_config_file_path(instance): DCNL  DCSP return os.path.join(CONF.baremetal.tftp_root, instance['uuid'], 'config')
def get_pxe_mac_path(mac): DCNL  DCSP return os.path.join(CONF.baremetal.tftp_root, 'pxelinux.cfg', ('01-' + mac.replace(':', '-').lower()))
def get_tftp_image_info(instance, instance_type): DCNL  DCSP image_info = {'kernel': [None, None], 'ramdisk': [None, None], 'deploy_kernel': [None, None], 'deploy_ramdisk': [None, None]} DCNL DCSP try: DCNL DCSP  DCSP image_info['kernel'][0] = str(instance['kernel_id']) DCNL DCSP  DCSP image_info['ramdisk'][0] = str(instance['ramdisk_id']) DCNL DCSP  DCSP image_info['deploy_kernel'][0] = get_deploy_aki_id(instance_type) DCNL DCSP  DCSP image_info['deploy_ramdisk'][0] = get_deploy_ari_id(instance_type) DCNL DCSP except KeyError as e: DCNL DCSP  DCSP pass DCNL DCSP missing_labels = [] DCNL DCSP for label in image_info.keys(): DCNL DCSP  DCSP (uuid, path) = image_info[label] DCNL DCSP  DCSP if (not uuid): DCNL DCSP  DCSP  DCSP missing_labels.append(label) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_info[label][1] = os.path.join(CONF.baremetal.tftp_root, instance['uuid'], label) DCNL DCSP if missing_labels: DCNL DCSP  DCSP raise exception.NovaException((_('Can DCSP not DCSP activate DCSP PXE DCSP bootloader. DCSP The DCSP following DCSP boot DCSP parameters DCSP were DCSP not DCSP passed DCSP to DCSP baremetal DCSP driver: DCSP %s') % missing_labels)) DCNL DCSP return image_info
def get_session(autocommit=True, expire_on_commit=False): DCNL  DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = nova_session.get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
def get_engine(): DCNL  DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = nova_session.create_engine(CONF.baremetal.sql_connection) DCNL DCSP return _ENGINE
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def model_query(context, *args, **kwargs): DCNL  DCSP session = (kwargs.get('session') or db_session.get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and nova.context.is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
@sqlalchemy_api.require_admin_context DCNL def bm_node_associate_and_update(context, node_uuid, values): DCNL  DCSP if ('instance_uuid' not in values): DCNL DCSP  DCSP raise exception.NovaException(_('instance_uuid DCSP must DCSP be DCSP supplied DCSP to DCSP bm_node_associate_and_update')) DCNL DCSP session = db_session.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP query = model_query(context, models.BareMetalNode, session=session, read_deleted='no').filter_by(uuid=node_uuid) DCNL DCSP  DCSP count = query.filter_by(instance_uuid=None).update(values, synchronize_session=False) DCNL DCSP  DCSP if (count != 1): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Failed DCSP to DCSP associate DCSP instance DCSP %(i_uuid)s DCSP to DCSP baremetal DCSP node DCSP %(n_uuid)s.') % {'i_uuid': values['instance_uuid'], 'n_uuid': node_uuid})) DCNL DCSP  DCSP ref = query.first() DCNL DCSP return ref
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def _update_state(context, node, instance, state): DCNL  DCSP values = {'task_state': state} DCNL DCSP if (not instance): DCNL DCSP  DCSP values['instance_uuid'] = None DCNL DCSP  DCSP values['instance_name'] = None DCNL DCSP db.bm_node_update(context, node['id'], values)
def get_host_iqn(session, cluster=None): DCNL  DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP hbas_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.storageDevice.hostBusAdapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP return hba.iScsiName
def find_st(session, data, cluster=None): DCNL  DCSP target_portal = data['target_portal'] DCNL DCSP target_iqn = data['target_iqn'] DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP lst_properties = ['config.storageDevice.hostBusAdapter', 'config.storageDevice.scsiTopology', 'config.storageDevice.scsiLun'] DCNL DCSP props = session._call_method(vim_util, 'get_object_properties', None, host_mor, 'HostSystem', lst_properties) DCNL DCSP result = (None, None) DCNL DCSP hbas_ret = None DCNL DCSP scsi_topology = None DCNL DCSP scsi_lun_ret = None DCNL DCSP for elem in props: DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'config.storageDevice.hostBusAdapter'): DCNL DCSP  DCSP  DCSP  DCSP hbas_ret = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiTopology'): DCNL DCSP  DCSP  DCSP  DCSP scsi_topology = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiLun'): DCNL DCSP  DCSP  DCSP  DCSP scsi_lun_ret = prop.val DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return result DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_key = hba.key DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return result DCNL DCSP if (scsi_topology is None): DCNL DCSP  DCSP return result DCNL DCSP host_adapters = scsi_topology.adapter DCNL DCSP if (not host_adapters): DCNL DCSP  DCSP return result DCNL DCSP scsi_lun_key = None DCNL DCSP for adapter in host_adapters: DCNL DCSP  DCSP if (adapter.adapter == hba_key): DCNL DCSP  DCSP  DCSP if (not getattr(adapter, 'target', None)): DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP for target in adapter.target: DCNL DCSP  DCSP  DCSP  DCSP if (getattr(target.transport, 'address', None) and (target.transport.address[0] == target_portal) and (target.transport.iScsiName == target_iqn)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not target.lun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP  DCSP  DCSP for lun in target.lun: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('host.ScsiDisk' in lun.scsiLun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scsi_lun_key = lun.scsiLun DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP break DCNL DCSP if (scsi_lun_key is None): DCNL DCSP  DCSP return result DCNL DCSP if (scsi_lun_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_scsi_luns = scsi_lun_ret.ScsiLun DCNL DCSP if (not host_scsi_luns): DCNL DCSP  DCSP return result DCNL DCSP for scsi_lun in host_scsi_luns: DCNL DCSP  DCSP if (scsi_lun.key == scsi_lun_key): DCNL DCSP  DCSP  DCSP return (scsi_lun.deviceName, scsi_lun.uuid) DCNL DCSP return result
def rescan_iscsi_hba(session, cluster=None): DCNL  DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP storage_system_mor = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'configManager.storageSystem') DCNL DCSP hbas_ret = session._call_method(vim_util, 'get_dynamic_property', storage_system_mor, 'HostStorageSystem', 'storageDeviceInfo.hostBusAdapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_device = hba.device DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP LOG.debug((_('Rescanning DCSP HBA DCSP %s') % hba_device)) DCNL DCSP session._call_method(session._get_vim(), 'RescanHba', storage_system_mor, hbaDevice=hba_device) DCNL DCSP LOG.debug((_('Rescanned DCSP HBA DCSP %s DCSP ') % hba_device))
def mountpoint_to_number(mountpoint): DCNL  DCSP if mountpoint.startswith('/dev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hsv]d[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[2:3]) - ord('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn((_('Mountpoint DCSP cannot DCSP be DCSP translated: DCSP %s') % mountpoint)) DCNL DCSP  DCSP return (-1)
def start_transfer(context, read_file_handle, data_size, write_file_handle=None, image_service=None, image_id=None, image_meta=None): DCNL  DCSP if (not image_meta): DCNL DCSP  DCSP image_meta = {} DCNL DCSP thread_safe_pipe = io_util.ThreadSafePipe(QUEUE_BUFFER_SIZE, data_size) DCNL DCSP read_thread = io_util.IOThread(read_file_handle, thread_safe_pipe) DCNL DCSP if write_file_handle: DCNL DCSP  DCSP write_thread = io_util.IOThread(thread_safe_pipe, write_file_handle) DCNL DCSP elif (image_service and image_id): DCNL DCSP  DCSP write_thread = io_util.GlanceWriteThread(context, thread_safe_pipe, image_service, image_id, image_meta) DCNL DCSP read_event = read_thread.start() DCNL DCSP write_event = write_thread.start() DCNL DCSP try: DCNL DCSP  DCSP read_event.wait() DCNL DCSP  DCSP write_event.wait() DCNL DCSP except Exception as exc: DCNL DCSP  DCSP read_thread.stop() DCNL DCSP  DCSP write_thread.stop() DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP finally: DCNL DCSP  DCSP read_file_handle.close() DCNL DCSP  DCSP if write_file_handle: DCNL DCSP  DCSP  DCSP write_file_handle.close()
def fetch_image(context, image, instance, **kwargs): DCNL  DCSP LOG.debug((_('Downloading DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP metadata = image_service.show(context, image_id) DCNL DCSP file_size = int(metadata['size']) DCNL DCSP read_iter = image_service.download(context, image_id) DCNL DCSP read_file_handle = read_write_util.GlanceFileRead(read_iter) DCNL DCSP write_file_handle = read_write_util.VMwareHTTPWriteFile(kwargs.get('host'), kwargs.get('data_center_name'), kwargs.get('datastore_name'), kwargs.get('cookies'), kwargs.get('file_path'), file_size) DCNL DCSP start_transfer(context, read_file_handle, file_size, write_file_handle=write_file_handle) DCNL DCSP LOG.debug((_('Downloaded DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance)
def upload_image(context, image, instance, **kwargs): DCNL  DCSP LOG.debug((_('Uploading DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP read_file_handle = read_write_util.VMwareHTTPReadFile(kwargs.get('host'), kwargs.get('data_center_name'), kwargs.get('datastore_name'), kwargs.get('cookies'), kwargs.get('file_path')) DCNL DCSP file_size = read_file_handle.get_size() DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP image_metadata = {'disk_format': 'vmdk', 'is_public': 'false', 'name': kwargs.get('snapshot_name'), 'status': 'active', 'container_format': 'bare', 'size': file_size, 'properties': {'vmware_adaptertype': kwargs.get('adapter_type'), 'vmware_ostype': kwargs.get('os_type'), 'vmware_image_version': kwargs.get('image_version'), 'owner_id': instance['project_id']}} DCNL DCSP start_transfer(context, read_file_handle, file_size, image_service=image_service, image_id=image_id, image_meta=image_metadata) DCNL DCSP LOG.debug((_('Uploaded DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance)
def get_vmdk_size_and_properties(context, image, instance): DCNL  DCSP LOG.debug((_('Getting DCSP image DCSP size DCSP for DCSP the DCSP image DCSP %s') % image), instance=instance) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP meta_data = image_service.show(context, image_id) DCNL DCSP (size, properties) = (meta_data['size'], meta_data['properties']) DCNL DCSP LOG.debug((_('Got DCSP image DCSP size DCSP of DCSP %(size)s DCSP for DCSP the DCSP image DCSP %(image)s') % locals()), instance=instance) DCNL DCSP return (size, properties)
def log_db_contents(msg=None): DCNL  DCSP text = (msg or '') DCNL DCSP content = pprint.pformat(_db_content) DCNL DCSP LOG.debug((_('%(text)s: DCSP _db_content DCSP => DCSP %(content)s') % locals()))
def reset(): DCNL  DCSP for c in _CLASSES: DCNL DCSP  DCSP if (c == 'files'): DCNL DCSP  DCSP  DCSP _db_content[c] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _db_content[c] = {} DCNL DCSP create_network() DCNL DCSP create_host_network_system() DCNL DCSP create_host() DCNL DCSP create_datacenter() DCNL DCSP create_datastore() DCNL DCSP create_res_pool()
def cleanup(): DCNL  DCSP for c in _CLASSES: DCNL DCSP  DCSP _db_content[c] = {}
def _create_object(table, table_obj): DCNL  DCSP _db_content[table][table_obj.obj] = table_obj
def _get_objects(obj_type): DCNL  DCSP lst_objs = [] DCNL DCSP for key in _db_content[obj_type]: DCNL DCSP  DCSP lst_objs.append(_db_content[obj_type][key]) DCNL DCSP return lst_objs
def _add_file(file_path): DCNL  DCSP _db_content['files'].append(file_path)
def _remove_file(file_path): DCNL  DCSP if (_db_content.get('files') is None): DCNL DCSP  DCSP raise exception.NoFilesFound() DCNL DCSP if (file_path.find('.vmdk') != (-1)): DCNL DCSP  DCSP if (file_path not in _db_content.get('files')): DCNL DCSP  DCSP  DCSP raise exception.FileNotFound(file_path=file_path) DCNL DCSP  DCSP _db_content.get('files').remove(file_path) DCNL DCSP else: DCNL DCSP  DCSP for file in _db_content.get('files'): DCNL DCSP  DCSP  DCSP if (file.find(file_path) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP lst_files = _db_content.get('files') DCNL DCSP  DCSP  DCSP  DCSP if (lst_files and lst_files.count(file)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lst_files.remove(file)
def fake_plug_vifs(*args, **kwargs): DCNL  DCSP pass
def fake_get_network(*args, **kwargs): DCNL  DCSP return {'type': 'fake'}
def fake_fetch_image(context, image, instance, **kwargs): DCNL  DCSP ds_name = kwargs.get('datastore_name') DCNL DCSP file_path = kwargs.get('file_path') DCNL DCSP ds_file_path = ((('[' + ds_name) + '] DCSP ') + file_path) DCNL DCSP _add_file(ds_file_path)
def fake_upload_image(context, image, instance, **kwargs): DCNL  DCSP pass
def fake_get_vmdk_size_and_properties(context, image_id, instance): DCNL  DCSP props = {'vmware_ostype': 'otherGuest', 'vmware_adaptertype': 'lsiLogic'} DCNL DCSP return (_FAKE_FILE_SIZE, props)
def _get_vm_mdo(vm_ref): DCNL  DCSP if (_db_content.get('VirtualMachine', None) is None): DCNL DCSP  DCSP raise exception.NotFound(_('There DCSP is DCSP no DCSP VM DCSP registered')) DCNL DCSP if (vm_ref not in _db_content.get('VirtualMachine')): DCNL DCSP  DCSP raise exception.NotFound((_('Virtual DCSP Machine DCSP with DCSP ref DCSP %s DCSP is DCSP not DCSP there') % vm_ref)) DCNL DCSP return _db_content.get('VirtualMachine')[vm_ref]
def build_selection_spec(client_factory, name): DCNL  DCSP sel_spec = client_factory.create('ns0:SelectionSpec') DCNL DCSP sel_spec.name = name DCNL DCSP return sel_spec
def build_traversal_spec(client_factory, name, spec_type, path, skip, select_set): DCNL  DCSP traversal_spec = client_factory.create('ns0:TraversalSpec') DCNL DCSP traversal_spec.name = name DCNL DCSP traversal_spec.type = spec_type DCNL DCSP traversal_spec.path = path DCNL DCSP traversal_spec.skip = skip DCNL DCSP traversal_spec.selectSet = select_set DCNL DCSP return traversal_spec
def build_recursive_traversal_spec(client_factory): DCNL  DCSP visit_folders_select_spec = build_selection_spec(client_factory, 'visitFolders') DCNL DCSP dc_to_hf = build_traversal_spec(client_factory, 'dc_to_hf', 'Datacenter', 'hostFolder', False, [visit_folders_select_spec]) DCNL DCSP dc_to_vmf = build_traversal_spec(client_factory, 'dc_to_vmf', 'Datacenter', 'vmFolder', False, [visit_folders_select_spec]) DCNL DCSP h_to_vm = build_traversal_spec(client_factory, 'h_to_vm', 'HostSystem', 'vm', False, [visit_folders_select_spec]) DCNL DCSP cr_to_h = build_traversal_spec(client_factory, 'cr_to_h', 'ComputeResource', 'host', False, []) DCNL DCSP cr_to_ds = build_traversal_spec(client_factory, 'cr_to_ds', 'ComputeResource', 'datastore', False, []) DCNL DCSP rp_to_rp_select_spec = build_selection_spec(client_factory, 'rp_to_rp') DCNL DCSP rp_to_vm_select_spec = build_selection_spec(client_factory, 'rp_to_vm') DCNL DCSP cr_to_rp = build_traversal_spec(client_factory, 'cr_to_rp', 'ComputeResource', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_rp = build_traversal_spec(client_factory, 'rp_to_rp', 'ResourcePool', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_vm = build_traversal_spec(client_factory, 'rp_to_vm', 'ResourcePool', 'vm', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP traversal_spec = build_traversal_spec(client_factory, 'visitFolders', 'Folder', 'childEntity', False, [visit_folders_select_spec, dc_to_hf, dc_to_vmf, cr_to_ds, cr_to_h, cr_to_rp, rp_to_rp, h_to_vm, rp_to_vm]) DCNL DCSP return traversal_spec
def build_property_spec(client_factory, type='VirtualMachine', properties_to_collect=None, all_properties=False): DCNL  DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = all_properties DCNL DCSP property_spec.pathSet = properties_to_collect DCNL DCSP property_spec.type = type DCNL DCSP return property_spec
def build_object_spec(client_factory, root_folder, traversal_specs): DCNL  DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = root_folder DCNL DCSP object_spec.skip = False DCNL DCSP object_spec.selectSet = traversal_specs DCNL DCSP return object_spec
def build_property_filter_spec(client_factory, property_specs, object_specs): DCNL  DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_filter_spec.propSet = property_specs DCNL DCSP property_filter_spec.objectSet = object_specs DCNL DCSP return property_filter_spec
def get_object_properties(vim, collector, mobj, type, properties): DCNL  DCSP client_factory = vim.client.factory DCNL DCSP if (mobj is None): DCNL DCSP  DCSP return None DCNL DCSP usecoll = collector DCNL DCSP if (usecoll is None): DCNL DCSP  DCSP usecoll = vim.get_service_content().propertyCollector DCNL DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = ((properties is None) or (len(properties) == 0)) DCNL DCSP property_spec.pathSet = properties DCNL DCSP property_spec.type = type DCNL DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = mobj DCNL DCSP object_spec.skip = False DCNL DCSP property_filter_spec.propSet = [property_spec] DCNL DCSP property_filter_spec.objectSet = [object_spec] DCNL DCSP return vim.RetrieveProperties(usecoll, specSet=[property_filter_spec])
def get_dynamic_property(vim, mobj, type, property_name): DCNL  DCSP obj_content = get_object_properties(vim, None, mobj, type, [property_name]) DCNL DCSP property_value = None DCNL DCSP if obj_content: DCNL DCSP  DCSP dynamic_property = obj_content[0].propSet DCNL DCSP  DCSP if dynamic_property: DCNL DCSP  DCSP  DCSP property_value = dynamic_property[0].val DCNL DCSP return property_value
def get_objects(vim, type, properties_to_collect=None, all=False): DCNL  DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP client_factory = vim.client.factory DCNL DCSP object_spec = build_object_spec(client_factory, vim.get_service_content().rootFolder, [build_recursive_traversal_spec(client_factory)]) DCNL DCSP property_spec = build_property_spec(client_factory, type=type, properties_to_collect=properties_to_collect, all_properties=all) DCNL DCSP property_filter_spec = build_property_filter_spec(client_factory, [property_spec], [object_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[property_filter_spec])
def get_prop_spec(client_factory, spec_type, properties): DCNL  DCSP prop_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP prop_spec.type = spec_type DCNL DCSP prop_spec.pathSet = properties DCNL DCSP return prop_spec
def get_obj_spec(client_factory, obj, select_set=None): DCNL  DCSP obj_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP obj_spec.obj = obj DCNL DCSP obj_spec.skip = False DCNL DCSP if (select_set is not None): DCNL DCSP  DCSP obj_spec.selectSet = select_set DCNL DCSP return obj_spec
def get_prop_filter_spec(client_factory, obj_spec, prop_spec): DCNL  DCSP prop_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP prop_filter_spec.propSet = prop_spec DCNL DCSP prop_filter_spec.objectSet = obj_spec DCNL DCSP return prop_filter_spec
def get_properties_for_a_collection_of_objects(vim, type, obj_list, properties): DCNL  DCSP client_factory = vim.client.factory DCNL DCSP if (len(obj_list) == 0): DCNL DCSP  DCSP return [] DCNL DCSP prop_spec = get_prop_spec(client_factory, type, properties) DCNL DCSP lst_obj_specs = [] DCNL DCSP for obj in obj_list: DCNL DCSP  DCSP lst_obj_specs.append(get_obj_spec(client_factory, obj)) DCNL DCSP prop_filter_spec = get_prop_filter_spec(client_factory, lst_obj_specs, [prop_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[prop_filter_spec])
def ensure_vlan_bridge(session, vif, cluster=None): DCNL  DCSP vlan_num = vif['network'].get_meta('vlan') DCNL DCSP bridge = vif['network']['bridge'] DCNL DCSP vlan_interface = CONF.vmwareapi_vlan_interface DCNL DCSP if (not network_util.check_if_vlan_interface_exists(session, vlan_interface, cluster)): DCNL DCSP  DCSP raise exception.NetworkAdapterNotFound(adapter=vlan_interface) DCNL DCSP vswitch_associated = network_util.get_vswitch_for_vlan_interface(session, vlan_interface, cluster) DCNL DCSP if (vswitch_associated is None): DCNL DCSP  DCSP raise exception.SwitchNotFoundForNetworkAdapter(adapter=vlan_interface) DCNL DCSP network_ref = network_util.get_network_with_the_name(session, bridge, cluster) DCNL DCSP if (network_ref is None): DCNL DCSP  DCSP network_util.create_port_group(session, bridge, vswitch_associated, vlan_num, cluster) DCNL DCSP else: DCNL DCSP  DCSP _get_pg_info = network_util.get_vlanid_and_vswitch_for_portgroup DCNL DCSP  DCSP (pg_vlanid, pg_vswitch) = _get_pg_info(session, bridge, cluster) DCNL DCSP  DCSP if (pg_vswitch != vswitch_associated): DCNL DCSP  DCSP  DCSP raise exception.InvalidVLANPortGroup(bridge=bridge, expected=vswitch_associated, actual=pg_vswitch) DCNL DCSP  DCSP if (pg_vlanid != vlan_num): DCNL DCSP  DCSP  DCSP raise exception.InvalidVLANTag(bridge=bridge, tag=vlan_num, pgroup=pg_vlanid)
def build_datastore_path(datastore_name, path): DCNL  DCSP return ('[%s] DCSP %s' % (datastore_name, path))
def split_datastore_path(datastore_path): DCNL  DCSP spl = datastore_path.split('[', 1)[1].split(']', 1) DCNL DCSP path = '' DCNL DCSP if (len(spl) == 1): DCNL DCSP  DCSP datastore_url = spl[0] DCNL DCSP else: DCNL DCSP  DCSP (datastore_url, path) = spl DCNL DCSP return (datastore_url, path.strip())
def get_vm_create_spec(client_factory, instance, data_store_name, vif_infos, os_type='otherGuest'): DCNL  DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = instance['name'] DCNL DCSP config_spec.guestId = os_type DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + data_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStandby = True DCNL DCSP tools_info.beforeGuestShutdown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = int(instance['vcpus']) DCNL DCSP config_spec.memoryMB = int(instance['memory_mb']) DCNL DCSP vif_spec_list = [] DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP vif_spec = create_network_spec(client_factory, vif_info) DCNL DCSP  DCSP vif_spec_list.append(vif_spec) DCNL DCSP device_config_spec = vif_spec_list DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP extra_config = [] DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'nvp.vm-uuid' DCNL DCSP opt.value = instance['uuid'] DCNL DCSP extra_config.append(opt) DCNL DCSP i = 0 DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP if vif_info['iface_id']: DCNL DCSP  DCSP  DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP  DCSP  DCSP opt.key = ('nvp.iface-id.%d' % i) DCNL DCSP  DCSP  DCSP opt.value = vif_info['iface_id'] DCNL DCSP  DCSP  DCSP extra_config.append(opt) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP config_spec.extraConfig = extra_config DCNL DCSP return config_spec
def create_controller_spec(client_factory, key, adapter_type='lsiLogic'): DCNL  DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'add' DCNL DCSP if (adapter_type == 'busLogic'): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualBusLogicController') DCNL DCSP else: DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualLsiLogicController') DCNL DCSP virtual_controller.key = key DCNL DCSP virtual_controller.busNumber = 0 DCNL DCSP virtual_controller.sharedBus = 'noSharing' DCNL DCSP virtual_device_config.device = virtual_controller DCNL DCSP return virtual_device_config
def create_network_spec(client_factory, vif_info): DCNL  DCSP network_spec = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP network_spec.operation = 'add' DCNL DCSP net_device = client_factory.create('ns0:VirtualPCNet32') DCNL DCSP network_ref = vif_info['network_ref'] DCNL DCSP network_name = vif_info['network_name'] DCNL DCSP mac_address = vif_info['mac_address'] DCNL DCSP backing = None DCNL DCSP if (network_ref and (network_ref['type'] == 'DistributedVirtualPortgroup')): DCNL DCSP  DCSP backing_name = ''.join(['ns0:VirtualEthernetCardDistributed', 'VirtualPortBackingInfo']) DCNL DCSP  DCSP backing = client_factory.create(backing_name) DCNL DCSP  DCSP portgroup = client_factory.create('ns0:DistributedVirtualSwitchPortConnection') DCNL DCSP  DCSP portgroup.switchUuid = network_ref['dvsw'] DCNL DCSP  DCSP portgroup.portgroupKey = network_ref['dvpg'] DCNL DCSP  DCSP backing.port = portgroup DCNL DCSP else: DCNL DCSP  DCSP backing = client_factory.create('ns0:VirtualEthernetCardNetworkBackingInfo') DCNL DCSP  DCSP backing.deviceName = network_name DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnected = True DCNL DCSP connectable_spec.allowGuestControl = True DCNL DCSP connectable_spec.connected = True DCNL DCSP net_device.connectable = connectable_spec DCNL DCSP net_device.backing = backing DCNL DCSP net_device.key = (-47) DCNL DCSP net_device.addressType = 'manual' DCNL DCSP net_device.macAddress = mac_address DCNL DCSP net_device.wakeOnLanEnabled = True DCNL DCSP network_spec.device = net_device DCNL DCSP return network_spec
def get_vmdk_attach_config_spec(client_factory, adapter_type='lsiLogic', disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, controller_key=None, unit_number=None, device_name=None): DCNL  DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP device_config_spec = [] DCNL DCSP if (controller_key is None): DCNL DCSP  DCSP if (adapter_type == 'ide'): DCNL DCSP  DCSP  DCSP controller_key = 200 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP controller_key = (-101) DCNL DCSP  DCSP  DCSP controller_spec = create_controller_spec(client_factory, controller_key, adapter_type) DCNL DCSP  DCSP  DCSP device_config_spec.append(controller_spec) DCNL DCSP virtual_device_config_spec = create_virtual_disk_spec(client_factory, controller_key, disk_type, file_path, disk_size, linked_clone, unit_number, device_name) DCNL DCSP device_config_spec.append(virtual_device_config_spec) DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
def get_vmdk_detach_config_spec(client_factory, device): DCNL  DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP device_config_spec = [] DCNL DCSP virtual_device_config_spec = delete_virtual_disk_spec(client_factory, device) DCNL DCSP device_config_spec.append(virtual_device_config_spec) DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
def get_vmdk_path_and_adapter_type(hardware_devices): DCNL  DCSP if (hardware_devices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP hardware_devices = hardware_devices.VirtualDevice DCNL DCSP vmdk_file_path = None DCNL DCSP vmdk_controler_key = None DCNL DCSP disk_type = None DCNL DCSP unit_number = 0 DCNL DCSP adapter_type_dict = {} DCNL DCSP for device in hardware_devices: DCNL DCSP  DCSP if (device.__class__.__name__ == 'VirtualDisk'): DCNL DCSP  DCSP  DCSP if (device.backing.__class__.__name__ == 'VirtualDiskFlatVer2BackingInfo'): DCNL DCSP  DCSP  DCSP  DCSP vmdk_file_path = device.backing.fileName DCNL DCSP  DCSP  DCSP  DCSP vmdk_controler_key = device.controllerKey DCNL DCSP  DCSP  DCSP  DCSP if getattr(device.backing, 'thinProvisioned', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'thin' DCNL DCSP  DCSP  DCSP  DCSP elif getattr(device.backing, 'eagerlyScrub', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'eagerZeroedThick' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'preallocated' DCNL DCSP  DCSP  DCSP if (device.unitNumber > unit_number): DCNL DCSP  DCSP  DCSP  DCSP unit_number = device.unitNumber DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualLsiLogicController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'lsiLogic' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualBusLogicController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'busLogic' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualIDEController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'ide' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualLsiLogicSASController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'lsiLogic' DCNL DCSP adapter_type = adapter_type_dict.get(vmdk_controler_key, '') DCNL DCSP return (vmdk_file_path, vmdk_controler_key, adapter_type, disk_type, unit_number)
def get_rdm_disk(hardware_devices, uuid): DCNL  DCSP if (hardware_devices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP hardware_devices = hardware_devices.VirtualDevice DCNL DCSP for device in hardware_devices: DCNL DCSP  DCSP if ((device.__class__.__name__ == 'VirtualDisk') and (device.backing.__class__.__name__ == 'VirtualDiskRawDiskMappingVer1BackingInfo') and (device.backing.lunUuid == uuid)): DCNL DCSP  DCSP  DCSP return device
def get_copy_virtual_disk_spec(client_factory, adapter_type='lsilogic', disk_type='preallocated'): DCNL  DCSP dest_spec = client_factory.create('ns0:VirtualDiskSpec') DCNL DCSP dest_spec.adapterType = adapter_type DCNL DCSP dest_spec.diskType = disk_type DCNL DCSP return dest_spec
def get_vmdk_create_spec(client_factory, size_in_kb, adapter_type='lsiLogic', disk_type='preallocated'): DCNL  DCSP create_vmdk_spec = client_factory.create('ns0:FileBackedVirtualDiskSpec') DCNL DCSP create_vmdk_spec.adapterType = adapter_type DCNL DCSP create_vmdk_spec.diskType = disk_type DCNL DCSP create_vmdk_spec.capacityKb = size_in_kb DCNL DCSP return create_vmdk_spec
def get_rdm_create_spec(client_factory, device, adapter_type='lsiLogic', disk_type='rdmp'): DCNL  DCSP create_vmdk_spec = client_factory.create('ns0:DeviceBackedVirtualDiskSpec') DCNL DCSP create_vmdk_spec.adapterType = adapter_type DCNL DCSP create_vmdk_spec.diskType = disk_type DCNL DCSP create_vmdk_spec.device = device DCNL DCSP return create_vmdk_spec
def create_virtual_disk_spec(client_factory, controller_key, disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, unit_number=None, device_name=None): DCNL  DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'add' DCNL DCSP if ((file_path is None) or linked_clone): DCNL DCSP  DCSP virtual_device_config.fileOperation = 'create' DCNL DCSP virtual_disk = client_factory.create('ns0:VirtualDisk') DCNL DCSP if ((disk_type == 'rdm') or (disk_type == 'rdmp')): DCNL DCSP  DCSP disk_file_backing = client_factory.create('ns0:VirtualDiskRawDiskMappingVer1BackingInfo') DCNL DCSP  DCSP disk_file_backing.compatibilityMode = ('virtualMode' if (disk_type == 'rdm') else 'physicalMode') DCNL DCSP  DCSP disk_file_backing.diskMode = 'independent_persistent' DCNL DCSP  DCSP disk_file_backing.deviceName = (device_name or '') DCNL DCSP else: DCNL DCSP  DCSP disk_file_backing = client_factory.create('ns0:VirtualDiskFlatVer2BackingInfo') DCNL DCSP  DCSP disk_file_backing.diskMode = 'persistent' DCNL DCSP  DCSP if (disk_type == 'thin'): DCNL DCSP  DCSP  DCSP disk_file_backing.thinProvisioned = True DCNL DCSP  DCSP elif (disk_type == 'eagerZeroedThick'): DCNL DCSP  DCSP  DCSP disk_file_backing.eagerlyScrub = True DCNL DCSP disk_file_backing.fileName = (file_path or '') DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnected = True DCNL DCSP connectable_spec.allowGuestControl = False DCNL DCSP connectable_spec.connected = True DCNL DCSP if (not linked_clone): DCNL DCSP  DCSP virtual_disk.backing = disk_file_backing DCNL DCSP else: DCNL DCSP  DCSP virtual_disk.backing = copy.copy(disk_file_backing) DCNL DCSP  DCSP virtual_disk.backing.fileName = '' DCNL DCSP  DCSP virtual_disk.backing.parent = disk_file_backing DCNL DCSP virtual_disk.connectable = connectable_spec DCNL DCSP virtual_disk.key = (-100) DCNL DCSP virtual_disk.controllerKey = controller_key DCNL DCSP virtual_disk.unitNumber = (unit_number or 0) DCNL DCSP virtual_disk.capacityInKB = (disk_size or 0) DCNL DCSP virtual_device_config.device = virtual_disk DCNL DCSP return virtual_device_config
def delete_virtual_disk_spec(client_factory, device): DCNL  DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'remove' DCNL DCSP virtual_device_config.fileOperation = 'destroy' DCNL DCSP virtual_device_config.device = device DCNL DCSP return virtual_device_config
def clone_vm_spec(client_factory, location, power_on=False, snapshot=None, template=False): DCNL  DCSP clone_spec = client_factory.create('ns0:VirtualMachineCloneSpec') DCNL DCSP clone_spec.location = location DCNL DCSP clone_spec.powerOn = power_on DCNL DCSP clone_spec.snapshot = snapshot DCNL DCSP clone_spec.template = template DCNL DCSP return clone_spec
def relocate_vm_spec(client_factory, datastore=None, host=None, disk_move_type='moveAllDiskBackingsAndAllowSharing'): DCNL  DCSP rel_spec = client_factory.create('ns0:VirtualMachineRelocateSpec') DCNL DCSP rel_spec.datastore = datastore DCNL DCSP rel_spec.diskMoveType = disk_move_type DCNL DCSP rel_spec.host = host DCNL DCSP return rel_spec
def get_dummy_vm_create_spec(client_factory, name, data_store_name): DCNL  DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = name DCNL DCSP config_spec.guestId = 'otherGuest' DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + data_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStandby = True DCNL DCSP tools_info.beforeGuestShutdown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = 1 DCNL DCSP config_spec.memoryMB = 4 DCNL DCSP controller_key = (-101) DCNL DCSP controller_spec = create_controller_spec(client_factory, controller_key) DCNL DCSP disk_spec = create_virtual_disk_spec(client_factory, 1024, controller_key) DCNL DCSP device_config_spec = [controller_spec, disk_spec] DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
def get_machine_id_change_spec(client_factory, machine_id_str): DCNL  DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'machine.id' DCNL DCSP opt.value = machine_id_str DCNL DCSP virtual_machine_config_spec.extraConfig = [opt] DCNL DCSP return virtual_machine_config_spec
def get_add_vswitch_port_group_spec(client_factory, vswitch_name, port_group_name, vlan_id): DCNL  DCSP vswitch_port_group_spec = client_factory.create('ns0:HostPortGroupSpec') DCNL DCSP vswitch_port_group_spec.name = port_group_name DCNL DCSP vswitch_port_group_spec.vswitchName = vswitch_name DCNL DCSP vswitch_port_group_spec.vlanId = int(vlan_id) DCNL DCSP policy = client_factory.create('ns0:HostNetworkPolicy') DCNL DCSP nicteaming = client_factory.create('ns0:HostNicTeamingPolicy') DCNL DCSP nicteaming.notifySwitches = True DCNL DCSP policy.nicTeaming = nicteaming DCNL DCSP vswitch_port_group_spec.policy = policy DCNL DCSP return vswitch_port_group_spec
def get_vnc_config_spec(client_factory, port, password): DCNL  DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt_enabled = client_factory.create('ns0:OptionValue') DCNL DCSP opt_enabled.key = 'RemoteDisplay.vnc.enabled' DCNL DCSP opt_enabled.value = 'true' DCNL DCSP opt_port = client_factory.create('ns0:OptionValue') DCNL DCSP opt_port.key = 'RemoteDisplay.vnc.port' DCNL DCSP opt_port.value = port DCNL DCSP opt_pass = client_factory.create('ns0:OptionValue') DCNL DCSP opt_pass.key = 'RemoteDisplay.vnc.password' DCNL DCSP opt_pass.value = password DCNL DCSP virtual_machine_config_spec.extraConfig = [opt_enabled, opt_port, opt_pass] DCNL DCSP return virtual_machine_config_spec
def search_datastore_spec(client_factory, file_name): DCNL  DCSP search_spec = client_factory.create('ns0:HostDatastoreBrowserSearchSpec') DCNL DCSP search_spec.matchPattern = [file_name] DCNL DCSP return search_spec
def get_vm_ref_from_name(session, vm_name): DCNL  DCSP vms = session._call_method(vim_util, 'get_objects', 'VirtualMachine', ['name']) DCNL DCSP for vm in vms: DCNL DCSP  DCSP if (vm.propSet[0].val == vm_name): DCNL DCSP  DCSP  DCSP return vm.obj DCNL DCSP return None
def get_cluster_ref_from_name(session, cluster_name): DCNL  DCSP cls = session._call_method(vim_util, 'get_objects', 'ClusterComputeResource', ['name']) DCNL DCSP for cluster in cls: DCNL DCSP  DCSP if (cluster.propSet[0].val == cluster_name): DCNL DCSP  DCSP  DCSP return cluster.obj DCNL DCSP return None
def get_host_ref(session, cluster=None): DCNL  DCSP if (cluster is None): DCNL DCSP  DCSP host_mor = session._call_method(vim_util, 'get_objects', 'HostSystem')[0].obj DCNL DCSP else: DCNL DCSP  DCSP host_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'host') DCNL DCSP  DCSP if (host_ret is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not host_ret.ManagedObjectReference): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP host_mor = host_ret.ManagedObjectReference[0] DCNL DCSP return host_mor
def get_datastore_ref_and_name(session, cluster=None, host=None): DCNL  DCSP if ((cluster is None) and (host is None)): DCNL DCSP  DCSP data_stores = session._call_method(vim_util, 'get_objects', 'Datastore', ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP else: DCNL DCSP  DCSP if (cluster is not None): DCNL DCSP  DCSP  DCSP datastore_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'datastore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP datastore_ret = session._call_method(vim_util, 'get_dynamic_property', host, 'HostSystem', 'datastore') DCNL DCSP  DCSP if (datastore_ret is None): DCNL DCSP  DCSP  DCSP raise exception.DatastoreNotFound() DCNL DCSP  DCSP data_store_mors = datastore_ret.ManagedObjectReference DCNL DCSP  DCSP data_stores = session._call_method(vim_util, 'get_properties_for_a_collection_of_objects', 'Datastore', data_store_mors, ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP for elem in data_stores: DCNL DCSP  DCSP ds_name = None DCNL DCSP  DCSP ds_type = None DCNL DCSP  DCSP ds_cap = None DCNL DCSP  DCSP ds_free = None DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'summary.type'): DCNL DCSP  DCSP  DCSP  DCSP ds_type = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.name'): DCNL DCSP  DCSP  DCSP  DCSP ds_name = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.capacity'): DCNL DCSP  DCSP  DCSP  DCSP ds_cap = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.freeSpace'): DCNL DCSP  DCSP  DCSP  DCSP ds_free = prop.val DCNL DCSP  DCSP if ((ds_type == 'VMFS') or (ds_type == 'NFS')): DCNL DCSP  DCSP  DCSP data_store_name = ds_name DCNL DCSP  DCSP  DCSP return (elem.obj, data_store_name, ds_cap, ds_free) DCNL DCSP if (data_store_name is None): DCNL DCSP  DCSP raise exception.DatastoreNotFound()
def get_network_with_the_name(session, network_name='vmnet0', cluster=None): DCNL  DCSP host = vm_util.get_host_ref(session, cluster) DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP vm_networks_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'network') DCNL DCSP else: DCNL DCSP  DCSP vm_networks_ret = session._call_method(vim_util, 'get_dynamic_property', host, 'HostSystem', 'network') DCNL DCSP if (not vm_networks_ret): DCNL DCSP  DCSP return None DCNL DCSP vm_networks = vm_networks_ret.ManagedObjectReference DCNL DCSP networks = session._call_method(vim_util, 'get_properties_for_a_collection_of_objects', 'Network', vm_networks, ['summary.name']) DCNL DCSP network_obj = {} DCNL DCSP LOG.warn(vm_networks) DCNL DCSP for network in vm_networks: DCNL DCSP  DCSP if (network._type == 'DistributedVirtualPortgroup'): DCNL DCSP  DCSP  DCSP props = session._call_method(vim_util, 'get_dynamic_property', network, 'DistributedVirtualPortgroup', 'config') DCNL DCSP  DCSP  DCSP if (props.name == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'DistributedVirtualPortgroup' DCNL DCSP  DCSP  DCSP  DCSP network_obj['dvpg'] = props.key DCNL DCSP  DCSP  DCSP  DCSP dvs_props = session._call_method(vim_util, 'get_dynamic_property', props.distributedVirtualSwitch, 'VmwareDistributedVirtualSwitch', 'uuid') DCNL DCSP  DCSP  DCSP  DCSP network_obj['dvsw'] = dvs_props DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP props = session._call_method(vim_util, 'get_dynamic_property', network, 'Network', 'summary.name') DCNL DCSP  DCSP  DCSP if (props == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'Network' DCNL DCSP  DCSP  DCSP  DCSP network_obj['name'] = network_name DCNL DCSP if (len(network_obj) > 0): DCNL DCSP  DCSP return network_obj DCNL DCSP else: DCNL DCSP  DCSP return None
def get_vswitch_for_vlan_interface(session, vlan_interface, cluster=None): DCNL  DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP vswitches_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.vswitch') DCNL DCSP if (not vswitches_ret): DCNL DCSP  DCSP return DCNL DCSP vswitches = vswitches_ret.HostVirtualSwitch DCNL DCSP for elem in vswitches: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for nic_elem in elem.pnic: DCNL DCSP  DCSP  DCSP  DCSP if (str(nic_elem).split('-')[(-1)].find(vlan_interface) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return elem.name DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass
def check_if_vlan_interface_exists(session, vlan_interface, cluster=None): DCNL  DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP physical_nics_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.pnic') DCNL DCSP if (not physical_nics_ret): DCNL DCSP  DCSP return False DCNL DCSP physical_nics = physical_nics_ret.PhysicalNic DCNL DCSP for pnic in physical_nics: DCNL DCSP  DCSP if (vlan_interface == pnic.device): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def get_vlanid_and_vswitch_for_portgroup(session, pg_name, cluster=None): DCNL  DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP port_grps_on_host_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.portgroup') DCNL DCSP if (not port_grps_on_host_ret): DCNL DCSP  DCSP msg = _('ESX DCSP SOAP DCSP server DCSP returned DCSP an DCSP empty DCSP port DCSP group DCSP for DCSP the DCSP host DCSP system DCSP in DCSP its DCSP response') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP port_grps_on_host = port_grps_on_host_ret.HostPortGroup DCNL DCSP for p_gp in port_grps_on_host: DCNL DCSP  DCSP if (p_gp.spec.name == pg_name): DCNL DCSP  DCSP  DCSP p_grp_vswitch_name = p_gp.vswitch.split('-')[(-1)] DCNL DCSP  DCSP  DCSP return (p_gp.spec.vlanId, p_grp_vswitch_name)
def create_port_group(session, pg_name, vswitch_name, vlan_id=0, cluster=None): DCNL  DCSP client_factory = session._get_vim().client.factory DCNL DCSP add_prt_grp_spec = vm_util.get_add_vswitch_port_group_spec(client_factory, vswitch_name, pg_name, vlan_id) DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP network_system_mor = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'configManager.networkSystem') DCNL DCSP LOG.debug((_('Creating DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name)) DCNL DCSP try: DCNL DCSP  DCSP session._call_method(session._get_vim(), 'AddPortGroup', network_system_mor, portgrp=add_prt_grp_spec) DCNL DCSP except error_util.VimFaultException as exc: DCNL DCSP  DCSP if (error_util.FAULT_ALREADY_EXISTS not in exc.fault_list): DCNL DCSP  DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP LOG.debug((_('Created DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name))
def set_nodes(nodes): DCNL  DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = nodes
def restore_nodes(): DCNL  DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = ['fake-mini']
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def register_storage_use(storage_path, hostname): DCNL  DCSP d = {} DCNL DCSP id_path = os.path.join(storage_path, 'compute_nodes') DCNL DCSP if os.path.exists(id_path): DCNL DCSP  DCSP with open(id_path) as f: DCNL DCSP  DCSP  DCSP d = json.loads(f.read()) DCNL DCSP d[hostname] = time.time() DCNL DCSP with open(id_path, 'w') as f: DCNL DCSP  DCSP f.write(json.dumps(d))
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def get_storage_users(storage_path): DCNL  DCSP d = {} DCNL DCSP id_path = os.path.join(storage_path, 'compute_nodes') DCNL DCSP if os.path.exists(id_path): DCNL DCSP  DCSP with open(id_path) as f: DCNL DCSP  DCSP  DCSP d = json.loads(f.read()) DCNL DCSP recent_users = [] DCNL DCSP for node in d: DCNL DCSP  DCSP if ((time.time() - d[node]) < TWENTY_FOUR_HOURS): DCNL DCSP  DCSP  DCSP recent_users.append(node) DCNL DCSP return recent_users
def create_vm(session, instance, name_label, kernel, ramdisk, use_pv_kernel=False): DCNL  DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP mem = str(((long(instance_type['memory_mb']) * 1024) * 1024)) DCNL DCSP vcpus = str(instance_type['vcpus']) DCNL DCSP rec = {'actions_after_crash': 'destroy', 'actions_after_reboot': 'restart', 'actions_after_shutdown': 'destroy', 'affinity': '', 'blocked_operations': {}, 'ha_always_run': False, 'ha_restart_priority': '', 'HVM_boot_params': {}, 'HVM_boot_policy': '', 'is_a_template': False, 'memory_dynamic_min': mem, 'memory_dynamic_max': mem, 'memory_static_min': '0', 'memory_static_max': mem, 'memory_target': mem, 'name_description': '', 'name_label': name_label, 'other_config': {'nova_uuid': str(instance['uuid'])}, 'PCI_bus': '', 'platform': {'acpi': 'true', 'apic': 'true', 'pae': 'true', 'viridian': 'true', 'timeoffset': '0'}, 'PV_args': '', 'PV_bootloader': '', 'PV_bootloader_args': '', 'PV_kernel': '', 'PV_legacy_args': '', 'PV_ramdisk': '', 'recommendations': '', 'tags': [], 'user_version': '0', 'VCPUs_at_startup': vcpus, 'VCPUs_max': vcpus, 'VCPUs_params': {}, 'xenstore_data': {'allowvssprovider': 'false'}} DCNL DCSP if use_pv_kernel: DCNL DCSP  DCSP rec['platform']['nx'] = 'false' DCNL DCSP  DCSP if instance['kernel_id']: DCNL DCSP  DCSP  DCSP rec['PV_args'] = 'root=/dev/xvda1' DCNL DCSP  DCSP  DCSP rec['PV_kernel'] = kernel DCNL DCSP  DCSP  DCSP rec['PV_ramdisk'] = ramdisk DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rec['PV_bootloader'] = 'pygrub' DCNL DCSP else: DCNL DCSP  DCSP rec['platform']['nx'] = 'true' DCNL DCSP  DCSP rec['HVM_boot_params'] = {'order': 'dc'} DCNL DCSP  DCSP rec['HVM_boot_policy'] = 'BIOS DCSP order' DCNL DCSP vm_ref = session.call_xenapi('VM.create', rec) DCNL DCSP LOG.debug(_('Created DCSP VM'), instance=instance) DCNL DCSP return vm_ref
def destroy_vm(session, instance, vm_ref): DCNL  DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.destroy', vm_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP return DCNL DCSP LOG.debug(_('VM DCSP destroyed'), instance=instance)
def find_vbd_by_number(session, vm_ref, number): DCNL  DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP if vbd_refs: DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (vbd_rec['userdevice'] == str(number)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return vbd_ref DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP raise volume_utils.StorageError((_('VBD DCSP not DCSP found DCSP in DCSP instance DCSP %s') % vm_ref))
def unplug_vbd(session, vbd_ref): DCNL  DCSP max_attempts = (CONF.xenapi_num_vbd_unplug_retries + 1) DCNL DCSP for num_attempt in xrange(1, (max_attempts + 1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.call_xenapi('VBD.unplug', vbd_ref) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP err = ((len(exc.details) > 0) and exc.details[0]) DCNL DCSP  DCSP  DCSP if (err == 'DEVICE_ALREADY_DETACHED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %s DCSP already DCSP detached'), vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif (err == 'DEVICE_DETACH_REJECTED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %(vbd_ref)s DCSP detach DCSP rejected, DCSP attempt DCSP %(num_attempt)d/%(max_attempts)d'), locals()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP  DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP unplug DCSP VBD DCSP %s') % vbd_ref)) DCNL DCSP  DCSP greenthread.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Reached DCSP maximum DCSP number DCSP of DCSP retries DCSP trying DCSP to DCSP unplug DCSP VBD DCSP %s') % vbd_ref))
def destroy_vbd(session, vbd_ref): DCNL  DCSP try: DCNL DCSP  DCSP session.call_xenapi('VBD.destroy', vbd_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP destroy DCSP VBD DCSP %s') % vbd_ref))
def create_vbd(session, vm_ref, vdi_ref, userdevice, vbd_type='disk', read_only=False, bootable=False, osvol=False): DCNL  DCSP vbd_rec = {} DCNL DCSP vbd_rec['VM'] = vm_ref DCNL DCSP vbd_rec['VDI'] = vdi_ref DCNL DCSP vbd_rec['userdevice'] = str(userdevice) DCNL DCSP vbd_rec['bootable'] = bootable DCNL DCSP vbd_rec['mode'] = ((read_only and 'RO') or 'RW') DCNL DCSP vbd_rec['type'] = vbd_type DCNL DCSP vbd_rec['unpluggable'] = True DCNL DCSP vbd_rec['empty'] = False DCNL DCSP vbd_rec['other_config'] = {} DCNL DCSP vbd_rec['qos_algorithm_type'] = '' DCNL DCSP vbd_rec['qos_algorithm_params'] = {} DCNL DCSP vbd_rec['qos_supported_algorithms'] = [] DCNL DCSP LOG.debug(_('Creating DCSP %(vbd_type)s-type DCSP VBD DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vdi_ref)s DCSP ... DCSP '), locals()) DCNL DCSP vbd_ref = session.call_xenapi('VBD.create', vbd_rec) DCNL DCSP LOG.debug(_('Created DCSP VBD DCSP %(vbd_ref)s DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vdi_ref)s.'), locals()) DCNL DCSP if osvol: DCNL DCSP  DCSP session.call_xenapi('VBD.add_to_other_config', vbd_ref, 'osvol', 'True') DCNL DCSP return vbd_ref
def safe_destroy_vdis(session, vdi_refs): DCNL  DCSP for vdi_ref in vdi_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP except volume_utils.StorageError as exc: DCNL DCSP  DCSP  DCSP LOG.error(exc)
def create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size, read_only=False): DCNL  DCSP otherconf = {'nova_disk_type': disk_type} DCNL DCSP if instance: DCNL DCSP  DCSP otherconf['nova_instance_uuid'] = instance['uuid'] DCNL DCSP vdi_ref = session.call_xenapi('VDI.create', {'name_label': name_label, 'name_description': disk_type, 'SR': sr_ref, 'virtual_size': str(virtual_size), 'type': 'User', 'sharable': False, 'read_only': read_only, 'xenstore_data': {}, 'other_config': otherconf, 'sm_config': {}, 'tags': []}) DCNL DCSP LOG.debug(_('Created DCSP VDI DCSP %(vdi_ref)s DCSP (%(name_label)s, DCSP %(virtual_size)s, DCSP %(read_only)s) DCSP on DCSP %(sr_ref)s.'), locals()) DCNL DCSP return vdi_ref
@contextlib.contextmanager DCNL def _dummy_vm(session, instance, vdi_ref): DCNL  DCSP name_label = 'dummy' DCNL DCSP vm_ref = create_vm(session, instance, name_label, None, None) DCNL DCSP try: DCNL DCSP  DCSP vbd_ref = create_vbd(session, vm_ref, vdi_ref, 'autodetect', read_only=True) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield vm_ref) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP destroy_vbd(session, vbd_ref) DCNL DCSP  DCSP  DCSP except volume_utils.StorageError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP destroy_vm(session, instance, vm_ref)
def _safe_copy_vdi(session, sr_ref, instance, vdi_to_copy_ref): DCNL  DCSP with _dummy_vm(session, instance, vdi_to_copy_ref) as vm_ref: DCNL DCSP  DCSP label = 'snapshot' DCNL DCSP  DCSP with snapshot_attached_here(session, instance, vm_ref, label) as vdi_uuids: DCNL DCSP  DCSP  DCSP imported_vhds = session.call_plugin_serialized('workarounds', 'safe_copy_vdis', sr_path=get_sr_path(session), vdi_uuids=vdi_uuids, uuid_stack=_make_uuid_stack()) DCNL DCSP root_uuid = imported_vhds['root']['uuid'] DCNL DCSP scan_default_sr(session) DCNL DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', root_uuid) DCNL DCSP return vdi_ref
def _clone_vdi(session, vdi_to_clone_ref): DCNL  DCSP vdi_ref = session.call_xenapi('VDI.clone', vdi_to_clone_ref) DCNL DCSP LOG.debug((_('Cloned DCSP VDI DCSP %(vdi_ref)s DCSP from DCSP VDI DCSP %(vdi_to_clone_ref)s') % locals())) DCNL DCSP return vdi_ref
def get_vdi_for_vm_safely(session, vm_ref): DCNL  DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP for vbd in vbd_refs: DCNL DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd) DCNL DCSP  DCSP if (vbd_rec['userdevice'] == '0'): DCNL DCSP  DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vbd_rec['VDI']) DCNL DCSP  DCSP  DCSP return (vbd_rec['VDI'], vdi_rec) DCNL DCSP raise exception.NovaException((_('No DCSP primary DCSP VDI DCSP found DCSP for DCSP %(vm_ref)s') % locals()))
def get_sr_path(session): DCNL  DCSP sr_ref = safe_find_sr(session) DCNL DCSP sr_rec = session.call_xenapi('SR.get_record', sr_ref) DCNL DCSP sr_uuid = sr_rec['uuid'] DCNL DCSP return os.path.join(CONF.xenapi_sr_base_path, sr_uuid)
def destroy_cached_images(session, sr_ref, all_cached=False, dry_run=False): DCNL  DCSP cached_images = _find_cached_images(session, sr_ref) DCNL DCSP destroyed = set() DCNL DCSP def destroy_cached_vdi(vdi_uuid, vdi_ref): DCNL DCSP  DCSP LOG.debug(_("Destroying DCSP cached DCSP VDI DCSP '%(vdi_uuid)s'")) DCNL DCSP  DCSP if (not dry_run): DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP destroyed.add(vdi_uuid) DCNL DCSP for vdi_ref in cached_images.values(): DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_uuid', vdi_ref) DCNL DCSP  DCSP if all_cached: DCNL DCSP  DCSP  DCSP destroy_cached_vdi(vdi_uuid, vdi_ref) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chain = list(_walk_vdi_chain(session, vdi_uuid)) DCNL DCSP  DCSP if (len(chain) > 2): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (len(chain) == 2): DCNL DCSP  DCSP  DCSP root_vdi_rec = chain[(-1)] DCNL DCSP  DCSP  DCSP children = _child_vhds(session, sr_ref, root_vdi_rec['uuid']) DCNL DCSP  DCSP  DCSP if (len(children) > 1): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP destroy_cached_vdi(vdi_uuid, vdi_ref) DCNL DCSP return destroyed
def _find_cached_images(session, sr_ref): DCNL  DCSP cached_images = {} DCNL DCSP for (vdi_ref, vdi_rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_id = vdi_rec['other_config']['image-id'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP cached_images[image_id] = vdi_ref DCNL DCSP return cached_images
def _find_cached_image(session, image_id, sr_ref): DCNL  DCSP cached_images = _find_cached_images(session, sr_ref) DCNL DCSP return cached_images.get(image_id)
def auto_configure_disk(session, vdi_ref, new_gb): DCNL  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP partitions = _get_partitions(dev) DCNL DCSP  DCSP if (len(partitions) != 1): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (_num, start, old_sectors, ptype) = partitions[0] DCNL DCSP  DCSP if (ptype in ('ext3', 'ext4')): DCNL DCSP  DCSP  DCSP new_sectors = ((((new_gb * 1024) * 1024) * 1024) / SECTOR_SIZE) DCNL DCSP  DCSP  DCSP _resize_part_and_fs(dev, start, old_sectors, new_sectors)
def _generate_disk(session, instance, vm_ref, userdevice, name_label, disk_type, size_mb, fs_type): DCNL  DCSP sr_ref = safe_find_sr(session) DCNL DCSP ONE_MEG = (1024 * 1024) DCNL DCSP virtual_size = (size_mb * ONE_MEG) DCNL DCSP vdi_ref = create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size) DCNL DCSP try: DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mklabel', 'msdos', run_as_root=True) DCNL DCSP  DCSP  DCSP partition_start = 0 DCNL DCSP  DCSP  DCSP partition_end = size_mb DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mkpart', 'primary', str(partition_start), str(partition_end), run_as_root=True) DCNL DCSP  DCSP  DCSP partition_path = utils.make_dev_path(dev, partition=1) DCNL DCSP  DCSP  DCSP if (fs_type == 'linux-swap'): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkswap', partition_path, run_as_root=True) DCNL DCSP  DCSP  DCSP elif (fs_type is not None): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkfs', '-t', fs_type, partition_path, run_as_root=True) DCNL DCSP  DCSP create_vbd(session, vm_ref, vdi_ref, userdevice, bootable=False) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref)
def create_kernel_image(context, session, instance, name_label, image_id, image_type): DCNL  DCSP filename = '' DCNL DCSP if CONF.cache_images: DCNL DCSP  DCSP args = {} DCNL DCSP  DCSP args['cached-image'] = image_id DCNL DCSP  DCSP args['new-image-uuid'] = str(uuid.uuid4()) DCNL DCSP  DCSP filename = session.call_plugin('kernel', 'create_kernel_ramdisk', args) DCNL DCSP if (filename == ''): DCNL DCSP  DCSP return _fetch_disk_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP else: DCNL DCSP  DCSP vdi_type = ImageType.to_string(image_type) DCNL DCSP  DCSP return {vdi_type: dict(uuid=None, file=filename)}
def _create_image(context, session, instance, name_label, image_id, image_type): DCNL  DCSP cache_images = CONF.cache_images.lower() DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'all'): DCNL DCSP  DCSP cache = True DCNL DCSP elif (cache_images == 'some'): DCNL DCSP  DCSP sys_meta = utils.metadata_to_dict(instance['system_metadata']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cache = utils.bool_from_str(sys_meta['image_cache_in_nova']) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'none'): DCNL DCSP  DCSP cache = False DCNL DCSP else: DCNL DCSP  DCSP LOG.warning(_("Unrecognized DCSP cache_images DCSP value DCSP '%s', DCSP defaulting DCSP to DCSP True"), CONF.cache_images) DCNL DCSP  DCSP cache = True DCNL DCSP if cache: DCNL DCSP  DCSP vdis = _create_cached_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP else: DCNL DCSP  DCSP vdis = _fetch_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP for (vdi_type, vdi) in vdis.iteritems(): DCNL DCSP  DCSP set_vdi_name(session, vdi['uuid'], name_label, vdi_type) DCNL DCSP return vdis
def _fetch_image(context, session, instance, name_label, image_id, image_type): DCNL  DCSP if (image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP vdis = _fetch_vhd_image(context, session, instance, image_id) DCNL DCSP else: DCNL DCSP  DCSP vdis = _fetch_disk_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP for (vdi_type, vdi) in vdis.iteritems(): DCNL DCSP  DCSP vdi_uuid = vdi['uuid'] DCNL DCSP  DCSP LOG.debug(_("Fetched DCSP VDIs DCSP of DCSP type DCSP '%(vdi_type)s' DCSP with DCSP UUID DCSP '%(vdi_uuid)s'"), locals(), instance=instance) DCNL DCSP return vdis
def _fetch_vhd_image(context, session, instance, image_id): DCNL  DCSP LOG.debug(_('Asking DCSP xapi DCSP to DCSP fetch DCSP vhd DCSP image DCSP %(image_id)s'), locals(), instance=instance) DCNL DCSP params = {'image_id': image_id, 'uuid_stack': _make_uuid_stack(), 'sr_path': get_sr_path(session)} DCNL DCSP if _image_uses_bittorrent(context, instance): DCNL DCSP  DCSP plugin_name = 'bittorrent' DCNL DCSP  DCSP callback = None DCNL DCSP  DCSP params['torrent_base_url'] = CONF.xenapi_torrent_base_url DCNL DCSP  DCSP params['torrent_seed_duration'] = CONF.xenapi_torrent_seed_duration DCNL DCSP  DCSP params['torrent_seed_chance'] = CONF.xenapi_torrent_seed_chance DCNL DCSP  DCSP params['torrent_max_last_accessed'] = CONF.xenapi_torrent_max_last_accessed DCNL DCSP  DCSP params['torrent_listen_port_start'] = CONF.xenapi_torrent_listen_port_start DCNL DCSP  DCSP params['torrent_listen_port_end'] = CONF.xenapi_torrent_listen_port_end DCNL DCSP  DCSP params['torrent_download_stall_cutoff'] = CONF.xenapi_torrent_download_stall_cutoff DCNL DCSP  DCSP params['torrent_max_seeder_processes_per_host'] = CONF.xenapi_torrent_max_seeder_processes_per_host DCNL DCSP else: DCNL DCSP  DCSP plugin_name = 'glance' DCNL DCSP  DCSP glance_api_servers = glance.get_api_servers() DCNL DCSP  DCSP def pick_glance(params): DCNL DCSP  DCSP  DCSP (g_host, g_port, g_use_ssl) = glance_api_servers.next() DCNL DCSP  DCSP  DCSP params['glance_host'] = g_host DCNL DCSP  DCSP  DCSP params['glance_port'] = g_port DCNL DCSP  DCSP  DCSP params['glance_use_ssl'] = g_use_ssl DCNL DCSP  DCSP  DCSP params['auth_token'] = getattr(context, 'auth_token', None) DCNL DCSP  DCSP callback = pick_glance DCNL DCSP vdis = _fetch_using_dom0_plugin_with_retry(context, session, image_id, plugin_name, params, callback=callback) DCNL DCSP sr_ref = safe_find_sr(session) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP root_vdi_uuid = vdis['root']['uuid'] DCNL DCSP set_vdi_name(session, root_vdi_uuid, instance['name'], 'root') DCNL DCSP _check_vdi_size(context, session, instance, root_vdi_uuid) DCNL DCSP return vdis
def _get_vdi_chain_size(session, vdi_uuid): DCNL  DCSP size_bytes = 0 DCNL DCSP for vdi_rec in _walk_vdi_chain(session, vdi_uuid): DCNL DCSP  DCSP cur_vdi_uuid = vdi_rec['uuid'] DCNL DCSP  DCSP vdi_size_bytes = int(vdi_rec['physical_utilisation']) DCNL DCSP  DCSP LOG.debug(_('vdi_uuid=%(cur_vdi_uuid)s DCSP vdi_size_bytes=%(vdi_size_bytes)d'), locals()) DCNL DCSP  DCSP size_bytes += vdi_size_bytes DCNL DCSP return size_bytes
def _fetch_disk_image(context, session, instance, name_label, image_id, image_type): DCNL  DCSP image_type_str = ImageType.to_string(image_type) DCNL DCSP LOG.debug(_('Fetching DCSP image DCSP %(image_id)s, DCSP type DCSP %(image_type_str)s'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP sr_ref = _safe_find_iso_sr(session) DCNL DCSP else: DCNL DCSP  DCSP sr_ref = safe_find_sr(session) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image_id) DCNL DCSP meta = image_service.show(context, image_id) DCNL DCSP virtual_size = int(meta['size']) DCNL DCSP vdi_size = virtual_size DCNL DCSP LOG.debug(_('Size DCSP for DCSP image DCSP %(image_id)s: DCSP %(virtual_size)d'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK): DCNL DCSP  DCSP vdi_size += MBR_SIZE_BYTES DCNL DCSP elif ((image_type in (ImageType.KERNEL, ImageType.RAMDISK)) and (vdi_size > CONF.max_kernel_ramdisk_size)): DCNL DCSP  DCSP max_size = CONF.max_kernel_ramdisk_size DCNL DCSP  DCSP raise exception.NovaException((_('Kernel/Ramdisk DCSP image DCSP is DCSP too DCSP large: DCSP %(vdi_size)d DCSP bytes, DCSP max DCSP %(max_size)d DCSP bytes') % locals())) DCNL DCSP vdi_ref = create_vdi(session, sr_ref, instance, name_label, image_type_str, vdi_size) DCNL DCSP try: DCNL DCSP  DCSP filename = None DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_uuid', vdi_ref) DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP  DCSP stream_func = (lambda f: image_service.download(context, image_id, f)) DCNL DCSP  DCSP  DCSP _stream_disk(stream_func, image_type, virtual_size, dev) DCNL DCSP  DCSP if (image_type in (ImageType.KERNEL, ImageType.RAMDISK)): DCNL DCSP  DCSP  DCSP LOG.debug(_('Copying DCSP VDI DCSP %s DCSP to DCSP /boot/guest DCSP on DCSP dom0'), vdi_ref, instance=instance) DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP  DCSP args['vdi-ref'] = vdi_ref DCNL DCSP  DCSP  DCSP args['image-size'] = str(vdi_size) DCNL DCSP  DCSP  DCSP if CONF.cache_images: DCNL DCSP  DCSP  DCSP  DCSP args['cached-image'] = image_id DCNL DCSP  DCSP  DCSP filename = session.call_plugin('kernel', 'copy_vdi', args) DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP  DCSP LOG.debug(_('Kernel/Ramdisk DCSP VDI DCSP %s DCSP destroyed'), vdi_ref, instance=instance) DCNL DCSP  DCSP  DCSP vdi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vdi_role: dict(uuid=None, file=filename)} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vdi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vdi_role: dict(uuid=vdi_uuid, file=None)} DCNL DCSP except (session.XenAPI.Failure, IOError, OSError) as e: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP fetch DCSP glance DCSP image'), instance=instance) DCNL DCSP  DCSP e.args = (e.args + ([dict(type=ImageType.to_string(image_type), uuid=vdi_uuid, file=filename)],)) DCNL DCSP  DCSP raise
def determine_disk_image_type(image_meta): DCNL  DCSP if (not image_meta): DCNL DCSP  DCSP return None DCNL DCSP disk_format = image_meta['disk_format'] DCNL DCSP disk_format_map = {'ami': 'DISK', 'aki': 'KERNEL', 'ari': 'RAMDISK', 'raw': 'DISK_RAW', 'vhd': 'DISK_VHD', 'iso': 'DISK_ISO'} DCNL DCSP try: DCNL DCSP  DCSP image_type_str = disk_format_map[disk_format] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise exception.InvalidDiskFormat(disk_format=disk_format) DCNL DCSP image_type = getattr(ImageType, image_type_str) DCNL DCSP image_ref = image_meta['id'] DCNL DCSP msg = _('Detected DCSP %(image_type_str)s DCSP format DCSP for DCSP image DCSP %(image_ref)s') DCNL DCSP LOG.debug((msg % locals())) DCNL DCSP return image_type
def determine_is_pv(session, vdi_ref, disk_image_type, os_type): DCNL  DCSP LOG.debug(_('Looking DCSP up DCSP vdi DCSP %s DCSP for DCSP PV DCSP kernel'), vdi_ref) DCNL DCSP if (disk_image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP if (os_type == 'windows'): DCNL DCSP  DCSP  DCSP is_pv = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP is_pv = True DCNL DCSP elif (disk_image_type == ImageType.DISK_RAW): DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=True) as dev: DCNL DCSP  DCSP  DCSP is_pv = _is_vdi_pv(dev) DCNL DCSP elif (disk_image_type == ImageType.DISK): DCNL DCSP  DCSP is_pv = True DCNL DCSP elif (disk_image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP is_pv = False DCNL DCSP elif (not disk_image_type): DCNL DCSP  DCSP LOG.warning((_('Image DCSP format DCSP is DCSP None: DCSP trying DCSP to DCSP determine DCSP PV DCSP status DCSP using DCSP pygrub; DCSP if DCSP instance DCSP with DCSP vdi DCSP %s DCSP does DCSP not DCSP boot DCSP correctly, DCSP try DCSP with DCSP image DCSP metadata.') % vdi_ref)) DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=True) as dev: DCNL DCSP  DCSP  DCSP is_pv = _is_vdi_pv(dev) DCNL DCSP else: DCNL DCSP  DCSP msg = (_('Unknown DCSP image DCSP format DCSP %(disk_image_type)s') % locals()) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP return is_pv
def lookup_vm_vdis(session, vm_ref): DCNL  DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP vdi_refs = [] DCNL DCSP if vbd_refs: DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP record = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('VDI DCSP %s DCSP is DCSP still DCSP available'), record['uuid']) DCNL DCSP  DCSP  DCSP  DCSP vbd_other_config = session.call_xenapi('VBD.get_other_config', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (not vbd_other_config.get('osvol')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vdi_refs.append(vdi_ref) DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP return vdi_refs
def lookup(session, name_label): DCNL  DCSP vm_refs = session.call_xenapi('VM.get_by_name_label', name_label) DCNL DCSP n = len(vm_refs) DCNL DCSP if (n == 0): DCNL DCSP  DCSP return None DCNL DCSP elif (n > 1): DCNL DCSP  DCSP raise exception.InstanceExists(name=name_label) DCNL DCSP else: DCNL DCSP  DCSP return vm_refs[0]
def preconfigure_instance(session, instance, vdi_ref, network_info): DCNL  DCSP mount_required = False DCNL DCSP (key, net, metadata) = _prepare_injectables(instance, network_info) DCNL DCSP mount_required = (key or net or metadata) DCNL DCSP if (not mount_required): DCNL DCSP  DCSP return DCNL DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP _mounted_processing(dev, key, net, metadata)
def compile_info(record): DCNL  DCSP return {'state': XENAPI_POWER_STATE[record['power_state']], 'max_mem': (long(record['memory_static_max']) >> 10), 'mem': (long(record['memory_dynamic_max']) >> 10), 'num_cpu': record['VCPUs_max'], 'cpu_time': 0}
def compile_diagnostics(record): DCNL  DCSP try: DCNL DCSP  DCSP keys = [] DCNL DCSP  DCSP diags = {} DCNL DCSP  DCSP vm_uuid = record['uuid'] DCNL DCSP  DCSP xml = _get_rrd(_get_rrd_server(), vm_uuid) DCNL DCSP  DCSP if xml: DCNL DCSP  DCSP  DCSP rrd = minidom.parseString(xml) DCNL DCSP  DCSP  DCSP for (i, node) in enumerate(rrd.firstChild.childNodes): DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'lastupdate'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP diags['last_update'] = node.firstChild.data DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'ds'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ref = node.childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(ref) > 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keys.append(ref[0].firstChild.data) DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'rra'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = node.childNodes[4].childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_row = rows[(rows.length - 1)].childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (j, value) in enumerate(last_row): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP diags[keys[j]] = value.firstChild.data DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return diags DCNL DCSP except expat.ExpatError as e: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP parse DCSP rrd DCSP of DCSP %(vm_uuid)s') % locals())) DCNL DCSP  DCSP return {'Unable DCSP to DCSP retrieve DCSP diagnostics': e}
def compile_metrics(start_time, stop_time=None): DCNL  DCSP start_time = int(start_time) DCNL DCSP xml = _get_rrd_updates(_get_rrd_server(), start_time) DCNL DCSP if xml: DCNL DCSP  DCSP doc = minidom.parseString(xml) DCNL DCSP  DCSP return _parse_rrd_update(doc, start_time, stop_time) DCNL DCSP raise exception.CouldNotFetchMetrics()
def _scan_sr(session, sr_ref=None): DCNL  DCSP if sr_ref: DCNL DCSP  DCSP LOG.debug(_('Re-scanning DCSP SR DCSP %s'), sr_ref) DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref)
def scan_default_sr(session): DCNL  DCSP _scan_sr(session, _find_sr(session))
def safe_find_sr(session): DCNL  DCSP sr_ref = _find_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.StorageRepositoryNotFound() DCNL DCSP return sr_ref
def _find_sr(session): DCNL  DCSP host = session.get_xenapi_host() DCNL DCSP try: DCNL DCSP  DCSP tokens = CONF.sr_matching_filter.split(':') DCNL DCSP  DCSP filter_criteria = tokens[0] DCNL DCSP  DCSP filter_pattern = tokens[1] DCNL DCSP except IndexError: DCNL DCSP  DCSP LOG.warning(_("Flag DCSP sr_matching_filter DCSP '%s' DCSP does DCSP not DCSP respect DCSP formatting DCSP convention"), CONF.sr_matching_filter) DCNL DCSP  DCSP return None DCNL DCSP if (filter_criteria == 'other-config'): DCNL DCSP  DCSP (key, value) = filter_pattern.split('=', 1) DCNL DCSP  DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP  DCSP if (not ((key in sr_rec['other_config']) and (sr_rec['other_config'][key] == value))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for pbd_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP  DCSP pbd_rec = session.get_rec('PBD', pbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (pbd_rec and (pbd_rec['host'] == host)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP elif ((filter_criteria == 'default-sr') and (filter_pattern == 'true')): DCNL DCSP  DCSP pool_ref = session.call_xenapi('pool.get_all')[0] DCNL DCSP  DCSP return session.call_xenapi('pool.get_default_SR', pool_ref) DCNL DCSP LOG.warning(_("XenAPI DCSP is DCSP unable DCSP to DCSP find DCSP a DCSP Storage DCSP Repository DCSP to DCSP install DCSP guest DCSP instances DCSP on. DCSP Please DCSP check DCSP your DCSP configuration DCSP and/or DCSP configure DCSP the DCSP flag DCSP 'sr_matching_filter'")) DCNL DCSP return None
def _safe_find_iso_sr(session): DCNL  DCSP sr_ref = _find_iso_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.NotFound(_('Cannot DCSP find DCSP SR DCSP of DCSP content-type DCSP ISO')) DCNL DCSP return sr_ref
def _find_iso_sr(session): DCNL  DCSP host = session.get_xenapi_host() DCNL DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP LOG.debug((_('ISO: DCSP looking DCSP at DCSP SR DCSP %(sr_rec)s') % locals())) DCNL DCSP  DCSP if (not (sr_rec['content_type'] == 'iso')): DCNL DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP not DCSP iso DCSP content')) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('i18n-key' not in sr_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.debug(_("ISO: DCSP iso DCSP content_type, DCSP no DCSP 'i18n-key' DCSP key")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not (sr_rec['other_config']['i18n-key'] == 'local-storage-iso')): DCNL DCSP  DCSP  DCSP LOG.debug(_("ISO: DCSP iso DCSP content_type, DCSP i18n-key DCSP value DCSP not DCSP 'local-storage-iso'")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP LOG.debug(_('ISO: DCSP SR DCSP MATCHing DCSP our DCSP criteria')) DCNL DCSP  DCSP for pbd_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP ISO, DCSP looking DCSP to DCSP see DCSP if DCSP it DCSP is DCSP host DCSP local')) DCNL DCSP  DCSP  DCSP pbd_rec = session.get_rec('PBD', pbd_ref) DCNL DCSP  DCSP  DCSP if (not pbd_rec): DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('ISO: DCSP PBD DCSP %(pbd_ref)s DCSP disappeared') % locals())) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pbd_rec_host = pbd_rec['host'] DCNL DCSP  DCSP  DCSP LOG.debug((_('ISO: DCSP PBD DCSP matching, DCSP want DCSP %(pbd_rec)s, DCSP have DCSP %(host)s') % locals())) DCNL DCSP  DCSP  DCSP if (pbd_rec_host == host): DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP SR DCSP with DCSP local DCSP PBD')) DCNL DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
def _get_rrd_server(): DCNL  DCSP xs_url = urlparse.urlparse(CONF.xenapi_connection_url) DCNL DCSP return [xs_url.scheme, xs_url.netloc]
def _get_rrd(server, vm_uuid): DCNL  DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/vm_rrd?uuid=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_password, server[1], vm_uuid))) DCNL DCSP  DCSP return xml.read() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP for DCSP VM DCSP %(vm_uuid)s DCSP with DCSP server DCSP details: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
def _get_rrd_updates(server, start_time): DCNL  DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/rrd_updates?start=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_password, server[1], start_time))) DCNL DCSP  DCSP return xml.read() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP updates DCSP with DCSP server DCSP details: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
def get_instance_vdis_for_sr(session, vm_ref, sr_ref): DCNL  DCSP for vbd_ref in session.call_xenapi('VM.get_VBDs', vm_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP  DCSP if (sr_ref == session.call_xenapi('VDI.get_SR', vdi_ref)): DCNL DCSP  DCSP  DCSP  DCSP (yield vdi_ref) DCNL DCSP  DCSP except session.XenAPI.Failure: DCNL DCSP  DCSP  DCSP continue
def _walk_vdi_chain(session, vdi_uuid): DCNL  DCSP scan_default_sr(session) DCNL DCSP while True: DCNL DCSP  DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP (yield vdi_rec) DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP if (not parent_uuid): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vdi_uuid = parent_uuid
def _child_vhds(session, sr_ref, vdi_uuid): DCNL  DCSP children = set() DCNL DCSP for (ref, rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP rec_uuid = rec['uuid'] DCNL DCSP  DCSP if (rec_uuid == vdi_uuid): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, ref) DCNL DCSP  DCSP if (parent_uuid != vdi_uuid): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP children.add(rec_uuid) DCNL DCSP return children
def _wait_for_vhd_coalesce(session, instance, sr_ref, vdi_ref, original_parent_uuid): DCNL  DCSP def _another_child_vhd(): DCNL DCSP  DCSP if (not original_parent_uuid): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid'] DCNL DCSP  DCSP parent_vdi_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP for (_ref, rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP  DCSP if ((rec['uuid'] != vdi_uuid) and (rec['uuid'] != parent_vdi_uuid) and (rec['sm_config'].get('vhd-parent') == original_parent_uuid)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP if _another_child_vhd(): DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuid', parent_uuid) DCNL DCSP  DCSP base_uuid = _get_vhd_parent_uuid(session, parent_ref) DCNL DCSP  DCSP return (parent_uuid, base_uuid) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP max_attempts = CONF.xenapi_vhd_coalesce_max_attempts DCNL DCSP for i in xrange(max_attempts): DCNL DCSP  DCSP _scan_sr(session, sr_ref) DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP if (original_parent_uuid and (parent_uuid != original_parent_uuid)): DCNL DCSP  DCSP  DCSP LOG.debug(_("Parent DCSP %(parent_uuid)s DCSP doesn't DCSP match DCSP original DCSP parent DCSP %(original_parent_uuid)s, DCSP waiting DCSP for DCSP coalesce..."), locals(), instance=instance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuid', parent_uuid) DCNL DCSP  DCSP  DCSP base_uuid = _get_vhd_parent_uuid(session, parent_ref) DCNL DCSP  DCSP  DCSP return (parent_uuid, base_uuid) DCNL DCSP  DCSP greenthread.sleep(CONF.xenapi_vhd_coalesce_poll_interval) DCNL DCSP msg = (_('VHD DCSP coalesce DCSP attempts DCSP exceeded DCSP (%(max_attempts)d), DCSP giving DCSP up...') % locals()) DCNL DCSP raise exception.NovaException(msg)
def _remap_vbd_dev(dev): DCNL  DCSP should_remap = CONF.xenapi_remap_vbd_dev DCNL DCSP if (not should_remap): DCNL DCSP  DCSP return dev DCNL DCSP old_prefix = 'xvd' DCNL DCSP new_prefix = CONF.xenapi_remap_vbd_dev_prefix DCNL DCSP remapped_dev = dev.replace(old_prefix, new_prefix) DCNL DCSP return remapped_dev
def _wait_for_device(dev): DCNL  DCSP for i in xrange(0, CONF.block_device_creation_timeout): DCNL DCSP  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP  DCSP if os.path.exists(dev_path): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP time.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Timeout DCSP waiting DCSP for DCSP device DCSP %s DCSP to DCSP be DCSP created') % dev))
def cleanup_attached_vdis(session): DCNL  DCSP this_vm_ref = _get_this_vm_ref(session) DCNL DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', this_vm_ref) DCNL DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vbd_rec['VDI']) DCNL DCSP  DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('nova_instance_uuid' in vdi_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.info(_('Disconnecting DCSP stale DCSP VDI DCSP %s DCSP from DCSP compute DCSP domU'), vdi_rec['uuid']) DCNL DCSP  DCSP  DCSP unplug_vbd(session, vbd_ref) DCNL DCSP  DCSP  DCSP destroy_vbd(session, vbd_ref)
def _get_partitions(dev): DCNL  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP (out, _err) = utils.execute('parted', '--script', '--machine', dev_path, 'unit DCSP s', 'print', run_as_root=True) DCNL DCSP lines = [line for line in out.split('\n') if line] DCNL DCSP partitions = [] DCNL DCSP LOG.debug(_('Partitions:')) DCNL DCSP for line in lines[2:]: DCNL DCSP  DCSP (num, start, end, size, ptype) = line.split(':')[:5] DCNL DCSP  DCSP start = int(start.rstrip('s')) DCNL DCSP  DCSP end = int(end.rstrip('s')) DCNL DCSP  DCSP size = int(size.rstrip('s')) DCNL DCSP  DCSP LOG.debug((_(' DCSP  DCSP %(num)s: DCSP %(ptype)s DCSP %(size)d DCSP sectors') % locals())) DCNL DCSP  DCSP partitions.append((num, start, size, ptype)) DCNL DCSP return partitions
def _resize_part_and_fs(dev, start, old_sectors, new_sectors): DCNL  DCSP size = (new_sectors - start) DCNL DCSP end = (new_sectors - 1) DCNL DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP partition_path = utils.make_dev_path(dev, partition=1) DCNL DCSP utils.execute('e2fsck', '-f', '-y', partition_path, run_as_root=True, check_exit_code=[0, 1, 2]) DCNL DCSP utils.execute('tune2fs', '-O DCSP ^has_journal', partition_path, run_as_root=True) DCNL DCSP if (new_sectors < old_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, ('%ds' % size), run_as_root=True) DCNL DCSP utils.execute('parted', '--script', dev_path, 'rm', '1', run_as_root=True) DCNL DCSP utils.execute('parted', '--script', dev_path, 'mkpart', 'primary', ('%ds' % start), ('%ds' % end), run_as_root=True) DCNL DCSP if (new_sectors > old_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, run_as_root=True) DCNL DCSP utils.execute('tune2fs', '-j', partition_path, run_as_root=True)
def _sparse_copy(src_path, dst_path, virtual_size, block_size=4096): DCNL  DCSP start_time = time.time() DCNL DCSP EMPTY_BLOCK = ('\x00' * block_size) DCNL DCSP bytes_read = 0 DCNL DCSP skipped_bytes = 0 DCNL DCSP left = virtual_size DCNL DCSP LOG.debug(_('Starting DCSP sparse_copy DCSP src=%(src_path)s DCSP dst=%(dst_path)s DCSP virtual_size=%(virtual_size)d DCSP block_size=%(block_size)d'), locals()) DCNL DCSP with utils.temporary_chown(src_path): DCNL DCSP  DCSP with utils.temporary_chown(dst_path): DCNL DCSP  DCSP  DCSP with open(src_path, 'r') as src: DCNL DCSP  DCSP  DCSP  DCSP with open(dst_path, 'w') as dst: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = src.read(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (data == EMPTY_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dst.seek(block_size, os.SEEK_CUR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_read += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP skipped_bytes += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dst.write(data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data_len = len(data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= data_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_read += data_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (left <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data = src.read(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep(0) DCNL DCSP duration = (time.time() - start_time) DCNL DCSP compression_pct = ((float(skipped_bytes) / bytes_read) * 100) DCNL DCSP LOG.debug(_('Finished DCSP sparse_copy DCSP in DCSP %(duration).2f DCSP secs, DCSP %(compression_pct).2f%% DCSP reduction DCSP in DCSP size'), locals())
def _mount_filesystem(dev_path, dir): DCNL  DCSP try: DCNL DCSP  DCSP (_out, err) = utils.execute('mount', '-t', 'ext2,ext3,ext4,reiserfs', dev_path, dir, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP err = str(e) DCNL DCSP return err
def _mounted_processing(device, key, net, metadata): DCNL  DCSP dev_path = utils.make_dev_path(device, partition=1) DCNL DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP err = _mount_filesystem(dev_path, tmpdir) DCNL DCSP  DCSP if (not err): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not agent.find_guest_agent(tmpdir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vfs = vfsimpl.VFSLocalFS(imgfile=None, imgfmt=None, imgdir=tmpdir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.info(_('Manipulating DCSP interface DCSP files DCSP directly')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk.inject_data_into_fs(vfs, key, net, metadata, None, None) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('umount', dev_path, run_as_root=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info((_('Failed DCSP to DCSP mount DCSP filesystem DCSP (expected DCSP for DCSP non-linux DCSP instances): DCSP %s') % err))
def _prepare_injectables(inst, network_info): DCNL  DCSP from Cheetah import Template as t DCNL DCSP template = t.Template DCNL DCSP template_data = open(CONF.injected_network_template).read() DCNL DCSP metadata = inst['metadata'] DCNL DCSP key = str(inst['key_data']) DCNL DCSP net = None DCNL DCSP if network_info: DCNL DCSP  DCSP ifc_num = (-1) DCNL DCSP  DCSP interfaces_info = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not vif['network'].get_meta('injected')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP dns = [ip['address'] for subnet in vif['network']['subnets'] for ip in subnet['dns']] DCNL DCSP  DCSP  DCSP dns = ' DCSP '.join(dns).strip() DCNL DCSP  DCSP  DCSP interface_info = {'name': ('eth%d' % ifc_num), 'address': '', 'netmask': '', 'gateway': '', 'broadcast': '', 'dns': (dns or ''), 'address_v6': '', 'netmask_v6': '', 'gateway_v6': '', 'use_ipv6': CONF.use_ipv6} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 4)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP subnet_netaddr = subnet.as_netaddr() DCNL DCSP  DCSP  DCSP  DCSP interface_info['address'] = ip['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask'] = subnet_netaddr.netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway'] = subnet['gateway']['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['broadcast'] = subnet_netaddr.broadcast DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 6)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP interface_info['address_v6'] = ip['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask_v6'] = subnet.as_netaddr().netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway_v6'] = subnet['gateway']['address'] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP interfaces_info.append(interface_info) DCNL DCSP  DCSP if interfaces_info: DCNL DCSP  DCSP  DCSP net = str(template(template_data, searchList=[{'interfaces': interfaces_info, 'use_ipv6': CONF.use_ipv6}])) DCNL DCSP return (key, net, metadata)
def ensure_correct_host(session): DCNL  DCSP this_vm_uuid = get_this_vm_uuid() DCNL DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.get_by_uuid', this_vm_uuid) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP if (exc.details[0] != 'UUID_INVALID'): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raise Exception(_('This DCSP domU DCSP must DCSP be DCSP running DCSP on DCSP the DCSP host DCSP specified DCSP by DCSP xenapi_connection_url'))
def move_disks(session, instance, disk_info): DCNL  DCSP imported_vhds = session.call_plugin_serialized('migration', 'move_vhds_into_sr', instance_uuid=instance['uuid'], sr_path=get_sr_path(session), uuid_stack=_make_uuid_stack()) DCNL DCSP scan_default_sr(session) DCNL DCSP root_uuid = imported_vhds['root']['uuid'] DCNL DCSP set_vdi_name(session, root_uuid, instance['name'], 'root') DCNL DCSP root_vdi_ref = session.call_xenapi('VDI.get_by_uuid', root_uuid) DCNL DCSP return {'uuid': root_uuid, 'ref': root_vdi_ref}
def cmp_version(a, b): DCNL  DCSP a = a.split('.') DCNL DCSP b = b.split('.') DCNL DCSP for (va, vb) in zip(a, b): DCNL DCSP  DCSP ret = (int(va) - int(vb)) DCNL DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return (len(a) - len(b))
def make_step_decorator(context, instance, instance_update): DCNL  DCSP step_info = dict(total=0, current=0) DCNL DCSP def bump_progress(): DCNL DCSP  DCSP step_info['current'] += 1 DCNL DCSP  DCSP progress = round(((float(step_info['current']) / step_info['total']) * 100)) DCNL DCSP  DCSP LOG.debug(_('Updating DCSP progress DCSP to DCSP %(progress)d'), locals(), instance=instance) DCNL DCSP  DCSP instance_update(context, instance['uuid'], {'progress': progress}) DCNL DCSP def step_decorator(f): DCNL DCSP  DCSP step_info['total'] += 1 DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP bump_progress() DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return step_decorator
def swap_xapi_host(url, host_addr): DCNL  DCSP temp_url = urlparse.urlparse(url) DCNL DCSP (_netloc, sep, port) = temp_url.netloc.partition(':') DCNL DCSP return url.replace(temp_url.netloc, ('%s%s%s' % (host_addr, sep, port)))
def after_VBD_create(vbd_ref, vbd_rec): DCNL  DCSP vbd_rec['currently_attached'] = False DCNL DCSP vbd_rec['device'] = '' DCNL DCSP vm_ref = vbd_rec['VM'] DCNL DCSP vm_rec = _db_content['VM'][vm_ref] DCNL DCSP vm_rec['VBDs'].append(vbd_ref) DCNL DCSP vdi_ref = vbd_rec['VDI'] DCNL DCSP vdi_rec = _db_content['VDI'][vdi_ref] DCNL DCSP vdi_rec['VBDs'].append(vbd_ref) DCNL DCSP vm_name_label = _db_content['VM'][vm_ref]['name_label'] DCNL DCSP vbd_rec['vm_name_label'] = vm_name_label
def after_VM_create(vm_ref, vm_rec): DCNL  DCSP vm_rec.setdefault('is_control_domain', False) DCNL DCSP vm_rec.setdefault('memory_static_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setdefault('memory_dynamic_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setdefault('VCPUs_max', str(4)) DCNL DCSP vm_rec.setdefault('VBDs', []) DCNL DCSP vm_rec.setdefault('resident_on', '')
def create_local_pifs(): DCNL  DCSP for host_ref in _db_content['host'].keys(): DCNL DCSP  DCSP _create_local_pif(host_ref)
def create_local_srs(): DCNL  DCSP for host_ref in _db_content['host'].keys(): DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage', type='lvm', other_config={'i18n-original-value-name_label': 'Local DCSP storage', 'i18n-key': 'local-storage'}, physical_size=40000, physical_utilisation=20000, virtual_allocation=10000, host_ref=host_ref) DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage DCSP ISO', type='iso', other_config={'i18n-original-value-name_label': 'Local DCSP storage DCSP ISO', 'i18n-key': 'local-storage-iso'}, physical_size=80000, physical_utilisation=40000, virtual_allocation=80000, host_ref=host_ref)
def as_value(s): DCNL  DCSP return ('<value>%s</value>' % saxutils.escape(s))
def as_json(*args, **kwargs): DCNL  DCSP arg = (args or kwargs) DCNL DCSP return jsonutils.dumps(arg)
def _call_agent(session, instance, vm_ref, method, addl_args=None, timeout=None): DCNL  DCSP if (addl_args is None): DCNL DCSP  DCSP addl_args = {} DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = CONF.agent_timeout DCNL DCSP vm_rec = session.call_xenapi('VM.get_record', vm_ref) DCNL DCSP args = {'id': str(uuid.uuid4()), 'dom_id': vm_rec['domid'], 'timeout': str(timeout)} DCNL DCSP args.update(addl_args) DCNL DCSP try: DCNL DCSP  DCSP ret = session.call_plugin('agent', method, args) DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP err_msg = e.details[(-1)].splitlines()[(-1)] DCNL DCSP  DCSP if ('TIMEOUT:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('TIMEOUT: DCSP The DCSP call DCSP to DCSP %(method)s DCSP timed DCSP out. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'timeout', 'message': err_msg} DCNL DCSP  DCSP elif ('NOT DCSP IMPLEMENTED:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('NOT DCSP IMPLEMENTED: DCSP The DCSP call DCSP to DCSP %(method)s DCSP is DCSP not DCSP supported DCSP by DCSP the DCSP agent. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'notimplemented', 'message': err_msg} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error(_('The DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP error: DCSP %(e)s. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'error', 'message': err_msg} DCNL DCSP  DCSP return None DCNL DCSP if isinstance(ret, dict): DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP return jsonutils.loads(ret) DCNL DCSP except TypeError: DCNL DCSP  DCSP LOG.error(_('The DCSP agent DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP invalid DCSP response: DCSP %(ret)r. DCSP path=%(path)s; DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP return {'returncode': 'error', 'message': 'unable DCSP to DCSP deserialize DCSP response'}
def find_guest_agent(base_dir): DCNL  DCSP if CONF.xenapi_disable_agent: DCNL DCSP  DCSP return False DCNL DCSP agent_rel_path = CONF.xenapi_agent_path DCNL DCSP agent_path = os.path.join(base_dir, agent_rel_path) DCNL DCSP if os.path.isfile(agent_path): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP installed DCSP in DCSP this DCSP image DCSP are DCSP capable DCSP of DCSP network DCSP injection. DCSP  DCSP Networking DCSP files DCSP will DCSP not DCSP bemanipulated')) DCNL DCSP  DCSP return True DCNL DCSP xe_daemon_filename = os.path.join(base_dir, 'usr', 'sbin', 'xe-daemon') DCNL DCSP if os.path.isfile(xe_daemon_filename): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP present DCSP in DCSP this DCSP image DCSP but DCSP are DCSP not DCSP capable DCSP of DCSP network DCSP injection')) DCNL DCSP else: DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP not DCSP installed DCSP in DCSP this DCSP image')) DCNL DCSP return False
def find_network_with_bridge(session, bridge): DCNL  DCSP expr = ('field DCSP "name__label" DCSP = DCSP "%s" DCSP or DCSP field DCSP "bridge" DCSP = DCSP "%s"' % (bridge, bridge)) DCNL DCSP networks = session.call_xenapi('network.get_all_records_where', expr) DCNL DCSP if (len(networks) == 1): DCNL DCSP  DCSP return networks.keys()[0] DCNL DCSP elif (len(networks) > 1): DCNL DCSP  DCSP raise Exception((_('Found DCSP non-unique DCSP network DCSP for DCSP bridge DCSP %s') % bridge)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_('Found DCSP no DCSP network DCSP for DCSP bridge DCSP %s') % bridge))
def forget_sr(session, sr_ref): DCNL  DCSP LOG.debug(_('Forgetting DCSP SR...')) DCNL DCSP unplug_pbds(session, sr_ref) DCNL DCSP session.call_xenapi('SR.forget', sr_ref)
def find_sr_by_uuid(session, sr_uuid): DCNL  DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP if (sr_rec['uuid'] == sr_uuid): DCNL DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
def find_sr_from_vbd(session, vbd_ref): DCNL  DCSP try: DCNL DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP sr_ref = session.call_xenapi('VDI.get_SR', vdi_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP find DCSP SR DCSP from DCSP VBD DCSP %s') % vbd_ref)) DCNL DCSP return sr_ref
def introduce_vdi(session, sr_ref, vdi_uuid=None, target_lun=None): DCNL  DCSP try: DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref) DCNL DCSP  DCSP if vdi_uuid: DCNL DCSP  DCSP  DCSP LOG.debug(('vdi_uuid: DCSP %s' % vdi_uuid)) DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP elif target_lun: DCNL DCSP  DCSP  DCSP vdi_refs = session.call_xenapi('SR.get_VDIs', sr_ref) DCNL DCSP  DCSP  DCSP for curr_ref in vdi_refs: DCNL DCSP  DCSP  DCSP  DCSP curr_rec = session.call_xenapi('VDI.get_record', curr_ref) DCNL DCSP  DCSP  DCSP  DCSP if (('sm_config' in curr_rec) and ('LUNid' in curr_rec['sm_config']) and (curr_rec['sm_config']['LUNid'] == str(target_lun))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vdi_ref = curr_ref DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('SR.get_VDIs', sr_ref)[0] DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introduce DCSP VDI DCSP on DCSP SR DCSP %s') % sr_ref)) DCNL DCSP try: DCNL DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP LOG.debug(vdi_rec) DCNL DCSP  DCSP LOG.debug(type(vdi_rec)) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP get DCSP record DCSP of DCSP VDI DCSP %s DCSP on') % vdi_ref)) DCNL DCSP if vdi_rec['managed']: DCNL DCSP  DCSP return vdi_ref DCNL DCSP try: DCNL DCSP  DCSP return session.call_xenapi('VDI.introduce', vdi_rec['uuid'], vdi_rec['name_label'], vdi_rec['name_description'], vdi_rec['SR'], vdi_rec['type'], vdi_rec['sharable'], vdi_rec['read_only'], vdi_rec['other_config'], vdi_rec['location'], vdi_rec['xenstore_data'], vdi_rec['sm_config']) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introduce DCSP VDI DCSP for DCSP SR DCSP %s') % sr_ref))
def parse_volume_info(connection_data): DCNL  DCSP volume_id = connection_data['volume_id'] DCNL DCSP target_portal = connection_data['target_portal'] DCNL DCSP target_host = _get_target_host(target_portal) DCNL DCSP target_port = _get_target_port(target_portal) DCNL DCSP target_iqn = connection_data['target_iqn'] DCNL DCSP LOG.debug('(vol_id,number,host,port,iqn): DCSP (%s,%s,%s,%s)', volume_id, target_host, target_port, target_iqn) DCNL DCSP if ((volume_id is None) or (target_host is None) or (target_iqn is None)): DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP obtain DCSP target DCSP information DCSP %(connection_data)s') % locals())) DCNL DCSP volume_info = {} DCNL DCSP volume_info['id'] = volume_id DCNL DCSP volume_info['target'] = target_host DCNL DCSP volume_info['port'] = target_port DCNL DCSP volume_info['targetIQN'] = target_iqn DCNL DCSP if (('auth_method' in connection_data) and (connection_data['auth_method'] == 'CHAP')): DCNL DCSP  DCSP volume_info['chapuser'] = connection_data['auth_username'] DCNL DCSP  DCSP volume_info['chappassword'] = connection_data['auth_password'] DCNL DCSP return volume_info
def mountpoint_to_number(mountpoint): DCNL  DCSP if mountpoint.startswith('/dev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hs]d[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[2:3]) - ord('a')) DCNL DCSP elif re.match('^x?vd[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[(-1)]) - ord('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn(_('Mountpoint DCSP cannot DCSP be DCSP translated: DCSP %s'), mountpoint) DCNL DCSP  DCSP return (-1)
def _get_volume_id(path_or_id): DCNL  DCSP if isinstance(path_or_id, int): DCNL DCSP  DCSP return path_or_id DCNL DCSP volume_id = path_or_id[(path_or_id.find(':volume-') + 1):] DCNL DCSP if (volume_id == path_or_id): DCNL DCSP  DCSP volume_id = path_or_id[(path_or_id.find('-volume--') + 1):] DCNL DCSP  DCSP volume_id = volume_id.replace('volume--', '') DCNL DCSP else: DCNL DCSP  DCSP volume_id = volume_id.replace('volume-', '') DCNL DCSP  DCSP volume_id = volume_id[0:volume_id.find('-')] DCNL DCSP return int(volume_id)
def _get_target_host(iscsi_string): DCNL  DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[0:iscsi_string.find(':')] DCNL DCSP elif ((iscsi_string is None) or CONF.target_host): DCNL DCSP  DCSP return CONF.target_host
def _get_target_port(iscsi_string): DCNL  DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[(iscsi_string.find(':') + 1):] DCNL DCSP elif ((iscsi_string is None) or CONF.target_port): DCNL DCSP  DCSP return CONF.target_port
def call_xenhost(session, method, arg_dict): DCNL  DCSP try: DCNL DCSP  DCSP result = session.call_plugin('xenhost', method, args=arg_dict) DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP return jsonutils.loads(result) DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP get DCSP updated DCSP status')) DCNL DCSP  DCSP return None DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP LOG.error((_('The DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP error: DCSP %(e)s.') % locals())) DCNL DCSP  DCSP return e.details[1]
def _uuid_find(virtapi, context, host, name_label): DCNL  DCSP for i in virtapi.instance_get_all_by_host(context, host): DCNL DCSP  DCSP if (i.name == name_label): DCNL DCSP  DCSP  DCSP return i['uuid'] DCNL DCSP return None
def _host_find(context, session, src_aggregate, dst): DCNL  DCSP uuid = session.call_xenapi('host.get_record', dst)['uuid'] DCNL DCSP for (compute_host, host_uuid) in src_aggregate.metadetails.iteritems(): DCNL DCSP  DCSP if (host_uuid == uuid): DCNL DCSP  DCSP  DCSP return compute_host DCNL DCSP raise exception.NoValidHost(reason=('Host DCSP %(host_uuid)s DCSP could DCSP not DCSP be DCSP found DCSP from DCSP aggregate DCSP metadata: DCSP %(metadata)s.' % {'host_uuid': uuid, 'metadata': src_aggregate.metadetails}))
def is_hv_pool(metadata): DCNL  DCSP return (POOL_FLAG in metadata.keys())
def get_disk_size(path): DCNL  DCSP return images.qemu_img_info(path).virtual_size
def extend(image, size): DCNL  DCSP virt_size = get_disk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP return DCNL DCSP utils.execute('qemu-img', 'resize', image, size) DCNL DCSP resize2fs(image)
def can_resize_fs(image, size, use_cow=False): DCNL  DCSP LOG.debug(_('Checking DCSP if DCSP we DCSP can DCSP resize DCSP image DCSP %(image)s. DCSP size=%(size)s, DCSP CoW=%(use_cow)s'), locals()) DCNL DCSP virt_size = get_disk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP LOG.debug(_('Cannot DCSP resize DCSP filesystem DCSP %s DCSP to DCSP a DCSP smaller DCSP size.'), image) DCNL DCSP  DCSP return False DCNL DCSP if use_cow: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fs = vfs.VFS.instance_for_image(image, 'qcow2', None) DCNL DCSP  DCSP  DCSP fs.setup() DCNL DCSP  DCSP  DCSP fs.teardown() DCNL DCSP  DCSP except exception.NovaException as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Unable DCSP to DCSP mount DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(error)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP utils.execute('e2label', image) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Unable DCSP to DCSP determine DCSP label DCSP for DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(errror)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
def inject_data(image, key=None, net=None, metadata=None, admin_password=None, files=None, partition=None, use_cow=False, mandatory=()): DCNL  DCSP LOG.debug((_('Inject DCSP data DCSP image=%(image)s DCSP key=%(key)s DCSP net=%(net)s DCSP metadata=%(metadata)s DCSP admin_password=ha-ha-not-telling-you DCSP files=%(files)s DCSP partition=%(partition)s DCSP use_cow=%(use_cow)s') % locals())) DCNL DCSP fmt = 'raw' DCNL DCSP if use_cow: DCNL DCSP  DCSP fmt = 'qcow2' DCNL DCSP try: DCNL DCSP  DCSP fs = vfs.VFS.instance_for_image(image, fmt, partition) DCNL DCSP  DCSP fs.setup() DCNL DCSP except Exception as e: DCNL DCSP  DCSP for inject in mandatory: DCNL DCSP  DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP data DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return inject_data_into_fs(fs, key, net, metadata, admin_password, files, mandatory) DCNL DCSP finally: DCNL DCSP  DCSP fs.teardown()
def setup_container(image, container_dir, use_cow=False): DCNL  DCSP img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir) DCNL DCSP if (not img.mount()): DCNL DCSP  DCSP LOG.error((_("Failed DCSP to DCSP mount DCSP container DCSP filesystem DCSP '%(image)s' DCSP on DCSP '%(target)s': DCSP %(errors)s") % {'image': img, 'target': container_dir, 'errors': img.errors})) DCNL DCSP  DCSP raise exception.NovaException(img.errors)
def teardown_container(container_dir): DCNL  DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_dir=container_dir) DCNL DCSP  DCSP img.teardown() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP teardown DCSP ntainer DCSP filesystem: DCSP %s'), exn)
def clean_lxc_namespace(container_dir): DCNL  DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_dir=container_dir) DCNL DCSP  DCSP img.umount() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP umount DCSP container DCSP filesystem: DCSP %s'), exn)
def inject_data_into_fs(fs, key, net, metadata, admin_password, files, mandatory=()): DCNL  DCSP status = True DCNL DCSP for inject in ('key', 'net', 'metadata', 'admin_password', 'files'): DCNL DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP inject_func = globals()[('_inject_%s_into_fs' % inject)] DCNL DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP inject_func(inject_val, fs) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if (inject in mandatory): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP %(inject)s DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP  DCSP  DCSP status = False DCNL DCSP return status
def _setup_selinux_for_keys(fs, sshdir): DCNL  DCSP if (not fs.has_file(os.path.join('etc', 'selinux'))): DCNL DCSP  DCSP return DCNL DCSP rclocal = os.path.join('etc', 'rc.local') DCNL DCSP rc_d = os.path.join('etc', 'rc.d') DCNL DCSP if ((not fs.has_file(rclocal)) and fs.has_file(rc_d)): DCNL DCSP  DCSP rclocal = os.path.join(rc_d, 'rc.local') DCNL DCSP restorecon = ['\n', '# DCSP Added DCSP by DCSP Nova DCSP to DCSP ensure DCSP injected DCSP ssh DCSP keys DCSP have DCSP the DCSP right DCSP context\n', ('restorecon DCSP -RF DCSP %s DCSP 2>/dev/null DCSP || DCSP :\n' % sshdir)] DCNL DCSP if (not fs.has_file(rclocal)): DCNL DCSP  DCSP restorecon.insert(0, '#!/bin/sh') DCNL DCSP _inject_file_into_fs(fs, rclocal, ''.join(restorecon), append=True) DCNL DCSP fs.set_permissions(rclocal, 448)
def _inject_key_into_fs(key, fs): DCNL  DCSP LOG.debug((_('Inject DCSP key DCSP fs=%(fs)s DCSP key=%(key)s') % locals())) DCNL DCSP sshdir = os.path.join('root', '.ssh') DCNL DCSP fs.make_path(sshdir) DCNL DCSP fs.set_ownership(sshdir, 'root', 'root') DCNL DCSP fs.set_permissions(sshdir, 448) DCNL DCSP keyfile = os.path.join(sshdir, 'authorized_keys') DCNL DCSP key_data = ''.join(['\n', '# DCSP The DCSP following DCSP ssh DCSP key DCSP was DCSP injected DCSP by DCSP Nova', '\n', key.strip(), '\n']) DCNL DCSP _inject_file_into_fs(fs, keyfile, key_data, append=True) DCNL DCSP fs.set_permissions(keyfile, 384) DCNL DCSP _setup_selinux_for_keys(fs, sshdir)
def _inject_net_into_fs(net, fs): DCNL  DCSP LOG.debug((_('Inject DCSP key DCSP fs=%(fs)s DCSP net=%(net)s') % locals())) DCNL DCSP netdir = os.path.join('etc', 'network') DCNL DCSP fs.make_path(netdir) DCNL DCSP fs.set_ownership(netdir, 'root', 'root') DCNL DCSP fs.set_permissions(netdir, 484) DCNL DCSP netfile = os.path.join('etc', 'network', 'interfaces') DCNL DCSP _inject_file_into_fs(fs, netfile, net)
def _inject_admin_password_into_fs(admin_passwd, fs): DCNL  DCSP LOG.debug((_('Inject DCSP admin DCSP password DCSP fs=%(fs)s DCSP admin_passwd=ha-ha-not-telling-you') % locals())) DCNL DCSP admin_user = 'root' DCNL DCSP (fd, tmp_passwd) = tempfile.mkstemp() DCNL DCSP os.close(fd) DCNL DCSP (fd, tmp_shadow) = tempfile.mkstemp() DCNL DCSP os.close(fd) DCNL DCSP passwd_path = os.path.join('etc', 'passwd') DCNL DCSP shadow_path = os.path.join('etc', 'shadow') DCNL DCSP passwd_data = fs.read_file(passwd_path) DCNL DCSP shadow_data = fs.read_file(shadow_path) DCNL DCSP new_shadow_data = _set_passwd(admin_user, admin_passwd, passwd_data, shadow_data) DCNL DCSP fs.replace_file(shadow_path, new_shadow_data)
def _set_passwd(username, admin_passwd, passwd_data, shadow_data): DCNL  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP raise exception.NovaException(_('Not DCSP implemented DCSP on DCSP Windows')) DCNL DCSP algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''} DCNL DCSP salt = _generate_salt() DCNL DCSP encrypted_passwd = crypt.crypt(admin_passwd, (algos['MD5'] + salt)) DCNL DCSP if (len(encrypted_passwd) == 13): DCNL DCSP  DCSP encrypted_passwd = crypt.crypt(admin_passwd, (algos['DES'] + salt)) DCNL DCSP p_file = passwd_data.split('\n') DCNL DCSP s_file = shadow_data.split('\n') DCNL DCSP found = False DCNL DCSP for entry in p_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not found): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP found DCSP in DCSP password DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP new_shadow = list() DCNL DCSP found = False DCNL DCSP for entry in s_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP split_entry[1] = encrypted_passwd DCNL DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP new_entry = ':'.join(split_entry) DCNL DCSP  DCSP new_shadow.append(new_entry) DCNL DCSP if (not found): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP found DCSP in DCSP shadow DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP return '\n'.join(new_shadow)
def get_cache_fname(images, key): DCNL  DCSP image_id = str(images[key]) DCNL DCSP if ((not CONF.remove_unused_kernels) and (key in ['kernel_id', 'ramdisk_id'])): DCNL DCSP  DCSP return image_id DCNL DCSP else: DCNL DCSP  DCSP return hashlib.sha1(image_id).hexdigest()
def get_info_filename(base_path): DCNL  DCSP base_file = os.path.basename(base_path) DCNL DCSP return (CONF.image_info_filename_pattern % {'image': base_file})
def is_valid_info_file(path): DCNL  DCSP digest_size = (hashlib.sha1().digestsize * 2) DCNL DCSP regexp = (CONF.image_info_filename_pattern % {'image': ('([0-9a-f]{%(digest_size)d}|[0-9a-f]{%(digest_size)d}_sm|[0-9a-f]{%(digest_size)d}_[0-9]+)' % {'digest_size': digest_size})}) DCNL DCSP m = re.match(regexp, path) DCNL DCSP if m: DCNL DCSP  DCSP return True DCNL DCSP return False
def read_stored_info(target, field=None, timestamped=False): DCNL  DCSP info_file = get_info_filename(target) DCNL DCSP if (not os.path.exists(info_file)): DCNL DCSP  DCSP old_filename = (target + '.sha1') DCNL DCSP  DCSP if ((field == 'sha1') and os.path.exists(old_filename)): DCNL DCSP  DCSP  DCSP hash_file = open(old_filename) DCNL DCSP  DCSP  DCSP hash_value = hash_file.read() DCNL DCSP  DCSP  DCSP hash_file.close() DCNL DCSP  DCSP  DCSP write_stored_info(target, field=field, value=hash_value) DCNL DCSP  DCSP  DCSP os.remove(old_filename) DCNL DCSP  DCSP  DCSP d = {field: hash_value} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP d = {} DCNL DCSP else: DCNL DCSP  DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP  DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP  DCSP @lockutils.synchronized(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP  DCSP def read_file(info_file): DCNL DCSP  DCSP  DCSP LOG.debug(_('Reading DCSP image DCSP info DCSP file: DCSP %s'), info_file) DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return f.read().rstrip() DCNL DCSP  DCSP serialized = read_file(info_file) DCNL DCSP  DCSP d = _read_possible_json(serialized, info_file) DCNL DCSP if field: DCNL DCSP  DCSP if timestamped: DCNL DCSP  DCSP  DCSP return (d.get(field, None), d.get(('%s-timestamp' % field), None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return d.get(field, None) DCNL DCSP return d
def write_stored_info(target, field=None, value=None): DCNL  DCSP if (not field): DCNL DCSP  DCSP return DCNL DCSP info_file = get_info_filename(target) DCNL DCSP LOG.info(_('Writing DCSP stored DCSP info DCSP to DCSP %s'), info_file) DCNL DCSP fileutils.ensure_tree(os.path.dirname(info_file)) DCNL DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP @lockutils.synchronized(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP def write_file(info_file, field, value): DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP if os.path.exists(info_file): DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP d = _read_possible_json(f.read(), info_file) DCNL DCSP  DCSP d[field] = value DCNL DCSP  DCSP d[('%s-timestamp' % field)] = time.time() DCNL DCSP  DCSP with open(info_file, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(json.dumps(d)) DCNL DCSP write_file(info_file, field, value)
def read_stored_checksum(target, timestamped=True): DCNL  DCSP return read_stored_info(target, field='sha1', timestamped=timestamped)
def write_stored_checksum(target): DCNL  DCSP with open(target, 'r') as img_file: DCNL DCSP  DCSP checksum = utils.hash_file(img_file) DCNL DCSP write_stored_info(target, field='sha1', value=checksum)
def has_disk_dev(mapping, disk_dev): DCNL  DCSP for disk in mapping: DCNL DCSP  DCSP info = mapping[disk] DCNL DCSP  DCSP if (info['dev'] == disk_dev): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def get_dev_prefix_for_disk_bus(disk_bus): DCNL  DCSP if CONF.libvirt_disk_prefix: DCNL DCSP  DCSP return CONF.libvirt_disk_prefix DCNL DCSP if (disk_bus == 'ide'): DCNL DCSP  DCSP return 'hd' DCNL DCSP elif (disk_bus == 'virtio'): DCNL DCSP  DCSP return 'vd' DCNL DCSP elif (disk_bus == 'xen'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'scsi'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'usb'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'uml'): DCNL DCSP  DCSP return 'ubd' DCNL DCSP elif (disk_bus == 'lxc'): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP determine DCSP disk DCSP prefix DCSP for DCSP %s') % disk_bus))
def get_dev_count_for_disk_bus(disk_bus): DCNL  DCSP if (disk_bus == 'ide'): DCNL DCSP  DCSP return 4 DCNL DCSP else: DCNL DCSP  DCSP return 26
def find_disk_dev_for_disk_bus(mapping, bus, last_device=False): DCNL  DCSP dev_prefix = get_dev_prefix_for_disk_bus(bus) DCNL DCSP if (dev_prefix is None): DCNL DCSP  DCSP return None DCNL DCSP max_dev = get_dev_count_for_disk_bus(bus) DCNL DCSP if last_device: DCNL DCSP  DCSP devs = [(max_dev - 1)] DCNL DCSP else: DCNL DCSP  DCSP devs = range(max_dev) DCNL DCSP for idx in devs: DCNL DCSP  DCSP disk_dev = (dev_prefix + chr((ord('a') + idx))) DCNL DCSP  DCSP if (not has_disk_dev(mapping, disk_dev)): DCNL DCSP  DCSP  DCSP return disk_dev DCNL DCSP raise exception.NovaException(_("No DCSP free DCSP disk DCSP device DCSP names DCSP for DCSP prefix DCSP '%s'"), dev_prefix)
def get_disk_bus_for_device_type(virt_type, image_meta=None, device_type='disk'): DCNL  DCSP if image_meta: DCNL DCSP  DCSP key = (('hw_' + device_type) + '_bus') DCNL DCSP  DCSP disk_bus = image_meta.get('properties', {}).get(key) DCNL DCSP  DCSP if (disk_bus is not None): DCNL DCSP  DCSP  DCSP if (not is_disk_bus_valid_for_virt(virt_type, disk_bus)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupportedHardware(model=disk_bus, virt=virt_type) DCNL DCSP  DCSP  DCSP return disk_bus DCNL DCSP if (virt_type == 'uml'): DCNL DCSP  DCSP if (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'uml' DCNL DCSP elif (virt_type == 'lxc'): DCNL DCSP  DCSP return 'lxc' DCNL DCSP elif (virt_type == 'xen'): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP elif (virt_type in ('qemu', 'kvm')): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'virtio' DCNL DCSP return None
def get_disk_bus_for_disk_dev(virt_type, disk_dev): DCNL  DCSP if (disk_dev[:2] == 'hd'): DCNL DCSP  DCSP return 'ide' DCNL DCSP elif (disk_dev[:2] == 'sd'): DCNL DCSP  DCSP if (virt_type == 'xen'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'scsi' DCNL DCSP elif (disk_dev[:2] == 'vd'): DCNL DCSP  DCSP return 'virtio' DCNL DCSP elif (disk_dev[:3] == 'xvd'): DCNL DCSP  DCSP return 'xen' DCNL DCSP elif (disk_dev[:3] == 'ubd'): DCNL DCSP  DCSP return 'uml' DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_("Unable DCSP to DCSP determine DCSP disk DCSP bus DCSP for DCSP '%s'") % disk_dev[:1]))
def get_next_disk_info(mapping, disk_bus, device_type='disk', last_device=False): DCNL  DCSP disk_dev = find_disk_dev_for_disk_bus(mapping, disk_bus, last_device) DCNL DCSP return {'bus': disk_bus, 'dev': disk_dev, 'type': device_type}
def get_disk_mapping(virt_type, instance, disk_bus, cdrom_bus, block_device_info=None, image_meta=None, rescue=False): DCNL  DCSP inst_type = instance_types.extract_instance_type(instance) DCNL DCSP mapping = {} DCNL DCSP if (virt_type == 'lxc'): DCNL DCSP  DCSP root_disk_bus = disk_bus DCNL DCSP  DCSP root_device_type = 'disk' DCNL DCSP  DCSP root_info = get_next_disk_info(mapping, root_disk_bus, root_device_type) DCNL DCSP  DCSP mapping['root'] = root_info DCNL DCSP  DCSP mapping['disk'] = root_info DCNL DCSP  DCSP return mapping DCNL DCSP if rescue: DCNL DCSP  DCSP rescue_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP mapping['disk.rescue'] = rescue_info DCNL DCSP  DCSP mapping['root'] = rescue_info DCNL DCSP  DCSP os_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP mapping['disk'] = os_info DCNL DCSP  DCSP return mapping DCNL DCSP if (image_meta and (image_meta.get('disk_format') == 'iso')): DCNL DCSP  DCSP root_disk_bus = cdrom_bus DCNL DCSP  DCSP root_device_type = 'cdrom' DCNL DCSP else: DCNL DCSP  DCSP root_disk_bus = disk_bus DCNL DCSP  DCSP root_device_type = 'disk' DCNL DCSP root_device_name = driver.block_device_info_get_root(block_device_info) DCNL DCSP if (root_device_name is not None): DCNL DCSP  DCSP root_device = block_device.strip_dev(root_device_name) DCNL DCSP  DCSP root_info = {'bus': get_disk_bus_for_disk_dev(virt_type, root_device), 'dev': root_device, 'type': root_device_type} DCNL DCSP else: DCNL DCSP  DCSP root_info = get_next_disk_info(mapping, root_disk_bus, root_device_type) DCNL DCSP mapping['root'] = root_info DCNL DCSP if (not block_device.volume_in_mapping(root_info['dev'], block_device_info)): DCNL DCSP  DCSP mapping['disk'] = root_info DCNL DCSP eph_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP ephemeral_device = False DCNL DCSP if (not (block_device.volume_in_mapping(eph_info['dev'], block_device_info) or (0 in [eph['num'] for eph in driver.block_device_info_get_ephemerals(block_device_info)]))): DCNL DCSP  DCSP if (instance['ephemeral_gb'] > 0): DCNL DCSP  DCSP  DCSP ephemeral_device = True DCNL DCSP if ephemeral_device: DCNL DCSP  DCSP mapping['disk.local'] = eph_info DCNL DCSP for eph in driver.block_device_info_get_ephemerals(block_device_info): DCNL DCSP  DCSP disk_dev = block_device.strip_dev(eph['device_name']) DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping[get_eph_disk(eph)] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP swap = driver.block_device_info_get_swap(block_device_info) DCNL DCSP if driver.swap_is_usable(swap): DCNL DCSP  DCSP disk_dev = block_device.strip_dev(swap['device_name']) DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping['disk.swap'] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP elif (inst_type['swap'] > 0): DCNL DCSP  DCSP swap_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP if (not block_device.volume_in_mapping(swap_info['dev'], block_device_info)): DCNL DCSP  DCSP  DCSP mapping['disk.swap'] = swap_info DCNL DCSP block_device_mapping = driver.block_device_info_get_mapping(block_device_info) DCNL DCSP for vol in block_device_mapping: DCNL DCSP  DCSP disk_dev = vol['mount_device'].rpartition('/')[2] DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping[vol['mount_device']] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP if configdrive.enabled_for(instance): DCNL DCSP  DCSP config_info = get_next_disk_info(mapping, disk_bus, last_device=True) DCNL DCSP  DCSP mapping['disk.config'] = config_info DCNL DCSP return mapping
def get_disk_info(virt_type, instance, block_device_info=None, image_meta=None, rescue=False): DCNL  DCSP disk_bus = get_disk_bus_for_device_type(virt_type, image_meta, 'disk') DCNL DCSP cdrom_bus = get_disk_bus_for_device_type(virt_type, image_meta, 'cdrom') DCNL DCSP mapping = get_disk_mapping(virt_type, instance, disk_bus, cdrom_bus, block_device_info, image_meta, rescue) DCNL DCSP return {'disk_bus': disk_bus, 'cdrom_bus': cdrom_bus, 'mapping': mapping}
def set_vif_guest_frontend_config(conf, mac, model, driver): DCNL  DCSP conf.mac_addr = mac DCNL DCSP if (model is not None): DCNL DCSP  DCSP conf.model = model DCNL DCSP if (driver is not None): DCNL DCSP  DCSP conf.driver_name = driver
def set_vif_host_backend_bridge_config(conf, brname, tapname=None): DCNL  DCSP conf.net_type = 'bridge' DCNL DCSP conf.source_dev = brname DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
def set_vif_host_backend_ethernet_config(conf, tapname): DCNL  DCSP conf.net_type = 'ethernet' DCNL DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
def set_vif_host_backend_ovs_config(conf, brname, interfaceid, tapname=None): DCNL  DCSP conf.net_type = 'bridge' DCNL DCSP conf.source_dev = brname DCNL DCSP conf.vporttype = 'openvswitch' DCNL DCSP conf.add_vport_param('interfaceid', interfaceid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
def set_vif_host_backend_802qbg_config(conf, devname, managerid, typeid, typeidversion, instanceid, tapname=None): DCNL  DCSP conf.net_type = 'direct' DCNL DCSP conf.source_dev = devname DCNL DCSP conf.source_mode = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbg' DCNL DCSP conf.add_vport_param('managerid', managerid) DCNL DCSP conf.add_vport_param('typeid', typeid) DCNL DCSP conf.add_vport_param('typeidversion', typeidversion) DCNL DCSP conf.add_vport_param('instanceid', instanceid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname
def set_vif_host_backend_802qbh_config(conf, devname, profileid, tapname=None): DCNL  DCSP conf.net_type = 'direct' DCNL DCSP conf.source_dev = devname DCNL DCSP conf.source_mode = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbh' DCNL DCSP conf.add_vport_param('profileid', profileid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname
def set_vif_bandwidth_config(conf, extra_specs): DCNL  DCSP bandwidth_items = ['vif_inbound_average', 'vif_inbound_peak', 'vif_inbound_burst', 'vif_outbound_average', 'vif_outbound_peak', 'vif_outbound_burst'] DCNL DCSP for (key, value) in extra_specs.iteritems(): DCNL DCSP  DCSP scope = key.split(':') DCNL DCSP  DCSP if ((len(scope) > 1) and (scope[0] == 'quota')): DCNL DCSP  DCSP  DCSP if (scope[1] in bandwidth_items): DCNL DCSP  DCSP  DCSP  DCSP setattr(conf, scope[1], value)
def get_iscsi_initiator(): DCNL  DCSP contents = utils.read_file_as_root('/etc/iscsi/initiatorname.iscsi') DCNL DCSP for l in contents.split('\n'): DCNL DCSP  DCSP if l.startswith('InitiatorName='): DCNL DCSP  DCSP  DCSP return l[(l.index('=') + 1):].strip()
def get_fc_hbas(): DCNL  DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute('systool', '-c', 'fc_host', '-v', run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP if (exc.exit_code == 96): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installed')) DCNL DCSP  DCSP return [] DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installed')) DCNL DCSP  DCSP return [] DCNL DCSP if (out is None): DCNL DCSP  DCSP raise RuntimeError(_('Cannot DCSP find DCSP any DCSP Fibre DCSP Channel DCSP HBAs')) DCNL DCSP lines = out.split('\n') DCNL DCSP lines = lines[2:] DCNL DCSP hbas = [] DCNL DCSP hba = {} DCNL DCSP lastline = None DCNL DCSP for line in lines: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') and (lastline == '')): DCNL DCSP  DCSP  DCSP if (len(hba) > 0): DCNL DCSP  DCSP  DCSP  DCSP hbas.append(hba) DCNL DCSP  DCSP  DCSP  DCSP hba = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = line.split('=') DCNL DCSP  DCSP  DCSP if (len(val) == 2): DCNL DCSP  DCSP  DCSP  DCSP key = val[0].strip().replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP  DCSP value = val[1].strip() DCNL DCSP  DCSP  DCSP  DCSP hba[key] = value.replace('"', '') DCNL DCSP  DCSP lastline = line DCNL DCSP return hbas
def get_fc_hbas_info(): DCNL  DCSP hbas = get_fc_hbas() DCNL DCSP hbas_info = [] DCNL DCSP for hba in hbas: DCNL DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP wwnn = hba['node_name'].replace('0x', '') DCNL DCSP  DCSP device_path = hba['ClassDevicepath'] DCNL DCSP  DCSP device = hba['ClassDevice'] DCNL DCSP  DCSP hbas_info.append({'port_name': wwpn, 'node_name': wwnn, 'host_device': device, 'device_path': device_path}) DCNL DCSP return hbas_info
def get_fc_wwpns(): DCNL  DCSP hbas = get_fc_hbas() DCNL DCSP wwpns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwpns.append(wwpn) DCNL DCSP return wwpns
def get_fc_wwnns(): DCNL  DCSP hbas = get_fc_hbas() DCNL DCSP wwnns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwnn = hba['node_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwnns.append(wwnn) DCNL DCSP return wwnns
def create_image(disk_format, path, size): DCNL  DCSP execute('qemu-img', 'create', '-f', disk_format, path, size)
def create_cow_image(backing_file, path, size=None): DCNL  DCSP base_cmd = ['qemu-img', 'create', '-f', 'qcow2'] DCNL DCSP cow_opts = [] DCNL DCSP if backing_file: DCNL DCSP  DCSP cow_opts += [('backing_file=%s' % backing_file)] DCNL DCSP  DCSP base_details = images.qemu_img_info(backing_file) DCNL DCSP else: DCNL DCSP  DCSP base_details = None DCNL DCSP if (base_details and (base_details.cluster_size is not None)): DCNL DCSP  DCSP cow_opts += [('cluster_size=%s' % base_details.cluster_size)] DCNL DCSP if (base_details and base_details.encryption): DCNL DCSP  DCSP cow_opts += [('encryption=%s' % base_details.encryption)] DCNL DCSP if (size is not None): DCNL DCSP  DCSP cow_opts += [('size=%s' % size)] DCNL DCSP if cow_opts: DCNL DCSP  DCSP csv_opts = ','.join(cow_opts) DCNL DCSP  DCSP cow_opts = ['-o', csv_opts] DCNL DCSP cmd = ((base_cmd + cow_opts) + [path]) DCNL DCSP execute(*cmd)
def create_lvm_image(vg, lv, size, sparse=False): DCNL  DCSP vg_info = get_volume_group_info(vg) DCNL DCSP free_space = vg_info['free'] DCNL DCSP def check_size(vg, lv, size): DCNL DCSP  DCSP if (size > free_space): DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Insufficient DCSP Space DCSP on DCSP Volume DCSP Group DCSP %(vg)s. DCSP Only DCSP %(free_space)db DCSP available, DCSP but DCSP %(size)db DCSP required DCSP by DCSP volume DCSP %(lv)s.') % locals())) DCNL DCSP if sparse: DCNL DCSP  DCSP preallocated_space = ((64 * 1024) * 1024) DCNL DCSP  DCSP check_size(vg, lv, preallocated_space) DCNL DCSP  DCSP if (free_space < size): DCNL DCSP  DCSP  DCSP LOG.warning((_('Volume DCSP group DCSP %(vg)s DCSP will DCSP not DCSP be DCSP able DCSP to DCSP hold DCSP sparse DCSP volume DCSP %(lv)s. DCSP Virtual DCSP volume DCSP size DCSP is DCSP %(size)db, DCSP but DCSP free DCSP space DCSP on DCSP volume DCSP group DCSP is DCSP only DCSP %(free_space)db.') % locals())) DCNL DCSP  DCSP cmd = ('lvcreate', '-L', ('%db' % preallocated_space), '--virtualsize', ('%db' % size), '-n', lv, vg) DCNL DCSP else: DCNL DCSP  DCSP check_size(vg, lv, size) DCNL DCSP  DCSP cmd = ('lvcreate', '-L', ('%db' % size), '-n', lv, vg) DCNL DCSP execute(run_as_root=True, attempts=3, *cmd)
def get_volume_group_info(vg): DCNL  DCSP (out, err) = execute('vgs', '--noheadings', '--nosuffix', '--separator', '|', '--units', 'b', '-o', 'vg_size,vg_free', vg, run_as_root=True) DCNL DCSP info = out.split('|') DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('vg DCSP %s DCSP must DCSP be DCSP LVM DCSP volume DCSP group') % vg)) DCNL DCSP return {'total': int(info[0]), 'free': int(info[1]), 'used': (int(info[0]) - int(info[1]))}
def list_logical_volumes(vg): DCNL  DCSP (out, err) = execute('lvs', '--noheadings', '-o', 'lv_name', vg, run_as_root=True) DCNL DCSP return [line.strip() for line in out.splitlines()]
def logical_volume_info(path): DCNL  DCSP (out, err) = execute('lvs', '-o', 'vg_all,lv_all', '--separator', '|', path, run_as_root=True) DCNL DCSP info = [line.split('|') for line in out.splitlines()] DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('Path DCSP %s DCSP must DCSP be DCSP LVM DCSP logical DCSP volume') % path)) DCNL DCSP return dict(zip(*info))
def logical_volume_size(path): DCNL  DCSP (out, _err) = execute('lvs', '-o', 'lv_size', '--noheadings', '--units', 'b', '--nosuffix', path, run_as_root=True) DCNL DCSP return int(out)
def clear_logical_volume(path): DCNL  DCSP vol_size = logical_volume_size(path) DCNL DCSP bs = (1024 * 1024) DCNL DCSP direct_flags = ('oflag=direct',) DCNL DCSP sync_flags = () DCNL DCSP remaining_bytes = vol_size DCNL DCSP while remaining_bytes: DCNL DCSP  DCSP zero_blocks = (remaining_bytes / bs) DCNL DCSP  DCSP seek_blocks = ((vol_size - remaining_bytes) / bs) DCNL DCSP  DCSP zero_cmd = ('dd', ('bs=%s' % bs), 'if=/dev/zero', ('of=%s' % path), ('seek=%s' % seek_blocks), ('count=%s' % zero_blocks)) DCNL DCSP  DCSP zero_cmd += direct_flags DCNL DCSP  DCSP zero_cmd += sync_flags DCNL DCSP  DCSP if zero_blocks: DCNL DCSP  DCSP  DCSP utils.execute(run_as_root=True, *zero_cmd) DCNL DCSP  DCSP remaining_bytes %= bs DCNL DCSP  DCSP bs /= 1024 DCNL DCSP  DCSP direct_flags = () DCNL DCSP  DCSP sync_flags = ('conv=fdatasync',)
def remove_logical_volumes(*paths): DCNL  DCSP for path in paths: DCNL DCSP  DCSP clear_logical_volume(path) DCNL DCSP if paths: DCNL DCSP  DCSP lvremove = (('lvremove', '-f') + paths) DCNL DCSP  DCSP execute(attempts=3, run_as_root=True, *lvremove)
def pick_disk_driver_name(is_block_dev=False): DCNL  DCSP if (CONF.libvirt_type == 'xen'): DCNL DCSP  DCSP if is_block_dev: DCNL DCSP  DCSP  DCSP return 'phy' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'tap' DCNL DCSP elif (CONF.libvirt_type in ('kvm', 'qemu')): DCNL DCSP  DCSP return 'qemu' DCNL DCSP else: DCNL DCSP  DCSP return None
def get_disk_size(path): DCNL  DCSP size = images.qemu_img_info(path).virtual_size DCNL DCSP return int(size)
def get_disk_backing_file(path, basename=True): DCNL  DCSP backing_file = images.qemu_img_info(path).backing_file DCNL DCSP if (backing_file and basename): DCNL DCSP  DCSP backing_file = os.path.basename(backing_file) DCNL DCSP return backing_file
def copy_image(src, dest, host=None): DCNL  DCSP if (not host): DCNL DCSP  DCSP execute('cp', src, dest) DCNL DCSP else: DCNL DCSP  DCSP dest = ('%s:%s' % (host, dest)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', '--dry-run', src, dest) DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP execute('scp', src, dest) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', src, dest)
def write_to_file(path, contents, umask=None): DCNL  DCSP if umask: DCNL DCSP  DCSP saved_umask = os.umask(umask) DCNL DCSP try: DCNL DCSP  DCSP with open(path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(contents) DCNL DCSP finally: DCNL DCSP  DCSP if umask: DCNL DCSP  DCSP  DCSP os.umask(saved_umask)
def chown(path, owner): DCNL  DCSP execute('chown', owner, path, run_as_root=True)
def create_snapshot(disk_path, snapshot_name): DCNL  DCSP qemu_img_cmd = ('qemu-img', 'snapshot', '-c', snapshot_name, disk_path) DCNL DCSP execute(run_as_root=True, *qemu_img_cmd)
def delete_snapshot(disk_path, snapshot_name): DCNL  DCSP qemu_img_cmd = ('qemu-img', 'snapshot', '-d', snapshot_name, disk_path) DCNL DCSP execute(run_as_root=True, *qemu_img_cmd)
def extract_snapshot(disk_path, source_fmt, snapshot_name, out_path, dest_fmt): DCNL  DCSP if (dest_fmt == 'iso'): DCNL DCSP  DCSP dest_fmt = 'raw' DCNL DCSP qemu_img_cmd = ('qemu-img', 'convert', '-f', source_fmt, '-O', dest_fmt) DCNL DCSP if (CONF.libvirt_snapshot_compression and (dest_fmt == 'qcow2')): DCNL DCSP  DCSP qemu_img_cmd += ('-c',) DCNL DCSP if (snapshot_name is not None): DCNL DCSP  DCSP qemu_img_cmd += ('-s', snapshot_name) DCNL DCSP qemu_img_cmd += (disk_path, out_path) DCNL DCSP execute(*qemu_img_cmd)
def load_file(path): DCNL  DCSP with open(path, 'r') as fp: DCNL DCSP  DCSP return fp.read()
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def file_delete(path): DCNL  DCSP return os.unlink(path)
def find_disk(virt_dom): DCNL  DCSP xml_desc = virt_dom.XMLDesc(0) DCNL DCSP domain = etree.fromstring(xml_desc) DCNL DCSP if (CONF.libvirt_type == 'lxc'): DCNL DCSP  DCSP source = domain.find('devices/filesystem/source') DCNL DCSP  DCSP disk_path = source.get('dir') DCNL DCSP  DCSP disk_path = disk_path[0:disk_path.rfind('rootfs')] DCNL DCSP  DCSP disk_path = os.path.join(disk_path, 'disk') DCNL DCSP else: DCNL DCSP  DCSP source = domain.find('devices/disk/source') DCNL DCSP  DCSP disk_path = (source.get('file') or source.get('dev')) DCNL DCSP if (not disk_path): DCNL DCSP  DCSP raise RuntimeError(_("Can't DCSP retrieve DCSP root DCSP device DCSP path DCSP from DCSP instance DCSP libvirt DCSP configuration")) DCNL DCSP return disk_path
def get_disk_type(path): DCNL  DCSP if path.startswith('/dev'): DCNL DCSP  DCSP return 'lvm' DCNL DCSP return images.qemu_img_info(path).file_format
def get_fs_info(path): DCNL  DCSP hddinfo = os.statvfs(path) DCNL DCSP total = (hddinfo.f_frsize * hddinfo.f_blocks) DCNL DCSP free = (hddinfo.f_frsize * hddinfo.f_bavail) DCNL DCSP used = (hddinfo.f_frsize * (hddinfo.f_blocks - hddinfo.f_bfree)) DCNL DCSP return {'total': total, 'free': free, 'used': used}
def fetch_image(context, target, image_id, user_id, project_id): DCNL  DCSP images.fetch_to_raw(context, image_id, target, user_id, project_id)
def get_instance_path(instance, forceold=False): DCNL  DCSP pre_grizzly_name = os.path.join(CONF.instances_path, instance['name']) DCNL DCSP if (forceold or os.path.exists(pre_grizzly_name)): DCNL DCSP  DCSP return pre_grizzly_name DCNL DCSP return os.path.join(CONF.instances_path, instance['uuid'])
def patch_tpool_proxy(): DCNL  DCSP def str_method(self): DCNL DCSP  DCSP return str(self._obj) DCNL DCSP def repr_method(self): DCNL DCSP  DCSP return repr(self._obj) DCNL DCSP tpool.Proxy.__str__ = str_method DCNL DCSP tpool.Proxy.__repr__ = repr_method
def load_compute_driver(virtapi, compute_driver=None): DCNL  DCSP if (not compute_driver): DCNL DCSP  DCSP compute_driver = CONF.compute_driver DCNL DCSP if (not compute_driver): DCNL DCSP  DCSP LOG.error(_('Compute DCSP driver DCSP option DCSP required, DCSP but DCSP not DCSP specified')) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP LOG.info((_("Loading DCSP compute DCSP driver DCSP '%s'") % compute_driver)) DCNL DCSP try: DCNL DCSP  DCSP driver = importutils.import_object_ns('nova.virt', compute_driver, virtapi) DCNL DCSP  DCSP return utils.check_isinstance(driver, ComputeDriver) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP LOG.error((_('Unable DCSP to DCSP load DCSP the DCSP virtualization DCSP driver: DCSP %s') % e)) DCNL DCSP  DCSP sys.exit(1)
def ssh_connect(connection): DCNL  DCSP try: DCNL DCSP  DCSP ssh = paramiko.SSHClient() DCNL DCSP  DCSP ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) DCNL DCSP  DCSP ssh.connect(connection.host, username=connection.username, password=connection.password, port=connection.port, key_filename=connection.keyfile, timeout=constants.POWERVM_CONNECTION_TIMEOUT) DCNL DCSP  DCSP return ssh DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Connection DCSP error DCSP connecting DCSP PowerVM DCSP manager')) DCNL DCSP  DCSP raise exception.PowerVMConnectionFailed()
def ssh_command_as_root(ssh_connection, cmd, check_exit_code=True): DCNL  DCSP LOG.debug((_('Running DCSP cmd DCSP (SSH-as-root): DCSP %s') % cmd)) DCNL DCSP chan = ssh_connection._transport.open_session() DCNL DCSP chan.exec_command('ioscli DCSP oem_setup_env') DCNL DCSP bufsize = (-1) DCNL DCSP stdin = chan.makefile('wb', bufsize) DCNL DCSP stdout = chan.makefile('rb', bufsize) DCNL DCSP stderr = chan.makefile_stderr('rb', bufsize) DCNL DCSP stdin.write(('%s\n%s\n' % (cmd, 'exit'))) DCNL DCSP stdin.flush() DCNL DCSP exit_status = chan.recv_exit_status() DCNL DCSP if (exit_status != (-1)): DCNL DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % exit_status)) DCNL DCSP  DCSP if (check_exit_code and (exit_status != 0)): DCNL DCSP  DCSP  DCSP raise nova_exception.ProcessExecutionError(exit_code=exit_status, stdout=stdout, stderr=stderr, cmd=''.join(cmd)) DCNL DCSP return (stdout, stderr)
def ftp_put_command(connection, local_path, remote_dir): DCNL  DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwd=connection.password) DCNL DCSP  DCSP ftp.cwd(remote_dir) DCNL DCSP  DCSP name = os.path.split(local_path)[1] DCNL DCSP  DCSP f = open(local_path, 'rb') DCNL DCSP  DCSP ftp.storbinary(('STOR DCSP ' + name), f) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP to DCSP PowerVM DCSP manager DCSP failed')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFailed(ftp_cmd='PUT', source_path=local_path, dest_path=remote_dir)
def ftp_get_command(connection, remote_path, local_path): DCNL  DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwd=connection.password) DCNL DCSP  DCSP ftp.cwd(os.path.dirname(remote_path)) DCNL DCSP  DCSP name = os.path.basename(remote_path) DCNL DCSP  DCSP LOG.debug((_('ftp DCSP GET DCSP %(remote_path)s DCSP to: DCSP %(local_path)s') % locals())) DCNL DCSP  DCSP with open(local_path, 'w') as ftpfile: DCNL DCSP  DCSP  DCSP ftpcmd = ('RETR DCSP %s' % name) DCNL DCSP  DCSP  DCSP ftp.retrbinary(ftpcmd, ftpfile.write) DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP from DCSP PowerVM DCSP manager DCSP failed')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFailed(ftp_cmd='GET', source_path=remote_path, dest_path=local_path)
def aix_path_join(path_one, path_two): DCNL  DCSP if path_one.endswith('/'): DCNL DCSP  DCSP path_one = path_one.rstrip('/') DCNL DCSP if path_two.startswith('/'): DCNL DCSP  DCSP path_two = path_two.lstrip('/') DCNL DCSP final_path = ((path_one + '/') + path_two) DCNL DCSP return final_path
@contextlib.contextmanager DCNL def vios_to_vios_auth(source, dest, conn_info): DCNL  DCSP KEY_BASE_NAME = ('os-%s' % uuid.uuid4().hex) DCNL DCSP keypair_uuid = uuid.uuid4() DCNL DCSP src_conn_obj = ssh_connect(conn_info) DCNL DCSP dest_conn_info = Connection(dest, conn_info.username, conn_info.password) DCNL DCSP dest_conn_obj = ssh_connect(dest_conn_info) DCNL DCSP def run_command(conn_obj, cmd): DCNL DCSP  DCSP (stdout, stderr) = utils.ssh_execute(conn_obj, cmd) DCNL DCSP  DCSP return stdout.strip().splitlines() DCNL DCSP def build_keypair_on_source(): DCNL DCSP  DCSP mkkey = ('ssh-keygen DCSP -f DCSP %s DCSP -N DCSP "" DCSP -C DCSP %s' % (KEY_BASE_NAME, keypair_uuid.hex)) DCNL DCSP  DCSP ssh_command_as_root(src_conn_obj, mkkey) DCNL DCSP  DCSP chown_key = ('chown DCSP %s DCSP %s*' % (conn_info.username, KEY_BASE_NAME)) DCNL DCSP  DCSP ssh_command_as_root(src_conn_obj, chown_key) DCNL DCSP  DCSP cat_key = ('cat DCSP %s.pub' % KEY_BASE_NAME) DCNL DCSP  DCSP pubkey = run_command(src_conn_obj, cat_key) DCNL DCSP  DCSP return pubkey[0] DCNL DCSP def cleanup_key_on_source(): DCNL DCSP  DCSP rmkey = ('rm DCSP %s*' % KEY_BASE_NAME) DCNL DCSP  DCSP run_command(src_conn_obj, rmkey) DCNL DCSP def insert_into_authorized_keys(public_key): DCNL DCSP  DCSP echo_key = ('echo DCSP "%s" DCSP >> DCSP .ssh/authorized_keys' % public_key) DCNL DCSP  DCSP ssh_command_as_root(dest_conn_obj, echo_key) DCNL DCSP def remove_from_authorized_keys(): DCNL DCSP  DCSP rmkey = ('sed DCSP /%s/d DCSP .ssh/authorized_keys DCSP > DCSP .ssh/authorized_keys' % keypair_uuid.hex) DCNL DCSP  DCSP ssh_command_as_root(dest_conn_obj, rmkey) DCNL DCSP public_key = build_keypair_on_source() DCNL DCSP insert_into_authorized_keys(public_key) DCNL DCSP try: DCNL DCSP  DCSP (yield KEY_BASE_NAME) DCNL DCSP finally: DCNL DCSP  DCSP remove_from_authorized_keys() DCNL DCSP  DCSP cleanup_key_on_source()
def load_from_conf_data(conf_data): DCNL  DCSP cf_splitter = shlex.shlex(conf_data, posix=True) DCNL DCSP cf_splitter.whitespace = ',' DCNL DCSP cf_splitter.whitespace_split = True DCNL DCSP attribs = dict((item.split('=') for item in list(cf_splitter))) DCNL DCSP lpar = LPAR() DCNL DCSP for (key, value) in attribs.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lpar[key] = value DCNL DCSP  DCSP except exception.PowerVMLPARAttributeNotFound as e: DCNL DCSP  DCSP  DCSP LOG.info((_('Encountered DCSP unknown DCSP LPAR DCSP attribute: DCSP %s\nContinuing DCSP without DCSP storing') % key)) DCNL DCSP return lpar
def getcallargs(function, *args, **kwargs): DCNL  DCSP keyed_args = {} DCNL DCSP (argnames, varargs, keywords, defaults) = inspect.getargspec(function) DCNL DCSP keyed_args.update(kwargs) DCNL DCSP if (('self' in argnames[0]) or ('cls' == argnames[0])): DCNL DCSP  DCSP if (inspect.ismethod(function) and hasattr(function, 'im_self')): DCNL DCSP  DCSP  DCSP keyed_args[argnames[0]] = function.im_self DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP keyed_args[argnames[0]] = None DCNL DCSP remaining_argnames = filter((lambda x: (x not in keyed_args)), argnames) DCNL DCSP keyed_args.update(dict(zip(remaining_argnames, args))) DCNL DCSP if defaults: DCNL DCSP  DCSP num_defaults = len(defaults) DCNL DCSP  DCSP for (argname, value) in zip(argnames[(- num_defaults):], defaults): DCNL DCSP  DCSP  DCSP if (argname not in keyed_args): DCNL DCSP  DCSP  DCSP  DCSP keyed_args[argname] = value DCNL DCSP return keyed_args
def vpn_ping(address, port, timeout=0.05, session_id=None): DCNL  DCSP if (session_id is None): DCNL DCSP  DCSP session_id = random.randint(0, 18446744073709551615L) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP data = struct.pack('!BQxxxxx', 56, session_id) DCNL DCSP sock.sendto(data, (address, port)) DCNL DCSP sock.settimeout(timeout) DCNL DCSP try: DCNL DCSP  DCSP received = sock.recv(2048) DCNL DCSP except socket.timeout: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP sock.close() DCNL DCSP fmt = '!BQxxxxxQxxxx' DCNL DCSP if (len(received) != struct.calcsize(fmt)): DCNL DCSP  DCSP print struct.calcsize(fmt) DCNL DCSP  DCSP return False DCNL DCSP (identifier, server_sess, client_sess) = struct.unpack(fmt, received) DCNL DCSP if ((identifier == 64) and (client_sess == session_id)): DCNL DCSP  DCSP return server_sess
def execute(*cmd, **kwargs): DCNL  DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.NovaException((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root and (os.geteuid() != 0)): DCNL DCSP  DCSP cmd = (['sudo', 'nova-rootwrap', CONF.rootwrap_config] + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fds = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fds = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=close_fds, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
def trycmd(*args, **kwargs): DCNL  DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
def last_completed_audit_period(unit=None, before=None): DCNL  DCSP if (not unit): DCNL DCSP  DCSP unit = CONF.instance_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP if (before is not None): DCNL DCSP  DCSP rightnow = before DCNL DCSP else: DCNL DCSP  DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
def generate_password(length=None, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL  DCSP if (length is None): DCNL DCSP  DCSP length = CONF.password_length DCNL DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
def xhtml_escape(value): DCNL  DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
def utf8(value): DCNL  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
def to_bytes(text, default=0): DCNL  DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
def delete_if_exists(pathname): DCNL  DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
def get_from_path(items, path): DCNL  DCSP if (path is None): DCNL DCSP  DCSP raise exception.NovaException('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.NovaException('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
def flatten_dict(dict_, flattened=None): DCNL  DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
def partition_dict(dict_, keys): DCNL  DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
def map_dict_keys(dict_, key_map): DCNL  DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
def subset_dict(dict_, keys): DCNL  DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
def diff_dict(orig, new): DCNL  DCSP result = dict(((k, ['-']) for k in (set(orig.keys()) - set(new.keys())))) DCNL DCSP for (key, value) in new.items(): DCNL DCSP  DCSP if ((key not in orig) or (value != orig[key])): DCNL DCSP  DCSP  DCSP result[key] = ['+', value] DCNL DCSP return result
def check_isinstance(obj, cls): DCNL  DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls)))
def parse_server_string(server_str): DCNL  DCSP try: DCNL DCSP  DCSP if netaddr.valid_ipv6(server_str): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP if (server_str.find(']:') != (-1)): DCNL DCSP  DCSP  DCSP (address, port) = server_str.replace('[', '', 1).split(']:') DCNL DCSP  DCSP  DCSP return (address, port) DCNL DCSP  DCSP if (server_str.find(':') == (-1)): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP (address, port) = server_str.split(':') DCNL DCSP  DCSP return (address, port) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('Invalid DCSP server_string: DCSP %s'), server_str) DCNL DCSP  DCSP return ('', '')
def bool_from_str(val): DCNL  DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return ((val.lower() == 'true') or (val.lower() == 'yes') or (val.lower() == 'y'))
def is_int_like(val): DCNL  DCSP try: DCNL DCSP  DCSP return (str(int(val)) == str(val)) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
def is_valid_boolstr(val): DCNL  DCSP boolstrs = ('true', 'false', 'yes', 'no', 'y', 'n', '1', '0') DCNL DCSP return (str(val).lower() in boolstrs)
def is_valid_ipv4(address): DCNL  DCSP try: DCNL DCSP  DCSP return netaddr.valid_ipv4(address) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
def is_valid_cidr(address): DCNL  DCSP try: DCNL DCSP  DCSP netaddr.IPNetwork(address) DCNL DCSP except netaddr.core.AddrFormatError: DCNL DCSP  DCSP return False DCNL DCSP except UnboundLocalError: DCNL DCSP  DCSP return False DCNL DCSP ip_segment = address.split('/') DCNL DCSP if ((len(ip_segment) <= 1) or (ip_segment[1] == '')): DCNL DCSP  DCSP return False DCNL DCSP return True
def get_ip_version(network): DCNL  DCSP if (netaddr.IPNetwork(network).version == 6): DCNL DCSP  DCSP return 'IPv6' DCNL DCSP elif (netaddr.IPNetwork(network).version == 4): DCNL DCSP  DCSP return 'IPv4'
def monkey_patch(): DCNL  DCSP if (not CONF.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in CONF.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
def convert_to_list_dict(lst, label): DCNL  DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
def timefunc(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL  DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
def make_dev_path(dev, partition=None, base='/dev'): DCNL  DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
def total_seconds(td): DCNL  DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
def sanitize_hostname(hostname): DCNL  DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
def read_cached_file(filename, cache_info, reload_func=None): DCNL  DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.debug((_('Reloading DCSP cached DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
def file_open(*args, **kwargs): DCNL  DCSP return file(*args, **kwargs)
def hash_file(file_like_object): DCNL  DCSP checksum = hashlib.sha1() DCNL DCSP for chunk in iter((lambda : file_like_object.read(32768)), ''): DCNL DCSP  DCSP checksum.update(chunk) DCNL DCSP return checksum.hexdigest()
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL  DCSP def is_dict_like(thing): DCNL DCSP  DCSP return hasattr(thing, 'has_key') DCNL DCSP def get(thing, attr, default): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP return thing.get(attr, default) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return getattr(thing, attr, default) DCNL DCSP def set_value(thing, attr, val): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP thing[attr] = val DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(thing, attr, val) DCNL DCSP def delete(thing, attr): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP del thing[attr] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delattr(thing, attr) DCNL DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = get(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP set_value(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP delete(obj, attr) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP set_value(obj, attr, old_value)
def generate_mac_address(): DCNL  DCSP mac = [250, 22, 62, random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
def read_file_as_root(file_path): DCNL  DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL  DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
def walk_class_hierarchy(clazz, encountered=None): DCNL  DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
def mkfs(fs, path, label=None): DCNL  DCSP if (fs == 'swap'): DCNL DCSP  DCSP args = ['mkswap'] DCNL DCSP else: DCNL DCSP  DCSP args = ['mkfs', '-t', fs] DCNL DCSP if (fs in ('ext3', 'ext4')): DCNL DCSP  DCSP args.extend(['-F']) DCNL DCSP if label: DCNL DCSP  DCSP if (fs in ('msdos', 'vfat')): DCNL DCSP  DCSP  DCSP label_opt = '-n' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP label_opt = '-L' DCNL DCSP  DCSP args.extend([label_opt, label]) DCNL DCSP args.append(path) DCNL DCSP execute(*args)
def last_bytes(file_like_object, num): DCNL  DCSP try: DCNL DCSP  DCSP file_like_object.seek((- num), os.SEEK_END) DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == 22): DCNL DCSP  DCSP  DCSP file_like_object.seek(0, os.SEEK_SET) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP remaining = file_like_object.tell() DCNL DCSP return (file_like_object.read(), remaining)
def get_wrapped_function(function): DCNL  DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP return function DCNL DCSP def _get_wrapped_function(function): DCNL DCSP  DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP for closure in function.func_closure: DCNL DCSP  DCSP  DCSP func = closure.cell_contents DCNL DCSP  DCSP  DCSP deeper_func = _get_wrapped_function(func) DCNL DCSP  DCSP  DCSP if deeper_func: DCNL DCSP  DCSP  DCSP  DCSP return deeper_func DCNL DCSP  DCSP  DCSP elif hasattr(closure.cell_contents, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP return closure.cell_contents DCNL DCSP return _get_wrapped_function(function)
def check_string_length(value, name, min_length=0, max_length=None): DCNL  DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP not DCSP a DCSP string DCSP or DCSP unicode') % name) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg) DCNL DCSP if (len(value) < min_length): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP less DCSP than DCSP %(min_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg) DCNL DCSP if (max_length and (len(value) > max_length)): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP more DCSP than DCSP %(max_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg)
def enforce(context, action, target, do_raise=True): DCNL  DCSP init() DCNL DCSP credentials = context.to_dict() DCNL DCSP extra = {} DCNL DCSP if do_raise: DCNL DCSP  DCSP extra.update(exc=exception.PolicyNotAuthorized, action=action) DCNL DCSP return policy.check(action, target, credentials, **extra)
def check_is_admin(context): DCNL  DCSP init() DCNL DCSP credentials = context.to_dict() DCNL DCSP target = credentials DCNL DCSP return policy.check('context_is_admin', target, credentials)
def ensure_ca_filesystem(): DCNL  DCSP ca_dir = ca_folder() DCNL DCSP if (not os.path.exists(ca_path())): DCNL DCSP  DCSP genrootca_sh_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'CA', 'genrootca.sh')) DCNL DCSP  DCSP start = os.getcwd() DCNL DCSP  DCSP fileutils.ensure_tree(ca_dir) DCNL DCSP  DCSP os.chdir(ca_dir) DCNL DCSP  DCSP utils.execute('sh', genrootca_sh_path) DCNL DCSP  DCSP os.chdir(start)
def fetch_crl(project_id): DCNL  DCSP if (not CONF.use_project_ca): DCNL DCSP  DCSP project_id = None DCNL DCSP crl_file_path = crl_path(project_id) DCNL DCSP if (not os.path.exists(crl_file_path)): DCNL DCSP  DCSP raise exception.CryptoCRLFileNotFound(project=project_id) DCNL DCSP with open(crl_file_path, 'r') as crlfile: DCNL DCSP  DCSP return crlfile.read()
def convert_from_sshrsa_to_pkcs8(pubkey): DCNL  DCSP try: DCNL DCSP  DCSP keydata = base64.b64decode(pubkey.split(None)[1]) DCNL DCSP except IndexError: DCNL DCSP  DCSP msg = _('Unable DCSP to DCSP find DCSP the DCSP key') DCNL DCSP  DCSP raise exception.EncryptionFailure(reason=msg) DCNL DCSP parts = [] DCNL DCSP while keydata: DCNL DCSP  DCSP dlen = struct.unpack('>I', keydata[:4])[0] DCNL DCSP  DCSP data = keydata[4:(dlen + 4)] DCNL DCSP  DCSP keydata = keydata[(4 + dlen):] DCNL DCSP  DCSP parts.append(data) DCNL DCSP n_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[2]]))) DCNL DCSP e_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[1]]))) DCNL DCSP pkinfo = _to_sequence(univ.Integer(n_val), univ.Integer(e_val)) DCNL DCSP pklong = long(der_encoder.encode(pkinfo).encode('hex'), 16) DCNL DCSP pkbitstring = univ.BitString(("'00%s'B" % bin(pklong)[2:])) DCNL DCSP oid = _to_sequence(_RSA_OID, univ.Null()) DCNL DCSP pkcs1_seq = _to_sequence(oid, pkbitstring) DCNL DCSP pkcs8 = base64.encodestring(der_encoder.encode(pkcs1_seq)) DCNL DCSP return ('-----BEGIN DCSP PUBLIC DCSP KEY-----\n%s\n-----END DCSP PUBLIC DCSP KEY-----\n' % re.sub('(.{64})', '\\1\n', pkcs8.replace('\n', ''), re.DOTALL))
def ssh_encrypt_text(ssh_public_key, text): DCNL  DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP sslkey = os.path.abspath(os.path.join(tmpdir, 'ssl.key')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP out = convert_from_sshrsa_to_pkcs8(ssh_public_key) DCNL DCSP  DCSP  DCSP with open(sslkey, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(out) DCNL DCSP  DCSP  DCSP (enc, _err) = utils.execute('openssl', 'rsautl', '-encrypt', '-pubin', '-inkey', sslkey, '-keyform', 'PEM', process_input=text) DCNL DCSP  DCSP  DCSP return enc DCNL DCSP  DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP  DCSP raise exception.EncryptionFailure(reason=exc.stderr)
def revoke_cert(project_id, file_name): DCNL  DCSP start = os.getcwd() DCNL DCSP os.chdir(ca_folder(project_id)) DCNL DCSP utils.execute('openssl', 'ca', '-config', './openssl.cnf', '-revoke', file_name) DCNL DCSP utils.execute('openssl', 'ca', '-gencrl', '-config', './openssl.cnf', '-out', CONF.crl_file) DCNL DCSP os.chdir(start)
def revoke_certs_by_user(user_id): DCNL  DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_user(admin, user_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
def revoke_certs_by_project(project_id): DCNL  DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_project(admin, project_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
def revoke_certs_by_user_and_project(user_id, project_id): DCNL  DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_user_and_project(admin, user_id, project_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
def _project_cert_subject(project_id): DCNL  DCSP return (CONF.project_cert_subject % (project_id, timeutils.isotime()))
def _user_cert_subject(user_id, project_id): DCNL  DCSP return (CONF.user_cert_subject % (project_id, user_id, timeutils.isotime()))
def generate_x509_cert(user_id, project_id, bits=1024): DCNL  DCSP subject = _user_cert_subject(user_id, project_id) DCNL DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP keyfile = os.path.abspath(os.path.join(tmpdir, 'temp.key')) DCNL DCSP  DCSP csrfile = os.path.join(tmpdir, 'temp.csr') DCNL DCSP  DCSP utils.execute('openssl', 'genrsa', '-out', keyfile, str(bits)) DCNL DCSP  DCSP utils.execute('openssl', 'req', '-new', '-key', keyfile, '-out', csrfile, '-batch', '-subj', subject) DCNL DCSP  DCSP private_key = open(keyfile).read() DCNL DCSP  DCSP csr = open(csrfile).read() DCNL DCSP (serial, signed_csr) = sign_csr(csr, project_id) DCNL DCSP fname = os.path.join(ca_folder(project_id), ('newcerts/%s.pem' % serial)) DCNL DCSP cert = {'user_id': user_id, 'project_id': project_id, 'file_name': fname} DCNL DCSP db.certificate_create(context.get_admin_context(), cert) DCNL DCSP return (private_key, signed_csr)
def compute_md5(fp): DCNL  DCSP m = hashlib.md5() DCNL DCSP fp.seek(0) DCNL DCSP s = fp.read(8192) DCNL DCSP while s: DCNL DCSP  DCSP m.update(s) DCNL DCSP  DCSP s = fp.read(8192) DCNL DCSP hex_md5 = m.hexdigest() DCNL DCSP fp.seek(0) DCNL DCSP return hex_md5
def periodic_task(*args, **kwargs): DCNL  DCSP def decorator(f): DCNL DCSP  DCSP if ('ticks_between_runs' in kwargs): DCNL DCSP  DCSP  DCSP raise exception.InvalidPeriodicTaskArg(arg='ticks_between_runs') DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._periodic_external_ok = kwargs.pop('external_process_ok', False) DCNL DCSP  DCSP if (f._periodic_external_ok and (not CONF.run_external_periodic_tasks)): DCNL DCSP  DCSP  DCSP f._periodic_enabled = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._periodic_enabled = kwargs.pop('enabled', True) DCNL DCSP  DCSP f._periodic_spacing = kwargs.pop('spacing', 0) DCNL DCSP  DCSP if kwargs.pop('run_immediately', False): DCNL DCSP  DCSP  DCSP f._periodic_last_run = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._periodic_last_run = time.time() DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
def properties_root_device_name(properties): DCNL  DCSP root_device_name = None DCNL DCSP for bdm in properties.get('mappings', []): DCNL DCSP  DCSP if (bdm['virtual'] == 'root'): DCNL DCSP  DCSP  DCSP root_device_name = bdm['device'] DCNL DCSP if ('root_device_name' in properties): DCNL DCSP  DCSP root_device_name = properties['root_device_name'] DCNL DCSP return root_device_name
def mappings_prepend_dev(mappings): DCNL  DCSP for m in mappings: DCNL DCSP  DCSP virtual = m['virtual'] DCNL DCSP  DCSP if (is_swap_or_ephemeral(virtual) and (not m['device'].startswith('/'))): DCNL DCSP  DCSP  DCSP m['device'] = ('/dev/' + m['device']) DCNL DCSP return mappings
def strip_dev(device_name): DCNL  DCSP return (_dev.sub('', device_name) if device_name else device_name)
def strip_prefix(device_name): DCNL  DCSP device_name = strip_dev(device_name) DCNL DCSP return _pref.sub('', device_name)
def match_device(device): DCNL  DCSP match = re.match('(^/dev/x{0,1}[a-z]{0,1}d{0,1})([a-z]+)[0-9]*$', device) DCNL DCSP if (not match): DCNL DCSP  DCSP return None DCNL DCSP return match.groups()
def downgrade(migrate_engine): DCNL  DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is not postgresql.dialect): DCNL DCSP  DCSP meta = MetaData(bind=migrate_engine) DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(255))
def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for column in ('period_beginning', 'period_ending'): DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP task_log DCSP ALTER DCSP COLUMN DCSP %s DCSP TYPE DCSP TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE DCSP USING DCSP %s::TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE' % (column, column))) DCNL DCSP else: DCNL DCSP  DCSP migrations = Table('task_log', meta, autoload=True) DCNL DCSP  DCSP migrations.c.period_beginning.alter(DateTime) DCNL DCSP  DCSP migrations.c.period_ending.alter(DateTime)
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP migrations = Table('task_log', meta, autoload=True) DCNL DCSP migrations.c.period_beginning.alter(String(255)) DCNL DCSP migrations.c.period_ending.alter(String(255))
def _drop_index(engine, table, idx_name): DCNL  DCSP for idx in getattr(table, 'indexes'): DCNL DCSP  DCSP if (idx.name == idx_name): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Index DCSP '%s' DCSP not DCSP found!" % idx_name)) DCNL DCSP idx.drop(engine) DCNL DCSP table.indexes.remove(idx)
def _map_nodes(meta): DCNL  DCSP services = Table('services', meta, autoload=True) DCNL DCSP c_nodes = Table('compute_nodes', meta, autoload=True) DCNL DCSP q = select([services.c.host, c_nodes.c.hypervisor_hostname], whereclause=and_((c_nodes.c.deleted == False), (services.c.deleted == False)), from_obj=c_nodes.join(services, (c_nodes.c.service_id == services.c.id))) DCNL DCSP nodemap = {} DCNL DCSP for (host, node) in q.execute(): DCNL DCSP  DCSP nodes = nodemap.setdefault(host, []) DCNL DCSP  DCSP nodes.append(node) DCNL DCSP return nodemap
def _update_nodes(nodemap, instances, migrations): DCNL  DCSP q = select([migrations.c.id, migrations.c.source_compute, migrations.c.dest_compute, instances.c.uuid, instances.c.host, instances.c.node], whereclause=and_((migrations.c.source_compute != None), (migrations.c.dest_compute != None), (instances.c.deleted == False), (migrations.c.status != 'reverted'), (migrations.c.status != 'error')), from_obj=migrations.join(instances, (migrations.c.instance_uuid == instances.c.uuid))) DCNL DCSP result = q.execute() DCNL DCSP for (migration_id, src, dest, uuid, instance_host, instance_node) in result: DCNL DCSP  DCSP values = {} DCNL DCSP  DCSP nodes = nodemap.get(src, []) DCNL DCSP  DCSP if (len(nodes) == 1): DCNL DCSP  DCSP  DCSP node = nodes[0] DCNL DCSP  DCSP  DCSP values['source_node'] = node DCNL DCSP  DCSP  DCSP if ((src == instance_host) and (node != instance_node)): DCNL DCSP  DCSP  DCSP  DCSP update(instances).where((instances.c.uuid == uuid)).values(node=node) DCNL DCSP  DCSP nodes = nodemap.get(dest, []) DCNL DCSP  DCSP if (len(nodes) == 1): DCNL DCSP  DCSP  DCSP node = nodes[0] DCNL DCSP  DCSP  DCSP values['dest_node'] = node DCNL DCSP  DCSP  DCSP if ((dest == instance_host) and (node != instance_node)): DCNL DCSP  DCSP  DCSP  DCSP update(instances).where((instances.c.uuid == uuid)).values(node=node) DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP q = update(migrations, values=values, whereclause=(migrations.c.id == migration_id)) DCNL DCSP  DCSP  DCSP q.execute()
def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
def downgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(39))
def _find_migrate_repo(): DCNL  DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
def drop_unique_constraint(migrate_engine, table_name, uc_name, *columns, **col_name_col_instance): DCNL  DCSP if (migrate_engine.name in ['mysql', 'postgresql']): DCNL DCSP  DCSP meta = MetaData() DCNL DCSP  DCSP meta.bind = migrate_engine DCNL DCSP  DCSP t = Table(table_name, meta, autoload=True) DCNL DCSP  DCSP uc = UniqueConstraint(table=t, name=uc_name, *columns) DCNL DCSP  DCSP uc.drop() DCNL DCSP else: DCNL DCSP  DCSP _drop_unique_constraint_in_sqlite(migrate_engine, table_name, uc_name, **col_name_col_instance)
def drop_old_duplicate_entries_from_table(migrate_engine, table_name, use_soft_delete, *uc_column_names): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP table = Table(table_name, meta, autoload=True) DCNL DCSP columns_for_group_by = [table.c[name] for name in uc_column_names] DCNL DCSP columns_for_select = [func.max(table.c.id)] DCNL DCSP columns_for_select.extend(list(columns_for_group_by)) DCNL DCSP duplicated_rows_select = select(columns_for_select, group_by=columns_for_group_by, having=(func.count(table.c.id) > 1)) DCNL DCSP for row in migrate_engine.execute(duplicated_rows_select): DCNL DCSP  DCSP delete_condition = (table.c.id != row[0]) DCNL DCSP  DCSP for name in uc_column_names: DCNL DCSP  DCSP  DCSP delete_condition &= (table.c[name] == row[name]) DCNL DCSP  DCSP rows_to_delete_select = select([table.c.id]).where(delete_condition) DCNL DCSP  DCSP for row in migrate_engine.execute(rows_to_delete_select).fetchall(): DCNL DCSP  DCSP  DCSP LOG.info((_('Deleted DCSP duplicated DCSP row DCSP with DCSP id: DCSP %(id)s DCSP from DCSP table: DCSP %(table)s') % dict(id=row[0], table=table_name))) DCNL DCSP  DCSP if use_soft_delete: DCNL DCSP  DCSP  DCSP delete_statement = table.update().where(delete_condition).values({'deleted': literal_column('id'), 'updated_at': literal_column('updated_at'), 'deleted_at': timeutils.utcnow()}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delete_statement = table.delete().where(delete_condition) DCNL DCSP  DCSP migrate_engine.execute(delete_statement)
def get_backend(): DCNL  DCSP return sys.modules[__name__]
def require_admin_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.require_admin_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_context(f): DCNL  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.require_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
def require_instance_exists_using_uuid(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(context, instance_uuid, *args, **kwargs): DCNL DCSP  DCSP instance_get_by_uuid(context, instance_uuid) DCNL DCSP  DCSP return f(context, instance_uuid, *args, **kwargs) DCNL DCSP return wrapper
def require_aggregate_exists(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(context, aggregate_id, *args, **kwargs): DCNL DCSP  DCSP aggregate_get(context, aggregate_id) DCNL DCSP  DCSP return f(context, aggregate_id, *args, **kwargs) DCNL DCSP return wrapper
def _retry_on_deadlock(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapped(*args, **kwargs): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP except db_exc.DBDeadlock: DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_("Deadlock DCSP detected DCSP when DCSP running DCSP '%(func_name)s': DCSP Retrying..."), dict(func_name=f.__name__)) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP functools.update_wrapper(wrapped, f) DCNL DCSP return wrapped
def model_query(context, model, *args, **kwargs): DCNL  DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only', False) DCNL DCSP def issubclassof_nova_base(obj): DCNL DCSP  DCSP return (isinstance(obj, type) and issubclass(obj, models.NovaBase)) DCNL DCSP base_model = model DCNL DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP base_model = kwargs.get('base_model', None) DCNL DCSP  DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP  DCSP raise Exception(_('model DCSP or DCSP base_model DCSP parameter DCSP should DCSP be DCSP subclass DCSP of DCSP NovaBase')) DCNL DCSP query = session.query(model, *args) DCNL DCSP default_deleted_value = base_model.__mapper__.c.deleted.default.arg DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter((base_model.deleted == default_deleted_value)) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter((base_model.deleted != default_deleted_value)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (nova.context.is_user_context(context) and project_only): DCNL DCSP  DCSP if (project_only == 'allow_none'): DCNL DCSP  DCSP  DCSP query = query.filter(or_((base_model.project_id == context.project_id), (base_model.project_id == None))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
def exact_filter(query, model, filters, legal_keys): DCNL  DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if (key == 'metadata'): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP for item in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in item.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(value=v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(value=v)) DCNL DCSP  DCSP elif isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
def _prep_stats_dict(values): DCNL  DCSP stats = [] DCNL DCSP d = values.get('stats', {}) DCNL DCSP for (k, v) in d.iteritems(): DCNL DCSP  DCSP stat = models.ComputeNodeStat() DCNL DCSP  DCSP stat['key'] = k DCNL DCSP  DCSP stat['value'] = v DCNL DCSP  DCSP stats.append(stat) DCNL DCSP values['stats'] = stats
@require_admin_context DCNL def compute_node_create(context, values): DCNL  DCSP _prep_stats_dict(values) DCNL DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP compute_node_ref = models.ComputeNode() DCNL DCSP compute_node_ref.update(values) DCNL DCSP compute_node_ref.save() DCNL DCSP return compute_node_ref
@require_admin_context DCNL def compute_node_update(context, compute_id, values, prune_stats=False): DCNL  DCSP stats = values.pop('stats', {}) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP _update_stats(context, stats, compute_id, session, prune_stats) DCNL DCSP  DCSP compute_ref = _compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP if ('updated_at' not in values): DCNL DCSP  DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref.update(values) DCNL DCSP return compute_ref
@require_admin_context DCNL def compute_node_delete(context, compute_id): DCNL  DCSP result = model_query(context, models.ComputeNode).filter_by(id=compute_id).soft_delete() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ComputeHostNotFound(host=compute_id)
def compute_node_statistics(context): DCNL  DCSP result = model_query(context, func.count(models.ComputeNode.id), func.sum(models.ComputeNode.vcpus), func.sum(models.ComputeNode.memory_mb), func.sum(models.ComputeNode.local_gb), func.sum(models.ComputeNode.vcpus_used), func.sum(models.ComputeNode.memory_mb_used), func.sum(models.ComputeNode.local_gb_used), func.sum(models.ComputeNode.free_ram_mb), func.sum(models.ComputeNode.free_disk_gb), func.sum(models.ComputeNode.current_workload), func.sum(models.ComputeNode.running_vms), func.sum(models.ComputeNode.disk_available_least), base_model=models.ComputeNode, read_deleted='no').first() DCNL DCSP fields = ('count', 'vcpus', 'memory_mb', 'local_gb', 'vcpus_used', 'memory_mb_used', 'local_gb_used', 'free_ram_mb', 'free_disk_gb', 'current_workload', 'running_vms', 'disk_available_least') DCNL DCSP return dict(((field, int((result[idx] or 0))) for (idx, field) in enumerate(fields)))
def _ip_range_splitter(ips, block_size=256): DCNL  DCSP out = [] DCNL DCSP count = 0 DCNL DCSP for ip in ips: DCNL DCSP  DCSP out.append(ip['address']) DCNL DCSP  DCSP count += 1 DCNL DCSP  DCSP if (count > (block_size - 1)): DCNL DCSP  DCSP  DCSP (yield out) DCNL DCSP  DCSP  DCSP out = [] DCNL DCSP  DCSP  DCSP count = 0 DCNL DCSP if out: DCNL DCSP  DCSP (yield out)
@require_admin_context DCNL def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL  DCSP if (not uuidutils.is_uuid_like(instance_uuid)): DCNL DCSP  DCSP raise exception.InvalidUUID(uuid=instance_uuid) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP network_or_none = or_((models.FixedIp.network_id == network_id), (models.FixedIp.network_id == None)) DCNL DCSP  DCSP fixed_ip_ref = model_query(context, models.FixedIp, session=session, read_deleted='no').filter(network_or_none).filter_by(reserved=reserved).filter_by(address=address).with_lockmode('update').first() DCNL DCSP  DCSP if (fixed_ip_ref is None): DCNL DCSP  DCSP  DCSP raise exception.FixedIpNotFoundForNetwork(address=address, network_uuid=network_id) DCNL DCSP  DCSP if fixed_ip_ref.instance_uuid: DCNL DCSP  DCSP  DCSP raise exception.FixedIpAlreadyInUse(address=address, instance_uuid=instance_uuid) DCNL DCSP  DCSP if (not fixed_ip_ref.network_id): DCNL DCSP  DCSP  DCSP fixed_ip_ref.network_id = network_id DCNL DCSP  DCSP fixed_ip_ref.instance_uuid = instance_uuid DCNL DCSP  DCSP session.add(fixed_ip_ref) DCNL DCSP return fixed_ip_ref['address']
@require_admin_context DCNL def fixed_ip_get_by_address_detailed(context, address, session=None): DCNL  DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP result = model_query(context, models.FixedIp, models.Network, models.Instance, session=session).filter_by(address=address).outerjoin((models.Network, (models.Network.id == models.FixedIp.network_id))).outerjoin((models.Instance, (models.Instance.uuid == models.FixedIp.instance_uuid))).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FixedIpNotFoundForAddress(address=address) DCNL DCSP return result
@require_context DCNL def virtual_interface_create(context, values): DCNL  DCSP try: DCNL DCSP  DCSP vif_ref = models.VirtualInterface() DCNL DCSP  DCSP vif_ref.update(values) DCNL DCSP  DCSP vif_ref.save() DCNL DCSP except db_exc.DBError: DCNL DCSP  DCSP raise exception.VirtualInterfaceCreateException() DCNL DCSP return vif_ref
@require_context DCNL def virtual_interface_get(context, vif_id): DCNL  DCSP vif_ref = _virtual_interface_query(context).filter_by(id=vif_id).first() DCNL DCSP return vif_ref
@require_context DCNL def virtual_interface_get_by_address(context, address): DCNL  DCSP vif_ref = _virtual_interface_query(context).filter_by(address=address).first() DCNL DCSP return vif_ref
@require_context DCNL def virtual_interface_get_by_uuid(context, vif_uuid): DCNL  DCSP vif_ref = _virtual_interface_query(context).filter_by(uuid=vif_uuid).first() DCNL DCSP return vif_ref
@require_context DCNL @require_instance_exists_using_uuid DCNL def virtual_interface_get_by_instance(context, instance_uuid): DCNL  DCSP vif_refs = _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).all() DCNL DCSP return vif_refs
@require_context DCNL def virtual_interface_get_by_instance_and_network(context, instance_uuid, network_id): DCNL  DCSP vif_ref = _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).filter_by(network_id=network_id).first() DCNL DCSP return vif_ref
@require_context DCNL def virtual_interface_delete_by_instance(context, instance_uuid): DCNL  DCSP _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).delete()
@require_context DCNL def virtual_interface_get_all(context): DCNL  DCSP vif_refs = _virtual_interface_query(context).all() DCNL DCSP return vif_refs
@require_context DCNL def instance_create(context, values): DCNL  DCSP values = values.copy() DCNL DCSP values['metadata'] = _metadata_refs(values.get('metadata'), models.InstanceMetadata) DCNL DCSP values['system_metadata'] = _metadata_refs(values.get('system_metadata'), models.InstanceSystemMetadata) DCNL DCSP instance_ref = models.Instance() DCNL DCSP if (not values.get('uuid')): DCNL DCSP  DCSP values['uuid'] = str(uuid.uuid4()) DCNL DCSP instance_ref['info_cache'] = models.InstanceInfoCache() DCNL DCSP info_cache = values.pop('info_cache', None) DCNL DCSP if (info_cache is not None): DCNL DCSP  DCSP instance_ref['info_cache'].update(info_cache) DCNL DCSP security_groups = values.pop('security_groups', []) DCNL DCSP instance_ref.update(values) DCNL DCSP def _get_sec_group_models(session, security_groups): DCNL DCSP  DCSP models = [] DCNL DCSP  DCSP (_existed, default_group) = security_group_ensure_default(context, session=session) DCNL DCSP  DCSP if ('default' in security_groups): DCNL DCSP  DCSP  DCSP models.append(default_group) DCNL DCSP  DCSP  DCSP security_groups = [x for x in security_groups if (x != 'default')] DCNL DCSP  DCSP if security_groups: DCNL DCSP  DCSP  DCSP models.extend(_security_group_get_by_names(context, session, context.project_id, security_groups)) DCNL DCSP  DCSP return models DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP if ('hostname' in values): DCNL DCSP  DCSP  DCSP _validate_unique_server_name(context, session, values['hostname']) DCNL DCSP  DCSP instance_ref.security_groups = _get_sec_group_models(session, security_groups) DCNL DCSP  DCSP instance_ref.save(session=session) DCNL DCSP ec2_instance_create(context, instance_ref['uuid']) DCNL DCSP return instance_ref
def _instances_fill_metadata(context, instances, manual_joins=None): DCNL  DCSP uuids = [inst['uuid'] for inst in instances] DCNL DCSP if (manual_joins is None): DCNL DCSP  DCSP manual_joins = ['metadata', 'system_metadata'] DCNL DCSP meta = collections.defaultdict(list) DCNL DCSP if ('metadata' in manual_joins): DCNL DCSP  DCSP for row in _instance_metadata_get_multi(context, uuids): DCNL DCSP  DCSP  DCSP meta[row['instance_uuid']].append(row) DCNL DCSP sys_meta = collections.defaultdict(list) DCNL DCSP if ('system_metadata' in manual_joins): DCNL DCSP  DCSP for row in _instance_system_metadata_get_multi(context, uuids): DCNL DCSP  DCSP  DCSP sys_meta[row['instance_uuid']].append(row) DCNL DCSP filled_instances = [] DCNL DCSP for inst in instances: DCNL DCSP  DCSP inst = dict(inst.iteritems()) DCNL DCSP  DCSP inst['system_metadata'] = sys_meta[inst['uuid']] DCNL DCSP  DCSP inst['metadata'] = meta[inst['uuid']] DCNL DCSP  DCSP filled_instances.append(inst) DCNL DCSP return filled_instances
@require_context DCNL def instance_get_all_by_filters(context, filters, sort_key, sort_dir, limit=None, marker=None, columns_to_join=None, session=None): DCNL  DCSP sort_fn = {'desc': desc, 'asc': asc} DCNL DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP if (columns_to_join is None): DCNL DCSP  DCSP columns_to_join = ['info_cache', 'security_groups'] DCNL DCSP  DCSP manual_joins = ['metadata', 'system_metadata'] DCNL DCSP else: DCNL DCSP  DCSP (manual_joins, columns_to_join) = _manual_join_columns(columns_to_join) DCNL DCSP query_prefix = session.query(models.Instance) DCNL DCSP for column in columns_to_join: DCNL DCSP  DCSP query_prefix = query_prefix.options(joinedload(column)) DCNL DCSP query_prefix = query_prefix.order_by(sort_fn[sort_dir](getattr(models.Instance, sort_key))) DCNL DCSP filters = filters.copy() DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters['changes-since']) DCNL DCSP  DCSP query_prefix = query_prefix.filter((models.Instance.updated_at > changes_since)) DCNL DCSP if ('deleted' in filters): DCNL DCSP  DCSP if filters.pop('deleted'): DCNL DCSP  DCSP  DCSP deleted = or_((models.Instance.deleted == models.Instance.id), (models.Instance.vm_state == vm_states.SOFT_DELETED)) DCNL DCSP  DCSP  DCSP query_prefix = query_prefix.filter(deleted) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query_prefix = query_prefix.filter_by(deleted=0).filter((models.Instance.vm_state != vm_states.SOFT_DELETED)) DCNL DCSP if (not context.is_admin): DCNL DCSP  DCSP if context.project_id: DCNL DCSP  DCSP  DCSP filters['project_id'] = context.project_id DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filters['user_id'] = context.user_id DCNL DCSP exact_match_filter_names = ['project_id', 'user_id', 'image_ref', 'vm_state', 'instance_type_id', 'uuid', 'metadata'] DCNL DCSP query_prefix = exact_filter(query_prefix, models.Instance, filters, exact_match_filter_names) DCNL DCSP query_prefix = regex_filter(query_prefix, models.Instance, filters) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP marker = _instance_get_by_uuid(context, marker, session=session) DCNL DCSP  DCSP except exception.InstanceNotFound: DCNL DCSP  DCSP  DCSP raise exception.MarkerNotFound(marker) DCNL DCSP query_prefix = sqlalchemyutils.paginate_query(query_prefix, models.Instance, limit, [sort_key, 'created_at', 'id'], marker=marker, sort_dir=sort_dir) DCNL DCSP return _instances_fill_metadata(context, query_prefix.all(), manual_joins)
def regex_filter(query, model, filters): DCNL  DCSP regexp_op_map = {'postgresql': '~', 'mysql': 'REGEXP', 'oracle': 'REGEXP_LIKE', 'sqlite': 'REGEXP'} DCNL DCSP db_string = CONF.sql_connection.split(':')[0].split('+')[0] DCNL DCSP db_regexp_op = regexp_op_map.get(db_string, 'LIKE') DCNL DCSP for filter_name in filters.iterkeys(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column_attr = getattr(model, filter_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('property' == type(column_attr).__name__): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP query = query.filter(column_attr.op(db_regexp_op)(str(filters[filter_name]))) DCNL DCSP return query
@require_context DCNL def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL  DCSP session = get_session() DCNL DCSP query = session.query(models.Instance) DCNL DCSP query = query.options(joinedload('info_cache')).options(joinedload('security_groups')).filter(or_((models.Instance.terminated_at == None), (models.Instance.terminated_at > begin))) DCNL DCSP if end: DCNL DCSP  DCSP query = query.filter((models.Instance.launched_at < end)) DCNL DCSP if project_id: DCNL DCSP  DCSP query = query.filter_by(project_id=project_id) DCNL DCSP if host: DCNL DCSP  DCSP query = query.filter_by(host=host) DCNL DCSP return _instances_fill_metadata(context, query.all())
@require_admin_context DCNL def _instance_get_all_uuids_by_host(context, host, session=None): DCNL  DCSP uuids = [] DCNL DCSP for tuple in model_query(context, models.Instance.uuid, read_deleted='no', base_model=models.Instance, session=session).filter_by(host=host).all(): DCNL DCSP  DCSP uuids.append(tuple[0]) DCNL DCSP return uuids
@require_context DCNL def instance_update_and_get_original(context, instance_uuid, values): DCNL  DCSP return _instance_update(context, instance_uuid, values, copy_old_instance=True)
def instance_add_security_group(context, instance_uuid, security_group_id): DCNL  DCSP sec_group_ref = models.SecurityGroupInstanceAssociation() DCNL DCSP sec_group_ref.update({'instance_uuid': instance_uuid, 'security_group_id': security_group_id}) DCNL DCSP sec_group_ref.save()
@require_context DCNL def instance_remove_security_group(context, instance_uuid, security_group_id): DCNL  DCSP model_query(context, models.SecurityGroupInstanceAssociation).filter_by(instance_uuid=instance_uuid).filter_by(security_group_id=security_group_id).soft_delete()
@require_context DCNL def instance_info_cache_get(context, instance_uuid): DCNL  DCSP return model_query(context, models.InstanceInfoCache).filter_by(instance_uuid=instance_uuid).first()
@require_context DCNL def instance_info_cache_update(context, instance_uuid, values): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP info_cache = model_query(context, models.InstanceInfoCache, session=session).filter_by(instance_uuid=instance_uuid).first() DCNL DCSP  DCSP if (info_cache and info_cache['deleted']): DCNL DCSP  DCSP  DCSP raise exception.InstanceInfoCacheNotFound(instance_uuid=instance_uuid) DCNL DCSP  DCSP elif (not info_cache): DCNL DCSP  DCSP  DCSP info_cache = models.InstanceInfoCache() DCNL DCSP  DCSP  DCSP values['instance_uuid'] = instance_uuid DCNL DCSP  DCSP info_cache.update(values) DCNL DCSP return info_cache
@require_context DCNL def instance_info_cache_delete(context, instance_uuid): DCNL  DCSP model_query(context, models.InstanceInfoCache).filter_by(instance_uuid=instance_uuid).soft_delete()
@require_admin_context DCNL def network_associate(context, project_id, network_id=None, force=False): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP def network_query(project_filter, id=None): DCNL DCSP  DCSP  DCSP filter_kwargs = {'project_id': project_filter} DCNL DCSP  DCSP  DCSP if (id is not None): DCNL DCSP  DCSP  DCSP  DCSP filter_kwargs['id'] = id DCNL DCSP  DCSP  DCSP return model_query(context, models.Network, session=session, read_deleted='no').filter_by(**filter_kwargs).with_lockmode('update').first() DCNL DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP network_ref = network_query(project_id) DCNL DCSP  DCSP if (force or (not network_ref)): DCNL DCSP  DCSP  DCSP network_ref = network_query(None, network_id) DCNL DCSP  DCSP  DCSP if (not network_ref): DCNL DCSP  DCSP  DCSP  DCSP raise db.NoMoreNetworks() DCNL DCSP  DCSP  DCSP network_ref['project_id'] = project_id DCNL DCSP  DCSP  DCSP session.add(network_ref) DCNL DCSP return network_ref
def _quota_reservations_query(session, context, reservations): DCNL  DCSP return model_query(context, models.Reservation, read_deleted='no', session=session).filter(models.Reservation.uuid.in_(reservations)).with_lockmode('update')
@require_context DCNL def ec2_volume_create(context, volume_uuid, id=None): DCNL  DCSP ec2_volume_ref = models.VolumeIdMapping() DCNL DCSP ec2_volume_ref.update({'uuid': volume_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_volume_ref.update({'id': id}) DCNL DCSP ec2_volume_ref.save() DCNL DCSP return ec2_volume_ref
@require_context DCNL def ec2_snapshot_create(context, snapshot_uuid, id=None): DCNL  DCSP ec2_snapshot_ref = models.SnapshotIdMapping() DCNL DCSP ec2_snapshot_ref.update({'uuid': snapshot_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_snapshot_ref.update({'id': id}) DCNL DCSP ec2_snapshot_ref.save() DCNL DCSP return ec2_snapshot_ref
def _security_group_get_by_names(context, session, project_id, group_names): DCNL  DCSP query = _security_group_get_query(context, session=session, read_deleted='no', join_rules=False).filter_by(project_id=project_id).filter(models.SecurityGroup.name.in_(group_names)) DCNL DCSP sg_models = query.all() DCNL DCSP if (len(sg_models) == len(group_names)): DCNL DCSP  DCSP return sg_models DCNL DCSP group_names_from_models = [x.name for x in sg_models] DCNL DCSP for group_name in group_names: DCNL DCSP  DCSP if (group_name not in group_names_from_models): DCNL DCSP  DCSP  DCSP raise exception.SecurityGroupNotFoundForProject(project_id=project_id, security_group_id=group_name)
def security_group_ensure_default(context, session=None): DCNL  DCSP try: DCNL DCSP  DCSP default_group = security_group_get_by_name(context, context.project_id, 'default', columns_to_join=[], session=session) DCNL DCSP  DCSP return (True, default_group) DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP values = {'name': 'default', 'description': 'default', 'user_id': context.user_id, 'project_id': context.project_id} DCNL DCSP  DCSP default_group = security_group_create(context, values, session=session) DCNL DCSP  DCSP for default_rule in security_group_default_rule_list(context): DCNL DCSP  DCSP  DCSP rule_values = {'protocol': default_rule.protocol, 'from_port': default_rule.from_port, 'to_port': default_rule.to_port, 'cidr': default_rule.cidr, 'parent_group_id': default_group.id} DCNL DCSP  DCSP  DCSP security_group_rule_create(context, rule_values) DCNL DCSP  DCSP return (False, default_group)
@require_admin_context DCNL def instance_type_create(context, values): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeExists(name=values['name']) DCNL DCSP  DCSP except exception.InstanceTypeNotFoundByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_flavor_id(context, values['flavorid'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeIdExists(flavor_id=values['flavorid']) DCNL DCSP  DCSP except exception.FlavorNotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP specs = values.get('extra_specs') DCNL DCSP  DCSP  DCSP specs_refs = [] DCNL DCSP  DCSP  DCSP if specs: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in specs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref = models.InstanceTypeExtraSpecs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['key'] = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['value'] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_refs.append(specs_ref) DCNL DCSP  DCSP  DCSP values['extra_specs'] = specs_refs DCNL DCSP  DCSP  DCSP instance_type_ref = models.InstanceTypes() DCNL DCSP  DCSP  DCSP instance_type_ref.update(values) DCNL DCSP  DCSP  DCSP instance_type_ref.save(session=session) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise db_exc.DBError(e) DCNL DCSP  DCSP return _dict_with_extra_specs(instance_type_ref)
def _dict_with_extra_specs(inst_type_query): DCNL  DCSP inst_type_dict = dict(inst_type_query) DCNL DCSP extra_specs = dict([(x['key'], x['value']) for x in inst_type_query['extra_specs']]) DCNL DCSP inst_type_dict['extra_specs'] = extra_specs DCNL DCSP return inst_type_dict
@require_context DCNL def instance_type_get_all(context, inactive=False, filters=None): DCNL  DCSP filters = (filters or {}) DCNL DCSP read_deleted = ('yes' if inactive else 'no') DCNL DCSP query = _instance_type_get_query(context, read_deleted=read_deleted) DCNL DCSP if ('min_memory_mb' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.memory_mb >= filters['min_memory_mb'])) DCNL DCSP if ('min_root_gb' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.root_gb >= filters['min_root_gb'])) DCNL DCSP if ('disabled' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.disabled == filters['disabled'])) DCNL DCSP if (('is_public' in filters) and (filters['is_public'] is not None)): DCNL DCSP  DCSP the_filter = [(models.InstanceTypes.is_public == filters['is_public'])] DCNL DCSP  DCSP if (filters['is_public'] and (context.project_id is not None)): DCNL DCSP  DCSP  DCSP the_filter.extend([models.InstanceTypes.projects.any(project_id=context.project_id, deleted=0)]) DCNL DCSP  DCSP if (len(the_filter) > 1): DCNL DCSP  DCSP  DCSP query = query.filter(or_(*the_filter)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter(the_filter[0]) DCNL DCSP  DCSP del filters['is_public'] DCNL DCSP inst_types = query.order_by('name').all() DCNL DCSP return [_dict_with_extra_specs(i) for i in inst_types]
@require_context DCNL def instance_type_get(context, id, session=None): DCNL  DCSP result = _instance_type_get_query(context, session=session).filter_by(id=id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFound(instance_type_id=id) DCNL DCSP return _dict_with_extra_specs(result)
@require_context DCNL def instance_type_get_by_name(context, name, session=None): DCNL  DCSP result = _instance_type_get_query(context, session=session).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFoundByName(instance_type_name=name) DCNL DCSP return _dict_with_extra_specs(result)
@require_context DCNL def instance_type_get_by_flavor_id(context, flavor_id, session=None): DCNL  DCSP result = _instance_type_get_query(context, session=session).filter_by(flavorid=flavor_id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FlavorNotFound(flavor_id=flavor_id) DCNL DCSP return _dict_with_extra_specs(result)
@require_admin_context DCNL def instance_type_destroy(context, name): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_name(context, name, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP session.query(models.InstanceTypes).filter_by(id=instance_type_id).soft_delete() DCNL DCSP  DCSP session.query(models.InstanceTypeExtraSpecs).filter_by(instance_type_id=instance_type_id).soft_delete()
@require_admin_context DCNL def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL  DCSP instance_type_ref = _instance_type_get_query(context).filter_by(flavorid=flavor_id).first() DCNL DCSP return [r for r in instance_type_ref.projects]
@require_admin_context DCNL def instance_type_access_add(context, flavor_id, project_id): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_id(context, flavor_id, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP access_ref = _instance_type_access_query(context, session=session).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).first() DCNL DCSP  DCSP if access_ref: DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessExists(flavor_id=flavor_id, project_id=project_id) DCNL DCSP  DCSP access_ref = models.InstanceTypeProjects() DCNL DCSP  DCSP access_ref.update({'instance_type_id': instance_type_id, 'project_id': project_id}) DCNL DCSP  DCSP access_ref.save(session=session) DCNL DCSP  DCSP return access_ref
@require_admin_context DCNL def instance_type_access_remove(context, flavor_id, project_id): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_id(context, flavor_id, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP count = _instance_type_access_query(context, session=session).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).soft_delete() DCNL DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessNotFound(flavor_id=flavor_id, project_id=project_id)
@require_context DCNL def vol_get_usage_by_time(context, begin): DCNL  DCSP return model_query(context, models.VolumeUsage, read_deleted='yes').filter(or_((models.VolumeUsage.tot_last_refreshed == None), (models.VolumeUsage.tot_last_refreshed > begin), (models.VolumeUsage.curr_last_refreshed == None), (models.VolumeUsage.curr_last_refreshed > begin))).all()
def s3_image_get(context, image_id): DCNL  DCSP result = model_query(context, models.S3Image, read_deleted='yes').filter_by(id=image_id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFound(image_id=image_id) DCNL DCSP return result
def s3_image_get_by_uuid(context, image_uuid): DCNL  DCSP result = model_query(context, models.S3Image, read_deleted='yes').filter_by(uuid=image_uuid).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFound(image_id=image_uuid) DCNL DCSP return result
def s3_image_create(context, image_uuid): DCNL  DCSP try: DCNL DCSP  DCSP s3_image_ref = models.S3Image() DCNL DCSP  DCSP s3_image_ref.update({'uuid': image_uuid}) DCNL DCSP  DCSP s3_image_ref.save() DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise db_exc.DBError(e) DCNL DCSP return s3_image_ref
def instance_fault_create(context, values): DCNL  DCSP fault_ref = models.InstanceFault() DCNL DCSP fault_ref.update(values) DCNL DCSP fault_ref.save() DCNL DCSP return dict(fault_ref.iteritems())
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL  DCSP rows = model_query(context, models.InstanceFault, read_deleted='no').filter(models.InstanceFault.instance_uuid.in_(instance_uuids)).order_by(desc('created_at'), desc('id')).all() DCNL DCSP output = {} DCNL DCSP for instance_uuid in instance_uuids: DCNL DCSP  DCSP output[instance_uuid] = [] DCNL DCSP for row in rows: DCNL DCSP  DCSP data = dict(row.iteritems()) DCNL DCSP  DCSP output[row['instance_uuid']].append(data) DCNL DCSP return output
def actions_get(context, instance_uuid): DCNL  DCSP actions = model_query(context, models.InstanceAction).filter_by(instance_uuid=instance_uuid).order_by(desc('created_at')).all() DCNL DCSP return actions
def action_get_by_request_id(context, instance_uuid, request_id): DCNL  DCSP action = _action_get_by_request_id(context, instance_uuid, request_id) DCNL DCSP return action
def action_event_start(context, values): DCNL  DCSP convert_datetimes(values, 'start_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_request_id(context, values['instance_uuid'], values['request_id'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFound(request_id=values['request_id'], instance_uuid=values['instance_uuid']) DCNL DCSP  DCSP values['action_id'] = action['id'] DCNL DCSP  DCSP event_ref = models.InstanceActionEvent() DCNL DCSP  DCSP event_ref.update(values) DCNL DCSP  DCSP event_ref.save(session=session) DCNL DCSP return event_ref
def action_event_finish(context, values): DCNL  DCSP convert_datetimes(values, 'start_time', 'finish_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_request_id(context, values['instance_uuid'], values['request_id'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFound(request_id=values['request_id'], instance_uuid=values['instance_uuid']) DCNL DCSP  DCSP event_ref = model_query(context, models.InstanceActionEvent, session=session).filter_by(action_id=action['id']).filter_by(event=values['event']).first() DCNL DCSP  DCSP if (not event_ref): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionEventNotFound(action_id=action['id'], event=values['event']) DCNL DCSP  DCSP event_ref.update(values) DCNL DCSP  DCSP if (values['result'].lower() == 'error'): DCNL DCSP  DCSP  DCSP action.update({'message': 'Error'}) DCNL DCSP return event_ref
@require_context DCNL def ec2_instance_create(context, instance_uuid, id=None): DCNL  DCSP ec2_instance_ref = models.InstanceIdMapping() DCNL DCSP ec2_instance_ref.update({'uuid': instance_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_instance_ref.update({'id': id}) DCNL DCSP ec2_instance_ref.save() DCNL DCSP return ec2_instance_ref
@require_admin_context DCNL def archive_deleted_rows_for_table(context, tablename, max_rows): DCNL  DCSP engine = get_engine() DCNL DCSP conn = engine.connect() DCNL DCSP metadata = MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP table = Table(tablename, metadata, autoload=True) DCNL DCSP default_deleted_value = _get_default_deleted_value(table) DCNL DCSP shadow_tablename = ('shadow_' + tablename) DCNL DCSP rows_archived = 0 DCNL DCSP try: DCNL DCSP  DCSP shadow_table = Table(shadow_tablename, metadata, autoload=True) DCNL DCSP except NoSuchTableError: DCNL DCSP  DCSP return rows_archived DCNL DCSP with conn.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column = table.c.id DCNL DCSP  DCSP  DCSP column_name = 'id' DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP column = table.c.domain DCNL DCSP  DCSP  DCSP column_name = 'domain' DCNL DCSP  DCSP query = select([table], (table.c.deleted != default_deleted_value)).order_by(column).limit(max_rows) DCNL DCSP  DCSP rows = conn.execute(query).fetchall() DCNL DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP keys = [getattr(row, column_name) for row in rows] DCNL DCSP  DCSP  DCSP delete_statement = table.delete(column.in_(keys)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result = conn.execute(delete_statement) DCNL DCSP  DCSP  DCSP except IntegrityError: DCNL DCSP  DCSP  DCSP  DCSP return rows_archived DCNL DCSP  DCSP  DCSP insert_statement = shadow_table.insert() DCNL DCSP  DCSP  DCSP conn.execute(insert_statement, rows) DCNL DCSP  DCSP  DCSP rows_archived = result.rowcount DCNL DCSP return rows_archived
@require_admin_context DCNL def archive_deleted_rows(context, max_rows=None): DCNL  DCSP tablenames = [] DCNL DCSP for model_class in models.__dict__.itervalues(): DCNL DCSP  DCSP if hasattr(model_class, '__tablename__'): DCNL DCSP  DCSP  DCSP tablenames.append(model_class.__tablename__) DCNL DCSP rows_archived = 0 DCNL DCSP for tablename in tablenames: DCNL DCSP  DCSP rows_archived += archive_deleted_rows_for_table(context, tablename, max_rows=(max_rows - rows_archived)) DCNL DCSP  DCSP if (rows_archived >= max_rows): DCNL DCSP  DCSP  DCSP break DCNL DCSP return rows_archived
def db_sync(version=None): DCNL  DCSP return IMPL.db_sync(version=version)
def db_version(): DCNL  DCSP return IMPL.db_version()
def constraint(**conditions): DCNL  DCSP return IMPL.constraint(**conditions)
def equal_any(*values): DCNL  DCSP return IMPL.equal_any(*values)
def not_equal(*values): DCNL  DCSP return IMPL.not_equal(*values)
def service_destroy(context, instance_id): DCNL  DCSP return IMPL.service_destroy(context, instance_id)
def service_get(context, service_id): DCNL  DCSP return IMPL.service_get(context, service_id)
def service_get_by_host_and_topic(context, host, topic): DCNL  DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
def service_get_all(context, disabled=None): DCNL  DCSP return IMPL.service_get_all(context, disabled)
def service_get_all_by_topic(context, topic): DCNL  DCSP return IMPL.service_get_all_by_topic(context, topic)
def service_get_all_by_host(context, host): DCNL  DCSP return IMPL.service_get_all_by_host(context, host)
def service_get_by_compute_host(context, host): DCNL  DCSP return IMPL.service_get_by_compute_host(context, host)
def service_get_by_args(context, host, binary): DCNL  DCSP return IMPL.service_get_by_args(context, host, binary)
def service_create(context, values): DCNL  DCSP return IMPL.service_create(context, values)
def service_update(context, service_id, values): DCNL  DCSP return IMPL.service_update(context, service_id, values)
def compute_node_get(context, compute_id): DCNL  DCSP return IMPL.compute_node_get(context, compute_id)
def compute_node_get_all(context): DCNL  DCSP return IMPL.compute_node_get_all(context)
def compute_node_search_by_hypervisor(context, hypervisor_match): DCNL  DCSP return IMPL.compute_node_search_by_hypervisor(context, hypervisor_match)
def compute_node_create(context, values): DCNL  DCSP return IMPL.compute_node_create(context, values)
def compute_node_update(context, compute_id, values, prune_stats=False): DCNL  DCSP return IMPL.compute_node_update(context, compute_id, values, prune_stats)
def compute_node_delete(context, compute_id): DCNL  DCSP return IMPL.compute_node_delete(context, compute_id)
def certificate_create(context, values): DCNL  DCSP return IMPL.certificate_create(context, values)
def certificate_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.certificate_get_all_by_project(context, project_id)
def certificate_get_all_by_user(context, user_id): DCNL  DCSP return IMPL.certificate_get_all_by_user(context, user_id)
def certificate_get_all_by_user_and_project(context, user_id, project_id): DCNL  DCSP return IMPL.certificate_get_all_by_user_and_project(context, user_id, project_id)
def floating_ip_get_pools(context): DCNL  DCSP return IMPL.floating_ip_get_pools(context)
def floating_ip_allocate_address(context, project_id, pool): DCNL  DCSP return IMPL.floating_ip_allocate_address(context, project_id, pool)
def floating_ip_bulk_create(context, ips): DCNL  DCSP return IMPL.floating_ip_bulk_create(context, ips)
def floating_ip_bulk_destroy(context, ips): DCNL  DCSP return IMPL.floating_ip_bulk_destroy(context, ips)
def floating_ip_create(context, values): DCNL  DCSP return IMPL.floating_ip_create(context, values)
def floating_ip_count_by_project(context, project_id, session=None): DCNL  DCSP return IMPL.floating_ip_count_by_project(context, project_id, session=session)
def floating_ip_deallocate(context, address): DCNL  DCSP return IMPL.floating_ip_deallocate(context, address)
def floating_ip_destroy(context, address): DCNL  DCSP return IMPL.floating_ip_destroy(context, address)
def floating_ip_disassociate(context, address): DCNL  DCSP return IMPL.floating_ip_disassociate(context, address)
def floating_ip_fixed_ip_associate(context, floating_address, fixed_address, host): DCNL  DCSP return IMPL.floating_ip_fixed_ip_associate(context, floating_address, fixed_address, host)
def floating_ip_get_all(context): DCNL  DCSP return IMPL.floating_ip_get_all(context)
def floating_ip_get_all_by_host(context, host): DCNL  DCSP return IMPL.floating_ip_get_all_by_host(context, host)
def floating_ip_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.floating_ip_get_all_by_project(context, project_id)
def floating_ip_get_by_address(context, address): DCNL  DCSP return IMPL.floating_ip_get_by_address(context, address)
def floating_ip_get_by_fixed_address(context, fixed_address): DCNL  DCSP return IMPL.floating_ip_get_by_fixed_address(context, fixed_address)
def floating_ip_get_by_fixed_ip_id(context, fixed_ip_id): DCNL  DCSP return IMPL.floating_ip_get_by_fixed_ip_id(context, fixed_ip_id)
def floating_ip_update(context, address, values): DCNL  DCSP return IMPL.floating_ip_update(context, address, values)
def floating_ip_set_auto_assigned(context, address): DCNL  DCSP return IMPL.floating_ip_set_auto_assigned(context, address)
def dnsdomain_list(context): DCNL  DCSP return IMPL.dnsdomain_list(context)
def dnsdomain_register_for_zone(context, fqdomain, zone): DCNL  DCSP return IMPL.dnsdomain_register_for_zone(context, fqdomain, zone)
def dnsdomain_register_for_project(context, fqdomain, project): DCNL  DCSP return IMPL.dnsdomain_register_for_project(context, fqdomain, project)
def dnsdomain_unregister(context, fqdomain): DCNL  DCSP return IMPL.dnsdomain_unregister(context, fqdomain)
def dnsdomain_get(context, fqdomain): DCNL  DCSP return IMPL.dnsdomain_get(context, fqdomain)
def migration_update(context, id, values): DCNL  DCSP return IMPL.migration_update(context, id, values)
def migration_create(context, values): DCNL  DCSP return IMPL.migration_create(context, values)
def migration_get(context, migration_id): DCNL  DCSP return IMPL.migration_get(context, migration_id)
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL  DCSP return IMPL.migration_get_by_instance_and_status(context, instance_uuid, status)
def migration_get_unconfirmed_by_dest_compute(context, confirm_window, dest_compute): DCNL  DCSP return IMPL.migration_get_unconfirmed_by_dest_compute(context, confirm_window, dest_compute)
def migration_get_in_progress_by_host_and_node(context, host, node): DCNL  DCSP return IMPL.migration_get_in_progress_by_host_and_node(context, host, node)
def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL  DCSP return IMPL.fixed_ip_associate(context, address, instance_uuid, network_id, reserved)
def fixed_ip_associate_pool(context, network_id, instance_uuid=None, host=None): DCNL  DCSP return IMPL.fixed_ip_associate_pool(context, network_id, instance_uuid, host)
def fixed_ip_create(context, values): DCNL  DCSP return IMPL.fixed_ip_create(context, values)
def fixed_ip_bulk_create(context, ips): DCNL  DCSP return IMPL.fixed_ip_bulk_create(context, ips)
def fixed_ip_disassociate(context, address): DCNL  DCSP return IMPL.fixed_ip_disassociate(context, address)
def fixed_ip_disassociate_all_by_timeout(context, host, time): DCNL  DCSP return IMPL.fixed_ip_disassociate_all_by_timeout(context, host, time)
def fixed_ip_get(context, id, get_network=False): DCNL  DCSP return IMPL.fixed_ip_get(context, id, get_network)
def fixed_ip_get_all(context): DCNL  DCSP return IMPL.fixed_ip_get_all(context)
def fixed_ip_get_by_address(context, address): DCNL  DCSP return IMPL.fixed_ip_get_by_address(context, address)
def fixed_ip_get_by_address_detailed(context, address): DCNL  DCSP return IMPL.fixed_ip_get_by_address_detailed(context, address)
def fixed_ip_get_by_floating_address(context, floating_address): DCNL  DCSP return IMPL.fixed_ip_get_by_floating_address(context, floating_address)
def fixed_ip_get_by_instance(context, instance_uuid): DCNL  DCSP return IMPL.fixed_ip_get_by_instance(context, instance_uuid)
def fixed_ip_get_by_host(context, host): DCNL  DCSP return IMPL.fixed_ip_get_by_host(context, host)
def fixed_ip_get_by_network_host(context, network_uuid, host): DCNL  DCSP return IMPL.fixed_ip_get_by_network_host(context, network_uuid, host)
def fixed_ips_by_virtual_interface(context, vif_id): DCNL  DCSP return IMPL.fixed_ips_by_virtual_interface(context, vif_id)
def fixed_ip_update(context, address, values): DCNL  DCSP return IMPL.fixed_ip_update(context, address, values)
def fixed_ip_count_by_project(context, project_id, session=None): DCNL  DCSP return IMPL.fixed_ip_count_by_project(context, project_id, session=session)
def virtual_interface_create(context, values): DCNL  DCSP return IMPL.virtual_interface_create(context, values)
def virtual_interface_get(context, vif_id): DCNL  DCSP return IMPL.virtual_interface_get(context, vif_id)
def virtual_interface_get_by_address(context, address): DCNL  DCSP return IMPL.virtual_interface_get_by_address(context, address)
def virtual_interface_get_by_uuid(context, vif_uuid): DCNL  DCSP return IMPL.virtual_interface_get_by_uuid(context, vif_uuid)
def virtual_interface_get_by_instance(context, instance_id): DCNL  DCSP return IMPL.virtual_interface_get_by_instance(context, instance_id)
def virtual_interface_get_by_instance_and_network(context, instance_id, network_id): DCNL  DCSP return IMPL.virtual_interface_get_by_instance_and_network(context, instance_id, network_id)
def virtual_interface_delete_by_instance(context, instance_id): DCNL  DCSP return IMPL.virtual_interface_delete_by_instance(context, instance_id)
def virtual_interface_get_all(context): DCNL  DCSP return IMPL.virtual_interface_get_all(context)
def instance_create(context, values): DCNL  DCSP return IMPL.instance_create(context, values)
def instance_data_get_for_project(context, project_id, session=None): DCNL  DCSP return IMPL.instance_data_get_for_project(context, project_id, session=session)
def instance_destroy(context, instance_uuid, constraint=None, update_cells=True): DCNL  DCSP rv = IMPL.instance_destroy(context, instance_uuid, constraint) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_destroy_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP destroy')) DCNL DCSP return rv
def instance_get_by_uuid(context, uuid): DCNL  DCSP return IMPL.instance_get_by_uuid(context, uuid)
def instance_get(context, instance_id): DCNL  DCSP return IMPL.instance_get(context, instance_id)
def instance_get_all(context, columns_to_join=None): DCNL  DCSP return IMPL.instance_get_all(context, columns_to_join=columns_to_join)
def instance_get_all_by_filters(context, filters, sort_key='created_at', sort_dir='desc', limit=None, marker=None, columns_to_join=None): DCNL  DCSP return IMPL.instance_get_all_by_filters(context, filters, sort_key, sort_dir, limit=limit, marker=marker, columns_to_join=columns_to_join)
def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL  DCSP return IMPL.instance_get_active_by_window_joined(context, begin, end, project_id, host)
def instance_get_all_by_host(context, host, columns_to_join=None): DCNL  DCSP return IMPL.instance_get_all_by_host(context, host, columns_to_join)
def instance_get_all_by_host_and_node(context, host, node): DCNL  DCSP return IMPL.instance_get_all_by_host_and_node(context, host, node)
def instance_get_all_by_host_and_not_type(context, host, type_id=None): DCNL  DCSP return IMPL.instance_get_all_by_host_and_not_type(context, host, type_id)
def instance_get_floating_address(context, instance_id): DCNL  DCSP return IMPL.instance_get_floating_address(context, instance_id)
def instance_floating_address_get_all(context, instance_uuid): DCNL  DCSP return IMPL.instance_floating_address_get_all(context, instance_uuid)
def instance_get_all_hung_in_rebooting(context, reboot_window): DCNL  DCSP return IMPL.instance_get_all_hung_in_rebooting(context, reboot_window)
def instance_test_and_set(context, instance_uuid, attr, ok_states, new_state): DCNL  DCSP return IMPL.instance_test_and_set(context, instance_uuid, attr, ok_states, new_state)
def instance_update(context, instance_uuid, values, update_cells=True): DCNL  DCSP rv = IMPL.instance_update(context, instance_uuid, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_update_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP update')) DCNL DCSP return rv
def instance_update_and_get_original(context, instance_uuid, values): DCNL  DCSP rv = IMPL.instance_update_and_get_original(context, instance_uuid, values) DCNL DCSP try: DCNL DCSP  DCSP cells_rpcapi.CellsAPI().instance_update_at_top(context, rv[1]) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP update')) DCNL DCSP return rv
def instance_add_security_group(context, instance_id, security_group_id): DCNL  DCSP return IMPL.instance_add_security_group(context, instance_id, security_group_id)
def instance_remove_security_group(context, instance_id, security_group_id): DCNL  DCSP return IMPL.instance_remove_security_group(context, instance_id, security_group_id)
def instance_info_cache_get(context, instance_uuid): DCNL  DCSP return IMPL.instance_info_cache_get(context, instance_uuid)
def instance_info_cache_update(context, instance_uuid, values, update_cells=True): DCNL  DCSP rv = IMPL.instance_info_cache_update(context, instance_uuid, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_info_cache_update_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP info DCSP cache DCSP update')) DCNL DCSP return rv
def instance_info_cache_delete(context, instance_uuid): DCNL  DCSP return IMPL.instance_info_cache_delete(context, instance_uuid)
def key_pair_create(context, values): DCNL  DCSP return IMPL.key_pair_create(context, values)
def key_pair_destroy(context, user_id, name): DCNL  DCSP return IMPL.key_pair_destroy(context, user_id, name)
def key_pair_get(context, user_id, name): DCNL  DCSP return IMPL.key_pair_get(context, user_id, name)
def key_pair_get_all_by_user(context, user_id): DCNL  DCSP return IMPL.key_pair_get_all_by_user(context, user_id)
def key_pair_count_by_user(context, user_id): DCNL  DCSP return IMPL.key_pair_count_by_user(context, user_id)
def network_associate(context, project_id, network_id=None, force=False): DCNL  DCSP return IMPL.network_associate(context, project_id, network_id, force)
def network_count_reserved_ips(context, network_id): DCNL  DCSP return IMPL.network_count_reserved_ips(context, network_id)
def network_create_safe(context, values): DCNL  DCSP return IMPL.network_create_safe(context, values)
def network_delete_safe(context, network_id): DCNL  DCSP return IMPL.network_delete_safe(context, network_id)
def network_disassociate(context, network_id, disassociate_host=True, disassociate_project=True): DCNL  DCSP return IMPL.network_disassociate(context, network_id, disassociate_host, disassociate_project)
def network_get(context, network_id, project_only='allow_none'): DCNL  DCSP return IMPL.network_get(context, network_id, project_only=project_only)
def network_get_all(context): DCNL  DCSP return IMPL.network_get_all(context)
def network_get_all_by_uuids(context, network_uuids, project_only='allow_none'): DCNL  DCSP return IMPL.network_get_all_by_uuids(context, network_uuids, project_only=project_only)
def network_in_use_on_host(context, network_id, host=None): DCNL  DCSP return IMPL.network_in_use_on_host(context, network_id, host)
def network_get_associated_fixed_ips(context, network_id, host=None): DCNL  DCSP return IMPL.network_get_associated_fixed_ips(context, network_id, host)
def network_get_by_uuid(context, uuid): DCNL  DCSP return IMPL.network_get_by_uuid(context, uuid)
def network_get_by_cidr(context, cidr): DCNL  DCSP return IMPL.network_get_by_cidr(context, cidr)
def network_get_all_by_instance(context, instance_id): DCNL  DCSP return IMPL.network_get_all_by_instance(context, instance_id)
def network_get_all_by_host(context, host): DCNL  DCSP return IMPL.network_get_all_by_host(context, host)
def network_set_host(context, network_id, host_id): DCNL  DCSP return IMPL.network_set_host(context, network_id, host_id)
def network_update(context, network_id, values): DCNL  DCSP return IMPL.network_update(context, network_id, values)
def quota_create(context, project_id, resource, limit): DCNL  DCSP return IMPL.quota_create(context, project_id, resource, limit)
def quota_get(context, project_id, resource): DCNL  DCSP return IMPL.quota_get(context, project_id, resource)
def quota_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_get_all_by_project(context, project_id)
def quota_update(context, project_id, resource, limit): DCNL  DCSP return IMPL.quota_update(context, project_id, resource, limit)
def quota_class_create(context, class_name, resource, limit): DCNL  DCSP return IMPL.quota_class_create(context, class_name, resource, limit)
def quota_class_get(context, class_name, resource): DCNL  DCSP return IMPL.quota_class_get(context, class_name, resource)
def quota_class_get_all_by_name(context, class_name): DCNL  DCSP return IMPL.quota_class_get_all_by_name(context, class_name)
def quota_class_update(context, class_name, resource, limit): DCNL  DCSP return IMPL.quota_class_update(context, class_name, resource, limit)
def quota_usage_get(context, project_id, resource): DCNL  DCSP return IMPL.quota_usage_get(context, project_id, resource)
def quota_usage_get_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_usage_get_all_by_project(context, project_id)
def quota_usage_update(context, project_id, resource, **kwargs): DCNL  DCSP return IMPL.quota_usage_update(context, project_id, resource, **kwargs)
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL  DCSP return IMPL.reservation_create(context, uuid, usage, project_id, resource, delta, expire)
def reservation_get(context, uuid): DCNL  DCSP return IMPL.reservation_get(context, uuid)
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL  DCSP return IMPL.quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=project_id)
def reservation_commit(context, reservations, project_id=None): DCNL  DCSP return IMPL.reservation_commit(context, reservations, project_id=project_id)
def reservation_rollback(context, reservations, project_id=None): DCNL  DCSP return IMPL.reservation_rollback(context, reservations, project_id=project_id)
def quota_destroy_all_by_project(context, project_id): DCNL  DCSP return IMPL.quota_destroy_all_by_project(context, project_id)
def reservation_expire(context): DCNL  DCSP return IMPL.reservation_expire(context)
def block_device_mapping_create(context, values): DCNL  DCSP return IMPL.block_device_mapping_create(context, values)
def block_device_mapping_update(context, bdm_id, values): DCNL  DCSP return IMPL.block_device_mapping_update(context, bdm_id, values)
def block_device_mapping_update_or_create(context, values): DCNL  DCSP return IMPL.block_device_mapping_update_or_create(context, values)
def block_device_mapping_get_all_by_instance(context, instance_uuid): DCNL  DCSP return IMPL.block_device_mapping_get_all_by_instance(context, instance_uuid)
def block_device_mapping_destroy(context, bdm_id): DCNL  DCSP return IMPL.block_device_mapping_destroy(context, bdm_id)
def block_device_mapping_destroy_by_instance_and_device(context, instance_uuid, device_name): DCNL  DCSP return IMPL.block_device_mapping_destroy_by_instance_and_device(context, instance_uuid, device_name)
def block_device_mapping_destroy_by_instance_and_volume(context, instance_uuid, volume_id): DCNL  DCSP return IMPL.block_device_mapping_destroy_by_instance_and_volume(context, instance_uuid, volume_id)
def security_group_get_all(context): DCNL  DCSP return IMPL.security_group_get_all(context)
def security_group_get(context, security_group_id): DCNL  DCSP return IMPL.security_group_get(context, security_group_id)
def security_group_get_by_name(context, project_id, group_name): DCNL  DCSP return IMPL.security_group_get_by_name(context, project_id, group_name)
def security_group_get_by_project(context, project_id): DCNL  DCSP return IMPL.security_group_get_by_project(context, project_id)
def security_group_get_by_instance(context, instance_id): DCNL  DCSP return IMPL.security_group_get_by_instance(context, instance_id)
def security_group_exists(context, project_id, group_name): DCNL  DCSP return IMPL.security_group_exists(context, project_id, group_name)
def security_group_in_use(context, group_id): DCNL  DCSP return IMPL.security_group_in_use(context, group_id)
def security_group_create(context, values): DCNL  DCSP return IMPL.security_group_create(context, values)
def security_group_ensure_default(context): DCNL  DCSP return IMPL.security_group_ensure_default(context)
def security_group_destroy(context, security_group_id): DCNL  DCSP return IMPL.security_group_destroy(context, security_group_id)
def security_group_count_by_project(context, project_id, session=None): DCNL  DCSP return IMPL.security_group_count_by_project(context, project_id, session=session)
def security_group_rule_create(context, values): DCNL  DCSP return IMPL.security_group_rule_create(context, values)
def security_group_rule_get_by_security_group(context, security_group_id): DCNL  DCSP return IMPL.security_group_rule_get_by_security_group(context, security_group_id)
def security_group_rule_get_by_security_group_grantee(context, security_group_id): DCNL  DCSP return IMPL.security_group_rule_get_by_security_group_grantee(context, security_group_id)
def security_group_rule_destroy(context, security_group_rule_id): DCNL  DCSP return IMPL.security_group_rule_destroy(context, security_group_rule_id)
def security_group_rule_get(context, security_group_rule_id): DCNL  DCSP return IMPL.security_group_rule_get(context, security_group_rule_id)
def security_group_rule_count_by_group(context, security_group_id): DCNL  DCSP return IMPL.security_group_rule_count_by_group(context, security_group_id)
def provider_fw_rule_create(context, rule): DCNL  DCSP return IMPL.provider_fw_rule_create(context, rule)
def provider_fw_rule_get_all(context): DCNL  DCSP return IMPL.provider_fw_rule_get_all(context)
def provider_fw_rule_destroy(context, rule_id): DCNL  DCSP return IMPL.provider_fw_rule_destroy(context, rule_id)
def project_get_networks(context, project_id, associate=True): DCNL  DCSP return IMPL.project_get_networks(context, project_id, associate)
def console_pool_create(context, values): DCNL  DCSP return IMPL.console_pool_create(context, values)
def console_pool_get_by_host_type(context, compute_host, proxy_host, console_type): DCNL  DCSP return IMPL.console_pool_get_by_host_type(context, compute_host, proxy_host, console_type)
def console_pool_get_all_by_host_type(context, host, console_type): DCNL  DCSP return IMPL.console_pool_get_all_by_host_type(context, host, console_type)
def console_create(context, values): DCNL  DCSP return IMPL.console_create(context, values)
def console_delete(context, console_id): DCNL  DCSP return IMPL.console_delete(context, console_id)
def console_get_by_pool_instance(context, pool_id, instance_uuid): DCNL  DCSP return IMPL.console_get_by_pool_instance(context, pool_id, instance_uuid)
def console_get_all_by_instance(context, instance_uuid): DCNL  DCSP return IMPL.console_get_all_by_instance(context, instance_uuid)
def console_get(context, console_id, instance_uuid=None): DCNL  DCSP return IMPL.console_get(context, console_id, instance_uuid)
def instance_type_create(context, values): DCNL  DCSP return IMPL.instance_type_create(context, values)
def instance_type_get_all(context, inactive=False, filters=None): DCNL  DCSP return IMPL.instance_type_get_all(context, inactive=inactive, filters=filters)
def instance_type_get(context, id): DCNL  DCSP return IMPL.instance_type_get(context, id)
def instance_type_get_by_name(context, name): DCNL  DCSP return IMPL.instance_type_get_by_name(context, name)
def instance_type_get_by_flavor_id(context, id): DCNL  DCSP return IMPL.instance_type_get_by_flavor_id(context, id)
def instance_type_destroy(context, name): DCNL  DCSP return IMPL.instance_type_destroy(context, name)
def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL  DCSP return IMPL.instance_type_access_get_by_flavor_id(context, flavor_id)
def instance_type_access_add(context, flavor_id, project_id): DCNL  DCSP return IMPL.instance_type_access_add(context, flavor_id, project_id)
def instance_type_access_remove(context, flavor_id, project_id): DCNL  DCSP return IMPL.instance_type_access_remove(context, flavor_id, project_id)
def cell_create(context, values): DCNL  DCSP return IMPL.cell_create(context, values)
def cell_update(context, cell_name, values): DCNL  DCSP return IMPL.cell_update(context, cell_name, values)
def cell_delete(context, cell_name): DCNL  DCSP return IMPL.cell_delete(context, cell_name)
def cell_get(context, cell_name): DCNL  DCSP return IMPL.cell_get(context, cell_name)
def cell_get_all(context): DCNL  DCSP return IMPL.cell_get_all(context)
def instance_metadata_get(context, instance_uuid): DCNL  DCSP return IMPL.instance_metadata_get(context, instance_uuid)
def instance_metadata_delete(context, instance_uuid, key): DCNL  DCSP IMPL.instance_metadata_delete(context, instance_uuid, key)
def instance_metadata_update(context, instance_uuid, metadata, delete): DCNL  DCSP return IMPL.instance_metadata_update(context, instance_uuid, metadata, delete)
def instance_system_metadata_get(context, instance_uuid): DCNL  DCSP return IMPL.instance_system_metadata_get(context, instance_uuid)
def instance_system_metadata_update(context, instance_uuid, metadata, delete): DCNL  DCSP IMPL.instance_system_metadata_update(context, instance_uuid, metadata, delete)
def agent_build_create(context, values): DCNL  DCSP return IMPL.agent_build_create(context, values)
def agent_build_get_by_triple(context, hypervisor, os, architecture): DCNL  DCSP return IMPL.agent_build_get_by_triple(context, hypervisor, os, architecture)
def agent_build_get_all(context, hypervisor=None): DCNL  DCSP return IMPL.agent_build_get_all(context, hypervisor)
def agent_build_destroy(context, agent_update_id): DCNL  DCSP IMPL.agent_build_destroy(context, agent_update_id)
def agent_build_update(context, agent_build_id, values): DCNL  DCSP IMPL.agent_build_update(context, agent_build_id, values)
def bw_usage_get(context, uuid, start_period, mac): DCNL  DCSP return IMPL.bw_usage_get(context, uuid, start_period, mac)
def bw_usage_get_by_uuids(context, uuids, start_period): DCNL  DCSP return IMPL.bw_usage_get_by_uuids(context, uuids, start_period)
def bw_usage_update(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=None, update_cells=True): DCNL  DCSP rv = IMPL.bw_usage_update(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=last_refreshed) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().bw_usage_update_at_top(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP bw_usage DCSP update')) DCNL DCSP return rv
def instance_type_extra_specs_get(context, flavor_id): DCNL  DCSP return IMPL.instance_type_extra_specs_get(context, flavor_id)
def instance_type_extra_specs_delete(context, flavor_id, key): DCNL  DCSP IMPL.instance_type_extra_specs_delete(context, flavor_id, key)
def instance_type_extra_specs_update_or_create(context, flavor_id, extra_specs): DCNL  DCSP IMPL.instance_type_extra_specs_update_or_create(context, flavor_id, extra_specs)
def vol_get_usage_by_time(context, begin): DCNL  DCSP return IMPL.vol_get_usage_by_time(context, begin)
def vol_usage_update(context, id, rd_req, rd_bytes, wr_req, wr_bytes, instance_id, last_refreshed=None, update_totals=False): DCNL  DCSP return IMPL.vol_usage_update(context, id, rd_req, rd_bytes, wr_req, wr_bytes, instance_id, last_refreshed=last_refreshed, update_totals=update_totals)
def s3_image_get(context, image_id): DCNL  DCSP return IMPL.s3_image_get(context, image_id)
def s3_image_get_by_uuid(context, image_uuid): DCNL  DCSP return IMPL.s3_image_get_by_uuid(context, image_uuid)
def s3_image_create(context, image_uuid): DCNL  DCSP return IMPL.s3_image_create(context, image_uuid)
def aggregate_create(context, values, metadata=None): DCNL  DCSP return IMPL.aggregate_create(context, values, metadata)
def aggregate_get(context, aggregate_id): DCNL  DCSP return IMPL.aggregate_get(context, aggregate_id)
def aggregate_get_by_host(context, host, key=None): DCNL  DCSP return IMPL.aggregate_get_by_host(context, host, key)
def aggregate_metadata_get_by_host(context, host, key=None): DCNL  DCSP return IMPL.aggregate_metadata_get_by_host(context, host, key)
def aggregate_host_get_by_metadata_key(context, key): DCNL  DCSP return IMPL.aggregate_host_get_by_metadata_key(context, key)
def aggregate_update(context, aggregate_id, values): DCNL  DCSP return IMPL.aggregate_update(context, aggregate_id, values)
def aggregate_delete(context, aggregate_id): DCNL  DCSP return IMPL.aggregate_delete(context, aggregate_id)
def aggregate_get_all(context): DCNL  DCSP return IMPL.aggregate_get_all(context)
def aggregate_metadata_add(context, aggregate_id, metadata, set_delete=False): DCNL  DCSP IMPL.aggregate_metadata_add(context, aggregate_id, metadata, set_delete)
def aggregate_metadata_get(context, aggregate_id): DCNL  DCSP return IMPL.aggregate_metadata_get(context, aggregate_id)
def aggregate_metadata_delete(context, aggregate_id, key): DCNL  DCSP IMPL.aggregate_metadata_delete(context, aggregate_id, key)
def aggregate_host_add(context, aggregate_id, host): DCNL  DCSP IMPL.aggregate_host_add(context, aggregate_id, host)
def aggregate_host_get_all(context, aggregate_id): DCNL  DCSP return IMPL.aggregate_host_get_all(context, aggregate_id)
def aggregate_host_delete(context, aggregate_id, host): DCNL  DCSP IMPL.aggregate_host_delete(context, aggregate_id, host)
def instance_fault_create(context, values, update_cells=True): DCNL  DCSP rv = IMPL.instance_fault_create(context, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_fault_create_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP fault')) DCNL DCSP return rv
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL  DCSP return IMPL.instance_fault_get_by_instance_uuids(context, instance_uuids)
def action_start(context, values): DCNL  DCSP return IMPL.action_start(context, values)
def action_finish(context, values): DCNL  DCSP return IMPL.action_finish(context, values)
def actions_get(context, uuid): DCNL  DCSP return IMPL.actions_get(context, uuid)
def action_get_by_request_id(context, uuid, request_id): DCNL  DCSP return IMPL.action_get_by_request_id(context, uuid, request_id)
def action_event_start(context, values): DCNL  DCSP return IMPL.action_event_start(context, values)
def action_event_finish(context, values): DCNL  DCSP return IMPL.action_event_finish(context, values)
def action_events_get(context, action_id): DCNL  DCSP return IMPL.action_events_get(context, action_id)
def get_ec2_instance_id_by_uuid(context, instance_id): DCNL  DCSP return IMPL.get_ec2_instance_id_by_uuid(context, instance_id)
def get_instance_uuid_by_ec2_id(context, ec2_id): DCNL  DCSP return IMPL.get_instance_uuid_by_ec2_id(context, ec2_id)
def ec2_instance_create(context, instance_uuid, id=None): DCNL  DCSP return IMPL.ec2_instance_create(context, instance_uuid, id)
def task_log_end_task(context, task_name, period_beginning, period_ending, host, errors, message=None): DCNL  DCSP return IMPL.task_log_end_task(context, task_name, period_beginning, period_ending, host, errors, message)
def task_log_begin_task(context, task_name, period_beginning, period_ending, host, task_items=None, message=None): DCNL  DCSP return IMPL.task_log_begin_task(context, task_name, period_beginning, period_ending, host, task_items, message)
def archive_deleted_rows(context, max_rows=None): DCNL  DCSP return IMPL.archive_deleted_rows(context, max_rows=max_rows)
def archive_deleted_rows_for_table(context, tablename, max_rows=None): DCNL  DCSP return IMPL.archive_deleted_rows_for_table(context, tablename, max_rows=max_rows)
def all_filters(): DCNL  DCSP return HostFilterHandler().get_all_classes()
def standard_filters(): DCNL  DCSP LOG.deprecated(_("Use DCSP 'nova.scheduler.filters.all_filters' DCSP instead DCSP of DCSP 'nova.scheduler.filters.standard_filters'")) DCNL DCSP return all_filters()
def new_host_state(self, host, node, capabilities=None, service=None): DCNL  DCSP if (capabilities is None): DCNL DCSP  DCSP capabilities = {} DCNL DCSP cap = capabilities.get('compute', {}) DCNL DCSP if bool(cap.get('baremetal_driver')): DCNL DCSP  DCSP return BaremetalNodeState(host, node, capabilities, service) DCNL DCSP else: DCNL DCSP  DCSP return host_manager.HostState(host, node, capabilities, service)
def all_weighers(): DCNL  DCSP if ((CONF.least_cost_functions is not None) or (CONF.compute_fill_first_cost_fn_weight is not None)): DCNL DCSP  DCSP LOG.deprecated(_('least_cost DCSP has DCSP been DCSP deprecated DCSP in DCSP favor DCSP of DCSP the DCSP RAM DCSP Weigher.')) DCNL DCSP  DCSP return least_cost.get_least_cost_weighers() DCNL DCSP return HostWeightHandler().get_all_classes()
def noop_cost_fn(host_state, weight_properties): DCNL  DCSP return 1
def compute_fill_first_cost_fn(host_state, weight_properties): DCNL  DCSP return (- host_state.free_ram_mb)
def _get_cost_functions(): DCNL  DCSP cost_fns_conf = CONF.least_cost_functions DCNL DCSP if (cost_fns_conf is None): DCNL DCSP  DCSP fn_str = 'nova.scheduler.least_cost.compute_fill_first_cost_fn' DCNL DCSP  DCSP cost_fns_conf = [fn_str] DCNL DCSP cost_fns = [] DCNL DCSP for cost_fn_str in cost_fns_conf: DCNL DCSP  DCSP short_name = cost_fn_str.split('.')[(-1)] DCNL DCSP  DCSP if (not (short_name.startswith('compute_') or short_name.startswith('noop'))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if cost_fn_str.startswith('nova.scheduler.least_cost.'): DCNL DCSP  DCSP  DCSP cost_fn_str = ('nova.scheduler.weights.least_cost' + cost_fn_str[25:]) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cost_fn = importutils.import_class(cost_fn_str) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP raise exception.SchedulerCostFunctionNotFound(cost_fn_str=cost_fn_str) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP flag_name = ('%s_weight' % cost_fn.__name__) DCNL DCSP  DCSP  DCSP weight = getattr(CONF, flag_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.SchedulerWeightFlagNotFound(flag_name=flag_name) DCNL DCSP  DCSP if ((flag_name == 'compute_fill_first_cost_fn_weight') and (weight is None)): DCNL DCSP  DCSP  DCSP weight = (-1.0) DCNL DCSP  DCSP cost_fns.append((weight, cost_fn)) DCNL DCSP return cost_fns
def instance_update_db(context, instance_uuid, extra_values=None): DCNL  DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': None, 'node': None, 'scheduled_at': now} DCNL DCSP if extra_values: DCNL DCSP  DCSP values.update(extra_values) DCNL DCSP return db.instance_update(context, instance_uuid, values)
def encode_instance(instance, local=True): DCNL  DCSP if local: DCNL DCSP  DCSP return dict(id=instance['id'], _is_precooked=False) DCNL DCSP else: DCNL DCSP  DCSP inst = dict(instance) DCNL DCSP  DCSP inst['_is_precooked'] = True DCNL DCSP  DCSP return inst
def create(name, memory, vcpus, root_gb, ephemeral_gb=None, flavorid=None, swap=None, rxtx_factor=None, is_public=True): DCNL  DCSP if ((flavorid is None) or (flavorid == '')): DCNL DCSP  DCSP flavorid = uuid.uuid4() DCNL DCSP if (swap is None): DCNL DCSP  DCSP swap = 0 DCNL DCSP if (rxtx_factor is None): DCNL DCSP  DCSP rxtx_factor = 1.0 DCNL DCSP if (ephemeral_gb is None): DCNL DCSP  DCSP ephemeral_gb = 0 DCNL DCSP kwargs = {'memory_mb': memory, 'vcpus': vcpus, 'root_gb': root_gb, 'ephemeral_gb': ephemeral_gb, 'swap': swap, 'rxtx_factor': rxtx_factor} DCNL DCSP utils.check_string_length(name, 'name', min_length=1, max_length=255) DCNL DCSP invalid_name = INVALID_NAME_REGEX.search(name) DCNL DCSP if invalid_name: DCNL DCSP  DCSP msg = _('names DCSP can DCSP only DCSP contain DCSP [a-zA-Z0-9_.- DCSP ]') DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus', 'root_gb', 'ephemeral_gb', 'swap']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP kwargs[option] = int(kwargs[option]) DCNL DCSP  DCSP  DCSP assert (kwargs[option] >= 0) DCNL DCSP  DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP integer") % option) DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP try: DCNL DCSP  DCSP kwargs['rxtx_factor'] = float(kwargs['rxtx_factor']) DCNL DCSP  DCSP assert (kwargs['rxtx_factor'] > 0) DCNL DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP msg = _("'rxtx_factor' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP float") DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (kwargs[option] > 0) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP greater DCSP than DCSP 0") % option) DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP kwargs['name'] = name DCNL DCSP kwargs['flavorid'] = unicode(flavorid) DCNL DCSP if (not utils.is_valid_boolstr(is_public)): DCNL DCSP  DCSP msg = _('is_public DCSP must DCSP be DCSP a DCSP boolean') DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP kwargs['is_public'] = utils.bool_from_str(is_public) DCNL DCSP try: DCNL DCSP  DCSP return db.instance_type_create(context.get_admin_context(), kwargs) DCNL DCSP except db_exc.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.InstanceTypeCreateFailed()
def destroy(name): DCNL  DCSP try: DCNL DCSP  DCSP assert (name is not None) DCNL DCSP  DCSP db.instance_type_destroy(context.get_admin_context(), name) DCNL DCSP except (AssertionError, exception.NotFound): DCNL DCSP  DCSP LOG.exception((_('Instance DCSP type DCSP %s DCSP not DCSP found DCSP for DCSP deletion') % name)) DCNL DCSP  DCSP raise exception.InstanceTypeNotFoundByName(instance_type_name=name)
def get_all_types(ctxt=None, inactive=False, filters=None): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP inst_types = db.instance_type_get_all(ctxt, inactive=inactive, filters=filters) DCNL DCSP inst_type_dict = {} DCNL DCSP for inst_type in inst_types: DCNL DCSP  DCSP inst_type_dict[inst_type['name']] = inst_type DCNL DCSP return inst_type_dict
def get_default_instance_type(): DCNL  DCSP name = CONF.default_instance_type DCNL DCSP return get_instance_type_by_name(name)
def get_instance_type(instance_type_id, ctxt=None, inactive=False): DCNL  DCSP if (instance_type_id is None): DCNL DCSP  DCSP return get_default_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP if inactive: DCNL DCSP  DCSP ctxt = ctxt.elevated(read_deleted='yes') DCNL DCSP return db.instance_type_get(ctxt, instance_type_id)
def get_instance_type_by_name(name, ctxt=None): DCNL  DCSP if (name is None): DCNL DCSP  DCSP return get_default_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_get_by_name(ctxt, name)
def get_instance_type_by_flavor_id(flavorid, ctxt=None, read_deleted='yes'): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context(read_deleted=read_deleted) DCNL DCSP return db.instance_type_get_by_flavor_id(ctxt, flavorid)
def get_instance_type_access_by_flavor_id(flavorid, ctxt=None): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_get_by_flavor_id(ctxt, flavorid)
def add_instance_type_access(flavorid, projectid, ctxt=None): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_add(ctxt, flavorid, projectid)
def remove_instance_type_access(flavorid, projectid, ctxt=None): DCNL  DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_remove(ctxt, flavorid, projectid)
def extract_instance_type(instance, prefix=''): DCNL  DCSP instance_type = {} DCNL DCSP sys_meta = utils.metadata_to_dict(instance['system_metadata']) DCNL DCSP for (key, type_fn) in system_metadata_instance_type_props.items(): DCNL DCSP  DCSP type_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP instance_type[key] = type_fn(sys_meta[type_key]) DCNL DCSP return instance_type
def save_instance_type_info(metadata, instance_type, prefix=''): DCNL  DCSP for key in system_metadata_instance_type_props.keys(): DCNL DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP metadata[to_key] = instance_type[key] DCNL DCSP return metadata
def delete_instance_type_info(metadata, *prefixes): DCNL  DCSP for key in system_metadata_instance_type_props.keys(): DCNL DCSP  DCSP for prefix in prefixes: DCNL DCSP  DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP  DCSP del metadata[to_key] DCNL DCSP return metadata
def _compute_topic(topic, ctxt, host, instance): DCNL  DCSP if (not host): DCNL DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP raise exception.NovaException(_('No DCSP compute DCSP host DCSP specified')) DCNL DCSP  DCSP host = instance['host'] DCNL DCSP  DCSP if (not host): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP find DCSP host DCSP for DCSP Instance DCSP %s') % instance['uuid'])) DCNL DCSP return rpc.queue_get_for(ctxt, topic, host)
def add_instance_fault_from_exc(context, conductor, instance, fault, exc_info=None): DCNL  DCSP code = 500 DCNL DCSP message = fault.__class__.__name__ DCNL DCSP if hasattr(fault, 'kwargs'): DCNL DCSP  DCSP code = fault.kwargs.get('code', 500) DCNL DCSP  DCSP message = fault.kwargs.get('value', message) DCNL DCSP details = unicode(fault) DCNL DCSP if (exc_info and (code == 500)): DCNL DCSP  DCSP tb = exc_info[2] DCNL DCSP  DCSP details += ('\n' + ''.join(traceback.format_tb(tb))) DCNL DCSP values = {'instance_uuid': instance['uuid'], 'code': code, 'message': unicode(message), 'details': unicode(details), 'host': CONF.host} DCNL DCSP conductor.instance_fault_create(context, values)
def get_device_name_for_instance(context, instance, bdms, device): DCNL  DCSP req_prefix = None DCNL DCSP req_letter = None DCNL DCSP if device: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (req_prefix, req_letter) = block_device.match_device(device) DCNL DCSP  DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP  DCSP raise exception.InvalidDevicePath(path=device) DCNL DCSP mappings = block_device.instance_block_mapping(instance, bdms) DCNL DCSP try: DCNL DCSP  DCSP prefix = block_device.match_device(mappings['root'])[0] DCNL DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP raise exception.InvalidDevicePath(path=mappings['root']) DCNL DCSP if driver.compute_driver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP prefix = '/dev/xvd' DCNL DCSP if (req_prefix != prefix): DCNL DCSP  DCSP LOG.debug((_('Using DCSP %(prefix)s DCSP instead DCSP of DCSP %(req_prefix)s') % locals())) DCNL DCSP used_letters = set() DCNL DCSP for device_path in mappings.itervalues(): DCNL DCSP  DCSP letter = block_device.strip_prefix(device_path) DCNL DCSP  DCSP letter = re.sub('\\d+', '', letter) DCNL DCSP  DCSP used_letters.add(letter) DCNL DCSP if driver.compute_driver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP  DCSP if instance_type['ephemeral_gb']: DCNL DCSP  DCSP  DCSP used_letters.add('b') DCNL DCSP  DCSP if instance_type['swap']: DCNL DCSP  DCSP  DCSP used_letters.add('c') DCNL DCSP if (not req_letter): DCNL DCSP  DCSP req_letter = _get_unused_letter(used_letters) DCNL DCSP if (req_letter in used_letters): DCNL DCSP  DCSP raise exception.DevicePathInUse(path=device) DCNL DCSP device_name = (prefix + req_letter) DCNL DCSP return device_name
def notify_usage_exists(context, instance_ref, current_period=False, ignore_missing_network_data=True, system_metadata=None, extra_usage_info=None): DCNL  DCSP (audit_start, audit_end) = notifications.audit_period_bounds(current_period) DCNL DCSP bw = notifications.bandwidth_usage(instance_ref, audit_start, ignore_missing_network_data) DCNL DCSP if (system_metadata is None): DCNL DCSP  DCSP system_metadata = utils.metadata_to_dict(instance_ref['system_metadata']) DCNL DCSP image_meta = notifications.image_meta(system_metadata) DCNL DCSP extra_info = dict(audit_period_beginning=str(audit_start), audit_period_ending=str(audit_end), bandwidth=bw, image_meta=image_meta) DCNL DCSP if extra_usage_info: DCNL DCSP  DCSP extra_info.update(extra_usage_info) DCNL DCSP notify_about_instance_usage(context, instance_ref, 'exists', system_metadata=system_metadata, extra_usage_info=extra_info)
def notify_about_instance_usage(context, instance, event_suffix, network_info=None, system_metadata=None, extra_usage_info=None, host=None): DCNL  DCSP if (not host): DCNL DCSP  DCSP host = CONF.host DCNL DCSP if (not extra_usage_info): DCNL DCSP  DCSP extra_usage_info = {} DCNL DCSP usage_info = notifications.info_from_instance(context, instance, network_info, system_metadata, **extra_usage_info) DCNL DCSP notifier_api.notify(context, ('compute.%s' % host), ('compute.instance.%s' % event_suffix), notifier_api.INFO, usage_info)
def reverts_task_state(function): DCNL  DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.UnexpectedTaskStateError: DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Possibly DCSP task DCSP preempted.')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._instance_update(context, kwargs['instance']['uuid'], task_state=None) DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return decorated_function
def wrap_instance_fault(function): DCNL  DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.InstanceNotFound: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP kwargs.update(dict(zip(function.func_code.co_varnames[2:], args))) DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP compute_utils.add_instance_fault_from_exc(context, self.conductor_api, kwargs['instance'], e, sys.exc_info()) DCNL DCSP return decorated_function
def wrap_instance_event(function): DCNL  DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP wrapped_func = utils.get_wrapped_function(function) DCNL DCSP  DCSP keyed_args = safe_utils.getcallargs(wrapped_func, context, *args, **kwargs) DCNL DCSP  DCSP instance_uuid = keyed_args['instance']['uuid'] DCNL DCSP  DCSP event_name = 'compute_{0}'.format(function.func_name) DCNL DCSP  DCSP with compute_utils.EventReporter(context, self.conductor_api, event_name, instance_uuid): DCNL DCSP  DCSP  DCSP function(self, context, *args, **kwargs) DCNL DCSP return decorated_function
def HostAPI(*args, **kwargs): DCNL  DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__module__ + '.HostAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
def InstanceActionAPI(*args, **kwargs): DCNL  DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__module__ + '.InstanceActionAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
def check_instance_state(vm_state=None, task_state=(None,)): DCNL  DCSP if ((vm_state is not None) and (not isinstance(vm_state, set))): DCNL DCSP  DCSP vm_state = set(vm_state) DCNL DCSP if ((task_state is not None) and (not isinstance(task_state, set))): DCNL DCSP  DCSP task_state = set(task_state) DCNL DCSP def outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(self, context, instance, *args, **kw): DCNL DCSP  DCSP  DCSP if ((vm_state is not None) and (instance['vm_state'] not in vm_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvalidState(attr='vm_state', instance_uuid=instance['uuid'], state=instance['vm_state'], method=f.__name__) DCNL DCSP  DCSP  DCSP if ((task_state is not None) and (instance['task_state'] not in task_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvalidState(attr='task_state', instance_uuid=instance['uuid'], state=instance['task_state'], method=f.__name__) DCNL DCSP  DCSP  DCSP return f(self, context, instance, *args, **kw) DCNL DCSP  DCSP return inner DCNL DCSP return outer
def policy_decorator(scope): DCNL  DCSP def outer(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def wrapped(self, context, target, *args, **kwargs): DCNL DCSP  DCSP  DCSP check_policy(context, func.__name__, target, scope) DCNL DCSP  DCSP  DCSP return func(self, context, target, *args, **kwargs) DCNL DCSP  DCSP return wrapped DCNL DCSP return outer
def _ensure_requested_network_ordering(accessor, unordered, preferred): DCNL  DCSP if preferred: DCNL DCSP  DCSP unordered.sort(key=(lambda i: preferred.index(accessor(i))))
def get_binary_name(): DCNL  DCSP return os.path.basename(inspect.stack()[(-1)][1])[:16]
def metadata_forward(): DCNL  DCSP if (CONF.metadata_host != '127.0.0.1'): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP 80 DCSP -j DCSP DNAT DCSP --to-destination DCSP %s:%s' % (CONF.metadata_host, CONF.metadata_port))) DCNL DCSP else: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP 80 DCSP -j DCSP REDIRECT DCSP --to-ports DCSP %s' % CONF.metadata_port)) DCNL DCSP iptables_manager.apply()
def metadata_accept(): DCNL  DCSP iptables_manager.ipv4['filter'].add_rule('INPUT', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP %s DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP %s DCSP -j DCSP ACCEPT' % (CONF.metadata_host, CONF.metadata_port))) DCNL DCSP iptables_manager.apply()
def init_host(ip_range=None): DCNL  DCSP if (not ip_range): DCNL DCSP  DCSP ip_range = CONF.fixed_range DCNL DCSP add_snat_rule(ip_range) DCNL DCSP rules = [] DCNL DCSP for snat_range in CONF.force_snat_range: DCNL DCSP  DCSP rules.append(('PREROUTING DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP --ip-dst DCSP %s DCSP -j DCSP redirect DCSP --redirect-target DCSP ACCEPT' % (ip_range, snat_range))) DCNL DCSP if rules: DCNL DCSP  DCSP ensure_ebtables_rules(rules, 'nat') DCNL DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %s DCSP -d DCSP %s/32 DCSP -j DCSP ACCEPT' % (ip_range, CONF.metadata_host))) DCNL DCSP for dmz in CONF.dmz_cidr: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %s DCSP -d DCSP %s DCSP -j DCSP ACCEPT' % (ip_range, dmz))) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %(range)s DCSP -d DCSP %(range)s DCSP -m DCSP conntrack DCSP ! DCSP --ctstate DCSP DNAT DCSP -j DCSP ACCEPT' % {'range': ip_range})) DCNL DCSP iptables_manager.apply()
def bind_floating_ip(floating_ip, device): DCNL  DCSP _execute('ip', 'addr', 'add', (str(floating_ip) + '/32'), 'dev', device, run_as_root=True, check_exit_code=[0, 2, 254]) DCNL DCSP if (CONF.send_arp_for_ha and (CONF.send_arp_for_ha_count > 0)): DCNL DCSP  DCSP send_arp_for_ip(floating_ip, device, CONF.send_arp_for_ha_count)
def unbind_floating_ip(floating_ip, device): DCNL  DCSP _execute('ip', 'addr', 'del', (str(floating_ip) + '/32'), 'dev', device, run_as_root=True, check_exit_code=[0, 2, 254])
def ensure_metadata_ip(): DCNL  DCSP _execute('ip', 'addr', 'add', '169.254.169.254/32', 'scope', 'link', 'dev', 'lo', run_as_root=True, check_exit_code=[0, 2, 254])
def ensure_vpn_forward(public_ip, port, private_ip): DCNL  DCSP iptables_manager.ipv4['filter'].add_rule('FORWARD', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP 1194 DCSP -j DCSP ACCEPT' % private_ip)) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('OUTPUT', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.apply()
def ensure_floating_forward(floating_ip, fixed_ip, device, network): DCNL  DCSP regex = ('.*\\s+%s(/32|\\s+|$)' % floating_ip) DCNL DCSP num_rules = iptables_manager.ipv4['nat'].remove_rules_regex(regex) DCNL DCSP if num_rules: DCNL DCSP  DCSP msg = _('Removed DCSP %(num)d DCSP duplicate DCSP rules DCSP for DCSP floating DCSP ip DCSP %(float)s') DCNL DCSP  DCSP LOG.warn((msg % {'num': num_rules, 'float': floating_ip})) DCNL DCSP for (chain, rule) in floating_forward_rules(floating_ip, fixed_ip, device): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (device != network['bridge']): DCNL DCSP  DCSP ensure_ebtables_rules(*floating_ebtables_rules(fixed_ip, network))
def remove_floating_forward(floating_ip, fixed_ip, device, network): DCNL  DCSP for (chain, rule) in floating_forward_rules(floating_ip, fixed_ip, device): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].remove_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (device != network['bridge']): DCNL DCSP  DCSP remove_ebtables_rules(*floating_ebtables_rules(fixed_ip, network))
def floating_ebtables_rules(fixed_ip, network): DCNL  DCSP return ([('PREROUTING DCSP --logical-in DCSP %s DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP ! DCSP --ip-dst DCSP %s DCSP -j DCSP redirect DCSP --redirect-target DCSP ACCEPT' % (network['bridge'], fixed_ip, network['cidr']))], 'nat')
def get_dhcp_leases(context, network_ref): DCNL  DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id'], host=host): DCNL DCSP  DCSP if (data['allocated'] and data['leased']): DCNL DCSP  DCSP  DCSP hosts.append(_host_lease(data)) DCNL DCSP return '\n'.join(hosts)
def get_dhcp_hosts(context, network_ref): DCNL  DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP macs = set() DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id'], host=host): DCNL DCSP  DCSP if (data['vif_address'] not in macs): DCNL DCSP  DCSP  DCSP hosts.append(_host_dhcp(data)) DCNL DCSP  DCSP  DCSP macs.add(data['vif_address']) DCNL DCSP return '\n'.join(hosts)
def get_dns_hosts(context, network_ref): DCNL  DCSP hosts = [] DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id']): DCNL DCSP  DCSP hosts.append(_host_dns(data)) DCNL DCSP return '\n'.join(hosts)
def _add_dnsmasq_accept_rules(dev): DCNL  DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['udp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'dev': dev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.add_rule('INPUT', ('-i DCSP %(dev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --dport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
def _remove_dnsmasq_accept_rules(dev): DCNL  DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['udp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'dev': dev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.remove_rule('INPUT', ('-i DCSP %(dev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --dport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
def get_dhcp_opts(context, network_ref): DCNL  DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP data = db.network_get_associated_fixed_ips(context, network_ref['id'], host=host) DCNL DCSP if data: DCNL DCSP  DCSP instance_set = set([datum['instance_uuid'] for datum in data]) DCNL DCSP  DCSP default_gw_vif = {} DCNL DCSP  DCSP for instance_uuid in instance_set: DCNL DCSP  DCSP  DCSP vifs = db.virtual_interface_get_by_instance(context, instance_uuid) DCNL DCSP  DCSP  DCSP if vifs: DCNL DCSP  DCSP  DCSP  DCSP default_gw_vif[instance_uuid] = vifs[0]['id'] DCNL DCSP  DCSP for datum in data: DCNL DCSP  DCSP  DCSP instance_uuid = datum['instance_uuid'] DCNL DCSP  DCSP  DCSP if (instance_uuid in default_gw_vif): DCNL DCSP  DCSP  DCSP  DCSP if (default_gw_vif[instance_uuid] != datum['vif_id']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hosts.append(_host_dhcp_opts(datum)) DCNL DCSP return '\n'.join(hosts)
@lockutils.synchronized('dnsmasq_start', 'nova-') DCNL def restart_dhcp(context, dev, network_ref): DCNL  DCSP conffile = _dhcp_file(dev, 'conf') DCNL DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP optsfile = _dhcp_file(dev, 'opts') DCNL DCSP  DCSP write_to_file(optsfile, get_dhcp_opts(context, network_ref)) DCNL DCSP  DCSP os.chmod(optsfile, 420) DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP _add_dhcp_mangle_rule(dev) DCNL DCSP os.chmod(conffile, 420) DCNL DCSP pid = _dnsmasq_pid_for(dev) DCNL DCSP if pid: DCNL DCSP  DCSP (out, _err) = _execute('cat', ('/proc/%d/cmdline' % pid), check_exit_code=False) DCNL DCSP  DCSP if (conffile.split('/')[(-1)] in out): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _execute('kill', '-HUP', pid, run_as_root=True) DCNL DCSP  DCSP  DCSP  DCSP _add_dnsmasq_accept_rules(dev) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('Hupping DCSP dnsmasq DCSP threw DCSP %s'), exc) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.debug(_('Pid DCSP %d DCSP is DCSP stale, DCSP relaunching DCSP dnsmasq'), pid) DCNL DCSP cmd = ['env', ('CONFIG_FILE=%s' % jsonutils.dumps(CONF.dhcpbridge_flagfile)), ('NETWORK_ID=%s' % str(network_ref['id'])), 'dnsmasq', '--strict-order', '--bind-interfaces', ('--conf-file=%s' % CONF.dnsmasq_config_file), ('--pid-file=%s' % _dhcp_file(dev, 'pid')), ('--listen-address=%s' % network_ref['dhcp_server']), '--except-interface=lo', ('--dhcp-range=set:%s,%s,static,%s,%ss' % (network_ref['label'], network_ref['dhcp_start'], network_ref['netmask'], CONF.dhcp_lease_time)), ('--dhcp-lease-max=%s' % len(netaddr.IPNetwork(network_ref['cidr']))), ('--dhcp-hostsfile=%s' % _dhcp_file(dev, 'conf')), ('--dhcp-script=%s' % CONF.dhcpbridge), '--leasefile-ro'] DCNL DCSP if CONF.dhcp_domain: DCNL DCSP  DCSP cmd.append(('--domain=%s' % CONF.dhcp_domain)) DCNL DCSP dns_servers = set(CONF.dns_server) DCNL DCSP if CONF.use_network_dns_servers: DCNL DCSP  DCSP if network_ref.get('dns1'): DCNL DCSP  DCSP  DCSP dns_servers.add(network_ref.get('dns1')) DCNL DCSP  DCSP if network_ref.get('dns2'): DCNL DCSP  DCSP  DCSP dns_servers.add(network_ref.get('dns2')) DCNL DCSP if (network_ref['multi_host'] or dns_servers): DCNL DCSP  DCSP cmd.append('--no-hosts') DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP ('--addn-hosts=%s' % _dhcp_file(dev, 'hosts')) DCNL DCSP if dns_servers: DCNL DCSP  DCSP cmd.append('--no-resolv') DCNL DCSP for dns_server in dns_servers: DCNL DCSP  DCSP cmd.append(('--server=%s' % dns_server)) DCNL DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP cmd += [('--dhcp-optsfile=%s' % _dhcp_file(dev, 'opts'))] DCNL DCSP _execute(run_as_root=True, *cmd) DCNL DCSP _add_dnsmasq_accept_rules(dev)
def _host_lease(data): DCNL  DCSP timestamp = timeutils.utcnow() DCNL DCSP seconds_since_epoch = calendar.timegm(timestamp.utctimetuple()) DCNL DCSP return ('%d DCSP %s DCSP %s DCSP %s DCSP *' % ((seconds_since_epoch + CONF.dhcp_lease_time), data['vif_address'], data['address'], (data['instance_hostname'] or '*')))
def _host_dhcp(data): DCNL  DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP return ('%s,%s.%s,%s,%s' % (data['vif_address'], data['instance_hostname'], CONF.dhcp_domain, data['address'], ('net:' + _host_dhcp_network(data)))) DCNL DCSP else: DCNL DCSP  DCSP return ('%s,%s.%s,%s' % (data['vif_address'], data['instance_hostname'], CONF.dhcp_domain, data['address']))
def _host_dhcp_opts(data): DCNL  DCSP return ('%s,%s' % (_host_dhcp_network(data), 3))
def _execute(*cmd, **kwargs): DCNL  DCSP if CONF.fake_network: DCNL DCSP  DCSP LOG.debug('FAKE DCSP NET: DCSP %s', ' DCSP '.join(map(str, cmd))) DCNL DCSP  DCSP return ('fake', 0) DCNL DCSP else: DCNL DCSP  DCSP return utils.execute(*cmd, **kwargs)
def device_exists(device): DCNL  DCSP (_out, err) = _execute('ip', 'link', 'show', 'dev', device, check_exit_code=False, run_as_root=True) DCNL DCSP return (not err)
def _dhcp_file(dev, kind): DCNL  DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-%s.%s' % (CONF.networks_path, dev, kind)))
def _ra_file(dev, kind): DCNL  DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-ra-%s.%s' % (CONF.networks_path, dev, kind)))
def _dnsmasq_pid_for(dev): DCNL  DCSP pid_file = _dhcp_file(dev, 'pid') DCNL DCSP if os.path.exists(pid_file): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(pid_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return int(f.read()) DCNL DCSP  DCSP except (ValueError, IOError): DCNL DCSP  DCSP  DCSP return None
def _ra_pid_for(dev): DCNL  DCSP pid_file = _ra_file(dev, 'pid') DCNL DCSP if os.path.exists(pid_file): DCNL DCSP  DCSP with open(pid_file, 'r') as f: DCNL DCSP  DCSP  DCSP return int(f.read())
def _ip_bridge_cmd(action, params, device): DCNL  DCSP cmd = ['ip', 'addr', action] DCNL DCSP cmd.extend(params) DCNL DCSP cmd.extend(['dev', device]) DCNL DCSP return cmd
def _create_veth_pair(dev1_name, dev2_name): DCNL  DCSP for dev in [dev1_name, dev2_name]: DCNL DCSP  DCSP if device_exists(dev): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('ip', 'link', 'delete', dev1_name, run_as_root=True, check_exit_code=[0, 2, 254]) DCNL DCSP  DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception((_('Error DCSP clearing DCSP stale DCSP veth DCSP %s') % dev)) DCNL DCSP utils.execute('ip', 'link', 'add', dev1_name, 'type', 'veth', 'peer', 'name', dev2_name, run_as_root=True) DCNL DCSP for dev in [dev1_name, dev2_name]: DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', dev, 'up', run_as_root=True) DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', dev, 'promisc', 'on', run_as_root=True)
def refresh_cache(f): DCNL  DCSP argspec = inspect.getargspec(f) DCNL DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, context, *args, **kwargs): DCNL DCSP  DCSP res = f(self, context, *args, **kwargs) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance = kwargs.get('instance') DCNL DCSP  DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP  DCSP instance = args[(argspec.args.index('instance') - 2)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP msg = _('instance DCSP is DCSP a DCSP required DCSP argument DCSP to DCSP use DCSP @refresh_cache') DCNL DCSP  DCSP  DCSP raise Exception(msg) DCNL DCSP  DCSP update_instance_cache_with_nw_info(self, context, instance, nw_info=res, conductor_api=kwargs.get('conductor_api')) DCNL DCSP  DCSP return res DCNL DCSP return wrapper
def wrap_check_policy(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, context, *args, **kwargs): DCNL DCSP  DCSP action = func.__name__ DCNL DCSP  DCSP check_policy(context, action) DCNL DCSP  DCSP return func(self, context, *args, **kwargs) DCNL DCSP return wrapped
def echo_scsi_command(path, content): DCNL  DCSP args = ['-a', path] DCNL DCSP kwargs = dict(process_input=content, run_as_root=True) DCNL DCSP utils.execute('tee', *args, **kwargs)
def find_multipath_device(device): DCNL  DCSP mdev = None DCNL DCSP devices = [] DCNL DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = utils.execute('multipath', '-l', device, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP LOG.warn((_('Multipath DCSP call DCSP failed DCSP exit DCSP (%(code)s)') % {'code': exc.exit_code})) DCNL DCSP  DCSP return None DCNL DCSP if out: DCNL DCSP  DCSP lines = out.strip() DCNL DCSP  DCSP lines = lines.split('\n') DCNL DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP line = lines[0] DCNL DCSP  DCSP  DCSP info = line.split(' DCSP ') DCNL DCSP  DCSP  DCSP if (info[1][:2] == 'dm'): DCNL DCSP  DCSP  DCSP  DCSP mdev = ('/dev/%s' % info[1]) DCNL DCSP  DCSP  DCSP elif (info[2][:2] == 'dm'): DCNL DCSP  DCSP  DCSP  DCSP mdev = ('/dev/%s' % info[2]) DCNL DCSP  DCSP  DCSP if (mdev is None): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_("Couldn't DCSP find DCSP multipath DCSP device DCSP %(line)s") % locals())) DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP LOG.debug((_('Found DCSP multipath DCSP device DCSP = DCSP %(mdev)s') % locals())) DCNL DCSP  DCSP  DCSP device_lines = lines[3:] DCNL DCSP  DCSP  DCSP for dev_line in device_lines: DCNL DCSP  DCSP  DCSP  DCSP dev_line = dev_line.strip() DCNL DCSP  DCSP  DCSP  DCSP dev_line = dev_line[3:] DCNL DCSP  DCSP  DCSP  DCSP dev_info = dev_line.split(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (dev_line.find('policy') != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP address = dev_info[0].split(':') DCNL DCSP  DCSP  DCSP  DCSP  DCSP dev = {'device': ('/dev/%s' % dev_info[1]), 'host': address[0], 'channel': address[1], 'id': address[2], 'lun': address[3]} DCNL DCSP  DCSP  DCSP  DCSP  DCSP devices.append(dev) DCNL DCSP if (mdev is not None): DCNL DCSP  DCSP info = {'device': mdev, 'devices': devices} DCNL DCSP  DCSP return info DCNL DCSP return None
def stub_out_glanceclient_create(stubs, sent_to_glance): DCNL  DCSP orig_add_image = glanceclient.v1.images.ImageManager.create DCNL DCSP def fake_create(context, metadata, data=None): DCNL DCSP  DCSP sent_to_glance['metadata'] = metadata DCNL DCSP  DCSP sent_to_glance['data'] = data DCNL DCSP  DCSP return orig_add_image(metadata, data) DCNL DCSP stubs.Set(glanceclient.v1.images.ImageManager, 'create', fake_create)
def webob_factory(url): DCNL  DCSP base_url = url DCNL DCSP def web_request(url, method=None, body=None): DCNL DCSP  DCSP req = webob.Request.blank(('%s%s' % (base_url, url))) DCNL DCSP  DCSP if method: DCNL DCSP  DCSP  DCSP req.content_type = 'application/json' DCNL DCSP  DCSP  DCSP req.method = method DCNL DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP req.body = jsonutils.dumps(body) DCNL DCSP  DCSP return req DCNL DCSP return web_request
def compare_links(actual, expected): DCNL  DCSP return compare_tree_to_dict(actual, expected, ('rel', 'href', 'type'))
def compare_media_types(actual, expected): DCNL  DCSP return compare_tree_to_dict(actual, expected, ('base', 'type'))
def compare_tree_to_dict(actual, expected, keys): DCNL  DCSP for (elem, data) in zip(actual, expected): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != data.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
def format_action(action): DCNL  DCSP if ('id' in action): DCNL DCSP  DCSP del action['id'] DCNL DCSP if ('finish_time' in action): DCNL DCSP  DCSP del action['finish_time'] DCNL DCSP return action
def format_event(event): DCNL  DCSP if ('id' in event): DCNL DCSP  DCSP del event['id'] DCNL DCSP return event
def stub_set_host_enabled(context, host_name, enabled): DCNL  DCSP results = {True: 'enabled', False: 'disabled'} DCNL DCSP if (host_name == 'notimplemented'): DCNL DCSP  DCSP raise NotImplementedError() DCNL DCSP elif (host_name == 'dummydest'): DCNL DCSP  DCSP raise exception.ComputeHostNotFound(host=host_name) DCNL DCSP elif (host_name == 'host_c2'): DCNL DCSP  DCSP return results[(not enabled)] DCNL DCSP else: DCNL DCSP  DCSP return results[enabled]
def _create_instance(**kwargs): DCNL  DCSP ctxt = context_maker.get_admin_context() DCNL DCSP return db.instance_create(ctxt, _create_instance_dict(**kwargs))
def _create_instance_dict(**kwargs): DCNL  DCSP inst = {} DCNL DCSP inst['image_ref'] = 'cedef40a-ed67-4d10-800e-17455edce175' DCNL DCSP inst['reservation_id'] = 'r-fakeres' DCNL DCSP inst['user_id'] = kwargs.get('user_id', 'admin') DCNL DCSP inst['project_id'] = kwargs.get('project_id', 'fake') DCNL DCSP inst['instance_type_id'] = '1' DCNL DCSP if ('host' in kwargs): DCNL DCSP  DCSP inst['host'] = kwargs.get('host') DCNL DCSP inst['vcpus'] = kwargs.get('vcpus', 1) DCNL DCSP inst['memory_mb'] = kwargs.get('memory_mb', 20) DCNL DCSP inst['root_gb'] = kwargs.get('root_gb', 30) DCNL DCSP inst['ephemeral_gb'] = kwargs.get('ephemeral_gb', 30) DCNL DCSP inst['vm_state'] = kwargs.get('vm_state', vm_states.ACTIVE) DCNL DCSP inst['power_state'] = kwargs.get('power_state', power_state.RUNNING) DCNL DCSP inst['task_state'] = kwargs.get('task_state', None) DCNL DCSP inst['availability_zone'] = kwargs.get('availability_zone', None) DCNL DCSP inst['ami_launch_index'] = 0 DCNL DCSP inst['launched_on'] = kwargs.get('launched_on', 'dummy') DCNL DCSP return inst
def _quote_domain(domain): DCNL  DCSP return urllib.quote(domain.replace('.', '%2E'))
def wire_HTTPConnection_to_WSGI(host, app): DCNL  DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL  DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL  DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
@webob.dec.wsgify DCNL def conditional_forbid(req): DCNL  DCSP if (('die' in req.params) and (req.params['die'] == '1')): DCNL DCSP  DCSP raise webob.exc.HTTPForbidden() DCNL DCSP return 'OK'
def stub_vm_utils_with_vdi_attached_here(function, should_return=True): DCNL  DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, *args, **kwargs): DCNL DCSP  DCSP @contextlib.contextmanager DCNL DCSP  DCSP def fake_vdi_attached_here(*args, **kwargs): DCNL DCSP  DCSP  DCSP fake_dev = 'fakedev' DCNL DCSP  DCSP  DCSP (yield fake_dev) DCNL DCSP  DCSP def fake_image_download(*args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def fake_is_vdi_pv(*args, **kwargs): DCNL DCSP  DCSP  DCSP return should_return DCNL DCSP  DCSP orig_vdi_attached_here = vm_utils.vdi_attached_here DCNL DCSP  DCSP orig_image_download = fake_image._FakeImageService.download DCNL DCSP  DCSP orig_is_vdi_pv = vm_utils._is_vdi_pv DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_utils.vdi_attached_here = fake_vdi_attached_here DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.download = fake_image_download DCNL DCSP  DCSP  DCSP vm_utils._is_vdi_pv = fake_is_vdi_pv DCNL DCSP  DCSP  DCSP return function(self, *args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP vm_utils._is_vdi_pv = orig_is_vdi_pv DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.download = orig_image_download DCNL DCSP  DCSP  DCSP vm_utils.vdi_attached_here = orig_vdi_attached_here DCNL DCSP return decorated_function
def fake_get_vim_object(arg): DCNL  DCSP return fake.FakeVim()
def fake_is_vim_object(arg, module): DCNL  DCSP return isinstance(module, fake.FakeVim)
def set_stubs(stubs): DCNL  DCSP stubs.Set(vmops.VMwareVMOps, 'plug_vifs', fake.fake_plug_vifs) DCNL DCSP stubs.Set(network_util, 'get_network_with_the_name', fake.fake_get_network) DCNL DCSP stubs.Set(vmware_images, 'fetch_image', fake.fake_fetch_image) DCNL DCSP stubs.Set(vmware_images, 'get_vmdk_size_and_properties', fake.fake_get_vmdk_size_and_properties) DCNL DCSP stubs.Set(vmware_images, 'upload_image', fake.fake_upload_image) DCNL DCSP stubs.Set(driver.VMwareAPISession, '_get_vim_object', fake_get_vim_object) DCNL DCSP stubs.Set(driver.VMwareAPISession, '_is_vim_object', fake_is_vim_object)
def stub_out_db_instance_api(stubs): DCNL  DCSP INSTANCE_TYPES = {'m1.tiny': dict(memory_mb=512, vcpus=1, root_gb=0, flavorid=1), 'm1.small': dict(memory_mb=2048, vcpus=1, root_gb=20, flavorid=2), 'm1.medium': dict(memory_mb=4096, vcpus=2, root_gb=40, flavorid=3), 'm1.large': dict(memory_mb=8192, vcpus=4, root_gb=80, flavorid=4), 'm1.xlarge': dict(memory_mb=16384, vcpus=8, root_gb=160, flavorid=5)} DCNL DCSP class FakeModel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP model.' DCNL DCSP  DCSP def __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP def __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP def __getitem__(self, key): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementedError() DCNL DCSP def fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP db.instance_create DCSP method.' DCNL DCSP  DCSP type_data = INSTANCE_TYPES[values['instance_type']] DCNL DCSP  DCSP base_options = {'name': values['name'], 'id': values['id'], 'uuid': uuid.uuid4(), 'reservation_id': utils.generate_uid('r'), 'image_ref': values['image_ref'], 'kernel_id': values['kernel_id'], 'ramdisk_id': values['ramdisk_id'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_id': values['user_id'], 'project_id': values['project_id'], 'launch_time': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'instance_type': values['instance_type'], 'memory_mb': type_data['memory_mb'], 'vcpus': type_data['vcpus'], 'mac_addresses': [{'address': values['mac_address']}], 'root_gb': type_data['root_gb']} DCNL DCSP  DCSP return FakeModel(base_options) DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP stubs.Set(db, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(db, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(db, 'instance_type_get_by_name', fake_instance_type_get_by_name)
def example_decorator(name, function): DCNL  DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.append(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrapped_func
def stub_out_db_instance_api(stubs): DCNL  DCSP INSTANCE_TYPES = {'m1.tiny': dict(memory_mb=512, vcpus=1, root_gb=0, flavorid=1), 'm1.small': dict(memory_mb=2048, vcpus=1, root_gb=20, flavorid=2), 'm1.medium': dict(memory_mb=4096, vcpus=2, root_gb=40, flavorid=3), 'm1.large': dict(memory_mb=8192, vcpus=4, root_gb=80, flavorid=4), 'm1.xlarge': dict(memory_mb=16384, vcpus=8, root_gb=160, flavorid=5)} DCNL DCSP class FakeModel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP model.' DCNL DCSP  DCSP def __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP def get(self, key, default=None): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return default DCNL DCSP  DCSP def __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP def __getitem__(self, key): DCNL DCSP  DCSP  DCSP return self.get(key) DCNL DCSP  DCSP def __setitem__(self, key, value): DCNL DCSP  DCSP  DCSP self.values[key] = value DCNL DCSP  DCSP def __str__(self): DCNL DCSP  DCSP  DCSP return str(self.values) DCNL DCSP def fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP db.instance_create DCSP method.' DCNL DCSP  DCSP if ('instance_type' not in values): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP instance_type = values['instance_type'] DCNL DCSP  DCSP base_options = {'name': values['name'], 'id': values['id'], 'uuid': str(uuid.uuid4()), 'reservation_id': utils.generate_uid('r'), 'image_ref': values['image_ref'], 'kernel_id': values['kernel_id'], 'ramdisk_id': values['ramdisk_id'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_id': values['user_id'], 'project_id': values['project_id'], 'launch_time': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'instance_type': instance_type, 'memory_mb': instance_type['memory_mb'], 'vcpus': instance_type['vcpus'], 'mac_addresses': [{'address': values['mac_address']}], 'root_gb': instance_type['root_gb']} DCNL DCSP  DCSP return FakeModel(base_options) DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP def fake_block_device_mapping_get_all_by_instance(context, instance_uuid): DCNL DCSP  DCSP return {} DCNL DCSP stubs.Set(db, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(db, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(db, 'instance_type_get_by_name', fake_instance_type_get_by_name) DCNL DCSP stubs.Set(db, 'block_device_mapping_get_all_by_instance', fake_block_device_mapping_get_all_by_instance)
def stubout_session(stubs, cls, product_version=(5, 6, 2), product_brand='XenServer', **opt_args): DCNL  DCSP stubs.Set(xenapi_conn.XenAPISession, '_create_session', (lambda s, url: cls(url, **opt_args))) DCNL DCSP stubs.Set(xenapi_conn.XenAPISession, '_get_product_version_and_brand', (lambda s: (product_version, product_brand)))
def stubout_determine_is_pv_objectstore(stubs): DCNL  DCSP def f(*args): DCNL DCSP  DCSP return False DCNL DCSP stubs.Set(vm_utils, '_determine_is_pv_objectstore', f)
def stubout_is_snapshot(stubs): DCNL  DCSP def f(*args): DCNL DCSP  DCSP return True DCNL DCSP stubs.Set(vm_utils, 'is_snapshot', f)
def stubout_lookup_image(stubs): DCNL  DCSP def f(_1, _2, _3, _4): DCNL DCSP  DCSP raise Exception('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP lookup_image') DCNL DCSP stubs.Set(vm_utils, 'lookup_image', f)
def stubout_fetch_disk_image(stubs, raise_failure=False): DCNL  DCSP def _fake_fetch_disk_image(context, session, instance, name_label, image, image_type): DCNL DCSP  DCSP if raise_failure: DCNL DCSP  DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP fetch_image_glance_disk') DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.KERNEL): DCNL DCSP  DCSP  DCSP filename = 'kernel' DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.RAMDISK): DCNL DCSP  DCSP  DCSP filename = 'ramdisk' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filename = 'unknown' DCNL DCSP  DCSP vdi_type = vm_utils.ImageType.to_string(image_type) DCNL DCSP  DCSP return {vdi_type: dict(uuid=None, file=filename)} DCNL DCSP stubs.Set(vm_utils, '_fetch_disk_image', _fake_fetch_disk_image)
def stubout_create_vm(stubs): DCNL  DCSP def f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP create_vm') DCNL DCSP stubs.Set(vm_utils, 'create_vm', f)
def stubout_attach_disks(stubs): DCNL  DCSP def f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP _attach_disks') DCNL DCSP stubs.Set(vmops.VMOps, '_attach_disks', f)
def fake_execute_set_repliers(repliers): DCNL  DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL  DCSP return ('', '')
def fake_execute(*cmd_parts, **kwargs): DCNL  DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_code = kwargs.get('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.get('delay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmd_str = ' DCSP '.join((str(part) for part in cmd_parts)) DCNL DCSP LOG.debug(_('Faking DCSP execution DCSP of DCSP cmd DCSP (subprocess): DCSP %s'), cmd_str) DCNL DCSP _fake_execute_log.append(cmd_str) DCNL DCSP reply_handler = fake_execute_default_reply_handler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmd_str): DCNL DCSP  DCSP  DCSP reply_handler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.debug((_('Faked DCSP command DCSP matched DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_handler, basestring): DCNL DCSP  DCSP reply = (reply_handler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_handler(cmd_parts, process_input=process_input, delay_on_retry=delay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_code=check_exit_code) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Faked DCSP command DCSP raised DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stdout = reply[0] DCNL DCSP stderr = reply[1] DCNL DCSP LOG.debug((_("Reply DCSP to DCSP faked DCSP command DCSP is DCSP stdout='%(stdout)s' DCSP stderr='%(stderr)s'") % locals())) DCNL DCSP greenthread.sleep(0) DCNL DCSP return reply
def stub_out(stubs, funcs): DCNL  DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(db, func_name, func) DCNL DCSP  DCSP stubs.Set(db.sqlalchemy.api, func_name, func)
def stub_out_db_instance_api(stubs, injected=True): DCNL  DCSP INSTANCE_TYPES = {'m1.tiny': dict(id=2, name='m1.tiny', memory_mb=512, vcpus=1, vcpu_weight=None, root_gb=0, ephemeral_gb=10, flavorid=1, rxtx_factor=1.0, swap=0), 'm1.small': dict(id=5, name='m1.small', memory_mb=2048, vcpus=1, vcpu_weight=None, root_gb=20, ephemeral_gb=0, flavorid=2, rxtx_factor=1.0, swap=1024), 'm1.medium': dict(id=1, name='m1.medium', memory_mb=4096, vcpus=2, vcpu_weight=None, root_gb=40, ephemeral_gb=40, flavorid=3, rxtx_factor=1.0, swap=0), 'm1.large': dict(id=3, name='m1.large', memory_mb=8192, vcpus=4, vcpu_weight=None, root_gb=80, ephemeral_gb=80, flavorid=4, rxtx_factor=1.0, swap=0), 'm1.xlarge': dict(id=4, name='m1.xlarge', memory_mb=16384, vcpus=8, vcpu_weight=None, root_gb=160, ephemeral_gb=160, flavorid=5, rxtx_factor=1.0, swap=0)} DCNL DCSP flat_network_fields = {'id': 'fake_flat', 'bridge': 'xenbr0', 'label': 'fake_flat_network', 'netmask': '255.255.255.0', 'cidr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broadcast': '10.0.0.255', 'dns': '10.0.0.2', 'ra_server': None, 'injected': injected} DCNL DCSP vlan_network_fields = {'id': 'fake_vlan', 'bridge': 'br111', 'label': 'fake_vlan_network', 'netmask': '255.255.255.0', 'cidr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broadcast': '10.0.0.255', 'dns': '10.0.0.2', 'ra_server': None, 'vlan': 111, 'injected': False} DCNL DCSP fixed_ip_fields = {'address': '10.0.0.3', 'address_v6': 'fe80::a00:3', 'network_id': 'fake_flat'} DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP def fake_instance_type_get(context, id): DCNL DCSP  DCSP for (name, inst_type) in INSTANCE_TYPES.iteritems(): DCNL DCSP  DCSP  DCSP if (str(inst_type['id']) == str(id)): DCNL DCSP  DCSP  DCSP  DCSP return inst_type DCNL DCSP  DCSP return None DCNL DCSP def fake_network_get_all_by_instance(context, instance_id): DCNL DCSP  DCSP if ((instance_id % 2) == 0): DCNL DCSP  DCSP  DCSP return [FakeModel(vlan_network_fields)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [FakeModel(flat_network_fields)] DCNL DCSP def fake_fixed_ip_get_by_instance(context, instance_id): DCNL DCSP  DCSP return [FakeModel(fixed_ip_fields)] DCNL DCSP funcs = [fake_network_get_all_by_instance, fake_instance_type_get_all, fake_instance_type_get_by_name, fake_instance_type_get, fake_network_get_all_by_instance, fake_fixed_ip_get_by_instance] DCNL DCSP stub_out(stubs, funcs)
def initialize(_uri): DCNL  DCSP return FakeLDAP()
def _match_query(query, attrs): DCNL  DCSP inner = query[1:(-1)] DCNL DCSP if inner.startswith('&'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_query(l, attrs) and _match_query(r, attrs)) DCNL DCSP if inner.startswith('|'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_query(l, attrs) or _match_query(r, attrs)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_query(query[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
def _paren_groups(source): DCNL  DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.append(source[start:(pos + 1)]) DCNL DCSP return result
def _match(key, value, attrs): DCNL  DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
def _subs(value): DCNL  DCSP subs = {'groupOfNames': ['novaProject']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
def _from_json(encoded): DCNL  DCSP return [str(x) for x in jsonutils.loads(encoded)]
def _to_json(unencoded): DCNL  DCSP return jsonutils.dumps(list(unencoded))
def _get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL  DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP return instances
def generate_random_alphanumeric(length): DCNL  DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))
def generate_random_numeric(length): DCNL  DCSP return ''.join((random.choice(string.digits) for _x in range(length)))
def generate_new_element(items, prefix, numeric=False): DCNL  DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_alphanumeric(8)) DCNL DCSP  DCSP if (candidate not in items): DCNL DCSP  DCSP  DCSP return candidate DCNL DCSP  DCSP LOG.debug(('Random DCSP collision DCSP on DCSP %s' % candidate))
def _get_connect_string(backend, user, passwd, database): DCNL  DCSP if (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP elif (backend == 'mysql'): DCNL DCSP  DCSP backend = 'mysql+mysqldb' DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Unrecognized DCSP backend: DCSP '%s'" % backend)) DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
def get_table(engine, name): DCNL  DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
def catch_notimplementederror(f): DCNL  DCSP def wrapped_func(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP frame = traceback.extract_tb(sys.exc_info()[2])[(-1)] DCNL DCSP  DCSP  DCSP LOG.error(('%(driver)s DCSP does DCSP not DCSP implement DCSP %(method)s' % {'driver': type(self.connection), 'method': frame[2]})) DCNL DCSP wrapped_func.__name__ = f.__name__ DCNL DCSP wrapped_func.__doc__ = f.__doc__ DCNL DCSP return wrapped_func
def get_availability_zones(context): DCNL  DCSP enabled_services = db.service_get_all(context, False) DCNL DCSP disabled_services = db.service_get_all(context, True) DCNL DCSP enabled_services = set_availability_zones(context, enabled_services) DCNL DCSP disabled_services = set_availability_zones(context, disabled_services) DCNL DCSP available_zones = [] DCNL DCSP for zone in [service['availability_zone'] for service in enabled_services]: DCNL DCSP  DCSP if (zone not in available_zones): DCNL DCSP  DCSP  DCSP available_zones.append(zone) DCNL DCSP not_available_zones = [] DCNL DCSP zones = [service['availability_zone'] for service in disabled_services if (service['availability_zone'] not in available_zones)] DCNL DCSP for zone in zones: DCNL DCSP  DCSP if (zone not in not_available_zones): DCNL DCSP  DCSP  DCSP not_available_zones.append(zone) DCNL DCSP return (available_zones, not_available_zones)
def get_instances_to_sync(context, updated_since=None, project_id=None, deleted=True, shuffle=False, uuids_only=False): DCNL  DCSP filters = {} DCNL DCSP if (updated_since is not None): DCNL DCSP  DCSP filters['changes-since'] = updated_since DCNL DCSP if (project_id is not None): DCNL DCSP  DCSP filters['project_id'] = project_id DCNL DCSP if (not deleted): DCNL DCSP  DCSP filters['deleted'] = False DCNL DCSP instances = db.instance_get_all_by_filters(context, filters, 'deleted', 'asc') DCNL DCSP if shuffle: DCNL DCSP  DCSP random.shuffle(instances) DCNL DCSP for instance in instances: DCNL DCSP  DCSP if uuids_only: DCNL DCSP  DCSP  DCSP (yield instance['uuid']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield instance)
def cell_with_item(cell_name, item): DCNL  DCSP if (cell_name is None): DCNL DCSP  DCSP return item DCNL DCSP return ((cell_name + _CELL_ITEM_SEP) + str(item))
def split_cell_and_item(cell_and_item): DCNL  DCSP result = cell_and_item.rsplit(_CELL_ITEM_SEP, 1) DCNL DCSP if (len(result) == 1): DCNL DCSP  DCSP return (None, cell_and_item) DCNL DCSP else: DCNL DCSP  DCSP return result
def add_cell_to_compute_node(compute_node, cell_name): DCNL  DCSP compute_node['id'] = cell_with_item(cell_name, compute_node['id']) DCNL DCSP service = compute_node.get('service') DCNL DCSP if isinstance(service, dict): DCNL DCSP  DCSP _add_cell_to_service(service, cell_name)
def add_cell_to_service(service, cell_name): DCNL  DCSP _add_cell_to_service(service, cell_name) DCNL DCSP compute_node = service.get('compute_node') DCNL DCSP if compute_node: DCNL DCSP  DCSP add_cell_to_compute_node(compute_node[0], cell_name)
def add_cell_to_task_log(task_log, cell_name): DCNL  DCSP task_log['id'] = cell_with_item(cell_name, task_log['id']) DCNL DCSP task_log['host'] = cell_with_item(cell_name, task_log['host'])
def sync_from_db(f): DCNL  DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self._time_to_sync(): DCNL DCSP  DCSP  DCSP self._cell_db_sync() DCNL DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP return wrapper
def _reverse_path(path): DCNL  DCSP path_parts = path.split(_PATH_CELL_SEP) DCNL DCSP path_parts.reverse() DCNL DCSP return _PATH_CELL_SEP.join(path_parts)
def _response_cell_name_from_path(routing_path, neighbor_only=False): DCNL  DCSP path = _reverse_path(routing_path) DCNL DCSP if ((not neighbor_only) or (len(path) == 1)): DCNL DCSP  DCSP return path DCNL DCSP return _PATH_CELL_SEP.join(path.split(_PATH_CELL_SEP)[:2])
def _untranslate_volume_summary_view(context, vol): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol.id DCNL DCSP d['status'] = vol.status DCNL DCSP d['size'] = vol.size DCNL DCSP d['availability_zone'] = vol.availability_zone DCNL DCSP d['created_at'] = vol.created_at DCNL DCSP d['attach_time'] = '' DCNL DCSP d['mountpoint'] = '' DCNL DCSP if vol.attachments: DCNL DCSP  DCSP att = vol.attachments[0] DCNL DCSP  DCSP d['attach_status'] = 'attached' DCNL DCSP  DCSP d['instance_uuid'] = att['server_id'] DCNL DCSP  DCSP d['mountpoint'] = att['device'] DCNL DCSP else: DCNL DCSP  DCSP d['attach_status'] = 'detached' DCNL DCSP d['display_name'] = vol.display_name DCNL DCSP d['display_description'] = vol.display_description DCNL DCSP d['volume_type_id'] = vol.volume_type DCNL DCSP d['snapshot_id'] = vol.snapshot_id DCNL DCSP d['volume_metadata'] = [] DCNL DCSP for (key, value) in vol.metadata.items(): DCNL DCSP  DCSP item = {} DCNL DCSP  DCSP item['key'] = key DCNL DCSP  DCSP item['value'] = value DCNL DCSP  DCSP d['volume_metadata'].append(item) DCNL DCSP if hasattr(vol, 'volume_image_metadata'): DCNL DCSP  DCSP d['volume_image_metadata'] = copy.deepcopy(vol.volume_image_metadata) DCNL DCSP return d
def _untranslate_snapshot_summary_view(context, snapshot): DCNL  DCSP d = {} DCNL DCSP d['id'] = snapshot.id DCNL DCSP d['status'] = snapshot.status DCNL DCSP d['progress'] = snapshot.progress DCNL DCSP d['size'] = snapshot.size DCNL DCSP d['created_at'] = snapshot.created_at DCNL DCSP d['display_name'] = snapshot.display_name DCNL DCSP d['display_description'] = snapshot.display_description DCNL DCSP d['volume_id'] = snapshot.volume_id DCNL DCSP d['project_id'] = snapshot.project_id DCNL DCSP d['volume_size'] = snapshot.size DCNL DCSP return d
def parse_css_data(): DCNL  DCSP props = {} DCNL DCSP for (names, values) in PROPERTY_DICT.items(): DCNL DCSP  DCSP allowed_values = [] DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP if ((value[0] == '<') and (value[(-1)] == '>')): DCNL DCSP  DCSP  DCSP  DCSP key = value[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP if (key in COMMON_VALUES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allowed_values += COMMON_VALUES[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP allowed_values.append(value) DCNL DCSP  DCSP allowed_values += ['all', 'inherit', 'initial', 'unset'] DCNL DCSP  DCSP for name in names.split(): DCNL DCSP  DCSP  DCSP props[name] = sorted(allowed_values) DCNL DCSP return props
def get_tag_to_attributes(): DCNL  DCSP tag_dict = {'a': ['charset', 'coords', 'download', 'href', 'hreflang', 'media', 'name', 'ping', 'rel', 'rev', 'shape', 'target', 'type'], 'abbr': ['title'], 'address': [], 'applet': ['align', 'alt', 'archive', 'code', 'codebase', 'height', 'hspace', 'name', 'object', 'vspace', 'width'], 'area': ['alt', 'coords', 'download', 'href', 'hreflang', 'media', 'nohref', 'rel', 'shape', 'target'], 'article': [], 'aside': [], 'audio': ['autoplay', 'buffered', 'controls', 'loop', 'muted', 'played', 'preload', 'src', 'volume'], 'b': [], 'base': ['href', 'target'], 'basefont': ['color', 'face', 'size'], 'bdi': [], 'bdo': [], 'blockquote': ['cite'], 'body': ['alink', 'background', 'bgcolor', 'link', 'onafterprint', 'onbeforeprint', 'onbeforeunload', 'onhashchange', 'onmessage', 'onoffline', 'ononline', 'onpopstate', 'onredo', 'onstorage', 'onundo', 'onunload', 'text', 'vlink'], 'br': ['clear'], 'button': ['autofocus', 'disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'name', 'type', 'value'], 'canvas': ['height', 'width'], 'caption': ['align'], 'cite': [], 'code': [], 'col': ['align', 'char', 'charoff', 'span', 'valign', 'width'], 'colgroup': ['align', 'char', 'charoff', 'span', 'valign', 'width'], 'content': ['select'], 'data': ['value'], 'datalist': [], 'dd': [], 'del': ['cite', 'datetime'], 'details': ['open'], 'dfn': [], 'dir': ['compact'], 'div': ['align'], 'dl': ['compact'], 'dt': [], 'element': [], 'em': [], 'embed': ['height', 'src', 'type', 'width'], 'fieldset': ['disabled', 'form', 'name'], 'figcaption': [], 'figure': [], 'font': ['color', 'face', 'size'], 'footer': [], 'form': ['accept-charset', 'accept', 'action', 'autocomplete', 'enctype', 'method', 'name', 'novalidate', 'target'], 'frame': ['frameborder', 'longdesc', 'marginheight', 'marginwidth', 'name', 'noresize', 'scrolling', 'src'], 'frameset': ['cols', 'onunload', 'rows'], 'h1': ['align'], 'h2': ['align'], 'h3': ['align'], 'h4': ['align'], 'h5': ['align'], 'h6': ['align'], 'head': ['profile'], 'header': [], 'hr': ['align', 'noshade', 'size', 'width'], 'html': ['manifest', 'version', 'xmlns'], 'i': [], 'iframe': ['align', 'frameborder', 'height', 'longdesc', 'marginheight', 'marginwidth', 'name', 'sandbox', 'scrolling', 'seamless', 'src', 'srcdoc', 'width'], 'img': ['align', 'alt', 'border', 'crossorigin', 'height', 'hspace', 'ismap', 'longdesc', 'name', 'sizes', 'src', 'srcset', 'usemap', 'vspace', 'width'], 'input': ['accept', 'align', 'alt', 'autocomplete', 'autofocus', 'autosave', 'checked', 'disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'height', 'inputmode', 'ismap', 'list', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'selectionDirection', 'size', 'spellcheck', 'src', 'step', 'tabindex', 'type', 'usemap', 'value', 'width'], 'ins': ['cite', 'datetime'], 'isindex': ['prompt'], 'kbd': [], 'keygen': ['autofocus', 'challenge', 'disabled', 'form', 'keytype', 'name'], 'label': ['for', 'form'], 'legend': [], 'li': ['type', 'value'], 'link': ['charset', 'crossorigin', 'href', 'hreflang', 'media', 'rel', 'rev', 'sizes', 'target', 'type'], 'main': [], 'map': ['name'], 'mark': [], 'menu': ['compact'], 'meta': ['charset', 'content', 'http-equiv', 'name', 'scheme'], 'meter': ['value', 'min', 'max', 'low', 'high', 'optimum', 'form'], 'nav': [], 'noframes': [], 'noscript': [], 'object': ['align', 'archive', 'border', 'classid', 'codebase', 'codetype', 'data', 'declare', 'form', 'height', 'hspace', 'name', 'standby', 'type', 'typemustmatch', 'usemap', 'vspace', 'width'], 'ol': ['compact', 'reversed', 'start', 'type'], 'optgroup': ['disabled', 'label'], 'option': ['disabled', 'label', 'selected', 'value'], 'output': ['for', 'form', 'name'], 'p': ['align'], 'param': ['name', 'type', 'value', 'valuetype'], 'picture': [], 'pre': ['width'], 'progress': ['max', 'value'], 'q': ['cite'], 'rp': [], 'rt': [], 'rtc': [], 's': [], 'samp': [], 'script': ['async', 'charset', 'defer', 'language', 'src', 'type'], 'section': [], 'select': ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'], 'shadow': [], 'small': [], 'source': ['src', 'type'], 'span': [], 'strong': [], 'style': ['disabled', 'media', 'scoped', 'title', 'type'], 'sub': [], 'summary': [], 'sup': [], 'table': ['align', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'frame', 'rules', 'summary', 'width'], 'tbody': ['align', 'char', 'charoff', 'valign'], 'td': ['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'], 'template': ['content'], 'textarea': ['autocomplete', 'autofocus', 'cols', 'disabled', 'form', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'rows', 'selectionDirection', 'selectionEnd', 'selectionStart', 'spellcheck', 'wrap'], 'tfoot': ['align', 'char', 'charoff', 'valign'], 'th': ['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'], 'thead': ['align', 'char', 'charoff', 'valign'], 'time': ['datetime'], 'title': [], 'tr': ['align', 'bgcolor', 'char', 'charoff', 'valign'], 'track': ['default', 'kind', 'label', 'src', 'srclang'], 'u': [], 'ul': ['compact', 'type'], 'var': [], 'video': ['autoplay', 'autobuffer', 'buffered', 'controls', 'crossorigin', 'height', 'loop', 'muted', 'played', 'preload', 'poster', 'src', 'width'], 'wbr': []} DCNL DCSP global_attributes = ['accesskey', 'class', 'contenteditable', 'contextmenu', 'dir', 'hidden', 'id', 'lang', 'style', 'tabindex', 'title', 'translate'] DCNL DCSP global_attributes.extend(['onabort', 'onautocomplete', 'onautocompleteerror', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', 'oncuechange', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragexit', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpause', 'onplay', 'onplaying', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onseeked', 'onseeking', 'onselect', 'onshow', 'onsort', 'onstalled', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onvolumechange', 'onwaiting']) DCNL DCSP for attributes in tag_dict.values(): DCNL DCSP  DCSP attributes.extend(global_attributes) DCNL DCSP if ('bdi' in tag_dict): DCNL DCSP  DCSP tag_dict['bdi'] = [attr for attr in tag_dict['bdi'] if (attr != 'dir')] DCNL DCSP return tag_dict
def normalize(a, axis=None): DCNL  DCSP a_sum = a.sum(axis) DCNL DCSP if (axis and (a.ndim > 1)): DCNL DCSP  DCSP a_sum[(a_sum == 0)] = 1 DCNL DCSP  DCSP shape = list(a.shape) DCNL DCSP  DCSP shape[axis] = 1 DCNL DCSP  DCSP a_sum.shape = shape DCNL DCSP a /= a_sum
def log_normalize(a, axis=None): DCNL  DCSP a_lse = logsumexp(a, axis) DCNL DCSP a -= a_lse[:, np.newaxis]
def log_mask_zero(a): DCNL  DCSP a = np.asarray(a) DCNL DCSP with np.errstate(divide='ignore'): DCNL DCSP  DCSP a_log = np.log(a) DCNL DCSP  DCSP a_log[(a <= 0)] = 0.0 DCNL DCSP  DCSP return a_log
def gen_data(min_length=MIN_LENGTH, max_length=MAX_LENGTH, n_batch=N_BATCH): DCNL  DCSP X = np.concatenate([np.random.uniform(size=(n_batch, max_length, 1)), np.zeros((n_batch, max_length, 1))], axis=(-1)) DCNL DCSP mask = np.zeros((n_batch, max_length)) DCNL DCSP y = np.zeros((n_batch,)) DCNL DCSP for n in range(n_batch): DCNL DCSP  DCSP length = np.random.randint(min_length, max_length) DCNL DCSP  DCSP mask[n, :length] = 1 DCNL DCSP  DCSP X[n, length:, 0] = 0 DCNL DCSP  DCSP X[(n, np.random.randint((length / 10)), 1)] = 1 DCNL DCSP  DCSP X[(n, np.random.randint((length / 2), length), 1)] = 1 DCNL DCSP  DCSP y[n] = np.sum((X[n, :, 0] * X[n, :, 1])) DCNL DCSP X -= X.reshape((-1), 2).mean(axis=0) DCNL DCSP y -= y.mean() DCNL DCSP return (X.astype(theano.config.floatX), y.astype(theano.config.floatX), mask.astype(theano.config.floatX))
def get_or_compute_grads(loss_or_grads, params): DCNL  DCSP if any(((not isinstance(p, theano.compile.SharedVariable)) for p in params)): DCNL DCSP  DCSP raise ValueError('params DCSP must DCSP contain DCSP shared DCSP variables DCSP only. DCSP If DCSP it DCSP contains DCSP arbitrary DCSP parameter DCSP expressions, DCSP then DCSP lasagne.utils.collect_shared_vars() DCSP may DCSP help DCSP you.') DCNL DCSP if isinstance(loss_or_grads, list): DCNL DCSP  DCSP if (not (len(loss_or_grads) == len(params))): DCNL DCSP  DCSP  DCSP raise ValueError(('Got DCSP %d DCSP gradient DCSP expressions DCSP for DCSP %d DCSP parameters' % (len(loss_or_grads), len(params)))) DCNL DCSP  DCSP return loss_or_grads DCNL DCSP else: DCNL DCSP  DCSP return theano.grad(loss_or_grads, params)
def sgd(loss_or_grads, params, learning_rate): DCNL  DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP updates[param] = (param - (learning_rate * grad)) DCNL DCSP return updates
def apply_momentum(updates, params=None, momentum=0.9): DCNL  DCSP if (params is None): DCNL DCSP  DCSP params = updates.keys() DCNL DCSP updates = OrderedDict(updates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP x = ((momentum * velocity) + updates[param]) DCNL DCSP  DCSP updates[velocity] = (x - param) DCNL DCSP  DCSP updates[param] = x DCNL DCSP return updates
def momentum(loss_or_grads, params, learning_rate, momentum=0.9): DCNL  DCSP updates = sgd(loss_or_grads, params, learning_rate) DCNL DCSP return apply_momentum(updates, momentum=momentum)
def apply_nesterov_momentum(updates, params=None, momentum=0.9): DCNL  DCSP if (params is None): DCNL DCSP  DCSP params = updates.keys() DCNL DCSP updates = OrderedDict(updates) DCNL DCSP for param in params: DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP velocity = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP x = (((momentum * velocity) + updates[param]) - param) DCNL DCSP  DCSP updates[velocity] = x DCNL DCSP  DCSP updates[param] = ((momentum * x) + updates[param]) DCNL DCSP return updates
def nesterov_momentum(loss_or_grads, params, learning_rate, momentum=0.9): DCNL  DCSP updates = sgd(loss_or_grads, params, learning_rate) DCNL DCSP return apply_nesterov_momentum(updates, momentum=momentum)
def adagrad(loss_or_grads, params, learning_rate=1.0, epsilon=1e-06): DCNL  DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = (accu + (grad ** 2)) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP updates[param] = (param - ((learning_rate * grad) / T.sqrt((accu_new + epsilon)))) DCNL DCSP return updates
def rmsprop(loss_or_grads, params, learning_rate=1.0, rho=0.9, epsilon=1e-06): DCNL  DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP one = T.constant(1) DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (grad ** 2))) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP updates[param] = (param - ((learning_rate * grad) / T.sqrt((accu_new + epsilon)))) DCNL DCSP return updates
def adadelta(loss_or_grads, params, learning_rate=1.0, rho=0.95, epsilon=1e-06): DCNL  DCSP grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP updates = OrderedDict() DCNL DCSP one = T.constant(1) DCNL DCSP for (param, grad) in zip(params, grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP delta_accu = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP accu_new = ((rho * accu) + ((one - rho) * (grad ** 2))) DCNL DCSP  DCSP updates[accu] = accu_new DCNL DCSP  DCSP update = ((grad * T.sqrt((delta_accu + epsilon))) / T.sqrt((accu_new + epsilon))) DCNL DCSP  DCSP updates[param] = (param - (learning_rate * update)) DCNL DCSP  DCSP delta_accu_new = ((rho * delta_accu) + ((one - rho) * (update ** 2))) DCNL DCSP  DCSP updates[delta_accu] = delta_accu_new DCNL DCSP return updates
def adam(loss_or_grads, params, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL  DCSP all_grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP t_prev = theano.shared(utils.floatX(0.0)) DCNL DCSP updates = OrderedDict() DCNL DCSP one = T.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = ((learning_rate * T.sqrt((one - (beta2 ** t)))) / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP v_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP v_t = ((beta2 * v_prev) + ((one - beta2) * (g_t ** 2))) DCNL DCSP  DCSP step = ((a_t * m_t) / (T.sqrt(v_t) + epsilon)) DCNL DCSP  DCSP updates[m_prev] = m_t DCNL DCSP  DCSP updates[v_prev] = v_t DCNL DCSP  DCSP updates[param] = (param - step) DCNL DCSP updates[t_prev] = t DCNL DCSP return updates
def adamax(loss_or_grads, params, learning_rate=0.002, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL  DCSP all_grads = get_or_compute_grads(loss_or_grads, params) DCNL DCSP t_prev = theano.shared(utils.floatX(0.0)) DCNL DCSP updates = OrderedDict() DCNL DCSP one = T.constant(1) DCNL DCSP t = (t_prev + 1) DCNL DCSP a_t = (learning_rate / (one - (beta1 ** t))) DCNL DCSP for (param, g_t) in zip(params, all_grads): DCNL DCSP  DCSP value = param.get_value(borrow=True) DCNL DCSP  DCSP m_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP u_prev = theano.shared(np.zeros(value.shape, dtype=value.dtype), broadcastable=param.broadcastable) DCNL DCSP  DCSP m_t = ((beta1 * m_prev) + ((one - beta1) * g_t)) DCNL DCSP  DCSP u_t = T.maximum((beta2 * u_prev), abs(g_t)) DCNL DCSP  DCSP step = ((a_t * m_t) / (u_t + epsilon)) DCNL DCSP  DCSP updates[m_prev] = m_t DCNL DCSP  DCSP updates[u_prev] = u_t DCNL DCSP  DCSP updates[param] = (param - step) DCNL DCSP updates[t_prev] = t DCNL DCSP return updates
def norm_constraint(tensor_var, max_norm, norm_axes=None, epsilon=1e-07): DCNL  DCSP ndim = tensor_var.ndim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (ndim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (ndim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, ndim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupported DCSP tensor DCSP dimensionality DCSP {}.Must DCSP specify DCSP `norm_axes`'.format(ndim)) DCNL DCSP dtype = np.dtype(theano.config.floatX).type DCNL DCSP norms = T.sqrt(T.sum(T.sqr(tensor_var), axis=sum_over, keepdims=True)) DCNL DCSP target_norms = T.clip(norms, 0, dtype(max_norm)) DCNL DCSP constrained_output = (tensor_var * (target_norms / (dtype(epsilon) + norms))) DCNL DCSP return constrained_output
def total_norm_constraint(tensor_vars, max_norm, epsilon=1e-07, return_norm=False): DCNL  DCSP norm = T.sqrt(sum((T.sum((tensor ** 2)) for tensor in tensor_vars))) DCNL DCSP dtype = np.dtype(theano.config.floatX).type DCNL DCSP target_norm = T.clip(norm, 0, dtype(max_norm)) DCNL DCSP multiplier = (target_norm / (dtype(epsilon) + norm)) DCNL DCSP tensor_vars_scaled = [(step * multiplier) for step in tensor_vars] DCNL DCSP if return_norm: DCNL DCSP  DCSP return (tensor_vars_scaled, norm) DCNL DCSP else: DCNL DCSP  DCSP return tensor_vars_scaled
def pad(x, width, val=0, batch_ndim=1): DCNL  DCSP input_shape = x.shape DCNL DCSP input_ndim = x.ndim DCNL DCSP output_shape = list(input_shape) DCNL DCSP indices = [slice(None) for _ in output_shape] DCNL DCSP if isinstance(width, int): DCNL DCSP  DCSP widths = ([width] * (input_ndim - batch_ndim)) DCNL DCSP else: DCNL DCSP  DCSP widths = width DCNL DCSP for (k, w) in enumerate(widths): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (l, r) = w DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP l = r = w DCNL DCSP  DCSP output_shape[(k + batch_ndim)] += (l + r) DCNL DCSP  DCSP indices[(k + batch_ndim)] = slice(l, (l + input_shape[(k + batch_ndim)])) DCNL DCSP if val: DCNL DCSP  DCSP out = (T.ones(output_shape) * val) DCNL DCSP else: DCNL DCSP  DCSP out = T.zeros(output_shape) DCNL DCSP return T.set_subtensor(out[tuple(indices)], x)
def conv1d_sc(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (border_mode not in ('valid', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP border_mode DCSP for DCSP conv1d_sc: DCSP %s' % border_mode)) DCNL DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_sc = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_sc = (image_shape[0], 1, image_shape[1], image_shape[2]) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_sc = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_sc = (filter_shape[0], 1, filter_shape[1], filter_shape[2]) DCNL DCSP input_sc = input.dimshuffle(0, 'x', 1, 2) DCNL DCSP filters_sc = filters.dimshuffle(0, 'x', 1, 2)[:, :, ::(-1), :] DCNL DCSP conved = T.nnet.conv2d(input_sc, filters_sc, image_shape_sc, filter_shape_sc, subsample=(1, subsample[0]), filter_flip=filter_flip) DCNL DCSP return conved[:, :, 0, :]
def conv1d_mc0(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_mc0 = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_mc0 = (image_shape[0], image_shape[1], 1, image_shape[2]) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_mc0 = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_mc0 = (filter_shape[0], filter_shape[1], 1, filter_shape[2]) DCNL DCSP if isinstance(border_mode, tuple): DCNL DCSP  DCSP (border_mode,) = border_mode DCNL DCSP if isinstance(border_mode, int): DCNL DCSP  DCSP border_mode = (0, border_mode) DCNL DCSP input_mc0 = input.dimshuffle(0, 1, 'x', 2) DCNL DCSP filters_mc0 = filters.dimshuffle(0, 1, 'x', 2) DCNL DCSP conved = T.nnet.conv2d(input_mc0, filters_mc0, image_shape_mc0, filter_shape_mc0, subsample=(1, subsample[0]), border_mode=border_mode, filter_flip=filter_flip) DCNL DCSP return conved[:, :, 0, :]
def conv1d_mc1(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (image_shape is None): DCNL DCSP  DCSP image_shape_mc1 = None DCNL DCSP else: DCNL DCSP  DCSP image_shape_mc1 = (image_shape[0], image_shape[1], image_shape[2], 1) DCNL DCSP if (filter_shape is None): DCNL DCSP  DCSP filter_shape_mc1 = None DCNL DCSP else: DCNL DCSP  DCSP filter_shape_mc1 = (filter_shape[0], filter_shape[1], filter_shape[2], 1) DCNL DCSP if isinstance(border_mode, tuple): DCNL DCSP  DCSP (border_mode,) = border_mode DCNL DCSP if isinstance(border_mode, int): DCNL DCSP  DCSP border_mode = (border_mode, 0) DCNL DCSP input_mc1 = input.dimshuffle(0, 1, 2, 'x') DCNL DCSP filters_mc1 = filters.dimshuffle(0, 1, 2, 'x') DCNL DCSP conved = T.nnet.conv2d(input_mc1, filters_mc1, image_shape_mc1, filter_shape_mc1, subsample=(subsample[0], 1), border_mode=border_mode, filter_flip=filter_flip) DCNL DCSP return conved[:, :, :, 0]
def conv1d_unstrided(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True, implementation=conv1d_sc): DCNL  DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP stride = subsample[0] DCNL DCSP if ((filter_length % stride) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%d) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP stride DCSP (%d)' % (filter_length, stride))) DCNL DCSP if (border_mode not in ('valid', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP border_mode DCSP for DCSP conv1d_unstrided: DCSP %s' % border_mode)) DCNL DCSP num_steps = (filter_length // stride) DCNL DCSP truncated_length = ((input_length // stride) * stride) DCNL DCSP input_truncated = input[:, :, :truncated_length] DCNL DCSP r_input_shape = (batch_size, num_input_channels, (truncated_length // stride), stride) DCNL DCSP r_input = input_truncated.reshape(r_input_shape) DCNL DCSP r_input_folded_shape = (batch_size, (num_input_channels * stride), (truncated_length // stride)) DCNL DCSP r_input_folded = r_input.dimshuffle(0, 1, 3, 2).reshape(r_input_folded_shape) DCNL DCSP r_filter_shape = (num_filters, num_input_channels, num_steps, stride) DCNL DCSP r_filters_flipped = filters[:, :, ::(-1)].reshape(r_filter_shape) DCNL DCSP r_filter_folded_shape = (num_filters, (num_input_channels * stride), num_steps) DCNL DCSP r_filters_flipped_folded = r_filters_flipped.dimshuffle(0, 1, 3, 2).reshape(r_filter_folded_shape) DCNL DCSP r_filters_folded = r_filters_flipped_folded[:, :, ::(-1)] DCNL DCSP return implementation(r_input_folded, r_filters_folded, r_input_folded_shape, r_filter_folded_shape, border_mode, subsample=(1,), filter_flip=filter_flip)
def conv1d_sd(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (border_mode not in ('valid', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP border_mode DCSP for DCSP conv1d_sd: DCSP %s' % border_mode)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP stride = subsample[0] DCNL DCSP if ((filter_length % stride) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%d) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP stride DCSP (%d)' % (filter_length, stride))) DCNL DCSP num_steps = (filter_length // stride) DCNL DCSP output_length = (((input_length - filter_length) + stride) // stride) DCNL DCSP padded_length = (((input_length // filter_length) * filter_length) + ((num_steps - 1) * stride)) DCNL DCSP truncated_length = min(input_length, padded_length) DCNL DCSP input_truncated = input[:, :, :truncated_length] DCNL DCSP input_padded_shape = (batch_size, num_input_channels, padded_length) DCNL DCSP input_padded = T.zeros(input_padded_shape) DCNL DCSP input_padded = T.set_subtensor(input_padded[:, :, :truncated_length], input_truncated) DCNL DCSP inputs = [] DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * stride) DCNL DCSP  DCSP length = ((padded_length - shift) // filter_length) DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input_padded[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP inputs.append(r_input) DCNL DCSP inputs_stacked = T.stack(*inputs) DCNL DCSP filters_flipped = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP r_conved = T.tensordot(inputs_stacked, filters_flipped, np.asarray([[2, 4], [1, 2]])) DCNL DCSP r_conved = r_conved.dimshuffle(1, 3, 2, 0) DCNL DCSP conved = r_conved.reshape((r_conved.shape[0], r_conved.shape[1], (r_conved.shape[2] * r_conved.shape[3]))) DCNL DCSP return conved[:, :, :output_length]
def conv1d_md(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True): DCNL  DCSP if (border_mode not in ('valid', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupported DCSP border_mode DCSP for DCSP conv1d_md: DCSP %s' % border_mode)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP stride = subsample[0] DCNL DCSP if ((filter_length % stride) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%d) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP stride DCSP (%d)' % (filter_length, stride))) DCNL DCSP num_steps = (filter_length // stride) DCNL DCSP output_length = (((input_length - filter_length) + stride) // stride) DCNL DCSP output_shape = (batch_size, num_filters, output_length) DCNL DCSP filters_flipped = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP conved = T.zeros(output_shape) DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * stride) DCNL DCSP  DCSP length = ((input_length - shift) // filter_length) DCNL DCSP  DCSP if (length == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP r_conved = T.tensordot(r_input, filters_flipped, np.asarray([[1, 3], [1, 2]])) DCNL DCSP  DCSP r_conved = r_conved.dimshuffle(0, 2, 1) DCNL DCSP  DCSP conved = T.set_subtensor(conved[:, :, num::num_steps], r_conved) DCNL DCSP return conved
def get_rng(): DCNL  DCSP return _rng
def set_rng(new_rng): DCNL  DCSP global _rng DCNL DCSP _rng = new_rng
def pytest_ignore_collect(path, config): DCNL  DCSP return any((path.fnmatch(ignore) for ignore in ignore_test_paths))
def floatX(arr): DCNL  DCSP return np.asarray(arr, dtype=theano.config.floatX)
def shared_empty(dim=2, dtype=None): DCNL  DCSP if (dtype is None): DCNL DCSP  DCSP dtype = theano.config.floatX DCNL DCSP shp = tuple(([1] * dim)) DCNL DCSP return theano.shared(np.zeros(shp, dtype=dtype))
def as_theano_expression(input): DCNL  DCSP if isinstance(input, theano.gof.Variable): DCNL DCSP  DCSP return input DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return theano.tensor.constant(input) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise TypeError(('Input DCSP of DCSP type DCSP %s DCSP is DCSP not DCSP a DCSP Theano DCSP expression DCSP and DCSP cannot DCSP be DCSP wrapped DCSP as DCSP a DCSP Theano DCSP constant DCSP (original DCSP exception: DCSP %s)' % (type(input), e)))
def collect_shared_vars(expressions): DCNL  DCSP if isinstance(expressions, theano.Variable): DCNL DCSP  DCSP expressions = [expressions] DCNL DCSP return [v for v in theano.gof.graph.inputs(reversed(expressions)) if isinstance(v, theano.compile.SharedVariable)]
def one_hot(x, m=None): DCNL  DCSP if (m is None): DCNL DCSP  DCSP m = T.cast((T.max(x) + 1), 'int32') DCNL DCSP return T.eye(m)[T.cast(x, 'int32')]
def unique(l): DCNL  DCSP new_list = [] DCNL DCSP seen = set() DCNL DCSP for el in l: DCNL DCSP  DCSP if (el not in seen): DCNL DCSP  DCSP  DCSP new_list.append(el) DCNL DCSP  DCSP  DCSP seen.add(el) DCNL DCSP return new_list
def as_tuple(x, N, t=None): DCNL  DCSP try: DCNL DCSP  DCSP X = tuple(x) DCNL DCSP except TypeError: DCNL DCSP  DCSP X = ((x,) * N) DCNL DCSP if ((t is not None) and (not all((isinstance(v, t) for v in X)))): DCNL DCSP  DCSP raise TypeError('expected DCSP a DCSP single DCSP value DCSP or DCSP an DCSP iterable DCSP of DCSP {0}, DCSP got DCSP {1} DCSP instead'.format(t.__name__, x)) DCNL DCSP if (len(X) != N): DCNL DCSP  DCSP raise ValueError('expected DCSP a DCSP single DCSP value DCSP or DCSP an DCSP iterable DCSP with DCSP length DCSP {0}, DCSP got DCSP {1} DCSP instead'.format(N, x)) DCNL DCSP return X
def compute_norms(array, norm_axes=None): DCNL  DCSP if ((not isinstance(array, theano.Variable)) and (not isinstance(array, np.ndarray))): DCNL DCSP  DCSP raise RuntimeError('Unsupported DCSP type DCSP {}. DCSP Only DCSP theano DCSP variables DCSP and DCSP numpy DCSP arrays DCSP are DCSP supported'.format(type(array))) DCNL DCSP ndim = array.ndim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (ndim == 1): DCNL DCSP  DCSP sum_over = () DCNL DCSP elif (ndim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (ndim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, ndim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupported DCSP tensor DCSP dimensionality DCSP {}. DCSP Must DCSP specify DCSP `norm_axes`'.format(array.ndim)) DCNL DCSP if isinstance(array, theano.Variable): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = T.abs_(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = T.sqrt(T.sum((array ** 2), axis=sum_over)) DCNL DCSP elif isinstance(array, np.ndarray): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = abs(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = np.sqrt(np.sum((array ** 2), axis=sum_over)) DCNL DCSP return norms
def create_param(spec, shape, name=None): DCNL  DCSP import numbers DCNL DCSP shape = tuple(shape) DCNL DCSP if any(((d <= 0) for d in shape)): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP create DCSP param DCSP with DCSP a DCSP non-positive DCSP shape DCSP dimension. DCSP Tried DCSP to DCSP create DCSP param DCSP with DCSP shape=%r, DCSP name=%r' % (shape, name))) DCNL DCSP err_prefix = ('cannot DCSP initialize DCSP parameter DCSP %s: DCSP ' % name) DCNL DCSP if callable(spec): DCNL DCSP  DCSP spec = spec(shape) DCNL DCSP  DCSP err_prefix += 'the DCSP %s DCSP returned DCSP by DCSP the DCSP provided DCSP callable' DCNL DCSP else: DCNL DCSP  DCSP err_prefix += 'the DCSP provided DCSP %s' DCNL DCSP if (isinstance(spec, numbers.Number) or (isinstance(spec, np.generic) and (spec.dtype.kind in 'biufc'))): DCNL DCSP  DCSP spec = np.asarray(spec) DCNL DCSP if isinstance(spec, np.ndarray): DCNL DCSP  DCSP if (spec.shape != shape): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP has DCSP shape DCSP %s, DCSP should DCSP be DCSP %s' % ((err_prefix % 'numpy DCSP array'), spec.shape, shape))) DCNL DCSP  DCSP bcast = tuple(((s == 1) for s in shape)) DCNL DCSP  DCSP spec = theano.shared(spec, broadcastable=bcast) DCNL DCSP if isinstance(spec, theano.Variable): DCNL DCSP  DCSP if (spec.ndim != len(shape)): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP has DCSP %d DCSP dimensions, DCSP should DCSP be DCSP %d' % ((err_prefix % 'Theano DCSP variable'), spec.ndim, len(shape)))) DCNL DCSP  DCSP if (not spec.name): DCNL DCSP  DCSP  DCSP spec.name = name DCNL DCSP  DCSP return spec DCNL DCSP elif ('callable' in err_prefix): DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP numpy DCSP array DCSP or DCSP a DCSP Theano DCSP expression' % (err_prefix % 'value'))) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP numpy DCSP array, DCSP a DCSP Theano DCSP expression, DCSP or DCSP a DCSP callable' % (err_prefix % 'spec')))
def unroll_scan(fn, sequences, outputs_info, non_sequences, n_steps, go_backwards=False): DCNL  DCSP if (not isinstance(sequences, (list, tuple))): DCNL DCSP  DCSP sequences = [sequences] DCNL DCSP counter = range(n_steps) DCNL DCSP if go_backwards: DCNL DCSP  DCSP counter = counter[::(-1)] DCNL DCSP output = [] DCNL DCSP prev_vals = outputs_info DCNL DCSP for i in counter: DCNL DCSP  DCSP step_input = (([s[i] for s in sequences] + prev_vals) + non_sequences) DCNL DCSP  DCSP out_ = fn(*step_input) DCNL DCSP  DCSP if isinstance(out_, T.TensorVariable): DCNL DCSP  DCSP  DCSP out_ = [out_] DCNL DCSP  DCSP if isinstance(out_, tuple): DCNL DCSP  DCSP  DCSP out_ = list(out_) DCNL DCSP  DCSP output.append(out_) DCNL DCSP  DCSP prev_vals = output[(-1)] DCNL DCSP output_scan = [] DCNL DCSP for i in range(len(output[0])): DCNL DCSP  DCSP l = map((lambda x: x[i]), output) DCNL DCSP  DCSP output_scan.append(T.stack(*l)) DCNL DCSP return output_scan
def l1(x): DCNL  DCSP return T.sum(abs(x))
def l2(x): DCNL  DCSP return T.sum((x ** 2))
def apply_penalty(tensor_or_tensors, penalty, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP return sum((penalty(x, **kwargs) for x in tensor_or_tensors)) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return penalty(tensor_or_tensors, **kwargs)
def regularize_layer_params(layer, penalty, tags={'regularizable': True}, **kwargs): DCNL  DCSP layers = ([layer] if isinstance(layer, Layer) else layer) DCNL DCSP all_params = [] DCNL DCSP for layer in layers: DCNL DCSP  DCSP all_params += layer.get_params(**tags) DCNL DCSP return apply_penalty(all_params, penalty, **kwargs)
def regularize_layer_params_weighted(layers, penalty, tags={'regularizable': True}, **kwargs): DCNL  DCSP return sum(((coeff * apply_penalty(layer.get_params(**tags), penalty, **kwargs)) for (layer, coeff) in layers.items()))
def regularize_network_params(layer, penalty, tags={'regularizable': True}, **kwargs): DCNL  DCSP return apply_penalty(get_all_params(layer, **tags), penalty, **kwargs)
def autocrop(inputs, cropping): DCNL  DCSP if (cropping is None): DCNL DCSP  DCSP return inputs DCNL DCSP else: DCNL DCSP  DCSP ndim = inputs[0].ndim DCNL DCSP  DCSP if (not all(((input.ndim == ndim) for input in inputs))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP all DCSP inputs DCSP are DCSP of DCSP the DCSP same DCSP dimensionality. DCSP Got DCSP {0} DCSP inputs DCSP of DCSP dimensionalities DCSP {1}.'.format(len(inputs), [input.ndim for input in inputs])) DCNL DCSP  DCSP shapes = [input.shape for input in inputs] DCNL DCSP  DCSP shapes_tensor = T.as_tensor_variable(shapes) DCNL DCSP  DCSP min_shape = T.min(shapes_tensor, axis=0) DCNL DCSP  DCSP slices_by_input = [[] for i in range(len(inputs))] DCNL DCSP  DCSP cropping = list(cropping) DCNL DCSP  DCSP if (ndim > len(cropping)): DCNL DCSP  DCSP  DCSP cropping = (list(cropping) + ([None] * (ndim - len(cropping)))) DCNL DCSP  DCSP for (dim, cr) in enumerate(cropping): DCNL DCSP  DCSP  DCSP if (cr is None): DCNL DCSP  DCSP  DCSP  DCSP slice_all = slice(None) DCNL DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP slices.append(slice_all) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sz = min_shape[dim] DCNL DCSP  DCSP  DCSP  DCSP if (cr == 'lower'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP slc_lower = slice(None, sz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.append(slc_lower) DCNL DCSP  DCSP  DCSP  DCSP elif (cr == 'upper'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP slc_upper = slice((- sz), None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for slices in slices_by_input: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.append(slc_upper) DCNL DCSP  DCSP  DCSP  DCSP elif (cr == 'center'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (sh, slices) in zip(shapes, slices_by_input): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP offset = ((sh[dim] - sz) // 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP slices.append(slice(offset, (offset + sz))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError("Unknown DCSP crop DCSP mode DCSP '{0}'".format(cr)) DCNL DCSP  DCSP return [input[slices] for (input, slices) in zip(inputs, slices_by_input)]
def autocrop_array_shapes(input_shapes, cropping): DCNL  DCSP if (cropping is None): DCNL DCSP  DCSP return input_shapes DCNL DCSP else: DCNL DCSP  DCSP ndim = len(input_shapes[0]) DCNL DCSP  DCSP if (not all(((len(sh) == ndim) for sh in input_shapes))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP all DCSP inputs DCSP are DCSP of DCSP the DCSP same DCSP dimensionality. DCSP Got DCSP {0} DCSP inputs DCSP of DCSP dimensionalities DCSP {1}.'.format(len(input_shapes), [len(sh) for sh in input_shapes])) DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP cropping = list(cropping) DCNL DCSP  DCSP if (ndim > len(cropping)): DCNL DCSP  DCSP  DCSP cropping = (list(cropping) + ([None] * (ndim - len(cropping)))) DCNL DCSP  DCSP for (sh, cr) in zip(zip(*input_shapes), cropping): DCNL DCSP  DCSP  DCSP if (cr is None): DCNL DCSP  DCSP  DCSP  DCSP result.append(sh) DCNL DCSP  DCSP  DCSP elif (cr in {'lower', 'center', 'upper'}): DCNL DCSP  DCSP  DCSP  DCSP min_sh = (None if any(((x is None) for x in sh)) else min(sh)) DCNL DCSP  DCSP  DCSP  DCSP result.append(([min_sh] * len(sh))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError("Unknown DCSP crop DCSP mode DCSP '{0}'".format(cr)) DCNL DCSP  DCSP return [tuple(sh) for sh in zip(*result)]
def conv_output_length(input_length, filter_size, stride, pad=0): DCNL  DCSP if (input_length is None): DCNL DCSP  DCSP return None DCNL DCSP if (pad == 'valid'): DCNL DCSP  DCSP output_length = ((input_length - filter_size) + 1) DCNL DCSP elif (pad == 'full'): DCNL DCSP  DCSP output_length = ((input_length + filter_size) - 1) DCNL DCSP elif (pad == 'same'): DCNL DCSP  DCSP output_length = input_length DCNL DCSP elif isinstance(pad, int): DCNL DCSP  DCSP output_length = (((input_length + (2 * pad)) - filter_size) + 1) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invalid DCSP pad: DCSP {0}'.format(pad)) DCNL DCSP output_length = (((output_length + stride) - 1) // stride) DCNL DCSP return output_length
def conv_input_length(output_length, filter_size, stride, pad=0): DCNL  DCSP if (output_length is None): DCNL DCSP  DCSP return None DCNL DCSP if (pad == 'valid'): DCNL DCSP  DCSP pad = 0 DCNL DCSP elif (pad == 'full'): DCNL DCSP  DCSP pad = (filter_size - 1) DCNL DCSP elif (pad == 'same'): DCNL DCSP  DCSP pad = (filter_size // 2) DCNL DCSP if (not isinstance(pad, int)): DCNL DCSP  DCSP raise ValueError('Invalid DCSP pad: DCSP {0}'.format(pad)) DCNL DCSP return ((((output_length - 1) * stride) - (2 * pad)) + filter_size)
def pool_output_length(input_length, pool_size, stride, pad, ignore_border): DCNL  DCSP if ((input_length is None) or (pool_size is None)): DCNL DCSP  DCSP return None DCNL DCSP if ignore_border: DCNL DCSP  DCSP output_length = (((input_length + (2 * pad)) - pool_size) + 1) DCNL DCSP  DCSP output_length = (((output_length + stride) - 1) // stride) DCNL DCSP else: DCNL DCSP  DCSP assert (pad == 0) DCNL DCSP  DCSP if (stride >= pool_size): DCNL DCSP  DCSP  DCSP output_length = (((input_length + stride) - 1) // stride) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output_length = (max(0, ((((input_length - pool_size) + stride) - 1) // stride)) + 1) DCNL DCSP return output_length
def pool_2d(input, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP return T.signal.pool.pool_2d(input, **kwargs) DCNL DCSP except TypeError: DCNL DCSP  DCSP kwargs['ds'] = kwargs.pop('ws') DCNL DCSP  DCSP kwargs['st'] = kwargs.pop('stride') DCNL DCSP  DCSP kwargs['padding'] = kwargs.pop('pad') DCNL DCSP  DCSP return T.signal.pool.pool_2d(input, **kwargs)
def dropout_channels(incoming, *args, **kwargs): DCNL  DCSP ndim = len(getattr(incoming, 'output_shape', incoming)) DCNL DCSP kwargs['shared_axes'] = tuple(range(2, ndim)) DCNL DCSP return DropoutLayer(incoming, *args, **kwargs)
def dropout_locations(incoming, *args, **kwargs): DCNL  DCSP kwargs['shared_axes'] = (1,) DCNL DCSP return DropoutLayer(incoming, *args, **kwargs)
def batch_norm_dnn(layer, **kwargs): DCNL  DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP if (hasattr(layer, 'b') and (layer.b is not None)): DCNL DCSP  DCSP del layer.params[layer.b] DCNL DCSP  DCSP layer.b = None DCNL DCSP bn_name = (kwargs.pop('name', None) or (getattr(layer, 'name', None) and (layer.name + '_bn'))) DCNL DCSP layer = BatchNormDNNLayer(layer, name=bn_name, **kwargs) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP from .special import NonlinearityLayer DCNL DCSP  DCSP nonlin_name = (bn_name and (bn_name + '_nonlin')) DCNL DCSP  DCSP layer = NonlinearityLayer(layer, nonlinearity, name=nonlin_name) DCNL DCSP return layer
def get_all_layers(layer, treat_as_input=None): DCNL  DCSP try: DCNL DCSP  DCSP queue = deque(layer) DCNL DCSP except TypeError: DCNL DCSP  DCSP queue = deque([layer]) DCNL DCSP seen = set() DCNL DCSP done = set() DCNL DCSP result = [] DCNL DCSP if (treat_as_input is not None): DCNL DCSP  DCSP seen.update(treat_as_input) DCNL DCSP while queue: DCNL DCSP  DCSP layer = queue[0] DCNL DCSP  DCSP if (layer is None): DCNL DCSP  DCSP  DCSP queue.popleft() DCNL DCSP  DCSP elif (layer not in seen): DCNL DCSP  DCSP  DCSP seen.add(layer) DCNL DCSP  DCSP  DCSP if hasattr(layer, 'input_layers'): DCNL DCSP  DCSP  DCSP  DCSP queue.extendleft(reversed(layer.input_layers)) DCNL DCSP  DCSP  DCSP elif hasattr(layer, 'input_layer'): DCNL DCSP  DCSP  DCSP  DCSP queue.appendleft(layer.input_layer) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP queue.popleft() DCNL DCSP  DCSP  DCSP if (layer not in done): DCNL DCSP  DCSP  DCSP  DCSP result.append(layer) DCNL DCSP  DCSP  DCSP  DCSP done.add(layer) DCNL DCSP return result
def get_output(layer_or_layers, inputs=None, **kwargs): DCNL  DCSP from .input import InputLayer DCNL DCSP from .base import MergeLayer DCNL DCSP accepted_kwargs = {'deterministic'} DCNL DCSP treat_as_input = (inputs.keys() if isinstance(inputs, dict) else []) DCNL DCSP all_layers = get_all_layers(layer_or_layers, treat_as_input) DCNL DCSP all_outputs = dict(((layer, layer.input_var) for layer in all_layers if (isinstance(layer, InputLayer) and (layer not in treat_as_input)))) DCNL DCSP if isinstance(inputs, dict): DCNL DCSP  DCSP all_outputs.update(((layer, utils.as_theano_expression(expr)) for (layer, expr) in inputs.items())) DCNL DCSP elif (inputs is not None): DCNL DCSP  DCSP if (len(all_outputs) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('get_output() DCSP was DCSP called DCSP with DCSP a DCSP single DCSP input DCSP expression DCSP on DCSP a DCSP network DCSP with DCSP multiple DCSP input DCSP layers. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP dictionary DCSP of DCSP input DCSP expressions DCSP instead.') DCNL DCSP  DCSP for input_layer in all_outputs: DCNL DCSP  DCSP  DCSP all_outputs[input_layer] = utils.as_theano_expression(inputs) DCNL DCSP for layer in all_layers: DCNL DCSP  DCSP if (layer not in all_outputs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(layer, MergeLayer): DCNL DCSP  DCSP  DCSP  DCSP  DCSP layer_inputs = [all_outputs[input_layer] for input_layer in layer.input_layers] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP layer_inputs = all_outputs[layer.input_layer] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('get_output() DCSP was DCSP called DCSP without DCSP giving DCSP an DCSP input DCSP expression DCSP for DCSP the DCSP free-floating DCSP layer DCSP %r. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP dictionary DCSP mapping DCSP this DCSP layer DCSP to DCSP an DCSP input DCSP expression.' % layer)) DCNL DCSP  DCSP  DCSP all_outputs[layer] = layer.get_output_for(layer_inputs, **kwargs) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (names, _, _, defaults) = getargspec(layer.get_output_for) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (defaults is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP accepted_kwargs |= set(names[(- len(defaults)):]) DCNL DCSP  DCSP  DCSP accepted_kwargs |= set(layer.get_output_kwargs) DCNL DCSP unused_kwargs = (set(kwargs.keys()) - accepted_kwargs) DCNL DCSP if unused_kwargs: DCNL DCSP  DCSP suggestions = [] DCNL DCSP  DCSP for kwarg in unused_kwargs: DCNL DCSP  DCSP  DCSP suggestion = get_close_matches(kwarg, accepted_kwargs) DCNL DCSP  DCSP  DCSP if suggestion: DCNL DCSP  DCSP  DCSP  DCSP suggestions.append(('%s DCSP (perhaps DCSP you DCSP meant DCSP %s)' % (kwarg, suggestion[0]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP suggestions.append(kwarg) DCNL DCSP  DCSP warn(('get_output() DCSP was DCSP called DCSP with DCSP unused DCSP kwargs:\n DCTB %s' % '\n DCTB '.join(suggestions))) DCNL DCSP try: DCNL DCSP  DCSP return [all_outputs[layer] for layer in layer_or_layers] DCNL DCSP except TypeError: DCNL DCSP  DCSP return all_outputs[layer_or_layers]
def get_output_shape(layer_or_layers, input_shapes=None): DCNL  DCSP if ((input_shapes is None) or (input_shapes == {})): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return [layer.output_shape for layer in layer_or_layers] DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return layer_or_layers.output_shape DCNL DCSP from .input import InputLayer DCNL DCSP from .base import MergeLayer DCNL DCSP if isinstance(input_shapes, dict): DCNL DCSP  DCSP treat_as_input = input_shapes.keys() DCNL DCSP else: DCNL DCSP  DCSP treat_as_input = [] DCNL DCSP all_layers = get_all_layers(layer_or_layers, treat_as_input) DCNL DCSP all_shapes = dict(((layer, layer.shape) for layer in all_layers if (isinstance(layer, InputLayer) and (layer not in treat_as_input)))) DCNL DCSP if isinstance(input_shapes, dict): DCNL DCSP  DCSP all_shapes.update(input_shapes) DCNL DCSP elif (input_shapes is not None): DCNL DCSP  DCSP if (len(all_shapes) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('get_output_shape() DCSP was DCSP called DCSP with DCSP a DCSP single DCSP input DCSP shape DCSP on DCSP a DCSP network DCSP with DCSP multiple DCSP input DCSP layers. DCSP Please DCSP call DCSP it DCSP with DCSP a DCSP dictionary DCSP of DCSP input DCSP shapes DCSP instead.') DCNL DCSP  DCSP for input_layer in all_shapes: DCNL DCSP  DCSP  DCSP all_shapes[input_layer] = input_shapes DCNL DCSP for layer in all_layers: DCNL DCSP  DCSP if (layer not in all_shapes): DCNL DCSP  DCSP  DCSP if isinstance(layer, MergeLayer): DCNL DCSP  DCSP  DCSP  DCSP input_shapes = [all_shapes[input_layer] for input_layer in layer.input_layers] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP input_shapes = all_shapes[layer.input_layer] DCNL DCSP  DCSP  DCSP all_shapes[layer] = layer.get_output_shape_for(input_shapes) DCNL DCSP try: DCNL DCSP  DCSP return [all_shapes[layer] for layer in layer_or_layers] DCNL DCSP except TypeError: DCNL DCSP  DCSP return all_shapes[layer_or_layers]
def get_all_params(layer, unwrap_shared=True, **tags): DCNL  DCSP layers = get_all_layers(layer) DCNL DCSP params = chain.from_iterable((l.get_params(unwrap_shared=unwrap_shared, **tags) for l in layers)) DCNL DCSP return utils.unique(params)
def count_params(layer, **tags): DCNL  DCSP params = get_all_params(layer, **tags) DCNL DCSP shapes = [p.get_value().shape for p in params] DCNL DCSP counts = [np.prod(shape) for shape in shapes] DCNL DCSP return sum(counts)
def get_all_param_values(layer, **tags): DCNL  DCSP params = get_all_params(layer, **tags) DCNL DCSP return [p.get_value() for p in params]
def set_all_param_values(layer, values, **tags): DCNL  DCSP params = get_all_params(layer, **tags) DCNL DCSP if (len(params) != len(values)): DCNL DCSP  DCSP raise ValueError(('mismatch: DCSP got DCSP %d DCSP values DCSP to DCSP set DCSP %d DCSP parameters' % (len(values), len(params)))) DCNL DCSP for (p, v) in zip(params, values): DCNL DCSP  DCSP if (p.get_value().shape != v.shape): DCNL DCSP  DCSP  DCSP raise ValueError(('mismatch: DCSP parameter DCSP has DCSP shape DCSP %r DCSP but DCSP value DCSP to DCSP set DCSP has DCSP shape DCSP %r' % (p.get_value().shape, v.shape))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP p.set_value(v)
def standardize(layer, offset, scale, shared_axes='auto'): DCNL  DCSP layer = BiasLayer(layer, (- offset), shared_axes) DCNL DCSP layer.params[layer.b].remove('trainable') DCNL DCSP layer = ScaleLayer(layer, (floatX(1.0) / scale), shared_axes) DCNL DCSP layer.params[layer.scales].remove('trainable') DCNL DCSP return layer
def _get_transformed_points_tps(new_points, source_points, coefficients, num_points, batch_size): DCNL  DCSP to_transform = new_points.dimshuffle(0, 'x', 1, 2) DCNL DCSP stacked_transform = T.tile(to_transform, (1, num_points, 1, 1)) DCNL DCSP r_2 = T.sum(((stacked_transform - source_points.dimshuffle('x', 1, 0, 'x')) ** 2), axis=2) DCNL DCSP log_r_2 = T.log(r_2) DCNL DCSP distances = T.switch(T.isnan(log_r_2), (r_2 * log_r_2), 0.0) DCNL DCSP upper_array = T.concatenate([T.ones((batch_size, 1, new_points.shape[2]), dtype=theano.config.floatX), new_points], axis=1) DCNL DCSP right_mat = T.concatenate([upper_array, distances], axis=1) DCNL DCSP new_value = T.batched_dot(coefficients, right_mat) DCNL DCSP return new_value
def _U_func_numpy(x1, y1, x2, y2): DCNL  DCSP if ((x1 == x2) and (y1 == y2)): DCNL DCSP  DCSP return 0.0 DCNL DCSP r_2 = (((x2 - x1) ** 2) + ((y2 - y1) ** 2)) DCNL DCSP return (r_2 * np.log(r_2))
def _initialize_tps(num_control_points, input_shape, downsample_factor, precompute_grid): DCNL  DCSP (_, _, height, width) = input_shape DCNL DCSP grid_size = np.sqrt(num_control_points) DCNL DCSP (x_control_source, y_control_source) = np.meshgrid(np.linspace((-1), 1, grid_size), np.linspace((-1), 1, grid_size)) DCNL DCSP source_points = np.vstack((x_control_source.flatten(), y_control_source.flatten())) DCNL DCSP source_points = source_points.astype(theano.config.floatX) DCNL DCSP num_equations = (num_control_points + 3) DCNL DCSP L = np.zeros((num_equations, num_equations), dtype=theano.config.floatX) DCNL DCSP L[0, 3:num_equations] = 1.0 DCNL DCSP L[1:3, 3:num_equations] = source_points DCNL DCSP L[3:num_equations, 0] = 1.0 DCNL DCSP L[3:num_equations, 1:3] = source_points.T DCNL DCSP for point_1 in range(num_control_points): DCNL DCSP  DCSP for point_2 in range(point_1, num_control_points): DCNL DCSP  DCSP  DCSP L[((point_1 + 3), (point_2 + 3))] = _U_func_numpy(source_points[(0, point_1)], source_points[(1, point_1)], source_points[(0, point_2)], source_points[(1, point_2)]) DCNL DCSP  DCSP  DCSP if (point_1 != point_2): DCNL DCSP  DCSP  DCSP  DCSP L[((point_2 + 3), (point_1 + 3))] = L[((point_1 + 3), (point_2 + 3))] DCNL DCSP L_inv = np.linalg.inv(L) DCNL DCSP if precompute_grid: DCNL DCSP  DCSP out_height = np.array((height // downsample_factor[0])).astype('int64') DCNL DCSP  DCSP out_width = np.array((width // downsample_factor[1])).astype('int64') DCNL DCSP  DCSP (x_t, y_t) = np.meshgrid(np.linspace((-1), 1, out_width), np.linspace((-1), 1, out_height)) DCNL DCSP  DCSP ones = np.ones(np.prod(x_t.shape)) DCNL DCSP  DCSP orig_grid = np.vstack([x_t.flatten(), y_t.flatten(), ones]) DCNL DCSP  DCSP orig_grid = orig_grid[0:2, :] DCNL DCSP  DCSP orig_grid = orig_grid.astype(theano.config.floatX) DCNL DCSP  DCSP to_transform = orig_grid[:, :, np.newaxis].transpose(2, 0, 1) DCNL DCSP  DCSP stacked_transform = np.tile(to_transform, (num_control_points, 1, 1)) DCNL DCSP  DCSP stacked_source_points = source_points[:, :, np.newaxis].transpose(1, 0, 2) DCNL DCSP  DCSP r_2 = np.sum(((stacked_transform - stacked_source_points) ** 2), axis=1) DCNL DCSP  DCSP log_r_2 = np.log(r_2) DCNL DCSP  DCSP log_r_2[np.isinf(log_r_2)] = 0.0 DCNL DCSP  DCSP distances = (r_2 * log_r_2) DCNL DCSP  DCSP upper_array = np.ones(shape=(1, orig_grid.shape[1]), dtype=theano.config.floatX) DCNL DCSP  DCSP upper_array = np.concatenate([upper_array, orig_grid], axis=0) DCNL DCSP  DCSP right_mat = np.concatenate([upper_array, distances], axis=0) DCNL DCSP  DCSP out_height = T.as_tensor_variable(out_height) DCNL DCSP  DCSP out_width = T.as_tensor_variable(out_width) DCNL DCSP  DCSP right_mat = T.as_tensor_variable(right_mat) DCNL DCSP else: DCNL DCSP  DCSP out_height = None DCNL DCSP  DCSP out_width = None DCNL DCSP  DCSP right_mat = None DCNL DCSP L_inv = T.as_tensor_variable(L_inv) DCNL DCSP source_points = T.as_tensor_variable(source_points) DCNL DCSP return (right_mat, L_inv, source_points, out_height, out_width)
def prelu(layer, **kwargs): DCNL  DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP return ParametricRectifierLayer(layer, **kwargs)
def rrelu(layer, **kwargs): DCNL  DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP return RandomizedRectifierLayer(layer, **kwargs)
def batch_norm(layer, **kwargs): DCNL  DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP if (hasattr(layer, 'b') and (layer.b is not None)): DCNL DCSP  DCSP del layer.params[layer.b] DCNL DCSP  DCSP layer.b = None DCNL DCSP bn_name = (kwargs.pop('name', None) or (getattr(layer, 'name', None) and (layer.name + '_bn'))) DCNL DCSP layer = BatchNormLayer(layer, name=bn_name, **kwargs) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP from .special import NonlinearityLayer DCNL DCSP  DCSP nonlin_name = (bn_name and (bn_name + '_nonlin')) DCNL DCSP  DCSP layer = NonlinearityLayer(layer, nonlinearity, name=nonlin_name) DCNL DCSP return layer
def align_targets(predictions, targets): DCNL  DCSP if ((getattr(predictions, 'broadcastable', None) == (False, True)) and (getattr(targets, 'ndim', None) == 1)): DCNL DCSP  DCSP targets = as_theano_expression(targets).dimshuffle(0, 'x') DCNL DCSP return (predictions, targets)
def binary_crossentropy(predictions, targets): DCNL  DCSP (predictions, targets) = align_targets(predictions, targets) DCNL DCSP return theano.tensor.nnet.binary_crossentropy(predictions, targets)
def categorical_crossentropy(predictions, targets): DCNL  DCSP return theano.tensor.nnet.categorical_crossentropy(predictions, targets)
def squared_error(a, b): DCNL  DCSP (a, b) = align_targets(a, b) DCNL DCSP return theano.tensor.square((a - b))
def aggregate(loss, weights=None, mode='mean'): DCNL  DCSP if (weights is not None): DCNL DCSP  DCSP loss = (loss * weights) DCNL DCSP if (mode == 'mean'): DCNL DCSP  DCSP return loss.mean() DCNL DCSP elif (mode == 'sum'): DCNL DCSP  DCSP return loss.sum() DCNL DCSP elif (mode == 'normalized_sum'): DCNL DCSP  DCSP if (weights is None): DCNL DCSP  DCSP  DCSP raise ValueError("require DCSP weights DCSP for DCSP mode='normalized_sum'") DCNL DCSP  DCSP return (loss.sum() / weights.sum()) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("mode DCSP must DCSP be DCSP 'mean', DCSP 'sum' DCSP or DCSP 'normalized_sum', DCSP got DCSP %r" % mode))
def binary_hinge_loss(predictions, targets, delta=1, log_odds=None, binary=True): DCNL  DCSP if (log_odds is None): DCNL DCSP  DCSP raise FutureWarning('The DCSP `log_odds` DCSP argument DCSP to DCSP `binary_hinge_loss` DCSP will DCSP change DCSP its DCSP default DCSP to DCSP `False` DCSP in DCSP a DCSP future DCSP version. DCSP Explicitly DCSP give DCSP `log_odds=True` DCSP to DCSP retain DCSP current DCSP behavior DCSP in DCSP your DCSP code, DCSP but DCSP also DCSP check DCSP the DCSP documentation DCSP if DCSP this DCSP is DCSP what DCSP you DCSP want.') DCNL DCSP  DCSP log_odds = True DCNL DCSP if (not log_odds): DCNL DCSP  DCSP predictions = theano.tensor.log((predictions / (1 - predictions))) DCNL DCSP if binary: DCNL DCSP  DCSP targets = ((2 * targets) - 1) DCNL DCSP (predictions, targets) = align_targets(predictions, targets) DCNL DCSP return theano.tensor.nnet.relu((delta - (predictions * targets)))
def multiclass_hinge_loss(predictions, targets, delta=1): DCNL  DCSP num_cls = predictions.shape[1] DCNL DCSP if (targets.ndim == (predictions.ndim - 1)): DCNL DCSP  DCSP targets = theano.tensor.extra_ops.to_one_hot(targets, num_cls) DCNL DCSP elif (targets.ndim != predictions.ndim): DCNL DCSP  DCSP raise TypeError('rank DCSP mismatch DCSP between DCSP targets DCSP and DCSP predictions') DCNL DCSP corrects = predictions[targets.nonzero()] DCNL DCSP rest = theano.tensor.reshape(predictions[(1 - targets).nonzero()], ((-1), (num_cls - 1))) DCNL DCSP rest = theano.tensor.max(rest, axis=1) DCNL DCSP return theano.tensor.nnet.relu(((rest - corrects) + delta))
def binary_accuracy(predictions, targets, threshold=0.5): DCNL  DCSP (predictions, targets) = align_targets(predictions, targets) DCNL DCSP predictions = theano.tensor.ge(predictions, threshold) DCNL DCSP return theano.tensor.eq(predictions, targets)
def categorical_accuracy(predictions, targets, top_k=1): DCNL  DCSP if (targets.ndim == predictions.ndim): DCNL DCSP  DCSP targets = theano.tensor.argmax(targets, axis=(-1)) DCNL DCSP elif (targets.ndim != (predictions.ndim - 1)): DCNL DCSP  DCSP raise TypeError('rank DCSP mismatch DCSP between DCSP targets DCSP and DCSP predictions') DCNL DCSP if (top_k == 1): DCNL DCSP  DCSP top = theano.tensor.argmax(predictions, axis=(-1)) DCNL DCSP  DCSP return theano.tensor.eq(top, targets) DCNL DCSP else: DCNL DCSP  DCSP top = theano.tensor.argsort(predictions, axis=(-1)) DCNL DCSP  DCSP top = top[([slice(None) for _ in range((top.ndim - 1))] + [slice((- top_k), None)])] DCNL DCSP  DCSP targets = theano.tensor.shape_padaxis(targets, axis=(-1)) DCNL DCSP  DCSP return theano.tensor.any(theano.tensor.eq(top, targets), axis=(-1))
def sigmoid(x): DCNL  DCSP return theano.tensor.nnet.sigmoid(x)
def softmax(x): DCNL  DCSP return theano.tensor.nnet.softmax(x)
def tanh(x): DCNL  DCSP return theano.tensor.tanh(x)
def rectify(x): DCNL  DCSP return theano.tensor.nnet.relu(x)
def elu(x): DCNL  DCSP return theano.tensor.switch((x > 0), x, (theano.tensor.exp(x) - 1))
def softplus(x): DCNL  DCSP return theano.tensor.nnet.softplus(x)
def linear(x): DCNL  DCSP return x
def locally_connected2d(input, W, flip_filters=True): DCNL  DCSP (num_batch, input_channels, input_rows, input_cols) = input.shape DCNL DCSP assert (W.shape[1] == input_channels) DCNL DCSP (num_filters, input_channels, filter_rows, filter_cols, output_rows, output_cols) = W.shape DCNL DCSP assert ((filter_rows % 2) == 1) DCNL DCSP assert ((filter_cols % 2) == 1) DCNL DCSP output = np.zeros((num_batch, num_filters, output_rows, output_cols)) DCNL DCSP for b in range(num_batch): DCNL DCSP  DCSP for f in range(num_filters): DCNL DCSP  DCSP  DCSP for c in range(input_channels): DCNL DCSP  DCSP  DCSP  DCSP for i_out in range(output_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j_out in range(output_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for i_filter in range(filter_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i_in = ((i_out + i_filter) - (filter_rows // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= i_in < input_rows)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for j_filter in range(filter_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j_in = ((j_out + j_filter) - (filter_cols // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= j_in < input_cols)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if flip_filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, c, i_in, j_in)] * W[(f, c, ((- i_filter) - 1), ((- j_filter) - 1), i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, c, i_in, j_in)] * W[(f, c, i_filter, j_filter, i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output[(b, f, i_out, j_out)] += inc DCNL DCSP return output
def channelwise_locally_connected2d(input, W, flip_filters=True): DCNL  DCSP (num_batch, input_channels, input_rows, input_cols) = input.shape DCNL DCSP (num_filters, filter_rows, filter_cols, output_rows, output_cols) = W.shape DCNL DCSP assert (input_channels == num_filters) DCNL DCSP assert ((filter_rows % 2) == 1) DCNL DCSP assert ((filter_cols % 2) == 1) DCNL DCSP output = np.zeros((num_batch, num_filters, output_rows, output_cols)) DCNL DCSP for b in range(num_batch): DCNL DCSP  DCSP for f in range(num_filters): DCNL DCSP  DCSP  DCSP for i_out in range(output_rows): DCNL DCSP  DCSP  DCSP  DCSP for j_out in range(output_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i_filter in range(filter_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i_in = ((i_out + i_filter) - (filter_rows // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= i_in < input_rows)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for j_filter in range(filter_cols): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j_in = ((j_out + j_filter) - (filter_cols // 2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not (0 <= j_in < input_cols)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if flip_filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, f, i_in, j_in)] * W[(f, ((- i_filter) - 1), ((- j_filter) - 1), i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inc = (input[(b, f, i_in, j_in)] * W[(f, i_filter, j_filter, i_out, j_out)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output[(b, f, i_out, j_out)] += inc DCNL DCSP return output
def convNd(input, kernel, pad, stride=1, n=None): DCNL  DCSP if (n is None): DCNL DCSP  DCSP n = (input.ndim - 2) DCNL DCSP if (pad not in ['valid', 'same', 'full']): DCNL DCSP  DCSP pad = as_tuple(pad, n, int) DCNL DCSP  DCSP input = np.pad(input, [(p, p) for p in ((0, 0) + pad)], mode='constant') DCNL DCSP  DCSP pad = 'valid' DCNL DCSP output = np.zeros(((input.shape[0], kernel.shape[0]) + tuple((((i + k) - 1) for (i, k) in zip(input.shape[2:], kernel.shape[2:]))))) DCNL DCSP if (n == 1): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1)] DCNL DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2])] += c DCNL DCSP elif (n == 2): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP for j in range(kernel.shape[3]): DCNL DCSP  DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1), j:(j + 1)] DCNL DCSP  DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2]), j:(j + input.shape[3])] += c DCNL DCSP elif (n == 3): DCNL DCSP  DCSP for i in range(kernel.shape[2]): DCNL DCSP  DCSP  DCSP for j in range(kernel.shape[3]): DCNL DCSP  DCSP  DCSP  DCSP for k in range(kernel.shape[4]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = kernel[:, :, i:(i + 1), j:(j + 1), k:(k + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP c = (input[:, np.newaxis] * f).sum(axis=2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output[:, :, i:(i + input.shape[2]), j:(j + input.shape[3]), k:(k + input.shape[4])] += c DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError('convNd() DCSP only DCSP supports DCSP n DCSP in DCSP (1, DCSP 2, DCSP 3)') DCNL DCSP if (pad == 'valid'): DCNL DCSP  DCSP trim = tuple(((k - 1) for k in kernel.shape[2:])) DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(t, ((- t) or None)) for t in trim] DCNL DCSP  DCSP output = output[slices] DCNL DCSP elif (pad == 'same'): DCNL DCSP  DCSP shift = tuple((((k - 1) // 2) for k in kernel.shape[2:])) DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(s, (s + i)) for (s, i) in zip(shift, input.shape[2:])] DCNL DCSP  DCSP output = output[slices] DCNL DCSP stride = as_tuple(stride, n, int) DCNL DCSP if any(((s > 1) for s in stride)): DCNL DCSP  DCSP slices = [slice(None), slice(None)] DCNL DCSP  DCSP slices += [slice(None, None, s) for s in stride] DCNL DCSP  DCSP output = output[slices] DCNL DCSP return output
def dilate(input, factors): DCNL  DCSP output = np.zeros(tuple(((((s - 1) * f) + 1) for (s, f) in zip(input.shape, factors))), dtype=input.dtype) DCNL DCSP output[[slice(None, None, factor) for factor in factors]] = input DCNL DCSP return output
