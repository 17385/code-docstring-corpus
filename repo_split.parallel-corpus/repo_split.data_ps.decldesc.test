def request(method, uri, *args, **kwargs): DCNL 'Handles all the common functionality required for API calls. Returns DCNL the resulting response object. DCNL Formats the request into a dict representing the headers DCNL and body that will be used to make the API call.'
def http_log_req(method, uri, args, kwargs): DCNL 'When pyrax.get_http_debug() is True, outputs the equivalent `curl` DCNL command for the API request being made.'
def http_log_resp(resp, body): DCNL 'When pyrax.get_http_debug() is True, outputs the response received DCNL from the API request.'
def _resolve_id(val): DCNL 'Takes an object or an ID and returns the ID.'
def _resolve_name(val): DCNL 'Takes an object or a name and returns the name.'
def assure_volume(fnc): DCNL 'Converts a volumeID passed as the volume to a CloudBlockStorageVolume object.'
def assure_snapshot(fnc): DCNL 'Converts a snapshot ID passed as the snapshot to a CloudBlockStorageSnapshot DCNL object.'
def _safe_quote(val): DCNL 'Unicode values will raise a KeyError, so catch those and encode in UTF-8.'
def runproc(cmd): DCNL 'Convenience method for executing operating system commands. DCNL Accepts a single string that would be the command as executed on the DCNL command line. DCNL Returns a 2-tuple consisting of the output of (STDOUT, STDERR). In your DCNL code you should check for an empty STDERR output to determine if your DCNL command completed successfully.'
def get_checksum(content, encoding='utf8', block_size=8192): DCNL 'Returns the MD5 checksum in hex for the given content. If \'content\' DCNL is a file-like object, the content will be obtained from its read() DCNL method. If \'content\' is a file path, that file is read and its DCNL contents used. Otherwise, \'content\' is assumed to be the string whose DCNL checksum is desired. If the content is unicode, it will be encoded DCNL using the specified encoding. DCNL To conserve memory, files and file-like objects will be read in blocks, DCNL with the default block size of 8192 bytes, which is 64 * the digest block DCNL size of md5 (128). This is optimal for most cases, but you can change this DCNL by passing in a different value for `block_size`.'
def _join_chars(chars, length): DCNL 'Used by the random character functions.'
def random_unicode(length=20): DCNL 'Generates a random name; useful for testing. DCNL Returns an encoded string of the specified length containing unicode values DCNL up to code point 1000.'
def random_ascii(length=20, ascii_only=False): DCNL 'Generates a random name; useful for testing. DCNL Returns a string of the specified length containing only ASCII characters.'
def coerce_to_list(val): DCNL 'For parameters that can take either a single string or a list of strings, DCNL this function will ensure that the result is a list containing the passed DCNL values.'
def folder_size(pth, ignore=None): DCNL 'Returns the total bytes for the specified path, optionally ignoring DCNL any files which match the \'ignore\' parameter. \'ignore\' can either be DCNL a single string pattern, or a list of such patterns.'
def add_method(obj, func, name=None): DCNL 'Adds an instance method to an object.'
def wait_until(obj, att, desired, callback=None, interval=5, attempts=0, verbose=False, verbose_atts=None): DCNL 'When changing the state of an object, it will commonly be in a transitional DCNL state until the change is complete. This will reload the object every DCNL `interval` seconds, and check its `att` attribute until the `desired` value DCNL is reached, or until the maximum number of attempts is reached. The updated DCNL object is returned. It is up to the calling program to check the returned DCNL object to make sure that it successfully reached the desired state. DCNL Once the desired value of the attribute is reached, the method returns. If DCNL not, it will re-try until the attribute\'s value matches one of the DCNL `desired` values. By default (attempts=0) it will loop infinitely until the DCNL attribute reaches the desired value. You can optionally limit the number of DCNL times that the object is reloaded by passing a positive value to DCNL `attempts`. If the attribute has not reached the desired value by then, the DCNL method will exit. DCNL If `verbose` is True, each attempt will print out the current value of the DCNL watched attribute and the time that has elapsed since the original request. DCNL Also, if `verbose_atts` is specified, the values of those attributes will DCNL also be output. If `verbose` is False, then `verbose_atts` has no effect. DCNL Note that `desired` can be a list of values; if the attribute becomes equal DCNL to any of those values, this will succeed. For example, when creating a new DCNL cloud server, it will initially have a status of \'BUILD\', and you can\'t DCNL work with it until its status is \'ACTIVE\'. However, there might be a DCNL problem with the build process, and the server will change to a status of DCNL \'ERROR\'. So for this case you need to set the `desired` parameter to DCNL `[\'ACTIVE\', \'ERROR\']`. If you simply pass \'ACTIVE\' as the desired state, DCNL this will loop indefinitely if a build fails, as the server will never DCNL reach a status of \'ACTIVE\'. DCNL Since this process of waiting can take a potentially long time, and will DCNL block your program\'s execution until the desired state of the object is DCNL reached, you may specify a callback function. The callback can be any DCNL callable that accepts a single parameter; the parameter it receives will be DCNL either the updated object (success), or None (failure). If a callback is DCNL specified, the program will return immediately after spawning the wait DCNL process in a separate thread.'
def _wait_until(obj, att, desired, callback, interval, attempts, verbose, verbose_atts): DCNL 'Loops until either the desired value of the attribute is reached, or the DCNL number of attempts is exceeded.'
def wait_for_build(obj, att=None, desired=None, callback=None, interval=None, attempts=None, verbose=None, verbose_atts=None): DCNL 'Designed to handle the most common use case for wait_until: an object whose DCNL \'status\' attribute will end up in either \'ACTIVE\' or \'ERROR\' state. Since DCNL builds don\'t happen very quickly, the interval will default to 20 seconds DCNL to avoid excess polling.'
def _parse_datetime_string(val): DCNL 'Attempts to parse a string representation of a date or datetime value, and DCNL returns a datetime if successful. If not, a InvalidDateTimeString exception DCNL will be raised.'
def iso_time_string(val, show_tzinfo=False): DCNL 'Takes either a date, datetime or a string, and returns the standard ISO DCNL formatted string for that date/time, with any fractional second portion DCNL removed.'
def rfc2822_format(val): DCNL 'Takes either a date, a datetime, or a string, and returns a string that DCNL represents the value in RFC 2822 format. If a string is passed it is DCNL returned unchanged.'
def to_timestamp(val): DCNL 'Takes a value that is either a Python date, datetime, or a string DCNL representation of a date/datetime value. Returns a standard Unix timestamp DCNL corresponding to that value.'
def get_id(id_or_obj): DCNL 'Returns the \'id\' attribute of \'id_or_obj\' if present; if not, DCNL returns \'id_or_obj\'.'
def get_name(name_or_obj): DCNL 'Returns the \'name\' attribute of \'name_or_obj\' if present; if not, DCNL returns \'name_or_obj\'.'
def params_to_dict(params, dct): DCNL 'Updates the \'dct\' dictionary with the \'params\' dictionary, filtering out DCNL all those whose param value is None.'
def dict_to_qs(dct): DCNL 'Takes a dictionary and uses it to create a query string.'
def match_pattern(nm, patterns): DCNL 'Compares `nm` with the supplied patterns, and returns True if it matches DCNL at least one. DCNL Patterns are standard file-name wildcard strings, as defined in the DCNL `fnmatch` module. For example, the pattern "*.py" will match the names DCNL of all Python scripts.'
def update_exc(exc, msg, before=True, separator='\n'): DCNL 'Adds additional text to an exception\'s error message. DCNL The new text will be added before the existing text by default; to append DCNL it after the original text, pass False to the `before` parameter. DCNL By default the old and new text will be separated by a newline. If you wish DCNL to use a different separator, pass that as the `separator` parameter.'
def case_insensitive_update(dct1, dct2): DCNL 'Given two dicts, updates the first one with the second, but considers keys DCNL that are identical except for case to be the same. DCNL No return value; this function modified dct1 similar to the update() method.'
def env(*args, **kwargs): DCNL 'Returns the first environment variable set DCNL if none are non-empty, defaults to "" or keyword arg default'
def unauthenticated(fnc): DCNL 'Adds \'unauthenticated\' attribute to decorated function. DCNL Usage: DCNL @unauthenticated DCNL def mymethod(fnc):'
def isunauthenticated(fnc): DCNL 'Checks to see if the function is marked as not requiring authentication DCNL with the @unauthenticated decorator. Returns True if decorator is DCNL set to True, False otherwise.'
def safe_issubclass(*args): DCNL 'Like issubclass, but will just return False if not a class.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming text/bytes string using `incoming` if they\'re not DCNL already unicode. DCNL This function was copied from novaclient.openstack.strutils DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an instance of str'
def to_slug(value, incoming=None, errors='strict'): DCNL 'Normalize string. DCNL Convert to lowercase, remove non-word characters, and convert spaces DCNL to hyphens. DCNL This function was copied from novaclient.openstack.strutils DCNL Inspired by Django\'s `slugify` filter. DCNL :param value: Text to slugify DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: slugified unicode representation of `value` DCNL :raises TypeError: If text is not an instance of str'
def _id_type(ityp): DCNL 'Allow for shorthand names for the most common types.'
def get_environment(): DCNL 'Returns the name of the current environment.'
def set_environment(env): DCNL 'Change your configuration environment. An EnvironmentNotFound exception DCNL is raised if you pass in an undefined environment name.'
def list_environments(): DCNL 'Returns a list of all defined environments.'
def get_setting(key, env=None): DCNL 'Returns the config setting for the specified key. If no environment is DCNL specified, returns the setting for the current environment.'
def set_setting(key, val, env=None): DCNL 'Changes the value of the specified key in the current environment, or in DCNL another environment if specified.'
def set_default_region(region): DCNL 'Changes the default_region setting.'
def create_context(id_type=None, env=None, username=None, password=None, tenant_id=None, tenant_name=None, api_key=None, verify_ssl=None): DCNL 'Returns an instance of the specified identity class, or if none is DCNL specified, an instance of the current setting for \'identity_class\'. DCNL You may optionally set the environment by passing the name of that DCNL environment in the \'env\' parameter.'
def _create_identity(id_type=None, username=None, password=None, tenant_id=None, tenant_name=None, api_key=None, verify_ssl=None, return_context=False): DCNL 'Creates an instance of the current identity_class and assigns it to the DCNL module-level name \'identity\' by default. If \'return_context\' is True, the DCNL module-level \'identity\' is untouched, and instead the instance is returned.'
def _assure_identity(fnc): DCNL 'Ensures that the \'identity\' attribute is not None.'
def _require_auth(fnc): DCNL 'Authentication decorator.'
def _safe_region(region=None, context=None): DCNL 'Value to use when no region is specified.'
@_assure_identity DCNL def auth_with_token(token, tenant_id=None, tenant_name=None, region=None): DCNL 'If you already have a valid token and either a tenant ID or name, you can DCNL call this to configure the identity and available services.'
@_assure_identity DCNL def set_credentials(username, api_key=None, password=None, region=None, tenant_id=None, authenticate=True): DCNL 'Set the credentials directly, and then try to authenticate. DCNL If the region is passed, it will authenticate against the proper endpoint DCNL for that region, and set the default region for connections.'
@_assure_identity DCNL def set_credential_file(cred_file, region=None, authenticate=True): DCNL 'Read in the credentials from the supplied file path, and then try to DCNL authenticate. The file should be a standard config file in one of the DCNL following formats: DCNL For Keystone authentication: DCNL [keystone] DCNL username = myusername DCNL password = 1234567890abcdef DCNL tenant_id = abcdef1234567890 DCNL For Rackspace authentication: DCNL [rackspace_cloud] DCNL username = myusername DCNL api_key = 1234567890abcdef DCNL If the region is passed, it will authenticate against the proper endpoint DCNL for that region, and set the default region for connections.'
def keyring_auth(username=None, region=None, authenticate=True): DCNL 'Use the password stored within the keyring to authenticate. If a username DCNL is supplied, that name is used; otherwise, the keyring_username value DCNL from the config file is used. DCNL If there is no username defined, or if the keyring module is not installed, DCNL or there is no password set for the given username, the appropriate errors DCNL will be raised. DCNL If the region is passed, it will authenticate against the proper endpoint DCNL for that region, and set the default region for connections.'
@_assure_identity DCNL def authenticate(connect=True): DCNL 'Generally you will not need to call this directly; passing in your DCNL credentials via set_credentials() and set_credential_file() will call DCNL authenticate() on the identity object by default. But for situations where DCNL you set your credentials manually or otherwise need finer control over DCNL the authentication sequence, this method will call the identity object\'s DCNL authenticate() method, and an AuthenticationFailed exception will be raised DCNL if your credentials have not been properly set first. DCNL Normally after successful authentication, connections to the various DCNL services will be made. However, passing False to the `connect` parameter DCNL will skip the service connection step. DCNL The \'connect\' parameter is retained for backwards compatibility. It no DCNL longer has any effect.'
def clear_credentials(): DCNL 'De-authenticate by clearing all the names back to None.'
def _make_agent_name(base): DCNL 'Appends pyrax information to the underlying library\'s user agent.'
def connect_to_services(region=None): DCNL 'Establishes authenticated connections to the various cloud APIs.'
def _get_service_endpoint(context, svc, region=None, public=True): DCNL 'Parses the services dict to get the proper endpoint for the given service.'
def connect_to_cloudservers(region=None, context=None, verify_ssl=None, **kwargs): DCNL 'Creates a client for working with cloud servers.'
def connect_to_cloudfiles(region=None, public=None): DCNL 'Creates a client for working with CloudFiles/Swift.'
def connect_to_cloud_databases(region=None): DCNL 'Creates a client for working with cloud databases.'
def connect_to_cloud_cdn(region=None): DCNL 'Creates a client for working with cloud loadbalancers.'
def connect_to_cloud_loadbalancers(region=None): DCNL 'Creates a client for working with cloud loadbalancers.'
def connect_to_cloud_blockstorage(region=None): DCNL 'Creates a client for working with cloud blockstorage.'
def connect_to_cloud_dns(region=None): DCNL 'Creates a client for working with cloud dns.'
def connect_to_cloud_networks(region=None): DCNL 'Creates a client for working with cloud networks.'
def connect_to_cloud_monitoring(region=None): DCNL 'Creates a client for working with cloud monitoring.'
def connect_to_autoscale(region=None): DCNL 'Creates a client for working with AutoScale.'
def connect_to_images(region=None, public=True): DCNL 'Creates a client for working with Images.'
def connect_to_queues(region=None, public=True): DCNL 'Creates a client for working with Queues.'
def client_class_for_service(service): DCNL 'Returns the client class registered for the given service, or None if there DCNL is no such service, or if no class has been registered.'
def get_encoding(): DCNL 'Returns the unicode encoding type.'
def assure_image(fnc): DCNL 'Converts a image ID passed as the \'image\' parameter to a image object.'
def assure_check(fnc): DCNL 'Converts an checkID passed as the check to a CloudMonitorCheck object.'
def assure_entity(fnc): DCNL 'Converts an entityID passed as the entity to a CloudMonitorEntity object.'
def assure_container(fnc): DCNL 'Assures that whether a Container or a name of a container is passed, a DCNL Container object is available.'
def _massage_metakeys(dct, prfx): DCNL 'Returns a copy of the supplied dictionary, prefixing any keys that do DCNL not begin with the specified prefix accordingly.'
def get_file_size(fileobj): DCNL 'Returns the size of a file-like object.'
def from_response(response, body): DCNL 'Return an instance of a ClientException or subclass DCNL based on an httplib2 response. DCNL Usage:: DCNL resp, body = http.request(...) DCNL if resp.status_code != 200: DCNL raise exception_from_response(resp, body)'
def assure_queue(fnc): DCNL 'Converts a queue ID or name passed as the \'queue\' parameter to a Queue DCNL object.'
def option_chooser(options, attr=None): DCNL 'Given an iterable, enumerate its contents for a user to choose from. DCNL If the optional `attr` is not None, that attribute in each iterated DCNL object will be printed. DCNL This function will exit the program if the user chooses the escape option.'
def safe_int(val, allow_zero=True): DCNL 'This function converts the six.moves.input values to integers. It handles DCNL invalid entries, and optionally forbids values of zero.'
def safe_int(val, allow_zero=True): DCNL 'This function converts the six.moves.input values to integers. It handles DCNL invalid entries, and optionally forbids values of zero.'
def safe_int(val, allow_zero=True): DCNL 'This function converts the six.moves.input values to integers. It handles DCNL invalid entries, and optionally forbids values of zero.'
def safe_int(val, allow_zero=True): DCNL 'This function converts the six.moves.input values to integers. It handles DCNL invalid entries, and optionally forbids values of zero.'
def safe_int(val, allow_zero=True): DCNL 'This function converts the six.moves.input values to integers. It handles DCNL invalid entries, and optionally forbids values of zero.'
def _safe_id(): DCNL 'Remove characters that shouldn\'t be in IDs, etc., that are being parsed DCNL from HREFs. This is a consequence of the random_unicode() function, which DCNL sometimes causes the urlparse function to return the wrong values when DCNL these characters are present.'
def strip_headers(post): DCNL 'Find the first blank line and drop the headers to keep the body'
def remove_outputs(nb): DCNL 'Remove the outputs from a notebook'
def encoder_type(encode): DCNL 'Takes the value sent from the user encoding menu and returns DCNL the actual value to be used.'
def ms_module(exploit): DCNL 'Receives the input given by the user from gen_payload.py'
def ms_payload(payload): DCNL 'Receives the input given by the user from create_payload.py DCNL and create_payloads.py'
def ms_payload_2(payload): DCNL 'Receives the input given by the user from create_payloadS.py'
def ms_payload_3(payload): DCNL 'Receives the input given by the user from create_payloadS.py'
def ms_attacks(exploit): DCNL 'Receives the input given by the user from create_payload.py'
def teensy_config(choice): DCNL 'Receives the input given by the user from set.py'
def webattack_vector(attack_vector): DCNL 'Receives the input given by the user from set.py'
def category(category): DCNL 'Takes the value sent from the user encoding menu and returns DCNL the actual value to be used.'
def value_type(value): DCNL 'Determines whether the setting parameter should be quoted.'
def getfqdn(name=''): DCNL 'Get fully qualified domain name from name. DCNL An empty argument is interpreted as meaning the local host. DCNL First the hostname returned by gethostbyaddr() is checked, then DCNL possibly existing aliases. In case no FQDN is available, hostname DCNL from gethostname() is returned.'
def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None): DCNL 'Connect to *address* and return the socket object. DCNL Convenience function.  Connect to *address* (a 2-tuple ``(host, DCNL port)``) and return the socket object.  Passing the optional DCNL *timeout* parameter will set the timeout on the socket instance DCNL before attempting to connect.  If no *timeout* is supplied, the DCNL global default timeout setting returned by :func:`getdefaulttimeout` DCNL is used.  If *source_address* is set it must be a tuple of (host, port) DCNL for the socket to bind as a source address before making the connection. DCNL An host of \'\' or port 0 tells the OS to use the default.'
def is_valid_ipv6(ip): DCNL 'Validates IPv6 addresses.'
def capture(func, *args, **kwargs): DCNL 'Capture the output of func when called with the given arguments. DCNL The function output includes any exception raised. capture returns DCNL a tuple of (function result, standard output, standard error).'
def launch(): DCNL 'here we cant use the path for metasploit via setcore.meta_path. If the full path is specified it breaks DCNL database support for msfconsole for some reason. reported this as a bug, may be fixed soon... until then DCNL if path variables aren\'t set for msfconsole this will break, even if its specified in set_config'
def load_version(): DCNL 'Executes imblearn/version.py in a globals dictionary and DCNL return it.'
def test_bc_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_bc_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_bc_init(): DCNL 'Test the initialisation of the object'
def test_bc_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_bc_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_bc_fit(): DCNL 'Test the fitting method'
def test_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_fit_sample_auto(): DCNL 'Test the fit and sample routine with auto ratio.'
def test_fit_sample_half(): DCNL 'Test the fit and sample routine with 0.5 ratio.'
def test_fit_sample_auto_decision_tree(): DCNL 'Test the fit and sample routine with auto ratio with a decision DCNL tree.'
def test_fit_sample_auto_random_forest(): DCNL 'Test the fit and sample routine with auto ratio with a random DCNL forest.'
def test_fit_sample_auto_adaboost(): DCNL 'Test the fit and sample routine with auto ratio with a adaboost.'
def test_fit_sample_auto_gradient_boosting(): DCNL 'Test the fit and sample routine with auto ratio with a gradient DCNL boosting.'
def test_fit_sample_auto_linear_svm(): DCNL 'Test the fit and sample routine with auto ratio with a linear DCNL svm.'
def test_init_wrong_classifier(): DCNL 'Test either if an error is raised the classifier provided is unknown.'
def test_fit_sample_auto_early_stop(): DCNL 'Test the fit and sample routine with auto ratio with 1 subset.'
def test_fit_sample_auto_early_stop_2(): DCNL 'Test the fit and sample routine with auto ratio with a 2 subsets.'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_give_classifier_obj(): DCNL 'Test the fit and sample routine with classifier a object'
def test_give_classifier_wrong_obj(): DCNL 'Test either if an error is raised while a wrong object is passed'
def test_rf_wth_bootstrap(): DCNL 'Test the fit and sample routine with auto ratio with a random DCNL forest.'
def test_ee_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_ee_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_ee_init(): DCNL 'Test the initialisation of the object'
def test_ee_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_ee_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_ee_fit(): DCNL 'Test the fitting method'
def test_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_fit_sample_auto(): DCNL 'Test the fit and sample routine with auto ratio.'
def test_fit_sample_half(): DCNL 'Test the fit and sample routine with 0.5 ratio.'
def test_random_state_none(): DCNL 'Test that the processing is going throw with random state being None.'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_cnn_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_cnn_init(): DCNL 'Test the initialisation of the object'
def test_cnn_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_cnn_fit(): DCNL 'Test the fitting method'
def test_cnn_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_cnn_fit_sample(): DCNL 'Test the fit sample routine'
def test_cnn_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_cnn_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_cnn_fit_sample_with_object(): DCNL 'Test the fit sample routine with a knn object'
def test_cnn_fit_sample_with_wrong_object(): DCNL 'Test either if an error is raised while a wrong object is given'
def test_nearmiss_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_nearmiss_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_nearmiss_wrong_version(): DCNL 'Test either if an error is raised when the version is unknown.'
def test_nearmiss_init(): DCNL 'Test the initialisation of the object'
def test_nearmiss_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_nm_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_nm2_fit(): DCNL 'Test the fitting method'
def test_nm2_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_nm2_fit_sample_auto(): DCNL 'Test fit and sample routines with auto ratio'
def test_nm2_fit_sample_auto_indices(): DCNL 'Test fit and sample routines with auto ratio and indices support'
def test_nm2_fit_sample_half(): DCNL 'Test fit and sample routines with .5 ratio'
def test_nm2_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_nm2_fit_sample_nn_obj(): DCNL 'Test fit-sample with nn object'
def test_nm2__wrong_nn_obj(): DCNL 'Test either if an error is raised with wrong NN object'
def test_cc_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_cc_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_init(): DCNL 'Test the initialisation of the object'
def test_cc_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_cc_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_cc_fit(): DCNL 'Test the fitting method'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_fit_sample_auto(): DCNL 'Test fit and sample routines with auto ratio'
def test_fit_sample_half(): DCNL 'Test fit and sample routines with ratio of .5'
def test_sample_wrong_X_dft_ratio(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling without ratio'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_multiclass_fit_sample(): DCNL 'Test fit sample method with multiclass target'
def test_fit_sample_object(): DCNL 'Test fit and sample using a KMeans object'
def test_fit_sample_wrong_object(): DCNL 'Test fit and sample using a KMeans object'
def test_enn_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_renn_init(): DCNL 'Test the initialisation of the object'
def test_renn_iter_wrong(): DCNL 'Test either if an error is raised when the numbr of iteration DCNL is wrong'
def test_renn_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_renn_fit(): DCNL 'Test the fitting method'
def test_renn_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_renn_fit_sample(): DCNL 'Test the fit sample routine'
def test_renn_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_renn_fit_sample_mode_object(): DCNL 'Test the fit sample routine using the mode as selection giving a NN DCNL object'
def test_renn_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_renn_fit_sample_mode(): DCNL 'Test the fit sample routine using the mode as selection'
def test_renn_not_good_object(): DCNL 'Test either if an error is raised while a wrong type of NN is given'
def test_nearmiss_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_nearmiss_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_nearmiss_wrong_version(): DCNL 'Test either if an error is raised when the version is unknown.'
def test_nearmiss_init(): DCNL 'Test the initialisation of the object'
def test_nearmiss_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_nm_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_nm3_fit(): DCNL 'Test the fitting method'
def test_nm3_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_nm3_fit_sample_auto(): DCNL 'Test fit and sample routines with auto ratio'
def test_nm3_fit_sample_auto_indices(): DCNL 'Test fit and sample routines with auto ratio and indices support'
def test_nm3_fit_sample_half(): DCNL 'Test fit and sample routines with .5 ratio'
def test_nm3_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_nm3_fit_sample_nn_obj(): DCNL 'Test fit-sample with nn object'
def test_nm3_wrong_nn_obj(): DCNL 'Test either if an error is raised with wrong NN object'
def test_iht_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_iht_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_iht_wrong_estimator(): DCNL 'Test either if an error is raised when the estimator is unknown'
def test_iht_init(): DCNL 'Test the initialisation of the object'
def test_iht_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_iht_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_iht_fit(): DCNL 'Test the fitting method'
def test_iht_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_iht_fit_sample(): DCNL 'Test the fit sample routine'
def test_iht_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_iht_fit_sample_half(): DCNL 'Test the fit sample routine with a 0.5 ratio'
def test_iht_fit_sample_knn(): DCNL 'Test the fit sample routine with knn'
def test_iht_fit_sample_decision_tree(): DCNL 'Test the fit sample routine with decision-tree'
def test_iht_fit_sample_random_forest(): DCNL 'Test the fit sample routine with random forest'
def test_iht_fit_sample_adaboost(): DCNL 'Test the fit sample routine with adaboost'
def test_iht_fit_sample_gradient_boosting(): DCNL 'Test the fit sample routine with gradient boosting'
def test_iht_fit_sample_linear_svm(): DCNL 'Test the fit sample routine with linear SVM'
def test_iht_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_iht_fit_sample_class_obj(): DCNL 'Test the fit sample routine passing a classifiermixin object'
def test_iht_fit_sample_wrong_class_obj(): DCNL 'Test either if an error is raised while passing a wrong classifier DCNL object'
def test_ncr_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_ncr_init(): DCNL 'Test the initialisation of the object'
def test_ncr_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_ncr_fit(): DCNL 'Test the fitting method'
def test_ncr_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_ncr_fit_sample(): DCNL 'Test the fit sample routine'
def test_ncr_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_ncr_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_ncr_fit_sample_nn_obj(): DCNL 'Test fit-sample with nn object'
def test_ncr_wrong_nn_obj(): DCNL 'Test either if an error is raised with wrong NN object'
def test_rus_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_rus_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_rus_init(): DCNL 'Test the initialisation of the object'
def test_rus_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_rus_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_rus_fit(): DCNL 'Test the fitting method'
def test_rus_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_rus_fit_sample(): DCNL 'Test the fit sample routine'
def test_rus_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_rus_fit_sample_half(): DCNL 'Test the fit sample routine with a 0.5 ratio'
def test_rus_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_multiclass_fit_sample(): DCNL 'Test fit sample method with multiclass target'
def test_enn_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_enn_init(): DCNL 'Test the initialisation of the object'
def test_enn_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_enn_fit(): DCNL 'Test the fitting method'
def test_enn_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_enn_fit_sample(): DCNL 'Test the fit sample routine'
def test_enn_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_enn_fit_sample_mode(): DCNL 'Test the fit sample routine using the mode as selection'
def test_enn_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_enn_fit_sample_with_nn_object(): DCNL 'Test the fit sample routine using a NN object'
def test_enn_not_good_object(): DCNL 'Test either if an error is raised while a wrong type of NN is given'
def test_tl_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_tl_init(): DCNL 'Test the initialisation of the object'
def test_tl_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_tl_fit(): DCNL 'Test the fitting method'
def test_tl_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_tl_fit_sample(): DCNL 'Test the fit sample routine'
def test_tl_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_tl_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_allknn_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_allknn_init(): DCNL 'Test the initialisation of the object'
def test_allknn_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_allknn_fit(): DCNL 'Test the fitting method'
def test_allknn_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_allknn_fit_sample(): DCNL 'Test the fit sample routine'
def test_allknn_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_allknn_fit_sample_mode(): DCNL 'Test the fit sample routine using the mode as selection'
def test_allknn_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_allknn_fit_sample_with_nn_object(): DCNL 'Test the fit sample routine using a NN object'
def test_alknn_not_good_object(): DCNL 'Test either if an error is raised while a wrong type of NN is given'
def test_nearmiss_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_nearmiss_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_nearmiss_wrong_version(): DCNL 'Test either if an error is raised when the version is unknown.'
def test_nearmiss_init(): DCNL 'Test the initialisation of the object'
def test_nearmiss_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_nm_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_nm1_fit(): DCNL 'Test the fitting method'
def test_nm1_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_nm1_fit_sample_auto(): DCNL 'Test fit and sample routines with auto ratio'
def test_nm1_fit_sample_auto_indices(): DCNL 'Test fit and sample routines with auto ratio and indices support'
def test_nm1_fit_sample_half(): DCNL 'Test fit and sample routines with .5 ratio'
def test_nm1_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_nm1_fit_sample_nn_obj(): DCNL 'Test fit-sample with nn object'
def test_nm1_wrong_nn_obj(): DCNL 'Test either if an error is raised with wrong NN object'
def test_oss_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_oss_init(): DCNL 'Test the initialisation of the object'
def test_oss_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_oss_fit(): DCNL 'Test the fitting method'
def test_oss_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_oss_fit_sample(): DCNL 'Test the fit sample routine'
def test_oss_fit_sample_with_indices(): DCNL 'Test the fit sample routine with indices support'
def test_oss_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_oss_with_object(): DCNL 'Test the fit sample routine with an knn object'
def test_oss_with_wrong_object(): DCNL 'Test if an error is raised while passing a wrong object'
def make_pipeline(*steps): DCNL 'Construct a Pipeline from the given estimators. DCNL This is a shorthand for the Pipeline constructor; it does not require, and DCNL does not permit, naming the estimators. Instead, their names will be set DCNL to the lowercase of their types automatically. DCNL Returns DCNL p : Pipeline'
def test_ros_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_ros_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_ros_init(): DCNL 'Test the initialisation of the object'
def test_ros_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_ros_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_ros_fit(): DCNL 'Test the fitting method'
def test_ros_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_ros_fit_sample(): DCNL 'Test the fit sample routine'
def test_ros_fit_sample_half(): DCNL 'Test the fit sample routine with a 0.5 ratio'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_continuous_error(): DCNL 'Test either if an error is raised when the target are continuous DCNL type'
def test_multiclass_fit_sample(): DCNL 'Test fit sample method with multiclass target'
def test_ada_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_ada_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_ada_init(): DCNL 'Test the initialisation of the object'
def test_ada_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_ada_fit_invalid_ratio(): DCNL 'Test either if an error is raised when the balancing ratio to fit is DCNL smaller than the one of the data'
def test_ada_fit(): DCNL 'Test the fitting method'
def test_ada_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_ada_fit_sample(): DCNL 'Test the fit sample routine'
def test_ada_fit_sample_half(): DCNL 'Test the fit sample routine with a 0.5 ratio'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_ada_fit_sample_nn_obj(): DCNL 'Test fit-sample with nn object'
def test_ada_wrong_nn_obj(): DCNL 'Test either if an error is raised while passing a wrong NN object'
def test_smote_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_smote_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_smote_wrong_kind(): DCNL 'Test either if an error is raised when the wrong kind of SMOTE is DCNL given.'
def test_smote_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_smote_fit(): DCNL 'Test the fitting method'
def test_smote_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_sample_regular(): DCNL 'Test sample function with regular SMOTE.'
def test_sample_regular_half(): DCNL 'Test sample function with regular SMOTE and a ratio of 0.5.'
def test_sample_borderline1(): DCNL 'Test sample function with borderline 1 SMOTE.'
def test_sample_borderline2(): DCNL 'Test sample function with borderline 2 SMOTE.'
def test_sample_svm(): DCNL 'Test sample function with SVM SMOTE.'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_fit_sample_nn_obj(): DCNL 'Test sample with NN object provided.'
def test_sample_regular_with_nn(): DCNL 'Test sample function with regular SMOTE with a NN object.'
def test_wrong_nn(): DCNL 'Test either if an error is raised while passing a wrong NN object.'
def test_sample_regular_with_nn_svm(): DCNL 'Test sample function with regular SMOTE with a NN object.'
def test_sample_regular_wrong_svm(): DCNL 'Test sample function with regular SMOTE with a NN object.'
def _import_module_with_version_check(module_name, minimum_version, install_info=None): DCNL 'Check that module is installed with a recent enough version'
def _check_module_dependencies(is_imbalanced_dataset_installing=False): DCNL 'Throw an exception if imbalanced-learn dependencies are not installed. DCNL Parameters DCNL is_imbalanced_dataset_installing: boolean DCNL if True, only error on missing packages that cannot be auto-installed. DCNL if False, error on any missing package. DCNL Throws DCNL ImportError'
def sensitivity_specificity_support(y_true, y_pred, labels=None, pos_label=1, average=None, warn_for=('sensitivity', 'specificity'), sample_weight=None): DCNL 'Compute sensitivity, specificity, and support for each class DCNL The sensitivity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives and ``fn`` the number of false negatives. The sensitivity DCNL quantifies the ability to avoid false negatives_[1]. DCNL The specificity is the ratio ``tn / (tn + fp)`` where ``tn`` is the number DCNL of true negatives and ``fn`` the number of false negatives. The specificity DCNL quantifies the ability to avoid false positives_[1]. DCNL The support is the number of occurrences of each class in ``y_true``. DCNL If ``pos_label is None`` and in binary classification, this function DCNL returns the average sensitivity and specificity if ``average`` DCNL is one of ``\'weighted\'``. DCNL Parameters DCNL y_true : ndarray, shape (n_samples, ) DCNL Ground truth (correct) target values. DCNL y_pred : ndarray, shape (n_samples, ) DCNL Estimated targets as returned by a classifier. DCNL labels : list, optional DCNL The set of labels to include when ``average != \'binary\'``, and their DCNL order if ``average is None``. Labels present in the data can be DCNL excluded, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the data will DCNL result in 0 components in a macro average. For multilabel targets, DCNL labels are column indices. By default, all labels in ``y_true`` and DCNL ``y_pred`` are used in sorted order. DCNL pos_label : str or int, optional (default=1) DCNL The class to report if ``average=\'binary\'`` and the data is binary. DCNL If the data are multiclass, this will be ignored; DCNL setting ``labels=[pos_label]`` and ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (default=None) DCNL If ``None``, the scores for each class are returned. Otherwise, this DCNL determines the type of averaging performed on the data: DCNL ``\'binary\'``: DCNL Only report results for the class specified by ``pos_label``. DCNL This is applicable only if targets (``y_{true,pred}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives and false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, and find their unweighted DCNL mean.  This does not take label imbalance into account. DCNL ``\'weighted\'``: DCNL Calculate metrics for each label, and find their average, weighted DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision and recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, and find their average (only DCNL meaningful for multilabel classification where this differs from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This determines which warnings will be made in the case that this DCNL function is being used to return only one of its metrics. DCNL sample_weight : ndarray, shape (n_samples, ) DCNL Sample weights. DCNL Returns DCNL sensitivity : float (if ``average`` = None) or ndarray,         shape (n_unique_labels, ) DCNL specificity : float (if ``average`` = None) or ndarray,         shape (n_unique_labels, ) DCNL support : int (if ``average`` = None) or ndarray,         shape (n_unique_labels, ) DCNL The number of occurrences of each label in ``y_true``. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import sensitivity_specificity_support DCNL >>> y_true = np.array([\'cat\', \'dog\', \'pig\', \'cat\', \'dog\', \'pig\']) DCNL >>> y_pred = np.array([\'cat\', \'pig\', \'dog\', \'cat\', \'cat\', \'dog\']) DCNL >>> sensitivity_specificity_support(y_true, y_pred, average=\'macro\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL >>> sensitivity_specificity_support(y_true, y_pred, average=\'micro\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL >>> sensitivity_specificity_support(y_true, y_pred, average=\'weighted\') DCNL (0.33333333333333331, 0.66666666666666663, None) DCNL References DCNL .. [1] `Wikipedia entry for the Sensitivity and specificity DCNL <https://en.wikipedia.org/wiki/Sensitivity_and_specificity>`_'
def sensitivity_score(y_true, y_pred, labels=None, pos_label=1, average='binary', sample_weight=None): DCNL 'Compute the sensitivity DCNL The sensitivity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives and ``fn`` the number of false negatives. The sensitivity DCNL quantifies the ability to avoid false negatives. DCNL The best value is 1 and the worst value is 0. DCNL Parameters DCNL y_true : ndarray, shape (n_samples, ) DCNL Ground truth (correct) target values. DCNL y_pred : ndarray, shape (n_samples, ) DCNL Estimated targets as returned by a classifier. DCNL labels : list, optional DCNL The set of labels to include when ``average != \'binary\'``, and their DCNL order if ``average is None``. Labels present in the data can be DCNL excluded, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the data will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (default=1) DCNL The class to report if ``average=\'binary\'`` and the data is binary. DCNL If the data are multiclass, this will be ignored; DCNL setting ``labels=[pos_label]`` and ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (default=None) DCNL If ``None``, the scores for each class are returned. Otherwise, this DCNL determines the type of averaging performed on the data: DCNL ``\'binary\'``: DCNL Only report results for the class specified by ``pos_label``. DCNL This is applicable only if targets (``y_{true,pred}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives and false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, and find their unweighted DCNL mean.  This does not take label imbalance into account. DCNL ``\'weighted\'``: DCNL Calculate metrics for each label, and find their average, weighted DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision and recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, and find their average (only DCNL meaningful for multilabel classification where this differs from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This determines which warnings will be made in the case that this DCNL function is being used to return only one of its metrics. DCNL sample_weight : ndarray, shape (n_samples, ) DCNL Sample weights. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import sensitivity_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_pred = [0, 2, 1, 0, 0, 1] DCNL >>> sensitivity_score(y_true, y_pred, average=\'macro\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_pred, average=\'micro\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_pred, average=\'weighted\') DCNL 0.33333333333333331 DCNL >>> sensitivity_score(y_true, y_pred, average=None) DCNL array([ 1.,  0.,  0.]) DCNL Returns DCNL specificity : float (if ``average`` = None) or ndarray,         shape (n_unique_labels, )'
def specificity_score(y_true, y_pred, labels=None, pos_label=1, average='binary', sample_weight=None): DCNL 'Compute the specificity DCNL The specificity is the ratio ``tp / (tp + fn)`` where ``tp`` is the number DCNL of true positives and ``fn`` the number of false negatives. The specificity DCNL is intuitively the ability of the classifier to find all the positive DCNL samples. DCNL The best value is 1 and the worst value is 0. DCNL Parameters DCNL y_true : ndarray, shape (n_samples, ) DCNL Ground truth (correct) target values. DCNL y_pred : ndarray, shape (n_samples, ) DCNL Estimated targets as returned by a classifier. DCNL labels : list, optional DCNL The set of labels to include when ``average != \'binary\'``, and their DCNL order if ``average is None``. Labels present in the data can be DCNL excluded, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the data will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (default=1) DCNL The class to report if ``average=\'binary\'`` and the data is binary. DCNL If the data are multiclass, this will be ignored; DCNL setting ``labels=[pos_label]`` and ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (default=None) DCNL If ``None``, the scores for each class are returned. Otherwise, this DCNL determines the type of averaging performed on the data: DCNL ``\'binary\'``: DCNL Only report results for the class specified by ``pos_label``. DCNL This is applicable only if targets (``y_{true,pred}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives and false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, and find their unweighted DCNL mean.  This does not take label imbalance into account. DCNL ``\'weighted\'``: DCNL Calculate metrics for each label, and find their average, weighted DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision and recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, and find their average (only DCNL meaningful for multilabel classification where this differs from DCNL :func:`accuracy_score`). DCNL warn_for : tuple or set, for internal use DCNL This determines which warnings will be made in the case that this DCNL function is being used to return only one of its metrics. DCNL sample_weight : ndarray, shape (n_samples, ) DCNL Sample weights. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import specificity_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_pred = [0, 2, 1, 0, 0, 1] DCNL >>> specificity_score(y_true, y_pred, average=\'macro\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_pred, average=\'micro\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_pred, average=\'weighted\') DCNL 0.66666666666666663 DCNL >>> specificity_score(y_true, y_pred, average=None) DCNL array([ 0.75,  0.5 ,  0.75]) DCNL Returns DCNL specificity : float (if ``average`` = None) or ndarray,         shape (n_unique_labels, )'
def geometric_mean_score(y_true, y_pred, labels=None, pos_label=1, average='multiclass', sample_weight=None, correction=0.0): DCNL 'Compute the geometric mean DCNL The geometric mean (G-mean) is the root of the product of class-wise DCNL sensitivity. This measure tries to maximize the accuracy on each of the DCNL classes while keeping these accuracies balanced. For binary classification DCNL G-mean is the squared root of the product of the sensitivity DCNL and specificity. For multi-class problems it is a higher root of the DCNL product of sensitivity for each class. DCNL For compatibility with other imbalance performance measures, G-mean can be DCNL calculated for each class separately on a one-vs-rest basis when DCNL ``average != \'multiclass\'``. DCNL The best value is 1 and the worst value is 0. Traditionally if at least one DCNL class is unrecognized by the classifier, G-mean resolves to zero. To DCNL alleviate this property, for highly multi-class the sensitivity of DCNL unrecognized classes can be "corrected" to be a user specified value DCNL (instead of zero). This option works only if ``average == \'multiclass\'``. DCNL Parameters DCNL y_true : ndarray, shape (n_samples, ) DCNL Ground truth (correct) target values. DCNL y_pred : ndarray, shape (n_samples, ) DCNL Estimated targets as returned by a classifier. DCNL labels : list, optional DCNL The set of labels to include when ``average != \'binary\'``, and their DCNL order if ``average is None``. Labels present in the data can be DCNL excluded, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the data will DCNL result in 0 components in a macro average. DCNL pos_label : str or int, optional (default=1) DCNL The class to report if ``average=\'binary\'`` and the data is binary. DCNL If the data are multiclass, this will be ignored; DCNL setting ``labels=[pos_label]`` and ``average != \'binary\'`` will report DCNL scores for that label only. DCNL average : str or None, optional (default=``\'multiclass\'``) DCNL If ``None``, the scores for each class are returned. Otherwise, this DCNL determines the type of averaging performed on the data: DCNL ``\'binary\'``: DCNL Only report results for the class specified by ``pos_label``. DCNL This is applicable only if targets (``y_{true,pred}``) are binary. DCNL ``\'micro\'``: DCNL Calculate metrics globally by counting the total true positives, DCNL false negatives and false positives. DCNL ``\'macro\'``: DCNL Calculate metrics for each label, and find their unweighted DCNL mean.  This does not take label imbalance into account. DCNL ``\'weighted\'``: DCNL Calculate metrics for each label, and find their average, weighted DCNL by support (the number of true instances for each label). This DCNL alters \'macro\' to account for label imbalance; it can result in an DCNL F-score that is not between precision and recall. DCNL ``\'samples\'``: DCNL Calculate metrics for each instance, and find their average (only DCNL meaningful for multilabel classification where this differs from DCNL :func:`accuracy_score`). DCNL sample_weight : ndarray, shape (n_samples, ) DCNL Sample weights. DCNL correction: float, optional (default=0.0) DCNL Substitutes sensitivity of unrecognized classes from zero to a given DCNL value. DCNL Returns DCNL geometric_mean : float DCNL Examples DCNL >>> from imblearn.metrics import geometric_mean_score DCNL >>> y_true = [0, 1, 2, 0, 1, 2] DCNL >>> y_pred = [0, 2, 1, 0, 0, 1] DCNL >>> geometric_mean_score(y_true, y_pred) DCNL 0.0 DCNL >>> geometric_mean_score(y_true, y_pred, correction=0.001) DCNL 0.010000000000000004 DCNL >>> geometric_mean_score(y_true, y_pred, average=\'macro\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_pred, average=\'micro\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_pred, average=\'weighted\') DCNL 0.47140452079103168 DCNL >>> geometric_mean_score(y_true, y_pred, average=None) DCNL array([ 0.8660254,  0.       ,  0.       ]) DCNL References DCNL .. [1] Kubat, M. and Matwin, S. "Addressing the curse of DCNL imbalanced training sets: one-sided selection" ICML (1997) DCNL .. [2] Barandela, R., Sánchez, J. S., Garcıa, V., & Rangel, E. "Strategies DCNL for learning in class imbalance problems", Pattern Recognition, DCNL 36(3), (2003), pp 849-851.'
def make_index_balanced_accuracy(alpha=0.1, squared=True): DCNL 'Balance any scoring function using the index balanced accuracy DCNL This factory function wraps scoring function to express it as the DCNL index balanced accuracy (IBA). You need to use this function to DCNL decorate any scoring function. DCNL Only metrics requiring ``y_pred`` can be corrected with the index DCNL balanced accuracy. ``y_score`` cannot be used since the dominance DCNL cannot be computed. DCNL Parameters DCNL alpha : float, optional (default=0.1) DCNL Weighting factor. DCNL squared : bool, optional (default=True) DCNL If ``squared`` is True, then the metric computed will be squared DCNL before to be weighted. DCNL Returns DCNL iba_scoring_func : callable, DCNL Returns the scoring metric decorated which will automatically compute DCNL the index balanced accuracy. DCNL Examples DCNL >>> from imblearn.metrics import geometric_mean_score as gmean DCNL >>> from imblearn.metrics import make_index_balanced_accuracy as iba DCNL >>> gmean = iba(alpha=0.1, squared=True)(gmean) DCNL >>> y_true = [1, 0, 0, 1, 0, 1] DCNL >>> y_pred = [0, 0, 1, 1, 0, 1] DCNL >>> print(gmean(y_true, y_pred, average=None)) DCNL [ 0.44444444  0.44444444]'
def classification_report_imbalanced(y_true, y_pred, labels=None, target_names=None, sample_weight=None, digits=2, alpha=0.1): DCNL 'Build a classification report based on metrics used with imbalanced DCNL dataset DCNL Specific metrics have been proposed to evaluate the classification DCNL performed on imbalanced dataset. This report compiles the DCNL state-of-the-art metrics: precision/recall/specificity, geometric DCNL mean, and index balanced accuracy of the DCNL geometric mean. DCNL Parameters DCNL y_true : ndarray, shape (n_samples, ) DCNL Ground truth (correct) target values. DCNL y_pred : ndarray, shape (n_samples, ) DCNL Estimated targets as returned by a classifier. DCNL labels : list, optional DCNL The set of labels to include when ``average != \'binary\'``, and their DCNL order if ``average is None``. Labels present in the data can be DCNL excluded, for example to calculate a multiclass average ignoring a DCNL majority negative class, while labels not present in the data will DCNL result in 0 components in a macro average. DCNL target_names : list of strings, optional DCNL Optional display names matching the labels (same order). DCNL sample_weight : ndarray, shape (n_samples, ) DCNL Sample weights. DCNL digits : int, optional (default=2) DCNL Number of digits for formatting output floating point values DCNL alpha : float, optional (default=0.1) DCNL Weighting factor. DCNL Returns DCNL report : string DCNL Text summary of the precision, recall, specificity, geometric mean, DCNL and index balanced accuracy. DCNL Examples DCNL >>> import numpy as np DCNL >>> from imblearn.metrics import classification_report_imbalanced DCNL >>> y_true = [0, 1, 2, 2, 2] DCNL >>> y_pred = [0, 0, 2, 2, 1] # doctest : +NORMALIZE_WHITESPACE DCNL >>> target_names = [\'class 0\', \'class 1\',     \'class 2\'] # doctest : +NORMALIZE_WHITESPACE DCNL >>> print(classification_report_imbalanced(y_true, y_pred,     target_names=target_names)) DCNL pre       rec       spe        f1       geo       iba       sup DCNL <BLANKLINE> DCNL class 0       0.50      1.00      0.75      0.67      0.71      0.48         1 DCNL class 1       0.00      0.00      0.75      0.00      0.00      0.00         1 DCNL class 2       1.00      0.67      1.00      0.80      0.82      0.69         3 DCNL <BLANKLINE> DCNL avg / total       0.70      0.60      0.90      0.61      0.63      0.51         5 DCNL <BLANKLINE>'
def make_prediction(dataset=None, binary=False): DCNL 'Make some classification predictions on a toy dataset using a SVC DCNL If binary is True restrict to a binary classification problem instead of a DCNL multiclass classification problem'
def test_sensitivity_specificity_score_binary(): DCNL 'Test Sensitivity Specificity for binary classification task'
def test_sensitivity_specificity_f_binary_single_class(): DCNL 'Test sensitivity and specificity behave with a single positive or DCNL negative class'
@ignore_warnings DCNL def test_sensitivity_specificity_extra_labels(): DCNL 'Test handling of explicit additional (not in input) labels to SS'
@ignore_warnings DCNL def test_sensitivity_specificity_ignored_labels(): DCNL 'Test a subset of labels may be requested for SS'
def test_sensitivity_specificity_error_multilabels(): DCNL 'Test either if an error is raised when the input are multilabels'
@ignore_warnings DCNL def test_sensitivity_specificity_support_errors(): DCNL 'Test either if an error is raised depending on parameters'
def test_sensitivity_specificity_unused_pos_label(): DCNL 'Check warning that pos_label unused when set to non-default value DCNL # but average != \'binary\'; even if data is binary'
def test_geometric_mean_support_binary(): DCNL 'Test the geometric mean for binary classification task'
def test_iba_geo_mean_binary(): DCNL 'Test to test the iba using the geometric mean'
def _format_report(report): DCNL 'Private function to reformat the report for testing'
def test_classification_report_imbalanced_multiclass(): DCNL 'Test classification report for multiclass problem'
def test_classification_report_imbalanced_multiclass_with_digits(): DCNL 'Test performance report with added digits in floating point values'
def test_classification_report_imbalanced_multiclass_with_string_label(): DCNL 'Test the report with string label'
def test_classification_report_imbalanced_multiclass_with_unicode_label(): DCNL 'Test classification report with unicode label'
def test_classification_report_imbalanced_multiclass_with_long_string_label(): DCNL 'Test classification report with long string label'
def test_iba_sklearn_metrics(): DCNL 'Test the compatibility of sklearn metrics within IBA'
def test_iba_error_y_score_prob(): DCNL 'Test if an error is raised when a scoring metric take over parameters DCNL than y_pred'
def test_imblearn_classification_scorers(): DCNL 'Test if the implemented scorer can be used in scikit-learn'
def make_imbalance(X, y, ratio, min_c_=None, random_state=None): DCNL 'Turns a dataset into an imbalanced dataset at specific ratio. DCNL A simple toy dataset to visualize clustering and classification DCNL algorithms. DCNL Parameters DCNL X : ndarray, shape (n_samples, n_features) DCNL Matrix containing the data to be imbalanced. DCNL y : ndarray, shape (n_samples, ) DCNL Corresponding label for each sample in X. DCNL ratio : float, DCNL The desired ratio given by the number of samples in DCNL the minority class over the the number of samples in DCNL the majority class. Thus the ratio should be in the interval [0., 1.] DCNL min_c_ : str or int, optional (default=None) DCNL The identifier of the class to be the minority class. DCNL If None, min_c_ is set to be the current minority class. DCNL random_state : int, RandomState instance or None, optional (default=None) DCNL If int, random_state is the seed used by the random number generator; DCNL If RandomState instance, random_state is the random number generator; DCNL If None, the random number generator is the RandomState instance used DCNL by np.random. DCNL Returns DCNL X_resampled : ndarray, shape (n_samples_new, n_features) DCNL The array containing the imbalanced data. DCNL y_resampled : ndarray, shape (n_samples_new) DCNL The corresponding label of `X_resampled`'
def test_make_imbalance_bad_ratio(): DCNL 'Test either if an error is raised with bad ratio DCNL argument'
def test_make_imbalance_invalid_ratio(): DCNL 'Test either if error is raised with higher ratio DCNL than current ratio.'
def test_make_imbalance_single_class(): DCNL 'Test either if an error when there is a single class'
def test_make_imbalance_1(): DCNL 'Test make_imbalance'
def test_make_imbalance_2(): DCNL 'Test make_imbalance'
def test_make_imbalance_3(): DCNL 'Test make_imbalance'
def test_make_imbalance_4(): DCNL 'Test make_imbalance'
def test_make_imbalance_5(): DCNL 'Test make_imbalance'
def test_make_imbalance_multiclass(): DCNL 'Test make_imbalance with multiclass data'
def test_smote_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_smote_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_smote_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_smote_fit(): DCNL 'Test the fitting method'
def test_smote_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_sample_regular(): DCNL 'Test sample function with regular SMOTE.'
def test_sample_regular_half(): DCNL 'Test sample function with regular SMOTE and a ratio of 0.5.'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_validate_estimator_init(): DCNL 'Test right processing while passing objects as initialization'
def test_validate_estimator_default(): DCNL 'Test right processing while passing no object as initialization'
def test_validate_estimator_deprecation(): DCNL 'Test right processing while passing old parameters'
def test_error_wrong_object(): DCNL 'Test either if an error is raised while wrong objects are provided DCNL at the initialization'
def test_senn_sk_estimator(): DCNL 'Test the sklearn estimator compatibility'
def test_senn_bad_ratio(): DCNL 'Test either if an error is raised with a wrong decimal value for DCNL the ratio'
def test_smote_fit_single_class(): DCNL 'Test either if an error when there is a single class'
def test_smote_fit(): DCNL 'Test the fitting method'
def test_smote_sample_wt_fit(): DCNL 'Test either if an error is raised when sample is called before DCNL fitting'
def test_sample_regular(): DCNL 'Test sample function with regular SMOTE.'
def test_sample_regular_half(): DCNL 'Test sample function with regular SMOTE and a ratio of 0.5.'
def test_sample_wrong_X(): DCNL 'Test either if an error is raised when X is different at fitting DCNL and sampling'
def test_senn_multiclass_error(): DCNL 'Test either if an error is raised when the target are not binary DCNL type.'
def test_validate_estimator_init(): DCNL 'Test right processing while passing objects as initialization'
def test_validate_estimator_default(): DCNL 'Test right processing while passing no object as initialization'
def test_validate_estimator_deprecation(): DCNL 'Test right processing while passing old parameters'
def test_error_wrong_object(): DCNL 'Test either if an error is raised while wrong objects are provided DCNL at the initialization'
def parse_content_type(content_type): DCNL 'Separates out the parameters from the content_type and returns both in a tuple (content_type, parameters)'
def content_type(content_type): DCNL 'Attaches the supplied content_type to a Hug formatting function'
def underscore(text): DCNL 'Converts text that may be camelcased into an underscored format'
def camelcase(text): DCNL 'Converts text that may be underscored into a camelcase format'
def content_type(transformers, default=None): DCNL 'Returns a different transformer depending on the content type passed in. DCNL If none match and no default is given no transformation takes place. DCNL should pass in a dict with the following format: DCNL {\'[content-type]\': transformation_action,'
def suffix(transformers, default=None): DCNL 'Returns a different transformer depending on the suffix at the end of the requested URL. DCNL If none match and no default is given no transformation takes place. DCNL should pass in a dict with the following format: DCNL {\'[suffix]\': transformation_action,'
def prefix(transformers, default=None): DCNL 'Returns a different transformer depending on the prefix at the end of the requested URL. DCNL If none match and no default is given no transformation takes place. DCNL should pass in a dict with the following format: DCNL {\'[prefix]\': transformation_action,'
def all(*transformers): DCNL 'Returns the results of applying all passed in transformers to data DCNL should pass in list of transformers DCNL [transformer_1, transformer_2...]'
def all(*validators): DCNL 'Validation only succeeds if all passed in validators return no errors'
def any(*validators): DCNL 'If any of the specified validators pass the validation succeeds'
def contains_one_of(*fields): DCNL 'Enables ensuring that one of multiple optional fields is set'
def is_method(function): DCNL 'Returns True if the passed in function is identified as a method (NOT a function)'
def is_coroutine(function): DCNL 'Returns True if the passed in function is a coroutine'
def arguments(function, extra_arguments=0): DCNL 'Returns the name of all arguments a function takes'
def takes_kwargs(function): DCNL 'Returns True if the supplied function takes keyword arguments'
def takes_args(function): DCNL 'Returns True if the supplied functions takes extra non-keyword arguments'
def takes_arguments(function, *named_arguments): DCNL 'Returns the arguments that a function takes from a list of requested arguments'
def takes_all_arguments(function, *named_arguments): DCNL 'Returns True if all supplied arguments are found in the function'
def generate_accepted_kwargs(function, *named_arguments): DCNL 'Dynamically creates a function that when called with dictionary of arguments will produce a kwarg that\'s DCNL compatible with the supplied function'
def to(location, code=falcon.HTTP_302): DCNL 'Redirects to the specified location using the provided http_code (defaults to HTTP_302 FOUND)'
def permanent(location): DCNL 'Redirects to the specified location using HTTP 301 status code'
def found(location): DCNL 'Redirects to the specified location using HTTP 302 status code'
def see_other(location): DCNL 'Redirects to the specified location using HTTP 303 status code'
def temporary(location): DCNL 'Redirects to the specified location using HTTP 304 status code'
def not_found(*args, **kwargs): DCNL 'Redirects request handling to the not found render'
def authenticator(function, challenges=()): DCNL 'Wraps authentication logic, verify_user through to the authentication function. DCNL The verify_user function passed in should accept an API key and return a user object to DCNL store in the request context if authentication succeeded.'
@authenticator DCNL def basic(request, response, verify_user, realm='simple', **kwargs): DCNL 'Basic HTTP Authentication'
@authenticator DCNL def api_key(request, response, verify_user, **kwargs): DCNL 'API Key Header Authentication DCNL The verify_user function passed in to ths authenticator shall receive an DCNL API key as input, and return a user object to store in the request context DCNL if the request was successful.'
@authenticator DCNL def token(request, response, verify_user, **kwargs): DCNL 'Token verification DCNL Checks for the Authorization header and verifies using the verify_user function'
def verify(user, password): DCNL 'Returns a simple verification callback that simply verifies that the users and password match that provided'
def json_convert(*kinds): DCNL 'Registers the wrapped method as a JSON converter for the provided types. DCNL NOTE: custom converters are always globally applied'
@content_type('application/json') DCNL def json(content, request=None, response=None, **kwargs): DCNL 'JSON (Javascript Serialized Object Notation)'
def on_valid(valid_content_type, on_invalid=json): DCNL 'Renders as the specified content type only if no errors are found in the provided data object'
@content_type('text/plain') DCNL def text(content, **kwargs): DCNL 'Free form UTF-8 text'
@content_type('text/html') DCNL def html(content, **kwargs): DCNL 'HTML (Hypertext Markup Language)'
@content_type('application/json') DCNL def json_camelcase(content, **kwargs): DCNL 'JSON (Javascript Serialized Object Notation) with all keys camelCased'
@content_type('application/json') DCNL def pretty_json(content, **kwargs): DCNL 'JSON (Javascript Serialized Object Notion) pretty printed and indented'
def image(image_format, doc=None): DCNL 'Dynamically creates an image type handler for the specified image type'
def video(video_type, video_mime, doc=None): DCNL 'Dynamically creates a video type handler for the specified video type'
@on_valid('file/dynamic') DCNL def file(data, response, **kwargs): DCNL 'A dynamically retrieved file'
def on_content_type(handlers, default=None, error='The DCSP requested DCSP content DCSP type DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL 'Returns a content in a different format based on the clients provided content type, DCNL should pass in a dict with the following format: DCNL {\'[content-type]\': action,'
def accept_quality(accept, default=1): DCNL 'Separates out the quality score from the accepted content_type'
def accept(handlers, default=None, error='The DCSP requested DCSP content DCSP type DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL 'Returns a content in a different format based on the clients defined accepted content type, DCNL should pass in a dict with the following format: DCNL {\'[content-type]\': action,'
def suffix(handlers, default=None, error='The DCSP requested DCSP suffix DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL 'Returns a content in a different format based on the suffix placed at the end of the URL route DCNL should pass in a dict with the following format: DCNL {\'[suffix]\': action,'
def prefix(handlers, default=None, error='The DCSP requested DCSP prefix DCSP does DCSP not DCSP match DCSP any DCSP of DCSP those DCSP allowed'): DCNL 'Returns a content in a different format based on the prefix placed at the end of the URL route DCNL should pass in a dict with the following format: DCNL {\'[prefix]\': action,'
@content_type('text/plain') DCNL def text(body, charset='utf-8', **kwargs): DCNL 'Takes plain text data'
@content_type('application/json') DCNL def json(body, charset='utf-8', **kwargs): DCNL 'Takes JSON formatted data, converting it into native Python objects'
def json_underscore(body, charset='utf-8', **kwargs): DCNL 'Converts JSON formatted date to native Python objects. DCNL The keys in any JSON dict are transformed from camelcase to underscore separated words.'
@content_type('application/x-www-form-urlencoded') DCNL def urlencoded(body, charset='ascii', **kwargs): DCNL 'Converts query strings into native Python objects'
@content_type('multipart/form-data') DCNL def multipart(body, **header_params): DCNL 'Converts multipart form data into native Python objects'
def call(method, api_or_module, url, body='', headers=None, params=None, query_string='', scheme='http', **kwargs): DCNL 'Simulates a round-trip call against the given API / URL'
def cli(method, *args, **arguments): DCNL 'Simulates testing a hug cli method from the command line'
def _built_in_directive(directive): DCNL 'Marks a callable as a built-in directive'
@_built_in_directive DCNL def module(default=None, api=None, **kwargs): DCNL 'Returns the module that is running this hug API function'
@_built_in_directive DCNL def api(default=None, api=None, **kwargs): DCNL 'Returns the api instance in which this API function is being ran'
@_built_in_directive DCNL def api_version(default=None, api_version=None, **kwargs): DCNL 'Returns the current api_version as a directive for use in both request and not request handling code'
@_built_in_directive DCNL def documentation(default=None, api_version=None, api=None, **kwargs): DCNL 'returns documentation for the current api'
@_built_in_directive DCNL def session(context_name='session', request=None, **kwargs): DCNL 'Returns the session associated with the current request'
@_built_in_directive DCNL def user(default=None, request=None, **kwargs): DCNL 'Returns the current logged in user'
def default_output_format(content_type='application/json', apply_globally=False, api=None): DCNL 'A decorator that allows you to override the default output format for an API'
def default_input_format(content_type='application/json', apply_globally=False, api=None): DCNL 'A decorator that allows you to override the default output format for an API'
def directive(apply_globally=False, api=None): DCNL 'A decorator that registers a single hug directive'
def startup(api=None): DCNL 'Runs the provided function on startup, passing in an instance of the api'
def request_middleware(api=None): DCNL 'Registers a middleware function that will be called on every request'
def response_middleware(api=None): DCNL 'Registers a middleware function that will be called on every response'
def middleware_class(api=None): DCNL 'Registers a middleware class'
def extend_api(route='', api=None, base_url=''): DCNL 'Extends the current api, with handlers from an imported api. Optionally provide a route that prefixes access'
def wraps(function): DCNL 'Enables building decorators around functions used for hug routes without chaninging their function signature'
def auto_kwargs(function): DCNL 'Modifies the provided function to support kwargs by only passing along kwargs for parameters it accepts'
@hug.post('/upload') DCNL def upload_file(body): DCNL 'accepts file uploads'
@hug.get('/image.png', output=hug.output_format.png_image) DCNL def image(): DCNL 'Serves up a PNG image.'
@hug.startup() DCNL def add_data(api): DCNL 'Adds initial data to the api on startup'
@hug.startup() DCNL def add_more_data(api): DCNL 'Adds initial data to the api on startup'
@hug.get() DCNL def test(): DCNL 'Returns all stored data'
@hug.post() DCNL def post_here(body): DCNL 'This example shows how to read in post data w/ hug outside of its automatic param parsing'
@hug.get() DCNL def hello(request): DCNL 'Says hello'
@hug.get(output=hug.output_format.mp4_video) DCNL def watch(): DCNL 'Watch an example movie, streamed directly to you from hug'
@hug.directive(apply_globally=False) DCNL def my_directive(default=None, **kwargs): DCNL 'for testing'
@hug.default_input_format('application/made-up') DCNL def made_up_formatter(data): DCNL 'for testing'
@hug.default_output_format() DCNL def output_formatter(data): DCNL 'for testing'
@hug.get() DCNL def made_up_api(hug_my_directive=True): DCNL 'for testing'
@hug.directive(apply_globally=True) DCNL def my_directive_global(default=None, **kwargs): DCNL 'for testing'
@hug.default_input_format('application/made-up', apply_globally=True) DCNL def made_up_formatter_global(data): DCNL 'for testing'
@hug.default_output_format(apply_globally=True) DCNL def output_formatter_global(data): DCNL 'for testing'
@hug.request_middleware() DCNL def handle_request(request, response): DCNL 'for testing'
@hug.startup() DCNL def on_startup(api): DCNL 'for testing'
@hug.static() DCNL def static(): DCNL 'for testing'
@hug.sink('/all') DCNL def sink(path): DCNL 'for testing'
@hug.exception(FakeException) DCNL def handle_exception(exception): DCNL 'Handles the provided exception for testing'
@hug.not_found() DCNL def not_found_handler(): DCNL 'for testing'
def test_from_object(): DCNL 'Test to ensure it\'s possible to rechieve an API singleton from an arbitrary object'
def test_api_fixture(hug_api): DCNL 'Ensure it\'s possible to dynamically insert a new hug API on demand'
def test_content_type(): DCNL 'Test to ensure the transformer used can change based on the provided content-type'
def test_suffix(): DCNL 'Test to ensure transformer content based on the end suffix of the URL works as expected'
def test_prefix(): DCNL 'Test to ensure transformer content based on the end prefix of the URL works as expected'
def test_all(): DCNL 'Test to ensure transform.all allows chaining multiple transformations as expected'
def test_to(): DCNL 'Test that the base redirect to function works as expected'
def test_permanent(): DCNL 'Test to ensure function causes a redirect with HTTP 301 status code'
def test_found(): DCNL 'Test to ensure function causes a redirect with HTTP 302 status code'
def test_see_other(): DCNL 'Test to ensure function causes a redirect with HTTP 303 status code'
def test_temporary(): DCNL 'Test to ensure function causes a redirect with HTTP 307 status code'
def test_text(): DCNL 'Ensure that it\'s possible to output a Hug API method as text'
def test_html(): DCNL 'Ensure that it\'s possible to output a Hug API method as HTML'
def test_json(): DCNL 'Ensure that it\'s possible to output a Hug API method as JSON'
def test_pretty_json(): DCNL 'Ensure that it\'s possible to output a Hug API method as prettified and indented JSON'
def test_json_camelcase(): DCNL 'Ensure that it\'s possible to output a Hug API method as camelCased JSON'
def test_image(): DCNL 'Ensure that it\'s possible to output images with hug'
def test_file(): DCNL 'Ensure that it\'s possible to easily output files'
def test_video(): DCNL 'Ensure that it\'s possible to output videos with hug'
def test_on_valid(): DCNL 'Test to ensure formats that use on_valid content types gracefully handle error dictionaries'
def test_on_content_type(): DCNL 'Ensure that it\'s possible to route the output type format by the requested content-type'
def test_accept(): DCNL 'Ensure that it\'s possible to route the output type format by the requests stated accept header'
def test_suffix(): DCNL 'Ensure that it\'s possible to route the output type format by the suffix of the requested URL'
def test_prefix(): DCNL 'Ensure that it\'s possible to route the output type format by the prefix of the requested URL'
def test_simple_class_based_view(): DCNL 'Test creating class based routers'
def test_simple_class_based_method_view(): DCNL 'Test creating class based routers using method mappings'
def test_routing_class_based_method_view_with_sub_routing(): DCNL 'Test creating class based routers using method mappings, then overriding url on sub method'
def test_routing_class_with_cli_commands(): DCNL 'Basic operation test'
def test_routing_class_based_method_view_with_cli_routing(): DCNL 'Test creating class based routers using method mappings exposing cli endpoints'
def test_routing_instance(): DCNL 'Test to ensure its possible to route a class after it is instanciated'
def test_is_method(): DCNL 'Test to ensure hugs introspection can correctly identify the difference between a function and method'
def test_arguments(): DCNL 'Test to ensure hug introspection can correctly pull out arguments from a function definition'
def test_takes_kwargs(): DCNL 'Test to ensure hug introspection can correctly identify when a function takes kwargs'
def test_takes_args(): DCNL 'Test to ensure hug introspection can correctly identify when a function takes args'
def test_takes_arguments(): DCNL 'Test to ensure hug introspection can correctly identify which arguments supplied a function will take'
def test_takes_all_arguments(): DCNL 'Test to ensure hug introspection can correctly identify if a function takes all specified arguments'
def test_generate_accepted_kwargs(): DCNL 'Test to ensure hug introspection can correctly dynamically filter out kwargs for only those accepted'
@pytest.fixture DCNL def hug_api(): DCNL 'Defines a dependency for and then includes a uniquely identified hug API for a single test case'
def test_basic_call_coroutine(): DCNL 'The most basic Happy-Path test for Hug APIs using async'
def test_nested_basic_call_coroutine(): DCNL 'The most basic Happy-Path test for Hug APIs using async'
def test_basic_call_on_method_coroutine(): DCNL 'Test to ensure the most basic call still works if applied to a method'
def test_basic_call_on_method_through_api_instance_coroutine(): DCNL 'Test to ensure the most basic call still works if applied to a method'
def test_basic_call_on_method_registering_without_decorator_coroutine(): DCNL 'Test to ensure instance method calling via async works as expected'
def test_type(): DCNL 'Test to ensure the abstract Type object can\'t be used'
def test_number(): DCNL 'Tests that hug\'s number type correctly converts and validates input'
def test_range(): DCNL 'Tests that hug\'s range type successfully handles ranges of numbers'
def test_less_than(): DCNL 'Tests that hug\'s less than type successfully limits the values passed in'
def test_greater_than(): DCNL 'Tests that hug\'s greater than type succefully limis the values passed in'
def test_multiple(): DCNL 'Tests that hug\'s multile type correctly forces values to come back as lists, but not lists of lists'
def test_delimited_list(): DCNL 'Test to ensure hug\'s custom delimited list type function works as expected'
def test_comma_separated_list(): DCNL 'Tests that hug\'s comma separated type correctly converts into a Python list'
def test_float_number(): DCNL 'Tests to ensure the float type correctly allows floating point values'
def test_decimal(): DCNL 'Tests to ensure the decimal type correctly allows decimal values'
def test_boolean(): DCNL 'Test to ensure the custom boolean type correctly supports boolean conversion'
def test_mapping(): DCNL 'Test to ensure the mapping type works as expected'
def test_smart_boolean(): DCNL 'Test to ensure that the smart boolean type works as expected'
def test_text(): DCNL 'Tests that hug\'s text validator correctly handles basic values'
def test_uuid(): DCNL 'Tests that hug\'s text validator correctly handles UUID values DCNL Examples were taken from https://docs.python.org/3/library/uuid.html'
def test_length(): DCNL 'Tests that hug\'s length type successfully handles a length range'
def test_shorter_than(): DCNL 'Tests that hug\'s shorter than type successfully limits the values passed in'
def test_longer_than(): DCNL 'Tests that hug\'s greater than type succefully limis the values passed in'
def test_cut_off(): DCNL 'Test to ensure that hug\'s cut_off type works as expected'
def test_inline_dictionary(): DCNL 'Tests that inline dictionary values are correctly handled'
def test_one_of(): DCNL 'Tests that hug allows limiting a value to one of a list of values'
def test_accept(): DCNL 'Tests to ensure the accept type wrapper works as expected'
def test_accept_custom_exception_text(): DCNL 'Tests to ensure it\'s easy to custom the exception text using the accept wrapper'
def test_accept_custom_exception_handlers(): DCNL 'Tests to ensure it\'s easy to custom the exception text using the accept wrapper'
def test_json(): DCNL 'Test to ensure that the json type correctly handles url encoded json, as well as direct json'
def test_multi(): DCNL 'Test to ensure that the multi type correctly handles a variety of value types'
def test_chain(): DCNL 'Test to ensure that chaining together multiple types works as expected'
def test_nullable(): DCNL 'Test the concept of a nullable type'
def test_schema_type(): DCNL 'Test hug\'s complex schema types'
def test_marshmallow_schema(): DCNL 'Test hug\'s marshmallow schema support'
def test_create_type(): DCNL 'Test hug\'s new type creation decorator works as expected'
@hug.get() DCNL def made_up_hello(): DCNL 'for science!'
def test_basic_auth(): DCNL 'Test to ensure hug provides basic_auth handler works as expected'
def test_api_key(): DCNL 'Test the included api_key based header to ensure it works as expected to allow X-Api-Key based authentication'
def test_token_auth(): DCNL 'Test JSON Web Token'
def test_documentation_carry_over(): DCNL 'Test to ensure documentation correctly carries over - to address issue #252'
def test_text(): DCNL 'Ensure that plain text input format works as intended'
def test_json(): DCNL 'Ensure that the json input format works as intended'
def test_json_underscore(): DCNL 'Ensure that camelCase keys can be converted into under_score for easier use within Python'
def test_urlencoded(): DCNL 'Ensure that urlencoded input format works as intended'
def test_multipart(): DCNL 'Ensure multipart form data works as intended'
def test_all(): DCNL 'Test to ensure hug\'s all validation function works as expected to combine validators'
def test_any(): DCNL 'Test to ensure hug\'s any validation function works as expected to combine validators'
def test_contains_one_of(): DCNL 'Test to ensure hug\'s contains_one_of validation function works as expected to ensure presence of a field'
def scope_key(instance, xblock): DCNL 'Generate a unique key for a scope that can be used as a DCNL filename, in a URL, or in a KVS. DCNL Our goal is to have a pretty, human-readable 1:1 encoding. DCNL This encoding is as good as we can do. It\'s reversable, but not DCNL trivial to reverse. DCNL Encoding scheme: DCNL Posix allows [A-Z][a-z][0-9]._- DCNL We\'d like to have a _concise_ representation for common punctuation DCNL We\'re okay with a _non-concise_ representation for repeated or uncommon characters DCNL We keep [A-z][a-z][0-9] as is. DCNL We encode other common punctuation as pairs of ._-. This gives a total of 3*3=9 combinations. DCNL We\'re pretty careful to keep this nice. Where possible, we double characters. The most common DCNL other character (\' \' and \':\') are encoded as _- and -_ DCNL We seperate field portions with /. This gives a natural directory DCNL tree. This is nice in URLs and filenames (although not so nice in DCNL urls.py) DCNL If a field starts with punctuatation, we prefix a _. This prevents hidden files. DCNL Uncommon characters, we encode as their ordinal value, surrounded by -. DCNL For example, tilde would be -126-. DCNL If a field is not used, we call it NONE.NONE. This does not DCNL conflict with fields with the same name, since they are escaped to DCNL NONE..NONE. DCNL Sample keys: DCNL Settings scope: DCNL animationxblock..animation..d0..u0/settings__fs/NONE.NONE DCNL User summary scope: DCNL animationxblock..animation..d0..u0/uss__fs/NONE.NONE DCNL User preferences, username is Aan.!a DCNL animation/pref__fs/Aan.._33_a'
def test_setting_the_same_value_marks_field_as_dirty(): DCNL 'Check that setting field to the same value marks mutable fields as dirty. DCNL However, since the value hasn\'t changed, these fields won\'t be saved.'
def _num_plugins_cached(): DCNL 'Returns the number of plugins that have been cached.'
def setup_save_failure(set_many): DCNL 'Set up tests for when there\'s a save error in the underlying KeyValueStore'
def test_get_mutable_mark_dirty(): DCNL 'Ensure that accessing a mutable field type does not mark it dirty DCNL if the field has never been set. If the field has been set, ensure DCNL that it is set to dirty.'
def test_change_mutable_default(): DCNL 'Ensure that mutating the default value for a field causes DCNL the changes to be saved, and doesn\'t corrupt other instances'
def blocks_are_equivalent(block1, block2): DCNL 'Compare two blocks for equivalence.'
def _unabc(cls, msg="{} DCSP isn't DCSP implemented"): DCNL 'Helper method to implement `unabc`'
def unabc(msg): DCNL 'Add dummy methods to a class to satisfy abstract base class constraints. DCNL Usage:: DCNL @unabc DCNL class NotAbstract(SomeAbstractClass): DCNL pass DCNL @unabc(\'Fake {}\') DCNL class NotAbstract(SomeAbstractClass): DCNL pass'
def test_dummy_user_service_current_user(): DCNL 'Tests that get_current_user() works on a dummy user service.'
def test_dummy_user_service_exception(): DCNL 'Tests NotImplemented error raised by UserService when not instantiated with kwarg get_current_user'
def get_namespace_attrs(): DCNL 'Returns string suitable to be used as an xmlns parameters in XBlock XML representation'
def squish(text): DCNL 'Turn any run of whitespace into one space.'
def check_field(collection, field): DCNL 'Test method. DCNL Asserts that the given `field` is present in `collection`. DCNL Sets the field to a new value and asserts that the update properly occurs. DCNL Deletes the new value, and asserts that the default value is properly restored.'
def test_ugettext_calls(): DCNL 'Test ugettext calls in xblock.'
def default_select(identifier, all_entry_points): DCNL 'Raise an exception when we have ambiguous entry points.'
def public(type=None, **kwargs): DCNL 'Mark a function as public. In the future, this will inform the DCNL XBlocks services framework to make the function remotable. For DCNL now, this is a placeholder. DCNL The kwargs will contain: DCNL type : A specification for what the function does. Multiple DCNL functions of the same type will have identical input/output DCNL semantics, but may have different implementations. For example, DCNL type = student_distance DCNL Takes two students and returns a number. Specific instances may DCNL look at e.g. difference in some measure of aptitude, geographic DCNL distance, culture, or language. See stevedor, as well as queries DCNL in https://github.com/edx/insights to understand how this will DCNL be used.'
def webob_to_django_response(webob_response): DCNL 'Returns a django response to the `webob_response`'
def querydict_to_multidict(query_dict, wrap=None): DCNL 'Returns a new `webob.MultiDict` from a `django.http.QueryDict`. DCNL If `wrap` is provided, it\'s used to wrap the values.'
def django_to_webob_request(django_request): DCNL 'Returns a WebOb request to the `django_request`'
def run_script(pycode): DCNL 'Run the Python in `pycode`, and return a dict of the resulting globals.'
def generate_key(key_length=64): DCNL 'Secret key generator. DCNL The quality of randomness depends on operating system support, DCNL see http://docs.python.org/library/random.html#random.SystemRandom.'
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL 'Multiprocess-safe secret key file generator. DCNL Useful to replace the default (and thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the dashboard Django application (e.g. in a mod_wsgi + daemonized DCNL environment).  Also checks if file permissions are set correctly and DCNL throws an exception if not.'
def _translate_attachment_detail_view(_context, vol): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(_context, vol): DCNL 'Maps keys for attachment summary view.'
def _translate_conductor_detail_view(context, vol, image_id=None): DCNL 'Maps keys for conductors details view.'
def _translate_conductor_summary_view(context, vol, image_id=None): DCNL 'Maps keys for conductors summary view.'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/monitor/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'monitor.api.ec2.cloud:\'      monitor.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises monitor.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def short_cycle_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from monitor.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL 'Compute the current utilization of a given host.'
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
def compute_node_get_by_host(context, host): DCNL 'Get all capacity entries for the given host.'
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL 'Update a specific ComputeNode entry by a series of deltas. DCNL Do this as a single atomic action and lock the row for the DCNL duration of the operation. Requires that ComputeNode record exist.'
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL 'Like compute_node_utilization_update() modify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a delta update).'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_bmc_by_host(context, host): DCNL 'Get all compute services for a given host.'
def service_get_all_servicemanage_sorted(context): DCNL 'Get all servicemanage services sorted by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get an computeNode or raise if it does not exist.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL 'Set the given properties on an computeNode and update it. DCNL Raises NotFound if computeNode does not exist.'
def monitor_todo_format(physical_line): DCNL 'Check for \'TODO()\'. DCNL monitor HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL N101'
def monitor_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL monitor HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'
def monitor_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL monitor HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL N202'
def monitor_one_import_per_line(logical_line): DCNL 'Check for import format. DCNL monitor HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL BAD: from monitor.rpc.common import RemoteError, LOG DCNL N301'
def monitor_import_module_only(logical_line): DCNL 'Check for import module only. DCNL monitor HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL N302 import only modules DCNL N303 Invalid Import DCNL N304 Relative Import'
def monitor_import_alphabetical(physical_line, line_number, lines): DCNL 'Check for imports in alphabetical order. DCNL monitor HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL N306'
def monitor_docstring_start_space(physical_line): DCNL 'Check for docstring not start with space. DCNL monitor HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL N401'
def monitor_docstring_one_line(physical_line): DCNL 'Check one line docstring end. DCNL monitor HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in a period. DCNL N402'
def monitor_docstring_multiline_end(physical_line): DCNL 'Check multi line docstring end. DCNL monitor HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL N403'
def check_l18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def monitor_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL N701: bad localization call DCNL N702: complex expression instead of string as argument to _() DCNL N703: multiple positional placeholders'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_monitor(): DCNL 'Monkey patch in monitor guidelines. DCNL Look for functions that start with monitor_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.monitor.com/v1.1/123\' DCNL Returns: \'http://www.monitor.com/123\' DCNL Given: \'http://www.monitor.com/v1.1\' DCNL Returns: \'http://www.monitor.com\''
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `monitor.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/monitor/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'monitor.api.ec2.cloud:\'      monitor.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See monitor.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: monitor context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_servicemanage``, DCNL ``servicemanage:attach_servicemanage`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises monitor.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def short_cycle_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@short_cycle_task \', this will be run on every tick DCNL of the periodic publisher. DCNL 2. With arguments, @short_cycle_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic publisher.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from monitor.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _get_host_utilization(context, host, ram_mb, disk_gb): DCNL 'Compute the current utilization of a given host.'
@require_admin_context DCNL def compute_node_create(context, values, session=None): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, auto_adjust): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
def compute_node_get_by_host(context, host): DCNL 'Get all capacity entries for the given host.'
def compute_node_utilization_update(context, host, free_ram_mb_delta=0, free_disk_gb_delta=0, work_delta=0, vm_delta=0): DCNL 'Update a specific ComputeNode entry by a series of deltas. DCNL Do this as a single atomic action and lock the row for the DCNL duration of the operation. Requires that ComputeNode record exist.'
def compute_node_utilization_set(context, host, free_ram_mb=None, free_disk_gb=None, work=None, vms=None): DCNL 'Like compute_node_utilization_update() modify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a delta update).'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_bmc_by_host(context, host): DCNL 'Get all compute services for a given host.'
def service_get_all_servicemanage_sorted(context): DCNL 'Get all servicemanage services sorted by servicemanage count. DCNL :returns: a list of (Service, servicemanage_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get an computeNode or raise if it does not exist.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, auto_adjust=True): DCNL 'Set the given properties on an computeNode and update it. DCNL Raises NotFound if computeNode does not exist.'
def run_command_with_code(cmd, redirect_output=True, check_exit_code=True): DCNL 'Runs a command in an out-of-process shell, returning the DCNL output of that command.  Working directory is ROOT.'
def create_virtualenv(venv=VENV, no_site_packages=True): DCNL 'Creates the virtual environment and installs PIP only into the DCNL virtual environment'
def parse_args(): DCNL 'Parse command-line arguments'
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL 'Block while an action is being performed, periodically printing DCNL progress.'
def _find_monitor(cs, monitor): DCNL 'Get a monitor by ID.'
def _find_monitor_snapshot(cs, snapshot): DCNL 'Get a monitor snapshot by ID.'
def _find_backup(cs, backup): DCNL 'Get a backup by ID.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL 'List all the monitors.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL 'Show details about a monitor.'
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL 'Add a new monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL 'Remove a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL 'Attempt forced removal of a monitor, regardless of its state.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL 'Rename a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL 'Set or Delete metadata on a monitor.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL 'List all the snapshots.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL 'Show details about a snapshot.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL 'Add a new snapshot.'
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL 'Remove a snapshot.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL 'Rename a snapshot.'
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL 'Print a list of available \'monitor types\'.'
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL 'Print a list of current \'monitor types and extra specs\' (Admin Only).'
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL 'Create a new monitor type.'
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL 'Delete a specific monitor type'
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL 'Set or unset extra_spec for a monitor type.'
def do_endpoints(cs, args): DCNL 'Discover endpoints that get returned from the authenticate services'
def do_credentials(cs, args): DCNL 'Show user credentials returned from auth'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL 'List the quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL 'List the default quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL 'Update the quotas for a tenant.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL 'List the quotas for a quota class.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL 'Update the quotas for a quota class.'
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL 'Print a list of absolute limits for a user'
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL 'Print a list of rate limits for a user'
def _find_monitor_type(cs, vtype): DCNL 'Get a monitor type by name or ID.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL 'Upload monitor to image service as image.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL 'Creates a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL 'Show details about a backup.'
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL 'List all the backups.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL 'Remove a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL 'Restore a backup.'
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL 'List all the os-api extensions that are available.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def arg(*args, **kwargs): DCNL 'Decorator for CLI args.'
def env(*vars, **kwargs): DCNL 'returns the first environment variable set DCNL if none are non-empty, defaults to \'\' or keyword arg default'
def add_arg(f, *args, **kwargs): DCNL 'Bind CLI arguments to a shell.py `do_foo` function.'
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL 'Adds hook to bind CLI arguments to ResourceManager calls. DCNL The `do_foo` calls in shell.py will receive CLI args and then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registered here will be called, giving us a chance to add extra DCNL kwargs (taken from the command-line) to what\'s passed to the DCNL ResourceManager.'
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL 'Return extra_kwargs by calling resource manager kwargs hooks.'
def unauthenticated(f): DCNL 'Adds \'unauthenticated\' attribute to decorated function. DCNL Usage: DCNL @unauthenticated DCNL def mymethod(f):'
def isunauthenticated(f): DCNL 'Checks to see if the function is marked as not requiring authentication DCNL with the @unauthenticated decorator. Returns True if decorator is DCNL set to True, False otherwise.'
def service_type(stype): DCNL 'Adds \'service_type\' attribute to decorated function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL def mymethod(f):'
def get_service_type(f): DCNL 'Retrieves service type from function'
def find_resource(manager, name_or_id): DCNL 'Helper for the _find_* methods.'
def safe_issubclass(*args): DCNL 'Like issubclass, but will just return False if not a class.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def slugify(value): DCNL 'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL and converts spaces to hyphens. DCNL From Django\'s "django/template/defaultfilters.py".'
def will_expire_soon(expiry): DCNL 'Determines if expiration is about to occur. DCNL :param expiry: a datetime of the expected expiration DCNL :returns: boolean : true if expiration is within 30 seconds'
def safe_quote(s): DCNL 'URL-encode strings that are not already URL-encoded.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def assert_crypto_availability(f): DCNL 'Ensure Crypto module is available.'
def generate_aes_key(token, secret): DCNL 'Generates and returns a 256 bit AES key, based on sha256 hash.'
def compute_mac(token, serialized_data): DCNL 'Computes and returns the base64 encoded MAC.'
def hash_data(data): DCNL 'Return the base64 encoded SHA1 hash of the data.'
def sign_data(token, data): DCNL 'MAC the data using SHA1.'
def verify_signed_data(token, data): DCNL 'Verify data integrity by ensuring MAC is valid.'
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL 'Encryptes the data with the given secret key.'
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL 'Decrypt the data with the given secret key.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def getid(obj): DCNL 'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when dealing with relationships.'
def from_response(response, body): DCNL 'Return an instance of an ClientException or subclass DCNL based on an requests response. DCNL Usage:: DCNL resp, body = requests.request(...) DCNL if resp.status_code != 200: DCNL raise exception_from_response(resp, rest.text)'
def _poll_for_status(poll_fn, obj_id, action, final_ok_states, poll_period=5, show_progress=True): DCNL 'Block while an action is being performed, periodically printing DCNL progress.'
def _find_monitor(cs, monitor): DCNL 'Get a monitor by ID.'
def _find_monitor_snapshot(cs, snapshot): DCNL 'Get a monitor snapshot by ID.'
def _find_backup(cs, backup): DCNL 'Get a backup by ID.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.service_type('monitor') DCNL def do_list(cs, args): DCNL 'List all the monitors.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor.') DCNL @utils.service_type('monitor') DCNL def do_show(cs, args): DCNL 'Show details about a monitor.'
@utils.arg('size', metavar='<size>', type=int, help='Size DCSP of DCSP monitor DCSP in DCSP GB') DCNL @utils.arg('--snapshot-id', metavar='<snapshot-id>', default=None, help='Create DCSP monitor DCSP from DCSP snapshot DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--snapshot_id', help=argparse.SUPPRESS) DCNL @utils.arg('--source-volid', metavar='<source-volid>', default=None, help='Create DCSP monitor DCSP from DCSP monitor DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--source_volid', help=argparse.SUPPRESS) DCNL @utils.arg('--image-id', metavar='<image-id>', default=None, help='Create DCSP monitor DCSP from DCSP image DCSP id DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--image_id', help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='ServiceManage DCSP name DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='ServiceManage DCSP description DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.arg('--monitor-type', metavar='<monitor-type>', default=None, help='ServiceManage DCSP type DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--monitor_type', help=argparse.SUPPRESS) DCNL @utils.arg('--availability-zone', metavar='<availability-zone>', default=None, help='Availability DCSP zone DCSP for DCSP monitor DCSP (Optional, DCSP Default=None)') DCNL @utils.arg('--availability_zone', help=argparse.SUPPRESS) DCNL @utils.arg('--metadata', type=str, nargs='*', metavar='<key=value>', help='Metadata DCSP key=value DCSP pairs DCSP (Optional, DCSP Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_create(cs, args): DCNL 'Add a new monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_delete(cs, args): DCNL 'Remove a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_force_delete(cs, args): DCNL 'Attempt forced removal of a monitor, regardless of its state.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP rename.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP monitor.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP monitor DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_rename(cs, args): DCNL 'Rename a monitor.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP update DCSP metadata DCSP on.') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='+', default=[], help='Metadata DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_metadata(cs, args): DCNL 'Set or Delete metadata on a monitor.'
@utils.arg('--all-tenants', dest='all_tenants', metavar='<0|1>', nargs='?', type=int, const=1, default=0, help='Display DCSP information DCSP from DCSP all DCSP tenants DCSP (Admin DCSP only).') DCNL @utils.arg('--all_tenants', nargs='?', type=int, const=1, help=argparse.SUPPRESS) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Filter DCSP results DCSP by DCSP display-name') DCNL @utils.arg('--status', metavar='<status>', default=None, help='Filter DCSP results DCSP by DCSP status') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', default=None, help='Filter DCSP results DCSP by DCSP monitor-id') DCNL @utils.service_type('monitor') DCNL def do_snapshot_list(cs, args): DCNL 'List all the snapshots.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_show(cs, args): DCNL 'Show details about a snapshot.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--display-name', metavar='<display-name>', default=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--display_name', help=argparse.SUPPRESS) DCNL @utils.arg('--display-description', metavar='<display-description>', default=None, help='Optional DCSP snapshot DCSP description. DCSP (Default=None)') DCNL @utils.arg('--display_description', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL def do_snapshot_create(cs, args): DCNL 'Add a new snapshot.'
@utils.arg('snapshot_id', metavar='<snapshot-id>', help='ID DCSP of DCSP the DCSP snapshot DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_snapshot_delete(cs, args): DCNL 'Remove a snapshot.'
@utils.arg('snapshot', metavar='<snapshot>', help='ID DCSP of DCSP the DCSP snapshot.') DCNL @utils.arg('display_name', nargs='?', metavar='<display-name>', help='New DCSP display-name DCSP for DCSP the DCSP snapshot.') DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP snapshot DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_snapshot_rename(cs, args): DCNL 'Rename a snapshot.'
@utils.service_type('monitor') DCNL def do_type_list(cs, args): DCNL 'Print a list of available \'monitor types\'.'
@utils.service_type('monitor') DCNL def do_extra_specs_list(cs, args): DCNL 'Print a list of current \'monitor types and extra specs\' (Admin Only).'
@utils.arg('name', metavar='<name>', help='Name DCSP of DCSP the DCSP new DCSP monitor DCSP type') DCNL @utils.service_type('monitor') DCNL def do_type_create(cs, args): DCNL 'Create a new monitor type.'
@utils.arg('id', metavar='<id>', help='Unique DCSP ID DCSP of DCSP the DCSP monitor DCSP type DCSP to DCSP delete') DCNL @utils.service_type('monitor') DCNL def do_type_delete(cs, args): DCNL 'Delete a specific monitor type'
@utils.arg('vtype', metavar='<vtype>', help='Name DCSP or DCSP ID DCSP of DCSP the DCSP monitor DCSP type') DCNL @utils.arg('action', metavar='<action>', choices=['set', 'unset'], help="Actions: DCSP 'set' DCSP or DCSP 'unset'") DCNL @utils.arg('metadata', metavar='<key=value>', nargs='*', default=None, help='Extra_specs DCSP to DCSP set/unset DCSP (only DCSP key DCSP is DCSP necessary DCSP on DCSP unset)') DCNL @utils.service_type('monitor') DCNL def do_type_key(cs, args): DCNL 'Set or unset extra_spec for a monitor type.'
def do_endpoints(cs, args): DCNL 'Discover endpoints that get returned from the authenticate services'
def do_credentials(cs, args): DCNL 'Show user credentials returned from auth'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_show(cs, args): DCNL 'List the quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP list DCSP the DCSP default DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_defaults(cs, args): DCNL 'List the default quotas for a tenant.'
@utils.arg('tenant', metavar='<tenant_id>', help='UUID DCSP of DCSP tenant DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_update(cs, args): DCNL 'Update the quotas for a tenant.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP list DCSP the DCSP quotas DCSP for.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_show(cs, args): DCNL 'List the quotas for a quota class.'
@utils.arg('class_name', metavar='<class>', help='Name DCSP of DCSP quota DCSP class DCSP to DCSP set DCSP the DCSP quotas DCSP for.') DCNL @utils.arg('--monitors', metavar='<monitors>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "monitors" DCSP quota.') DCNL @utils.arg('--snapshots', metavar='<snapshots>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "snapshots" DCSP quota.') DCNL @utils.arg('--gigabytes', metavar='<gigabytes>', type=int, default=None, help='New DCSP value DCSP for DCSP the DCSP "gigabytes" DCSP quota.') DCNL @utils.service_type('monitor') DCNL def do_quota_class_update(cs, args): DCNL 'Update the quotas for a quota class.'
@utils.service_type('monitor') DCNL def do_absolute_limits(cs, args): DCNL 'Print a list of absolute limits for a user'
@utils.service_type('monitor') DCNL def do_rate_limits(cs, args): DCNL 'Print a list of rate limits for a user'
def _find_monitor_type(cs, vtype): DCNL 'Get a monitor type by name or ID.'
@utils.arg('monitor_id', metavar='<monitor-id>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP upload DCSP to DCSP an DCSP image') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP indicate DCSP whether DCSP to DCSP upload DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attached DCSP to DCSP an DCSP instance. DCSP (Default=False)", default=False) DCNL @utils.arg('--container-format', metavar='<container-format>', help='Optional DCSP type DCSP for DCSP container DCSP format DCSP (Default=bare)', default='bare') DCNL @utils.arg('--disk-format', metavar='<disk-format>', help='Optional DCSP type DCSP for DCSP disk DCSP format DCSP (Default=raw)', default='raw') DCNL @utils.arg('image_name', metavar='<image-name>', help='Name DCSP for DCSP created DCSP image') DCNL @utils.service_type('monitor') DCNL def do_upload_to_image(cs, args): DCNL 'Upload monitor to image service as image.'
@utils.arg('monitor', metavar='<monitor>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP backup.') DCNL @utils.arg('--container', metavar='<container>', help='Optional DCSP Backup DCSP container DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-name', metavar='<display-name>', help='Optional DCSP backup DCSP name. DCSP (Default=None)', default=None) DCNL @utils.arg('--display-description', metavar='<display-description>', help='Optional DCSP backup DCSP description. DCSP (Default=None)', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_create(cs, args): DCNL 'Creates a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup.') DCNL @utils.service_type('monitor') DCNL def do_backup_show(cs, args): DCNL 'Show details about a backup.'
@utils.service_type('monitor') DCNL def do_backup_list(cs, args): DCNL 'List all the backups.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP delete.') DCNL @utils.service_type('monitor') DCNL def do_backup_delete(cs, args): DCNL 'Remove a backup.'
@utils.arg('backup', metavar='<backup>', help='ID DCSP of DCSP the DCSP backup DCSP to DCSP restore.') DCNL @utils.arg('--monitor-id', metavar='<monitor-id>', help='Optional DCSP ID DCSP of DCSP the DCSP monitor DCSP to DCSP restore DCSP to.', default=None) DCNL @utils.service_type('monitor') DCNL def do_backup_restore(cs, args): DCNL 'Restore a backup.'
@utils.service_type('monitor') DCNL def do_list_extensions(client, _args): DCNL 'List all the os-api extensions that are available.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def arg(*args, **kwargs): DCNL 'Decorator for CLI args.'
def env(*vars, **kwargs): DCNL 'returns the first environment variable set DCNL if none are non-empty, defaults to \'\' or keyword arg default'
def add_arg(f, *args, **kwargs): DCNL 'Bind CLI arguments to a shell.py `do_foo` function.'
def add_resource_manager_extra_kwargs_hook(f, hook): DCNL 'Adds hook to bind CLI arguments to ResourceManager calls. DCNL The `do_foo` calls in shell.py will receive CLI args and then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registered here will be called, giving us a chance to add extra DCNL kwargs (taken from the command-line) to what\'s passed to the DCNL ResourceManager.'
def get_resource_manager_extra_kwargs(f, args, allow_conflicts=False): DCNL 'Return extra_kwargs by calling resource manager kwargs hooks.'
def unauthenticated(f): DCNL 'Adds \'unauthenticated\' attribute to decorated function. DCNL Usage: DCNL @unauthenticated DCNL def mymethod(f):'
def isunauthenticated(f): DCNL 'Checks to see if the function is marked as not requiring authentication DCNL with the @unauthenticated decorator. Returns True if decorator is DCNL set to True, False otherwise.'
def service_type(stype): DCNL 'Adds \'service_type\' attribute to decorated function. DCNL Usage: DCNL @service_type(\'monitor\') DCNL def mymethod(f):'
def get_service_type(f): DCNL 'Retrieves service type from function'
def find_resource(manager, name_or_id): DCNL 'Helper for the _find_* methods.'
def safe_issubclass(*args): DCNL 'Like issubclass, but will just return False if not a class.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def slugify(value): DCNL 'Normalizes string, converts to lowercase, removes non-alpha characters, DCNL and converts spaces to hyphens. DCNL From Django\'s "django/template/defaultfilters.py".'
def will_expire_soon(expiry): DCNL 'Determines if expiration is about to occur. DCNL :param expiry: a datetime of the expected expiration DCNL :returns: boolean : true if expiration is within 30 seconds'
def safe_quote(s): DCNL 'URL-encode strings that are not already URL-encoded.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def assert_crypto_availability(f): DCNL 'Ensure Crypto module is available.'
def generate_aes_key(token, secret): DCNL 'Generates and returns a 256 bit AES key, based on sha256 hash.'
def compute_mac(token, serialized_data): DCNL 'Computes and returns the base64 encoded MAC.'
def hash_data(data): DCNL 'Return the base64 encoded SHA1 hash of the data.'
def sign_data(token, data): DCNL 'MAC the data using SHA1.'
def verify_signed_data(token, data): DCNL 'Verify data integrity by ensuring MAC is valid.'
@assert_crypto_availability DCNL def encrypt_data(token, secret, data): DCNL 'Encryptes the data with the given secret key.'
@assert_crypto_availability DCNL def decrypt_data(token, secret, data): DCNL 'Decrypt the data with the given secret key.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def getid(obj): DCNL 'Abstracts the common pattern of allowing both an object or an object\'s ID DCNL as a parameter when dealing with relationships.'
def from_response(response, body): DCNL 'Return an instance of an ClientException or subclass DCNL based on an requests response. DCNL Usage:: DCNL resp, body = requests.request(...) DCNL if resp.status_code != 200: DCNL raise exception_from_response(resp, rest.text)'
def to_primitive(value, convert_instances=False, level=0): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def unique_id(token_id): DCNL 'Return a unique ID for a token. DCNL The returned value is useful as the primary key of a database table, DCNL memcache store, or other lookup table. DCNL :returns: Given a PKI token, returns it\'s hashed value. Otherwise, returns DCNL the passed-in value (such as a UUID token ID or an existing DCNL hash).'
def default_expire_time(): DCNL 'Determine when a fresh token should expire. DCNL Expiration time varies based on configuration (see ``[token] expiration``). DCNL :returns: a naive UTC datetime.datetime object'
def validate_auth_info(self, context, user_ref, tenant_ref): DCNL 'Validate user and tenant auth info. DCNL Validate the user and tenant auth into in order to ensure that user and DCNL tenant information is valid and not disabled. DCNL Consolidate the checks here to ensure consistency between token auth and DCNL ec2 auth. DCNL :params context: keystone\'s request context DCNL :params user_ref: the authenticating user DCNL :params tenant_ref: the scope of authorization, if any DCNL :raises Unauthorized: if any of the user, user\'s domain, tenant or DCNL tenant\'s domain are either disabled or otherwise invalid'
def recreate_token_data(context, token_data=None, expires=None, user_ref=None, project_ref=None): DCNL 'Recreate token from an existing token. DCNL Repopulate the ephemeral data and return the new token data.'
def render_token_data_response(token_id, token_data, created=False): DCNL 'Render token data HTTP response. DCNL Stash token ID into the X-Auth-Token header.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def render_response(body=None, status=None, headers=None): DCNL 'Forms a WSGI response.'
def render_exception(error): DCNL 'Forms a WSGI response based on the current error.'
def provider(name): DCNL 'Register the wrapped dependency provider under the specified name.'
def requires(*dependencies): DCNL 'Inject specified dependencies from the registry into the instance.'
def fail_gracefully(f): DCNL 'Logs exceptions and aborts.'
def initialize_decorator(init): DCNL 'Ensure that the length of string field do not exceed the limit. DCNL This decorator check the initialize arguments, to make sure the DCNL length of string field do not exceed the length limit, or raise a DCNL \'StringLengthExceeded\' exception. DCNL Use decorator instead of inheritance, because the metaclass will DCNL check the __tablename__, primary key columns, etc. at the class DCNL definition.'
def handle_conflicts(type='object'): DCNL 'Converts IntegrityError into HTTP 409 Conflict.'
def upgrade(migrate_engine): DCNL 'Replace API-version specific endpoint tables with one based on v3.'
def downgrade(migrate_engine): DCNL 'Create API-version specific endpoint tables.'
def upgrade(migrate_engine): DCNL 'Create API-version specific endpoint tables.'
def downgrade(migrate_engine): DCNL 'Replace API-version specific endpoint tables with one based on v2.'
def upgrade(migrate_engine): DCNL 'Creates the default domain.'
def downgrade(migrate_engine): DCNL 'Delete the default domain.'
def upgrade(migrate_engine): DCNL 'Split each legacy endpoint into separate records for each interface.'
def downgrade(migrate_engine): DCNL 'Re-create the v2 endpoints table based on v3 endpoints.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def _match_query(query, attrs): DCNL 'Match an ldap query to an attribute dictionary. DCNL The characters &, |, and ! are supported in the query. No syntax checking DCNL is performed, so malformed queries will not work correctly.'
def _paren_groups(source): DCNL 'Split a string into parenthesized groups.'
def _match(key, value, attrs): DCNL 'Match a given key and value against an attribute list.'
def _subs(value): DCNL 'Returns a list of subclass strings. DCNL The strings represent the ldap objectclass plus any subclasses that DCNL inherit from it. Fakeldap doesn\'t know about the ldap object structure, DCNL so subclasses need to be defined manually in the dictionary below.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file.'
def trunc_password(password): DCNL 'Truncate passwords to the MAX_PASSWORD_LENGTH.'
def hash_user_password(user): DCNL 'Hash a user dict\'s password without modifying the passed-in dict'
def hash_ldap_user_password(user): DCNL 'Hash a user dict\'s password without modifying the passed-in dict'
def hash_password(password): DCNL 'Hash a password. Hard.'
def ldap_hash_password(password): DCNL 'Hash a password. Hard.'
def check_password(password, hashed): DCNL 'Check that a plaintext password matches hashed. DCNL hashpw returns the salt value concatenated with the actual hash value. DCNL It extracts the actual salt if this value is then passed as the salt.'
def check_output(*popenargs, **kwargs): DCNL 'Run command with arguments and return its output as a byte string. DCNL If the exit code was non-zero it raises a CalledProcessError.  The DCNL CalledProcessError object will have the return code in the returncode DCNL attribute and output in the output attribute. DCNL The arguments are the same as for the Popen constructor.  Example: DCNL >>> check_output([\'ls\', \'-l\', \'/dev/null\']) DCNL \'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n\' DCNL The stdout argument is not allowed as it is used internally. DCNL To capture standard error in the result, use stderr=STDOUT. DCNL >>> check_output([\'/bin/sh\', \'-c\', DCNL ...               \'ls -l non_existent_file ; exit 0\'], DCNL ...              stderr=STDOUT) DCNL \'ls: non_existent_file: No such file or directory\n\''
def unixtime(dt_obj): DCNL 'Format datetime object as unix timestamp DCNL :param dt_obj: datetime.datetime object DCNL :returns: float'
def auth_str_equal(provided, known): DCNL 'Constant-time string comparison. DCNL :params provided: the first string DCNL :params known: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.  When using the function for this purpose, always DCNL provide the user-provided password as the first argument.  The time this DCNL function will take is always a factor of the length of this string.'
def cms_verify(formatted, signing_cert_file_name, ca_file_name): DCNL 'verifies the signature of the contents IAW CMS syntax'
def is_ans1_token(token): DCNL 'thx to ayoung for sorting this out. DCNL base64 decoded hex representation of MII is 3082 DCNL In [3]: binascii.hexlify(base64.b64decode(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf DCNL pg4:  For tags from 0 to 30 the first octet is the identfier DCNL pg10: Hex 30 means sequence, followed by the length of that sequence. DCNL pg5:  Second octet is the length octet DCNL first bit indicates short or long form, next 7 bits encode the number DCNL of subsequent octets that make up the content length octets as an DCNL unsigned binary int DCNL 82 = 10000010 (first bit indicates long form) DCNL 0000010 = 2 octets of content length DCNL so read the next 2 octets to get the length of the content. DCNL In the case of a very large content length there could be a requirement to DCNL have more than 2 octets to designate the content length, therefore DCNL requiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encode(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encode(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI would become invalid at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encode(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 7FFF or 32767 DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only and ignore the case of larger tokens'
def cms_sign_text(text, signing_cert_file_name, signing_key_file_name): DCNL 'Uses OpenSSL to sign a document DCNL Produces a Base64 encoding of a DER formatted CMS Document DCNL http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax'
def cms_hash_token(token_id): DCNL 'return: for ans1_token, returns the hash of the passed in token DCNL otherwise, returns what it was passed in.'
def from_xml(xml): DCNL 'Deserialize XML to a dictionary.'
def to_xml(d, xmlns=None): DCNL 'Serialize a dictionary to XML.'
def flatten(d, parent_key=''): DCNL 'Flatten a nested dictionary DCNL Converts a dictionary with nested values to a single level flat DCNL dictionary, with dotted notation for each key.'
def protected(f): DCNL 'Wraps API calls with role based access controls (RBAC).'
def filterprotected(*filters): DCNL 'Wraps filtered API calls with role based access controls (RBAC).'
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param device: device of the node to query DCNL :param partition: partition on the device DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :param key_file Private key file (not needed if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False, key_file=None, cert_file=None): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :param key_file Private key file (not needed if cert_file has private key) DCNL :param cert_file Certificate file (Keystore) DCNL :returns: HTTPConnection object'
def setup_logging(conf): DCNL 'Sets up the logging options for a log with supplied name DCNL :param conf: a cfg.ConfOpts object'
def format_url(url, data): DCNL 'Helper Method for all Backend Catalog\'s to Deal with URLS'
def filter_user(user_ref): DCNL 'Filter out private items in a user dict. DCNL \'password\', \'tenants\' and \'groups\' are never returned. DCNL :returns: user_ref'
def enforce(credentials, action, target, do_raise=True): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param credentials: user credentials DCNL :param action: string representing the action to be checked, which DCNL should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary DCNL representing the location of the object e.g. DCNL {\'project_id\': object.project_id} DCNL :raises: `exception.Forbidden` if verification fails. DCNL Actions should be colon separated for clarity. For example: DCNL * identity:list_users'
def _build_user_auth(token=None, user_id=None, username=None, password=None, tenant_id=None, tenant_name=None, trust_id=None): DCNL 'Build auth dictionary. DCNL It will create an auth dictionary based on all the arguments DCNL that it receives.'
def retry(func, *args, **kwargs): DCNL 'You can use the kwargs to override the \'retries\' (default: 5) and DCNL \'use_account\' (default: 1).'
def get_config(section_name=None, defaults=None): DCNL 'Attempt to get a test config dictionary. DCNL :param section_name: the section to read (all sections if not defined) DCNL :param defaults: an optional dictionary namespace of defaults'
def sortHeaderNames(headerNames): DCNL 'Return the given string of header names sorted. DCNL headerName: a comma-delimited list of header names'
def teardown_module(): DCNL 'clean up my monkey patching'
def pop_stream(f): DCNL 'read everything out of file from the top and clear it out'
def premetadata_create_container_stat_table(self, conn, put_timestamp=None): DCNL 'Copied from swift.common.db.ContainerBroker before the metadata column was DCNL added; used for testing with TestContainerBrokerBeforeMetadata. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def prexsync_create_container_stat_table(self, conn, put_timestamp=None): DCNL 'Copied from swift.common.db.ContainerBroker before the DCNL x_container_sync_point[12] columns were added; used for testing with DCNL TestContainerBrokerBeforeXSync. DCNL Create the container_stat table which is specifc to the container DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def premetadata_create_account_stat_table(self, conn, put_timestamp): DCNL 'Copied from swift.common.db.AccountBroker before the metadata column was DCNL added; used for testing with TestAccountBrokerBeforeMetadata. DCNL Create account_stat table which is specific to the account DB. DCNL :param conn: DB connection object DCNL :param put_timestamp: put timestamp'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI container server apps'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI proxy apps.'
def update_headers(response, headers): DCNL 'Helper function to update headers in the response. DCNL :param response: swob.Response object DCNL :param headers: dictionary headers'
def source_key(resp): DCNL 'Provide the timestamp of the swift http response as a floating DCNL point value.  Used as a sort key. DCNL :param resp: httplib response object'
def delay_denial(func): DCNL 'Decorator to declare which methods should have any swift.authorize call DCNL delayed. This is so the method can load the Request object up with DCNL additional information that may be needed by the authorization system. DCNL :param func: function for which authorization will be delayed'
def headers_to_account_info(headers, status_int=HTTP_OK): DCNL 'Construct a cacheable dict of account info based on response headers.'
def headers_to_container_info(headers, status_int=HTTP_OK): DCNL 'Construct a cacheable dict of container info based on response headers.'
def cors_validation(func): DCNL 'Decorator to check if the request is a CORS request and if so, if it\'s DCNL valid. DCNL :param func: function to check'
def get_container_info(env, app, swift_source=None): DCNL 'Get the info structure for a container, based on env and app. DCNL This is useful to middlewares. DCNL Note: This call bypasses auth. Success does not imply that the DCNL request has authorization to the container_info.'
def get_account_info(env, app, swift_source=None): DCNL 'Get the info structure for an account, based on env and app. DCNL This is useful to middlewares. DCNL Note: This call bypasses auth. Success does not imply that the DCNL request has authorization to the account_info.'
def copy_headers_into(from_r, to_r): DCNL 'Will copy desired headers from from_r to to_r DCNL :params from_r: a swob Request or Response DCNL :params to_r: a swob Request or Response'
def is_informational(status): DCNL 'Check if HTTP status code is informational. DCNL :param status: http status code DCNL :returns: True if status is successful, else False'
def is_success(status): DCNL 'Check if HTTP status code is successful. DCNL :param status: http status code DCNL :returns: True if status is successful, else False'
def is_redirection(status): DCNL 'Check if HTTP status code is redirection. DCNL :param status: http status code DCNL :returns: True if status is redirection, else False'
def is_client_error(status): DCNL 'Check if HTTP status code is client error. DCNL :param status: http status code DCNL :returns: True if status is client error, else False'
def is_server_error(status): DCNL 'Check if HTTP status code is server error. DCNL :param status: http status code DCNL :returns: True if status is server error, else False'
def check_metadata(req, target_type): DCNL 'Check metadata sent in the request headers. DCNL :param req: request object DCNL :param target_type: str: one of: object, container, or account: indicates DCNL which type the target storage for the metadata is DCNL :returns: HTTPBadRequest with bad metadata otherwise None'
def check_object_creation(req, object_name): DCNL 'Check to ensure that everything is alright about an object to be created. DCNL :param req: HTTP request object DCNL :param object_name: name of object to be created DCNL :returns HTTPRequestEntityTooLarge: the object is too large DCNL :returns HTTPLengthRequired: missing content-length header and not DCNL a chunked request DCNL :returns HTTPBadRequest: missing or bad content-type header, or DCNL bad metadata'
def check_mount(root, drive): DCNL 'Verify that the path to the device is a mount point and mounted.  This DCNL allows us to fast fail on drives that have been unmounted because of DCNL issues, and also prevents us for accidentally filling up the root DCNL partition. DCNL :param root:  base path where the devices are mounted DCNL :param drive: drive name to be checked DCNL :returns: True if it is a valid mounted device, False otherwise'
def check_float(string): DCNL 'Helper function for checking if a string can be converted to a float. DCNL :param string: string to be verified as a float DCNL :returns: True if the string can be converted to a float, False otherwise'
def check_utf8(string): DCNL 'Validate if a string is valid UTF-8 str or unicode and that it DCNL does not contain any null character. DCNL :param string: string to be validated DCNL :returns: True if the string is valid utf-8 str or unicode and DCNL contains no null characters, False otherwise'
def monkey_patch_mimetools(): DCNL 'mimetools.Message defaults content-type to "text/plain" DCNL This changes it to default to None, so we can detect missing headers.'
def get_socket(conf, default_port=8080): DCNL 'Bind socket to bind ip:port in conf DCNL :param conf: Configuration dict to read settings from DCNL :param default_port: port to use if not specified in conf DCNL :returns : a socket object as returned from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'
def run_wsgi(conf_file, app_section, *args, **kwargs): DCNL 'Runs the server using the specified number of workers. DCNL :param conf_file: Path to paste.deploy style configuration file DCNL :param app_section: App name from conf file to load config from'
def init_request_processor(conf_file, app_section, *args, **kwargs): DCNL 'Loads common settings from conf DCNL Sets the logger DCNL Loads the request processor DCNL :param conf_file: Path to paste.deploy style configuration file DCNL :param app_section: App name from conf file to load config from DCNL :returns: the loaded application entry point DCNL :raises ConfigFileError: Exception is raised for config file error'
def make_pre_authed_request(env, method=None, path=None, body=None, headers=None, agent='Swift', swift_source=None): DCNL 'Makes a new swob.Request based on the current env but with the DCNL parameters specified. Note that this request will be preauthorized. DCNL :param env: The WSGI environment to base the new request on. DCNL :param method: HTTP method of new request; default is from DCNL the original env. DCNL :param path: HTTP path of new request; default is from the DCNL original env. path should be compatible with what you DCNL would send to Request.blank. path should be quoted and it DCNL can include a query string. for example: DCNL \'/a%20space?unicode_str%E8%AA%9E=y%20es\' DCNL :param body: HTTP body of new request; empty by default. DCNL :param headers: Extra HTTP headers of new request; None by DCNL default. DCNL :param agent: The HTTP user agent to use; default \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaced DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Used to mark the request as originating out of DCNL middleware. Will be logged in proxy logs. DCNL :returns: Fresh swob.Request object.'
def make_pre_authed_env(env, method=None, path=None, agent='Swift', query_string=None, swift_source=None): DCNL 'Returns a new fresh WSGI environment with escalated privileges to DCNL do backend checks, listings, etc. that the remote user wouldn\'t DCNL be able to accomplish directly. DCNL :param env: The WSGI environment to base the new environment on. DCNL :param method: The new REQUEST_METHOD or None to use the DCNL original. DCNL :param path: The new path_info or none to use the original. path DCNL should NOT be quoted. When building a url, a Webob DCNL Request (in accordance with wsgi spec) will quote DCNL env[\'PATH_INFO\'].  url += quote(environ[\'PATH_INFO\']) DCNL :param query_string: The new query_string or none to use the original. DCNL When building a url, a Webob Request will append DCNL the query string directly to the url. DCNL url += \'?\' + env[\'QUERY_STRING\'] DCNL :param agent: The HTTP user agent to use; default \'Swift\'. You DCNL can put %(orig)s in the agent to have it replaced DCNL with the original env\'s HTTP_USER_AGENT, such as DCNL \'%(orig)s StaticWeb\'. You also set agent to None to DCNL use the original env\'s HTTP_USER_AGENT or \'\' to DCNL have no HTTP_USER_AGENT. DCNL :param swift_source: Used to mark the request as originating out of DCNL middleware. Will be logged in proxy logs. DCNL :returns: Fresh WSGI environment.'
def _func_on_containers(logger, conf, concurrency_key, func): DCNL 'Run a function on each container with concurrency.'
def delete_containers(logger, conf): DCNL 'Utility function to delete benchmark containers.'
def create_containers(logger, conf): DCNL 'Utility function to create benchmark containers.'
def direct_get_account(node, part, account, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL 'Get listings directly from the account server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the account is on DCNL :param account: account name DCNL :param marker: marker query DCNL :param limit: query limit DCNL :param prefix: prefix query DCNL :param delimeter: delimeter for the query DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a tuple of (response headers, a list of containers) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_head_container(node, part, account, container, conn_timeout=5, response_timeout=15): DCNL 'Request container information directly from the container server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a dict containing the response\'s headers (all header names will DCNL be lowercase)'
def direct_get_container(node, part, account, container, marker=None, limit=None, prefix=None, delimiter=None, conn_timeout=5, response_timeout=15): DCNL 'Get container listings directly from the container server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param marker: marker query DCNL :param limit: query limit DCNL :param prefix: prefix query DCNL :param delimeter: delimeter for the query DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a tuple of (response headers, a list of objects) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_head_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15): DCNL 'Request object information directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: a dict containing the response\'s headers (all header names will DCNL be lowercase)'
def direct_get_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, headers={}): DCNL 'Get object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :param resp_chunk_size: if defined, chunk size of data to read. DCNL :param headers: dict to be passed into HTTPConnection headers DCNL :returns: a tuple of (response headers, the object\'s contents) The response DCNL headers will be a dict and all header names will be lowercase.'
def direct_put_object(node, part, account, container, name, contents, content_length=None, etag=None, content_type=None, headers=None, conn_timeout=5, response_timeout=15, resp_chunk_size=None): DCNL 'Put object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param contents: an iterable or string to read object data from DCNL :param content_length: value to send as content-length header DCNL :param etag: etag of contents DCNL :param content_type: value to send as content-type header DCNL :param headers: additional headers to include in the request DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :param chunk_size: if defined, chunk size of data to send. DCNL :returns: etag from the server response'
def direct_post_object(node, part, account, container, name, headers, conn_timeout=5, response_timeout=15): DCNL 'Direct update to object metadata on object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param name: object name DCNL :param headers: headers to store as metadata DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :raises ClientException: HTTP POST request failed'
def direct_delete_object(node, part, account, container, obj, conn_timeout=5, response_timeout=15, headers={}): DCNL 'Delete object directly from the object server. DCNL :param node: node dictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconds for establishing the connection DCNL :param response_timeout: timeout in seconds for getting the response DCNL :returns: response from server'
def retry(func, *args, **kwargs): DCNL 'Helper function to retry a given function a number of times. DCNL :param func: callable to be called DCNL :param retries: number of retries DCNL :param error_log: logger for errors DCNL :param args: arguments to send to func DCNL :param kwargs: keyward arguments to send to func (if retries or DCNL error_log are sent, they will be deleted from kwargs DCNL before sending on to func) DCNL :returns: restult of func'
def backward(f, blocksize=4096): DCNL 'A generator returning lines from a file starting with the last line, DCNL then the second last line, etc. i.e., it reads lines backwards. DCNL Stops when the first line (if any) is read. DCNL This is useful when searching for recent activity in very DCNL large files. DCNL :param f: file object to read DCNL :param blocksize: no of characters to go backwards at each block'
def config_true_value(value): DCNL 'Returns True if the value is either True or a string in TRUE_VALUES. DCNL Returns False otherwise.'
def load_libc_function(func_name, log_error=True): DCNL 'Attempt to find the function in libc, otherwise return a no-op func. DCNL :param func_name: name of the function to pull from libc.'
def get_param(req, name, default=None): DCNL 'Get parameters from an HTTP request ensuring proper handling UTF-8 DCNL encoding. DCNL :param req: request object DCNL :param name: parameter name DCNL :param default: result to return if the parameter is not found DCNL :returns: HTTP request parameter value'
def fallocate(fd, size): DCNL 'Pre-allocate disk space for a file. DCNL :param fd: file descriptor DCNL :param size: size to allocate (in bytes)'
def fsync(fd): DCNL 'Sync modified file data and metadata to disk. DCNL :param fd: file descriptor'
def fdatasync(fd): DCNL 'Sync modified file data to disk. DCNL :param fd: file descriptor'
def drop_buffer_cache(fd, offset, length): DCNL 'Drop \'buffer\' cache for the given range of the given file. DCNL :param fd: file descriptor DCNL :param offset: start offset DCNL :param length: length'
def normalize_timestamp(timestamp): DCNL 'Format a timestamp (string or numeric) into a standardized DCNL xxxxxxxxxx.xxxxx format. DCNL :param timestamp: unix timestamp DCNL :returns: normalized timestamp as a string'
def mkdirs(path): DCNL 'Ensures the path is a directory or makes it if not. Errors if the path DCNL exists but is a file or on permissions failure. DCNL :param path: path to create'
def renamer(old, new): DCNL 'Attempt to fix / hide race conditions like empty object directories DCNL being removed by backend processes during uploads, by retrying. DCNL :param old: old path to be renamed DCNL :param new: new path to be renamed to'
def split_path(path, minsegs=1, maxsegs=None, rest_with_last=False): DCNL 'Validate and split the given HTTP request path. DCNL **Examples**:: DCNL [\'a\'] = split_path(\'/a\') DCNL [\'a\', None] = split_path(\'/a\', 1, 2) DCNL [\'a\', \'c\'] = split_path(\'/a/c\', 1, 2) DCNL [\'a\', \'c\', \'o/r\'] = split_path(\'/a/c/o/r\', 1, 3, True) DCNL :param path: HTTP Request path to be split DCNL :param minsegs: Minimum number of segments to be extracted DCNL :param maxsegs: Maximum number of segments to be extracted DCNL :param rest_with_last: If True, trailing data will be returned as part DCNL of last segment.  If False, and there is DCNL trailing data, raises ValueError. DCNL :returns: list of segments with a length of maxsegs (non-existant DCNL segments will return as None) DCNL :raises: ValueError if given an invalid path'
def validate_device_partition(device, partition): DCNL 'Validate that a device and a partition are valid and won\'t lead to DCNL directory traversal when used. DCNL :param device: device to validate DCNL :param partition: partition to validate DCNL :raises: ValueError if given an invalid device or partition'
def timing_stats(**dec_kwargs): DCNL 'Returns a decorator that logs timing events or errors for public methods in DCNL swift\'s wsgi server controllers, based on response code.'
def get_logger(conf, name=None, log_to_console=False, log_route=None, fmt='%(server)s DCSP %(message)s'): DCNL 'Get the current system logger using config settings. DCNL **Log config and defaults**:: DCNL log_facility = LOG_LOCAL0 DCNL log_level = INFO DCNL log_name = swift DCNL log_udp_host = (disabled) DCNL log_udp_port = logging.handlers.SYSLOG_UDP_PORT DCNL log_address = /dev/log DCNL log_statsd_host = (disabled) DCNL log_statsd_port = 8125 DCNL log_statsd_default_sample_rate = 1.0 DCNL log_statsd_sample_rate_factor = 1.0 DCNL log_statsd_metric_prefix = (empty-string) DCNL :param conf: Configuration dict to read settings from DCNL :param name: Name of the logger DCNL :param log_to_console: Add handler which writes to console on stderr DCNL :param log_route: Route for the logging, not emitted to the log, just used DCNL to separate logging configurations DCNL :param fmt: Override log format'
def get_hub(): DCNL 'Checks whether poll is available and falls back DCNL on select if it isn\'t. DCNL Note about epoll: DCNL Review: https://review.openstack.org/#/c/18806/ DCNL There was a problem where once out of every 30 quadrillion DCNL connections, a coroutine wouldn\'t wake up when the client DCNL closed its end. Epoll was not reporting the event or it was DCNL getting swallowed somewhere. Then when that file descriptor DCNL was re-used, eventlet would freak right out because it still DCNL thought it was waiting for activity from it in some other coro.'
def drop_privileges(user): DCNL 'Sets the userid/groupid of the current process, get session leader, etc. DCNL :param user: User name to change privileges to'
def capture_stdio(logger, **kwargs): DCNL 'Log unhandled exceptions, close stdio, capture stdout and stderr. DCNL param logger: Logger object to use'
def parse_options(parser=None, once=False, test_args=None): DCNL 'Parse standard swift server/daemon options with optparse.OptionParser. DCNL :param parser: OptionParser to use. If not sent one will be created. DCNL :param once: Boolean indicating the "once" option is available DCNL :param test_args: Override sys.argv; used in testing DCNL :returns : Tuple of (config, options); config is an absolute path to the DCNL config file, options is the parser options as a dictionary. DCNL :raises SystemExit: First arg (CONFIG) is required, file must exist'
def whataremyips(): DCNL 'Get the machine\'s ip addresses DCNL :returns: list of Strings of ip addresses'
def storage_directory(datadir, partition, hash): DCNL 'Get the storage directory DCNL :param datadir: Base data directory DCNL :param partition: Partition DCNL :param hash: Account, container or object hash DCNL :returns: Storage directory'
def hash_path(account, container=None, object=None, raw_digest=False): DCNL 'Get the connonical hash for an account/container/object DCNL :param account: Account DCNL :param container: Container DCNL :param object: Object DCNL :param raw_digest: If True, return the raw version rather than a hex digest DCNL :returns: hash string'
@contextmanager DCNL def lock_path(directory, timeout=10): DCNL 'Context manager that acquires a lock on a directory.  This will block until DCNL the lock can be acquired, or the timeout time has expired (whichever occurs DCNL first). DCNL For locking exclusively, file or directory has to be opened in Write mode. DCNL Python doesn\'t allow directories to be opened in Write Mode. So we DCNL workaround by locking a hidden file in the directory. DCNL :param directory: directory to be locked DCNL :param timeout: timeout (in seconds)'
@contextmanager DCNL def lock_file(filename, timeout=10, append=False, unlink=True): DCNL 'Context manager that acquires a lock on a file.  This will block until DCNL the lock can be acquired, or the timeout time has expired (whichever occurs DCNL first). DCNL :param filename: file to be locked DCNL :param timeout: timeout (in seconds) DCNL :param append: True if file should be opened in append mode DCNL :param unlink: True if the file should be unlinked at the end'
def lock_parent_directory(filename, timeout=10): DCNL 'Context manager that acquires a lock on the parent directory of the given DCNL file path.  This will block until the lock can be acquired, or the timeout DCNL time has expired (whichever occurs first). DCNL :param filename: file path of the parent directory to be locked DCNL :param timeout: timeout (in seconds)'
def get_time_units(time_amount): DCNL 'Get a nomralized length of time in the largest unit of time (hours, DCNL minutes, or seconds.) DCNL :param time_amount: length of time in seconds DCNL :returns: A touple of (length of time, unit of time) where unit of time is DCNL one of (\'h\', \'m\', \'s\')'
def compute_eta(start_time, current_value, final_value): DCNL 'Compute an ETA.  Now only if we could also have a progress bar... DCNL :param start_time: Unix timestamp when the operation began DCNL :param current_value: Current value DCNL :param final_value: Final value DCNL :returns: ETA as a tuple of (length of time, unit of time) where unit of DCNL time is one of (\'h\', \'m\', \'s\')'
def iter_devices_partitions(devices_dir, item_type): DCNL 'Iterate over partitions across all devices. DCNL :param devices_dir: Path to devices DCNL :param item_type: One of \'accounts\', \'containers\', or \'objects\' DCNL :returns: Each iteration returns a tuple of (device, partition)'
def unlink_older_than(path, mtime): DCNL 'Remove any file in a given path that that was last modified before mtime. DCNL :param path: path to remove file from DCNL :mtime: timestamp of oldest file to keep'
def item_from_env(env, item_name): DCNL 'Get a value from the wsgi environment DCNL :param env: wsgi environment dict DCNL :param item_name: name of item to get DCNL :returns: the value from the environment'
def cache_from_env(env): DCNL 'Get memcache connection pool from the environment (which had been DCNL previously set by the memcache middleware DCNL :param env: wsgi environment dict DCNL :returns: swift.common.memcached.MemcacheRing from environment'
def readconf(conffile, section_name=None, log_name=None, defaults=None, raw=False): DCNL 'Read config file and return config items as a dict DCNL :param conffile: path to config file, or a file-like object (hasattr DCNL readline) DCNL :param section_name: config section to read (will return all sections if DCNL not defined) DCNL :param log_name: name to be used with logging (will use section_name if DCNL not defined) DCNL :param defaults: dict of default values to pre-populate the config with DCNL :returns: dict of config items'
def write_pickle(obj, dest, tmp=None, pickle_protocol=0): DCNL 'Ensure that a pickle file gets written to disk.  The file DCNL is first written to a tmp location, ensure it is synced to disk, then DCNL perform a move to its final location DCNL :param obj: python object to be pickled DCNL :param dest: path of final destination file DCNL :param tmp: path to tmp to use, defaults to None DCNL :param pickle_protocol: protocol to pickle the obj with, defaults to 0'
def search_tree(root, glob_match, ext): DCNL 'Look in root, for any files/dirs matching glob, recurively traversing DCNL any found directories looking for files ending with ext DCNL :param root: start of search path DCNL :param glob_match: glob to match in root, matching dirs are traversed with DCNL os.walk DCNL :param ext: only files that end in ext will be returned DCNL :returns: list of full paths to matching files, sorted'
def write_file(path, contents): DCNL 'Write contents to file at path DCNL :param path: any path, subdirs will be created as needed DCNL :param contents: data to write to file, will be converted to string'
def remove_file(path): DCNL 'Quiet wrapper for os.unlink, OSErrors are suppressed DCNL :param path: first and only argument passed to os.unlink'
def audit_location_generator(devices, datadir, mount_check=True, logger=None): DCNL 'Given a devices path and a data directory, yield (path, device, DCNL partition) for all files in that directory DCNL :param devices: parent directory of the devices to be audited DCNL :param datadir: a directory located under self.devices. This should be DCNL one of the DATADIR constants defined in the account, DCNL container, and object servers. DCNL :param mount_check: Flag to check if a mount check should be performed DCNL on devices DCNL :param logger: a logger object'
def ratelimit_sleep(running_time, max_rate, incr_by=1, rate_buffer=5): DCNL 'Will eventlet.sleep() for the appropriate time so that the max_rate DCNL is never exceeded.  If max_rate is 0, will not ratelimit.  The DCNL maximum recommended rate should not exceed (1000 * incr_by) a second DCNL as eventlet.sleep() does involve some overhead.  Returns running_time DCNL that should be used for subsequent calls. DCNL :param running_time: the running time of the next allowable request. Best DCNL to start at zero. DCNL :param max_rate: The maximum rate per second allowed for the process. DCNL :param incr_by: How much to increment the counter.  Useful if you want DCNL to ratelimit 1024 bytes/sec and have differing sizes DCNL of requests. Must be >= 0. DCNL :param rate_buffer: Number of seconds the rate counter can drop and be DCNL allowed to catch up (at a faster than listed rate). DCNL A larger number will result in larger spikes in rate DCNL but better average accuracy.'
def urlparse(url): DCNL 'urlparse augmentation. DCNL This is necessary because urlparse can\'t handle RFC 2732 URLs. DCNL :param url: URL to parse.'
def human_readable(value): DCNL 'Returns the number in a human readable format; for example 1048576 = "1Mi".'
def dump_recon_cache(cache_dict, cache_file, logger, lock_timeout=2): DCNL 'Update recon cache values DCNL :param cache_dict: Dictionary of cache key/value pairs to write out DCNL :param cache_file: cache file to update DCNL :param logger: the logger to use to log an encountered error DCNL :param lock_timeout: timeout (in seconds)'
def streq_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def public(func): DCNL 'Decorator to declare which methods are publicly accessible as HTTP DCNL requests DCNL :param func: function to make public'
def rsync_ip(ip): DCNL 'Transform ip string to an rsync-compatible form DCNL Will return ipv4 addresses unchanged, but will nest ipv6 addresses DCNL inside square brackets. DCNL :param ip: an ip string (ipv4 or ipv6) DCNL :returns: a string ip address'
def get_valid_utf8_str(str_or_unicode): DCNL 'Get valid parts of utf-8 str from str, unicode and even invalid utf-8 str DCNL :param str_or_unicode: a string or an unicode which can be invalid utf-8'
def list_from_csv(comma_separated_str): DCNL 'Splits the str given and returns a properly stripped list of the comma DCNL separated values.'
def csv_append(csv_string, item): DCNL 'Appends an item to a comma-separated string. DCNL If the comma-separated string is empty/None, just returns item.'
def reiterate(iterable): DCNL 'Consume the first item from an iterator, then re-chain it to the rest of DCNL the iterator.  This is useful when you want to make sure the prologue to DCNL downstream generators have been executed before continuing. DCNL :param iterable: an iterable object'
def lookup_cname(domain): DCNL 'Given a domain, returns its DNS CNAME mapping and DNS ttl. DCNL :param domain: domain to query on DCNL :returns: (ttl, result)'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a WSGI filter app for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns the WSGI filter for use with paste.deploy.'
def filter_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI proxy apps.'
def quote(value, safe='/'): DCNL 'Patched version of urllib.quote that encodes utf-8 strings before quoting'
def filter_factory(global_conf, **local_conf): DCNL 'Returns a Static Web WSGI filter for use with paste.deploy.'
def parse_input(raw_data): DCNL 'Given a request will parse the body and return a list of dictionaries DCNL :raises: HTTPException on parse errors DCNL :returns: a list of dictionaries on success'
def _parse_attrs(header): DCNL 'Given the value of a header like: DCNL Content-Disposition: form-data; name="somefile"; filename="test.html" DCNL Return data like DCNL ("form-data", {"name": "somefile", "filename": "test.html"}) DCNL :param header: Value of a header (the part after the \': \'). DCNL :returns: (value name, dict) of the attribute data parsed (see above).'
def _iter_requests(wsgi_input, boundary): DCNL 'Given a multi-part mime encoded input file object and boundary, DCNL yield file-like objects for each part. DCNL :param wsgi_input: The file-like object to read from. DCNL :param boundary: The mime boundary to separate new file-like DCNL objects on. DCNL :returns: A generator of file-like objects for each part.'
def filter_factory(global_conf, **local_conf): DCNL 'Returns the WSGI filter for use with paste.deploy.'
def clean_acl(name, value): DCNL 'Returns a cleaned ACL header value, validating that it meets the formatting DCNL requirements for standard Swift ACL strings. DCNL The ACL format is:: DCNL [item[,item...]] DCNL Each item can be a group name to give access to or a referrer designation DCNL to grant or deny based on the HTTP Referer header. DCNL The referrer designation format is:: DCNL .r:[-]value DCNL The ``.r`` can also be ``.ref``, ``.referer``, or ``.referrer``; though it DCNL will be shortened to just ``.r`` for decreased character count usage. DCNL The value can be ``*`` to specify any referrer host is allowed access, a DCNL specific host name like ``www.example.com``, or if it has a leading period DCNL ``.`` or leading ``*.`` it is a domain name specification, like DCNL ``.example.com`` or ``*.example.com``. The leading minus sign ``-`` DCNL indicates referrer hosts that should be denied access. DCNL Referrer access is applied in the order they are specified. For example, DCNL .r:.example.com,.r:-thief.example.com would allow all hosts ending with DCNL .example.com except for the specific host thief.example.com. DCNL Example valid ACLs:: DCNL .r:* DCNL .r:*,.r:-.thief.com DCNL .r:*,.r:.example.com,.r:-thief.example.com DCNL .r:*,.r:-.thief.com,bobs_account,sues_account:sue DCNL bobs_account,sues_account:sue DCNL Example invalid ACLs:: DCNL .r: DCNL .r:- DCNL By default, allowing read access via .r will not allow listing objects in DCNL the container -- just retrieving objects from the container. To turn on DCNL listings, use the .rlistings directive. DCNL Also, .r designations aren\'t allowed in headers whose names include the DCNL word \'write\'. DCNL ACLs that are "messy" will be cleaned up. Examples: DCNL Original                Cleaned DCNL ``bob, sue``            ``bob,sue`` DCNL ``bob , sue``           ``bob,sue`` DCNL ``bob,,,sue``           ``bob,sue`` DCNL ``.referrer : *``       ``.r:*`` DCNL ``.ref:*.example.com``  ``.r:.example.com`` DCNL ``.r:*, .rlistings``    ``.r:*,.rlistings`` DCNL :param name: The name of the header being cleaned, such as X-Container-Read DCNL or X-Container-Write. DCNL :param value: The value of the header being cleaned. DCNL :returns: The value, cleaned of extraneous formatting. DCNL :raises ValueError: If the value does not meet the ACL formatting DCNL requirements; the error message will indicate why.'
def parse_acl(acl_string): DCNL 'Parses a standard Swift ACL string into a referrers list and groups list. DCNL See :func:`clean_acl` for documentation of the standard Swift ACL format. DCNL :param acl_string: The standard Swift ACL string to parse. DCNL :returns: A tuple of (referrers, groups) where referrers is a list of DCNL referrer designations (without the leading .r:) and groups is a DCNL list of groups to allow access.'
def referrer_allowed(referrer, referrer_acl): DCNL 'Returns True if the referrer should be allowed based on the referrer_acl DCNL list (as returned by :func:`parse_acl`). DCNL See :func:`clean_acl` for documentation of the standard Swift ACL format. DCNL :param referrer: The value of the HTTP Referer header. DCNL :param referrer_acl: The list of referrer designations as returned by DCNL :func:`parse_acl`. DCNL :returns: True if the referrer should be allowed; False if not.'
def get_response_body(data_format, data_dict, error_list): DCNL 'Returns a properly formatted response body according to format. DCNL :params data_format: resulting format DCNL :params data_dict: generated data about results. DCNL :params error_list: list of quoted filenames that failed'
def setup_env(): DCNL 'Try to increase resource limits of the OS. Move PYTHON_EGG_CACHE to /tmp'
def command(func): DCNL 'Decorator to declare which methods are accessible as commands, commands DCNL always return 1 or 0, where 0 should indicate success. DCNL :param func: function to make public'
def watch_server_pids(server_pids, interval=1, **kwargs): DCNL 'Monitor a collection of server pids yielding back those pids that DCNL aren\'t responding to signals. DCNL :param server_pids: a dict, lists of pids [int,...] keyed on DCNL Server objects'
def _datetime_property(header): DCNL 'Set and retrieve the datetime value of self.headers[header] DCNL (Used by both request and response) DCNL The header is parsed on retrieval and a datetime object is returned. DCNL The header can be set using a datetime, numeric value, or str. DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _header_property(header): DCNL 'Set and retrieve the value of self.headers[header] DCNL (Used by both request and response) DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _header_int_property(header): DCNL 'Set and retrieve the value of self.headers[header] DCNL (Used by both request and response) DCNL On retrieval, it converts values to integers. DCNL If a value of None is given, the header is deleted. DCNL :param header: name of the header, e.g. "Content-Length"'
def _resp_status_property(): DCNL 'Set and retrieve the value of Response.status DCNL On retrieval, it concatenates status_int and title. DCNL When set to a str, it splits status_int and title apart. DCNL When set to an integer, retrieves the correct title for that DCNL response code from the RESPONSE_REASONS dict.'
def _resp_body_property(): DCNL 'Set and retrieve the value of Response.body DCNL If necessary, it will consume Response.app_iter to create a body. DCNL On assignment, encodes unicode values to utf-8, and sets the content-length DCNL to the length of the str.'
def _resp_etag_property(): DCNL 'Set and retrieve Response.etag DCNL This may be broken for etag use cases other than Swift\'s. DCNL Quotes strings when assigned and unquotes when read, for compatibility DCNL with webob.'
def _resp_content_type_property(): DCNL 'Set and retrieve Response.content_type DCNL Strips off any charset when retrieved -- that is accessible DCNL via Response.charset.'
def _resp_charset_property(): DCNL 'Set and retrieve Response.charset DCNL On retrieval, separates the charset from the content-type. DCNL On assignment, removes any existing charset from the content-type and DCNL appends the new one.'
def _resp_app_iter_property(): DCNL 'Set and retrieve Response.app_iter DCNL Mostly a pass-through to Response._app_iter; it\'s a property so it can zero DCNL out an existing content-length on assignment.'
def _req_fancy_property(cls, header, even_if_nonexistent=False): DCNL 'Set and retrieve "fancy" properties. DCNL On retrieval, these properties return a class that takes the value of the DCNL header as the only argument to their constructor. DCNL For assignment, those classes should implement a __str__ that converts them DCNL back to their header values. DCNL :param header: name of the header, e.g. "Accept" DCNL :param even_if_nonexistent: Return a value even if the header does not DCNL exist.  Classes using this should be prepared to accept None as a DCNL parameter.'
def _req_environ_property(environ_field): DCNL 'Set and retrieve value of the environ_field entry in self.environ. DCNL (Used by both request and response)'
def _req_body_property(): DCNL 'Set and retrieve the Request.body parameter.  It consumes wsgi.input and DCNL returns the results.  On assignment, uses a StringIO to create a new DCNL wsgi.input.'
def _host_url_property(): DCNL 'Retrieves the best guess that can be made for an absolute location up to DCNL the path, for example: https://host.com:1234'
def wsgify(func): DCNL 'A decorator for translating functions which take a swob Request object and DCNL return a Response object into WSGI callables.  Also catches any raised DCNL HTTPExceptions and treats them as a returned Response.'
def tiers_for_dev(dev): DCNL 'Returns a tuple of tiers for a given device in ascending order by DCNL length. DCNL :returns: tuple of tiers'
def build_tier_tree(devices): DCNL 'Construct the tier tree from the zone layout. DCNL The tier tree is a dictionary that maps tiers to their child tiers. DCNL A synthetic root node of () is generated so that there\'s one tree, DCNL not a forest. DCNL Example: DCNL region 1 -+---- zone 1 -+---- 192.168.101.1:6000 -+---- device id 0 DCNL |             |                         +---- device id 1 DCNL |             |                         +---- device id 2 DCNL |             +---- 192.168.101.2:6000 -+---- device id 3 DCNL |                                       +---- device id 4 DCNL |                                       +---- device id 5 DCNL +---- zone 2 -+---- 192.168.102.1:6000 -+---- device id 6 DCNL |                         +---- device id 7 DCNL |                         +---- device id 8 DCNL +---- 192.168.102.2:6000 -+---- device id 9 DCNL +---- device id 10 DCNL region 2 -+---- zone 1 -+---- 192.168.201.1:6000 -+---- device id 12 DCNL |                         +---- device id 13 DCNL |                         +---- device id 14 DCNL +---- 192.168.201.2:6000 -+---- device id 15 DCNL +---- device id 16 DCNL +---- device id 17 DCNL The tier tree would look like: DCNL (): [(1,), (2,)], DCNL (1,): [(1, 1), (1, 2)], DCNL (2,): [(2, 1)], DCNL (1, 1): [(1, 1, 192.168.101.1:6000), DCNL (1, 1, 192.168.101.2:6000)], DCNL (1, 2): [(1, 2, 192.168.102.1:6000), DCNL (1, 2, 192.168.102.2:6000)], DCNL (2, 1): [(2, 1, 192.168.201.1:6000), DCNL (2, 1, 192.168.201.2:6000)], DCNL (1, 1, 192.168.101.1:6000): [(1, 1, 192.168.101.1:6000, 0), DCNL (1, 1, 192.168.101.1:6000, 1), DCNL (1, 1, 192.168.101.1:6000, 2)], DCNL (1, 1, 192.168.101.2:6000): [(1, 1, 192.168.101.2:6000, 3), DCNL (1, 1, 192.168.101.2:6000, 4), DCNL (1, 1, 192.168.101.2:6000, 5)], DCNL (1, 2, 192.168.102.1:6000): [(1, 2, 192.168.102.1:6000, 6), DCNL (1, 2, 192.168.102.1:6000, 7), DCNL (1, 2, 192.168.102.1:6000, 8)], DCNL (1, 2, 192.168.102.2:6000): [(1, 2, 192.168.102.2:6000, 9), DCNL (1, 2, 192.168.102.2:6000, 10)], DCNL (2, 1, 192.168.201.1:6000): [(2, 1, 192.168.201.1:6000, 12), DCNL (2, 1, 192.168.201.1:6000, 13), DCNL (2, 1, 192.168.201.1:6000, 14)], DCNL (2, 1, 192.168.201.2:6000): [(2, 1, 192.168.201.2:6000, 15), DCNL (2, 1, 192.168.201.2:6000, 16), DCNL (2, 1, 192.168.201.2:6000, 17)], DCNL :devices: device dicts from which to generate the tree DCNL :returns: tier tree'
def sanitize_timeout(timeout): DCNL 'Sanitize a timeout value to use an absolute expiration time if the delta DCNL is greater than 30 days (in seconds). Note that the memcached server DCNL translates negative values to mean a delta of 30 days in seconds (and 1 DCNL additional second), client beware.'
def quarantine_db(object_file, server_type): DCNL 'In the case that a corrupt file is found, move it to a quarantined area to DCNL allow replication to fix it. DCNL :param object_file: path to corrupt file DCNL :param server_type: type of file that is corrupt DCNL (\'container\' or \'account\')'
def roundrobin_datadirs(datadirs): DCNL 'Generator to walk the data dirs in a round robin manner, evenly DCNL hitting each device on the system, and yielding any .db files DCNL found (in their proper places). The partitions within each data DCNL dir are walked randomly, however. DCNL :param datadirs: a list of (path, node_id) to walk DCNL :returns: A generator of (partition, path_to_db_file, node_id)'
def http_connect(ipaddr, port, device, partition, method, path, headers=None, query_string=None, ssl=False): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param device: device of the node to query DCNL :param partition: partition on the device DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :returns: HTTPConnection object'
def http_connect_raw(ipaddr, port, method, path, headers=None, query_string=None, ssl=False): DCNL 'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be used. However, if ssl=False, BufferedHTTPConnection DCNL will be used, which is buffered for backend Swift services. DCNL :param ipaddr: IPv4 address to connect to DCNL :param port: port to connect to DCNL :param method: HTTP method to request (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: request path DCNL :param headers: dictionary of headers DCNL :param query_string: request query string DCNL :param ssl: set True if SSL should be used (default: False) DCNL :returns: HTTPConnection object'
def run_daemon(klass, conf_file, section_name='', once=False, **kwargs): DCNL 'Loads settings from conf, then instantiates daemon "klass" and runs the DCNL daemon with the specified once kwarg.  The section_name will be derived DCNL from the daemon "klass" if not provided (e.g. ObjectReplicator => DCNL object-replicator). DCNL :param klass: Class to instantiate, subclass of common.daemon.Daemon DCNL :param conf_file: Path to configuration file DCNL :param section_name: Section name from conf file to load config from DCNL :param once: Passed to daemon run method'
def dict_factory(crs, row): DCNL 'This should only be used when you need a real dict, DCNL i.e. when you\'re going to serialize the results.'
def chexor(old, name, timestamp): DCNL 'Each entry in the account and container databases is XORed by the 128-bit DCNL hash on insert or delete.  This serves as a rolling, order-independent hash DCNL of the contents. (check + XOR) DCNL :param old: hex representation of the current DB hash DCNL :param name: name of the object or container being inserted DCNL :param timestamp: timestamp of the new record DCNL :returns: a hex representation of the new hash value'
def get_db_connection(path, timeout=30, okay_to_create=False): DCNL 'Returns a properly configured SQLite database connection. DCNL :param path: path to DB DCNL :param timeout: timeout for connection DCNL :param okay_to_create: if True, create the DB if it doesn\'t exist DCNL :returns: DB connection object'
def read_metadata(fd): DCNL 'Helper function to read the pickled metadata from an object file. DCNL :param fd: file descriptor to load the metadata from DCNL :returns: dictionary of metadata'
def write_metadata(fd, metadata): DCNL 'Helper function to write pickled metadata for an object file. DCNL :param fd: file descriptor to write the metadata DCNL :param metadata: metadata to write'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI object server apps'
def quarantine_renamer(device_path, corrupted_file_path): DCNL 'In the case that a file is corrupted, move it to a quarantined DCNL area to allow replication to fix it. DCNL :params device_path: The path to the device the corrupted file is on. DCNL :params corrupted_file_path: The path to the file you want quarantined. DCNL :returns: path (str) of directory the file was moved to DCNL :raises OSError: re-raises non errno.EEXIST / errno.ENOTEMPTY DCNL exceptions from rename'
def hash_suffix(path, reclaim_age): DCNL 'Performs reclamation and returns an md5 of all (remaining) files. DCNL :param reclaim_age: age in seconds at which to remove tombstones DCNL :raises PathNotDir: if given path is not a valid directory DCNL :raises OSError: for non-ENOTDIR errors'
def invalidate_hash(suffix_dir): DCNL 'Invalidates the hash for a suffix_dir in the partition\'s hashes file. DCNL :param suffix_dir: absolute path to suffix dir whose hash needs DCNL invalidating'
def get_hashes(partition_dir, recalculate=[], do_listdir=False, reclaim_age=ONE_WEEK): DCNL 'Get a list of hashes for the suffix dir.  do_listdir causes it to mistrust DCNL the hash cache for suffix existence at the (unexpectedly high) cost of a DCNL listdir.  reclaim_age is just passed on to hash_suffix. DCNL :param partition_dir: absolute path of partition to get hashes for DCNL :param recalculate: list of suffixes which should be recalculated when got DCNL :param do_listdir: force existence check for all hashes in the partition DCNL :param reclaim_age: age at which to remove tombstones DCNL :returns: tuple of (number of suffix dirs hashed, dictionary of hashes)'
def tpool_reraise(func, *args, **kwargs): DCNL 'Hack to work around Eventlet\'s tpool not catching and reraising Timeouts.'
def app_factory(global_conf, **local_conf): DCNL 'paste.deploy app factory for creating WSGI account server apps'
def is_localized(node): DCNL 'Check message wrapped by _()'
def is_log_callfunc(n): DCNL 'LOG.xxx(\'hello %s\' % xyz) and LOG(\'hello\')'
def is_log_i18n_msg_with_mod(n): DCNL 'LOG.xxx("Hello %s" % xyz) should be LOG.xxx("Hello %s", xyz)'
def is_wrong_i18n_format(n): DCNL 'Check _(\'hello %s\' % xyz)'
def Resource(controller, faults=None, deserializers=None, serializers=None): DCNL 'Represents an API entity resource and the associated serialization and DCNL deserialization logic'
def _verify_dict_keys(expected_keys, target_dict, strict=True): DCNL 'Allows to verify keys in a dictionary. DCNL :param expected_keys: A list of keys expected to be present. DCNL :param target_dict: The dictionary which should be verified. DCNL :param strict: Specifies whether additional keys are allowed to be present. DCNL :return: True, if keys in the dictionary correspond to the specification.'
def _validate_ip_pools(data, valid_values=None): DCNL 'Validate that start and end IP addresses are present DCNL In addition to this the IP addresses will also be validated'
def convert_kvp_str_to_list(data): DCNL 'Convert a value of the form \'key=value\' to [\'key\', \'value\']. DCNL :raises: q_exc.InvalidInput if any of the strings are malformed DCNL (e.g. do not contain a key).'
def convert_kvp_list_to_dict(kvp_list): DCNL 'Convert a list of \'key=value\' strings to a dict. DCNL :raises: q_exc.InvalidInput if any of the strings are malformed DCNL (e.g. do not contain a key) or if any DCNL of the keys appear more than once.'
def get_filters(request, attr_info, skips=[]): DCNL 'Extracts the filters from the request string DCNL Returns a dict of lists for the filters: DCNL check=a&check=b&name=Bob& DCNL becomes: DCNL {\'check\': [u\'a\', u\'b\'], \'name\': [u\'Bob\']}'
def get_limit_and_marker(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If limit == 0, it means we needn\'t DCNL pagination, then return None.'
def _get_limit_param(request, max_limit): DCNL 'Extract integer limit from request or fail.'
def list_args(request, arg): DCNL 'Extracts the list of arg from request'
def get_sorts(request, attr_info): DCNL 'Extract sort_key and sort_dir from request, return as: DCNL [(key1, value1), (key2, value2)]'
def plugin_aware_extension_middleware_factory(global_config, **local_config): DCNL 'Paste factory.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the command exits without returning this value DCNL as a returncode DCNL :type check_exit_code:  int DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix all cmd\'s with DCNL :type root_helper:      string DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def _thread_done(gt, *args, **kwargs): DCNL 'Callback function to be passed to GreenThread.link() when we spawn() DCNL Calls the :class:`ThreadGroup` to notify if.'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic scheduler. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic scheduler.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def run_server(application, port): DCNL 'Run a WSGI server with the given application.'
def create_consumers(dispatcher, prefix, topic_details): DCNL 'Create agent RPC consumers. DCNL :param dispatcher: The dispatcher to process the incoming messages. DCNL :param prefix: Common prefix for the plugin/agent message queues. DCNL :param topic_details: A list of topics. Each topic has a name and a DCNL operation. DCNL :returns: A common Connection.'
def replace_file(file_name, data): DCNL 'Replaces the contents of file_name with data in a safe manner. DCNL First write to a temp file and then rename. Since POSIX renames are DCNL atomic, the file is unlikely to be corrupted by competing writes. DCNL We create the tempfile on the same device to ensure that it can be renamed.'
def setup_conf(): DCNL 'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that do not apply during clean-up.'
def collect_quantum_ports(bridges, root_helper): DCNL 'Collect ports created by Quantum from OVS'
def delete_quantum_ports(ports, root_helper): DCNL 'Delete non-internal ports created by Quantum DCNL Non-internal OVS ports need to be removed manually.'
def main(): DCNL 'Main method for cleaning up OVS bridges. DCNL The utility cleans up the integration bridges used by Quantum.'
def setup_conf(): DCNL 'Setup the cfg for the clean up utility. DCNL Use separate setup_conf for the utility because there are many options DCNL from the main config that do not apply during clean-up.'
def kill_dhcp(conf, namespace): DCNL 'Disable DHCP for a network if DHCP is still active.'
def eligible_for_deletion(conf, namespace, force=False): DCNL 'Determine whether a namespace is eligible for deletion. DCNL Eligibility is determined by having only the lo device or if force DCNL is passed as a parameter.'
def destroy_namespace(conf, namespace, force=False): DCNL 'Destroy a given namespace. DCNL If force is True, then dhcp (if it exists) will be disabled and all DCNL devices will be forcibly removed.'
def main(): DCNL 'Main method for cleaning up network namespaces. DCNL This method will make two passes checking for namespaces to delete. The DCNL process will identify candidates, sleep, and call garbage collect. The DCNL garbage collection will re-verify that the namespace meets the criteria for DCNL deletion (ie it is empty). The period of sleep and the 2nd pass allow DCNL time for the namespace state to settle, so that the check prior deletion DCNL will re-confirm the namespace is empty. DCNL The utility is designed to clean-up after the forced or unexpected DCNL termination of Quantum agents. DCNL The --force flag should only be used as part of the cleanup of a devstack DCNL installation as it will blindly purge namespaces and their devices. This DCNL option also kills any lingering DHCP instances.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filter_list, userargs): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter, or None is none matched.'
def get_resource_and_action(action): DCNL 'Extract resource and action (write, read) from api operation'
def _is_attribute_explicitly_set(attribute_name, resource, target): DCNL 'Verify that an attribute is present and has a non-default value'
def _build_target(action, original_target, plugin, context): DCNL 'Augment dictionary of target attributes for policy engine. DCNL This routine adds to the dictionary attributes belonging to the DCNL "parent" resource of the targeted one.'
def _build_match_rule(action, target): DCNL 'Create the rule to match for a given action. DCNL The policy rule to be matched is built in the following way: DCNL 1) add entries for matching permission on objects DCNL 2) add an entry for the specific action (e.g.: create_network) DCNL 3) add an entry for attributes of a resource for which the action DCNL is being executed (e.g.: create_network:shared)'
def check(context, action, target, plugin=None): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: quantum context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param plugin: quantum plugin used to retrieve information required DCNL for augmenting the target DCNL :return: Returns True if access is permitted else False.'
def enforce(context, action, target, plugin=None): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: quantum context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param plugin: quantum plugin used to retrieve information required DCNL for augmenting the target DCNL :raises quantum.exceptions.PolicyNotAllowed: if verification fails.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def find_config_file(options, config_file): DCNL 'Return the first config file found. DCNL We search for the paste config file in the following order: DCNL * If --config-file option is used, use that DCNL * Search for the configuration files via common cfg directories DCNL :retval Full path to config file, or None if no config file found'
def parse_mappings(mapping_list, unique_values=True): DCNL 'Parse a list of of mapping strings into a dictionary. DCNL :param mapping_list: a list of strings of the form \'<key>:<value>\' DCNL :param unique_values: values must be unique if True DCNL :returns: a dict mapping keys to values'
def compare_elements(a, b): DCNL 'compare elements if a and b have same elements DCNL This method doesn\'t consider ordering'
def get_topic_name(prefix, table, operation): DCNL 'Create a topic name. DCNL The topic name needs to be synced between the agent and the DCNL plugin. The plugin will send a fanout message to all of the DCNL listening agents so that the agents in turn can perform their DCNL updates accordingly. DCNL :param prefix: Common prefix for the plugin/agent message queues. DCNL :param table: The table in question (NETWORK, SUBNET, PORT). DCNL :param operation: The operation that invokes notification (CREATE, DCNL DELETE, UPDATE) DCNL :returns: The topic name.'
def setup_logging(conf): DCNL 'Sets up the logging options for a log with supplied name DCNL :param conf: a cfg.ConfOpts object'
def load_paste_app(app_name): DCNL 'Builds and returns a WSGI app from a paste config file. DCNL :param app_name: Name of the application to load DCNL :raises RuntimeError when config file cannot be located or application DCNL cannot be loaded from config file'
def create_agent_config_map(config): DCNL 'Create a map of agent config parameters. DCNL :param config: an instance of cfg.CONF DCNL :returns: a map of agent configuration parameters'
def sync_vlan_allocations(network_vlan_ranges): DCNL 'Synchronize vlan_allocations table with configured VLAN ranges'
def sync_tunnel_allocations(tunnel_id_ranges): DCNL 'Synchronize tunnel_allocations table with configured tunnel ranges'
def get_port_from_device(port_id): DCNL 'Get port from database'
def get16ByteUUID(uuid): DCNL 'Return a 16 byte has of the UUID, used when smaller unique DCNL ID is required.'
def make_net_dict(net_id, net_name, ports): DCNL 'Helper funciton'
def make_port_dict(port_id, port_state, net_id, attachment): DCNL 'Helper funciton'
def get_all_nexusport_bindings(): DCNL 'Lists all the nexusport bindings'
def get_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Lists a nexusport binding'
def get_nexusvlan_binding(vlan_id, switch_ip): DCNL 'Lists a vlan and switch binding'
def add_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Adds a nexusport binding'
def remove_nexusport_binding(port_id, vlan_id, switch_ip, instance_id): DCNL 'Removes a nexusport binding'
def update_nexusport_binding(port_id, new_vlan_id): DCNL 'Updates nexusport binding'
def get_nexusvm_binding(vlan_id, instance_id): DCNL 'Lists nexusvm bindings'
def get_port_vlan_switch_binding(port_id, vlan_id, switch_ip): DCNL 'Lists nexusvm bindings'
def create_vlanids(): DCNL 'Prepopulates the vlan_bindings table'
def get_all_vlanids(): DCNL 'Gets all the vlanids'
def is_vlanid_used(vlan_id): DCNL 'Checks if a vlanid is in use'
def release_vlanid(vlan_id): DCNL 'Sets the vlanid state to be unused'
def delete_vlanid(vlan_id): DCNL 'Deletes a vlanid entry from db'
def reserve_vlanid(): DCNL 'Reserves the first unused vlanid'
def get_all_vlanids_used(): DCNL 'Gets all the vlanids used'
def get_all_vlan_bindings(): DCNL 'Lists all the vlan to network associations'
def get_vlan_binding(netid): DCNL 'Lists the vlan given a network_id'
def add_vlan_binding(vlanid, vlanname, netid): DCNL 'Adds a vlan to network association'
def remove_vlan_binding(netid): DCNL 'Removes a vlan to network association'
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL 'Updates a vlan to network association'
def get_all_qoss(tenant_id): DCNL 'Lists all the qos to tenant associations'
def get_qos(tenant_id, qos_id): DCNL 'Lists the qos given a tenant_id and qos_id'
def add_qos(tenant_id, qos_name, qos_desc): DCNL 'Adds a qos to tenant association'
def remove_qos(tenant_id, qos_id): DCNL 'Removes a qos to tenant association'
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL 'Updates a qos to tenant association'
def get_all_credentials(tenant_id): DCNL 'Lists all the creds for a tenant'
def get_credential(tenant_id, credential_id): DCNL 'Lists the creds for given a cred_id and tenant_id'
def get_credential_name(tenant_id, credential_name): DCNL 'Lists the creds for given a cred_name and tenant_id'
def add_credential(tenant_id, credential_name, user_name, password): DCNL 'Adds a qos to tenant association'
def remove_credential(tenant_id, credential_id): DCNL 'Removes a credential from a  tenant'
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL 'Updates a credential for a tenant'
def initialize(): DCNL 'Establish database connection and load models'
def create_vlanids(): DCNL 'Prepopulates the vlan_bindings table'
def get_all_vlanids(): DCNL 'Gets all the vlanids'
def is_vlanid_used(vlan_id): DCNL 'Checks if a vlanid is in use'
def release_vlanid(vlan_id): DCNL 'Sets the vlanid state to be unused'
def delete_vlanid(vlan_id): DCNL 'Deletes a vlanid entry from db'
def reserve_vlanid(): DCNL 'Reserves the first unused vlanid'
def get_all_vlanids_used(): DCNL 'Gets all the vlanids used'
def get_all_vlan_bindings(): DCNL 'Lists all the vlan to network associations'
def get_vlan_binding(netid): DCNL 'Lists the vlan given a network_id'
def add_vlan_binding(vlanid, vlanname, netid): DCNL 'Adds a vlan to network association'
def remove_vlan_binding(netid): DCNL 'Removes a vlan to network association'
def update_vlan_binding(netid, newvlanid=None, newvlanname=None): DCNL 'Updates a vlan to network association'
def get_all_qoss(tenant_id): DCNL 'Lists all the qos to tenant associations'
def get_qos(tenant_id, qos_id): DCNL 'Lists the qos given a tenant_id and qos_id'
def add_qos(tenant_id, qos_name, qos_desc): DCNL 'Adds a qos to tenant association'
def remove_qos(tenant_id, qos_id): DCNL 'Removes a qos to tenant association'
def update_qos(tenant_id, qos_id, new_qos_name=None): DCNL 'Updates a qos to tenant association'
def get_all_credentials(tenant_id): DCNL 'Lists all the creds for a tenant'
def get_credential(tenant_id, credential_id): DCNL 'Lists the creds for given a cred_id and tenant_id'
def get_credential_name(tenant_id, credential_name): DCNL 'Lists the creds for given a cred_name and tenant_id'
def add_credential(tenant_id, credential_name, user_name, password): DCNL 'Adds a qos to tenant association'
def remove_credential(tenant_id, credential_id): DCNL 'Removes a credential from a  tenant'
def update_credential(tenant_id, credential_id, new_user_name=None, new_password=None): DCNL 'Updates a credential for a tenant'
def configure_db(options): DCNL 'Establish the database, create an engine if needed, and DCNL register the models. DCNL :param options: Mapping of configuration options'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def register_models(): DCNL 'Register Models and create properties'
def unregister_models(): DCNL 'Unregister Models, useful clearing out data before testing'
def get_view_builder(req): DCNL 'get view builder'
def get_view_builder(req): DCNL 'get view builder'
def nos_unknown_host_cb(host, fingerprint): DCNL 'An unknown host callback. DCNL Returns `True` if it finds the key acceptable, DCNL and `False` if not. This default callback for NOS always returns \'True\' DCNL (i.e. trusts all hosts for now).'
def create_network(context, net_id, vlan): DCNL 'Create a brocade specific network/port-profiles.'
def delete_network(context, net_id): DCNL 'Delete a brocade specific network/port-profiles.'
def get_network(context, net_id, fields=None): DCNL 'Get brocade specific network, with vlan extension.'
def get_networks(context, filters=None, fields=None): DCNL 'Get all brocade specific networks.'
def create_port(context, port_id, network_id, physical_interface, vlan_id, tenant_id, admin_state_up): DCNL 'Create a brocade specific port, has policy like vlan.'
def get_port(context, port_id): DCNL 'get a brocade specific port.'
def get_ports(context, network_id=None): DCNL 'get a brocade specific port.'
def delete_port(context, port_id): DCNL 'delete brocade specific port.'
def get_port_from_device(session, port_id): DCNL 'get port from the tap device.'
def update_port_state(context, port_id, admin_state_up): DCNL 'Update port attributes.'
def save_config(conf_path, logical_config, socket_path=None): DCNL 'Convert a logical configuration to the HAProxy version'
def _get_server_health_option(config): DCNL 'return the first active health option'
def _expand_expected_codes(codes): DCNL 'Expand the expected code string in set of codes. DCNL 200-204 -> 200, 201, 202, 204 DCNL 200, 203 -> 200, 203'
def sg_label(sg_id, sg_name): DCNL 'Construct the security group ID used as chain identifier in MidoNet.'
def chain_names(sg_id, sg_name): DCNL 'Get inbound and outbound chain names.'
def parse_config(): DCNL 'Parse the supplied plugin configuration. DCNL :param config: a ConfigParser() object encapsulating nvp.ini. DCNL :returns: A tuple: (clusters, plugin_config). \'clusters\' is a list of DCNL NVPCluster objects, \'plugin_config\' is a dictionary with plugin DCNL parameters (currently only \'max_lp_per_bridged_ls\').'
def _retrieve_extra_groups(conf, key=None, delimiter=':'): DCNL 'retrieve configuration groups not listed above.'
def register_cluster_groups(conf): DCNL 'retrieve configuration groups for nvp clusters.'
def get_cluster_version(cluster): DCNL 'Return major/minor version #'
def do_single_request(*args, **kwargs): DCNL 'Issue a request to a specified cluster if specified via kwargs DCNL (cluster=<cluster>).'
def do_multi_request(*args, **kwargs): DCNL 'Issue a request to all clusters'
def find_port_and_cluster(clusters, port_id): DCNL 'Return (url, cluster_id) of port or (None, None) if port does not exist.'
def create_l2_gw_service(cluster, tenant_id, display_name, devices): DCNL 'Create a NVP Layer-2 Network Gateway Service. DCNL :param cluster: The target NVP cluster DCNL :param tenant_id: Identifier of the Openstack tenant for which DCNL the gateway service. DCNL :param display_name: Descriptive name of this gateway service DCNL :param devices: List of transport node uuids (and network DCNL interfaces on them) to use for the network gateway service DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'
def create_lrouter(cluster, tenant_id, display_name, nexthop): DCNL 'Create a NVP logical router on the specified cluster. DCNL :param cluster: The target NVP cluster DCNL :param tenant_id: Identifier of the Openstack tenant for which DCNL the logical router is being created DCNL :param display_name: Descriptive name of this logical router DCNL :param nexthop: External gateway IP address for the logical router DCNL :raise NvpApiException: if there is a problem while communicating DCNL with the NVP controller'
def get_all_networks(cluster, tenant_id, networks): DCNL 'Append the quantum network uuids we can find in the given cluster to DCNL "networks"'
def get_port_by_display_name(clusters, lswitch, display_name): DCNL 'Return (url, cluster_id) of port or raises ResourceNotFound'
def get_port_by_quantum_tag(cluster, lswitch_uuid, quantum_port_id): DCNL 'Return the NVP UUID of the logical port with tag q_port_id DCNL equal to quantum_port_id or None if the port is not Found.'
def create_lport(cluster, lswitch_uuid, tenant_id, quantum_port_id, display_name, device_id, admin_status_enabled, mac_address=None, fixed_ips=None, port_security_enabled=None, security_profiles=None, queue_id=None): DCNL 'Creates a logical port on the assigned logical switch'
def create_router_lport(cluster, lrouter_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL 'Creates a logical port on the assigned logical router'
def update_router_lport(cluster, lrouter_uuid, lrouter_port_uuid, tenant_id, quantum_port_id, display_name, admin_status_enabled, ip_addresses): DCNL 'Updates a logical port on the assigned logical router'
def delete_router_lport(cluster, lrouter_uuid, lport_uuid): DCNL 'Creates a logical port on the assigned logical router'
def find_router_gw_port(context, cluster, router_id): DCNL 'Retrieves the external gateway port for a NVP logical router'
def plug_router_port_attachment(cluster, router_id, port_id, attachment_uuid, nvp_attachment_type, attachment_vlan=None): DCNL 'Attach a router port to the given attachment. DCNL Current attachment types: DCNL - PatchAttachment [-> logical switch port uuid] DCNL - L3GatewayAttachment [-> L3GatewayService uuid] DCNL For the latter attachment type a VLAN ID can be specified as well'
def get_port_status(cluster, lswitch_id, port_id): DCNL 'Retrieve the operational status of the port'
def plug_l2_gw_service(cluster, lswitch_id, lport_id, gateway_id, vlan_id=None): DCNL 'Plug a Layer-2 Gateway Attachment object in a logical port'
def plug_interface(cluster, lswitch_id, port, type, attachment=None): DCNL 'Plug a VIF Attachment object in a logical port'
def format_exception(etype, e, execption_locals, request=None): DCNL 'Consistent formatting for exceptions. DCNL :param etype: a string describing the exception type. DCNL :param e: the exception. DCNL :param request: the request object. DCNL :param execption_locals: calling context local variable dict. DCNL :returns: a formatted string.'
def do_request(*args, **kwargs): DCNL 'Convenience function wraps do_single_request. DCNL :param args: a list of positional arguments. DCNL :param kwargs: a list of keyworkds arguments. DCNL :returns: the result of do_single_request loaded into a python object DCNL or None.'
def mk_body(**kwargs): DCNL 'Convenience function creates and dumps dictionary to string. DCNL :param kwargs: the key/value pirs to be dumped into a json string. DCNL :returns: a json string.'
def set_tenant_id_tag(tenant_id, taglist=None): DCNL 'Convenience function to add tenant_id tag to taglist. DCNL :param tenant_id: the tenant_id to set. DCNL :param taglist: the taglist to append to (or None). DCNL :returns: a new taglist that includes the old taglist with the new DCNL tenant_id tag set.'
def check_cluster_connectivity(cluster): DCNL 'Make sure that we can issue a request to each of the cluster nodes'
def _validate_device_list(data, valid_values=None): DCNL 'Validate the list of service definitions.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def get_port_from_device(port_id): DCNL 'Get port from database'
def sync_network_states(network_vlan_ranges): DCNL 'Synchronize network_states table with current configured VLAN ranges.'
def get_network_state(physical_network, vlan_id): DCNL 'Get state of specified network'
def get_port_from_device(device): DCNL 'Get port from database'
def set_port_status(port_id, status): DCNL 'Set the port status'
@event.listens_for(ServiceRouterBinding.resource_type, 'set', retval=True) DCNL def validate_resource_type(target, value, oldvalue, initiator): DCNL 'Make sure the resource type fit the resource_type column.'
def parse_service_definition_opt(): DCNL 'parse service definition opts and returns result'
def paginate_query(query, model, limit, sorts, marker_obj=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort key, specified by sorts. DCNL (If sort keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort key, this would be easy: sort_key > X. DCNL With a compound-values sort key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL The reason of didn\'t use OFFSET clause was it don\'t scale, please refer DCNL discussion at https://lists.launchpad.net/openstack/msg02547.html DCNL We also have to cope with different sort directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sorts: array of attributes and direction by which results should DCNL be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def run_migrations_offline(): DCNL 'Run migrations in \'offline\' mode. DCNL This configures the context with just a URL DCNL and not an Engine, though an Engine is acceptable DCNL here as well.  By skipping the Engine creation DCNL we don\'t even need a DBAPI to be available. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'
def run_migrations_online(): DCNL 'Run migrations in \'online\' mode. DCNL In this scenario we need to create an Engine DCNL and associate a connection with the context.'
def upgrade(active_plugin=None, options=None): DCNL 'A no-op migration for marking the Grizzly release.'
def downgrade(active_plugin=None, options=None): DCNL 'A no-op migration for marking the Grizzly release.'
def configure_db(): DCNL 'Establish the database, create an engine if needed, and DCNL register the models.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def register_models(base=BASE): DCNL 'Register Models and create properties'
def unregister_models(base=BASE): DCNL 'Unregister Models, useful clearing out data before testing'
def greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to execute by forcing a context DCNL switch. With common database backends (eg MySQLdb and sqlite), there is DCNL no implicit yield caused by network I/O since they are implemented by DCNL C libraries that eventlet cannot monkey patch.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'Create a paste pipeline based on the \'auth_strategy\' config option.'
def _validate_servicetype_ref(data, valid_values=None): DCNL 'Verify the service type id exists'
def _validate_service_defs(data, valid_values=None): DCNL 'Validate the list of service definitions.'
def _ofc(id): DCNL 'OFC ID converter'
def record_messages(connection, topic, output): DCNL 'Listen to notification.info messages and pickle them to output.'
def monitor_messages(connection, topic): DCNL 'Listen to notification.info messages and print them.'
def send_messages(connection, topic, input): DCNL 'Read messages from the input and send them to the AMQP queue.'
@blueprint.route('/meters') DCNL def list_meters_all(): DCNL 'Return a list of meters. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/resources/<resource>/meters') DCNL def list_meters_by_resource(resource): DCNL 'Return a list of meters by resource. DCNL :param resource: The ID of the resource. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/users/<user>/meters') DCNL def list_meters_by_user(user): DCNL 'Return a list of meters by user. DCNL :param user: The ID of the owning user. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/projects/<project>/meters') DCNL def list_meters_by_project(project): DCNL 'Return a list of meters by project. DCNL :param project: The ID of the owning project. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/sources/<source>/meters') DCNL def list_meters_by_source(source): DCNL 'Return a list of meters by source. DCNL :param source: The ID of the owning source. DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
def _list_resources(source=None, user=None, project=None): DCNL 'Return a list of resource identifiers.'
@blueprint.route('/projects/<project>/resources') DCNL def list_resources_by_project(project): DCNL 'Return a list of resources owned by the project. DCNL :param project: The ID of the owning project. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/resources') DCNL def list_all_resources(): DCNL 'Return a list of all known resources. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/sources/<source>') DCNL def get_source(source): DCNL 'Return a source details. DCNL :param source: The ID of the reporting source.'
@blueprint.route('/sources/<source>/resources') DCNL def list_resources_by_source(source): DCNL 'Return a list of resources for which a source is reporting DCNL data. DCNL :param source: The ID of the reporting source. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
@blueprint.route('/users/<user>/resources') DCNL def list_resources_by_user(user): DCNL 'Return a list of resources owned by the user. DCNL :param user: The ID of the owning user. DCNL :param start_timestamp: Limits resources by last update time >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits resources by last update time < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC DCNL :param metadata.<key>: match on the metadata within the resource. DCNL (optional)'
def _list_users(source=None): DCNL 'Return a list of user names.'
@blueprint.route('/users') DCNL def list_all_users(): DCNL 'Return a list of all known user names.'
@blueprint.route('/sources/<source>/users') DCNL def list_users_by_source(source): DCNL 'Return a list of the users for which the source is reporting DCNL data. DCNL :param source: The ID of the source.'
def _list_projects(source=None): DCNL 'Return a list of project names.'
@blueprint.route('/projects') DCNL def list_all_projects(): DCNL 'Return a list of all known project names.'
@blueprint.route('/sources/<source>/projects') DCNL def list_projects_by_source(source): DCNL 'Return a list project names for which the source is reporting DCNL data. DCNL :param source: The ID of the source.'
def _list_samples(meter, project=None, resource=None, source=None, user=None): DCNL 'Return a list of raw samples. DCNL Note: the API talks about "events" these are equivelent to samples. DCNL but we still need to return the samples within the "events" dict DCNL to maintain API compatibilty.'
@blueprint.route('/projects/<project>/meters/<meter>') DCNL def list_samples_by_project(project, meter): DCNL 'Return a list of raw samples for the project. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/resources/<resource>/meters/<meter>') DCNL def list_samples_by_resource(resource, meter): DCNL 'Return a list of raw samples for the resource. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/sources/<source>/meters/<meter>') DCNL def list_samples_by_source(source, meter): DCNL 'Return a list of raw samples for the source. DCNL :param source: The ID of the reporting source. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/users/<user>/meters/<meter>') DCNL def list_samples_by_user(user, meter): DCNL 'Return a list of raw samples for the user. DCNL :param user: The ID of the user. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: Limits samples by timestamp >= this value. DCNL (optional) DCNL :type start_timestamp: ISO date in UTC DCNL :param end_timestamp: Limits samples by timestamp < this value. DCNL (optional) DCNL :type end_timestamp: ISO date in UTC'
@blueprint.route('/resources/<resource>/meters/<meter>/duration') DCNL def compute_duration_by_resource(resource, meter): DCNL 'Return the earliest timestamp, last timestamp, DCNL and duration for the resource and meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest timestamp to return. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest timestamp to return. DCNL :param search_offset: Number of minutes before DCNL and after start and end timestamps to query.'
@blueprint.route('/resources/<resource>/meters/<meter>/volume/max') DCNL def compute_max_resource_volume(resource, meter): DCNL 'Return the max volume for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/resources/<resource>/meters/<meter>/volume/sum') DCNL def compute_resource_volume_sum(resource, meter): DCNL 'Return the sum of samples for a meter. DCNL :param resource: The ID of the resource. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/projects/<project>/meters/<meter>/volume/max') DCNL def compute_project_volume_max(project, meter): DCNL 'Return the max volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
@blueprint.route('/projects/<project>/meters/<meter>/volume/sum') DCNL def compute_project_volume_sum(project, meter): DCNL 'Return the total volume for a meter. DCNL :param project: The ID of the project. DCNL :param meter: The name of the meter. DCNL :param start_timestamp: ISO-formatted string of the DCNL earliest time to include in the calculation. DCNL :param end_timestamp: ISO-formatted string of the DCNL latest time to include in the calculation. DCNL :param search_offset: Number of minutes before and DCNL after start and end timestamps to query.'
def _sanitize_query(q): DCNL 'Check the query to see if: DCNL 1) the request is comming from admin - then allow full visibility DCNL 2) non-admin - make sure that the query includes the requester\'s DCNL project.'
def _get_query_timestamps(args={}): DCNL 'Return any optional timestamp information in the request. DCNL Determine the desired range, if any, from the GET arguments. Set DCNL up the query range using the specified offset. DCNL [query_start ... start_timestamp ... end_timestamp ... query_end] DCNL Returns a dictionary containing: DCNL query_start: First timestamp to use for query DCNL start_timestamp: start_timestamp parameter from request DCNL query_end: Final timestamp to use for query DCNL end_timestamp: end_timestamp parameter from request DCNL search_offset: search_offset parameter from request'
def _flatten_metadata(metadata): DCNL 'Return flattened resource metadata without nested structures DCNL and with all values converted to unicode strings.'
def register_opts(conf): DCNL 'Register keystoneclient middleware options'
def install(app, conf): DCNL 'Install ACL check on application.'
def get_limited_to_project(headers): DCNL 'Return the tenant the request should be limited to.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL :class:`ProcessExecutionError` unless DCNL program exits with one of these code. DCNL :type check_exit_code:  boolean, int, or [int] DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix to commands called with DCNL run_as_root=True DCNL :type root_helper:      string DCNL :param shell:           whether or not there should be a shell used to DCNL execute this command. Defaults to false. DCNL :type shell:            boolean DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def _is_in_group(opt, group): DCNL 'Check if opt is in group.'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def install(domain): DCNL 'Install a _() function using the given translation domain. DCNL Given a translation domain, install a _() function using gettext\'s DCNL install() function. DCNL The main difference from gettext.install() is that we allow DCNL overriding the default localedir (e.g. /usr/share/locale) using DCNL a translation-domain-specific environment variable (e.g. DCNL NOVA_LOCALEDIR).'
def get_lazy_gettext(domain): DCNL 'Assemble and return a lazy gettext function for a given domain. DCNL Factory method for a project/module to get a lazy gettext function DCNL for its own translation domain (i.e. nova, glance, cinder, etc.)'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def getLazyLogger(name='unknown', version='unknown'): DCNL 'Returns lazy logger. DCNL Creates a pass-through logger that does not create the real logger DCNL until it is really needed and delegates all calls to the real logger DCNL once it is created.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Translates the old list-of-lists syntax into a tree of Check objects. DCNL Provided for backwards compatibility.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods. DCNL Arguments are a sequence of tokens, in order, which should trigger running DCNL this reduction method.'
def _parse_text_rule(rule): DCNL 'Parses policy to the tree. DCNL Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def _thread_done(gt, *args, **kwargs): DCNL 'Callback function to be passed to GreenThread.link() when we spawn() DCNL Calls the :class:`ThreadGroup` to notify if.'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL :param lock_file_prefix: The lock_file_prefix argument is used to provide DCNL lock files on disk with a meaningful prefix. The prefix should end with a DCNL hyphen (\'-\') if specified. DCNL :param external: The external keyword argument denotes whether this lock DCNL should work across multiple processes. This means that if two different DCNL workers both run a a method decorated with @synchronized(\'mylock\', DCNL external=True), only one of them will execute at a time. DCNL :param lock_path: The lock_path keyword argument is used to specify a DCNL special location for external lock files to live. If nothing is set, then DCNL CONF.lock_path is used as a default.'
def synchronized_with_prefix(lock_file_prefix): DCNL 'Partial object generator for the synchronization decorator. DCNL Redefine @synchronized in each project like so:: DCNL (in nova/utils.py) DCNL from nova.openstack.common import lockutils DCNL synchronized = lockutils.synchronized_with_prefix(\'nova-\') DCNL (in nova/foo.py) DCNL from nova import utils DCNL @utils.synchronized(\'mylock\') DCNL def bar(self, *args): DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified.'
def set_defaults(sql_connection, sqlite_db, max_pool_size=None, max_overflow=None, pool_timeout=None): DCNL 'Set defaults for configuration variables.'
def get_session(autocommit=True, expire_on_commit=False, sqlite_fk=False, slave_session=False): DCNL 'Return a SQLAlchemy session.'
def _raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL 'Raise exception if two entries are duplicated. DCNL In this function will be raised DBDuplicateEntry exception if integrity DCNL error wrap unique constraint violation.'
def _raise_if_deadlock_error(operational_error, engine_name): DCNL 'Raise exception on deadlock condition. DCNL Raise DBDeadlock exception if OperationalError contains a Deadlock DCNL condition.'
def get_engine(sqlite_fk=False, slave_engine=False): DCNL 'Return a SQLAlchemy engine.'
def _synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode.'
def _add_regexp_listener(dbapi_con, con_record): DCNL 'Add REGEXP function to sqlite connections.'
def _greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to be executed. DCNL Force a context switch. With common database backends (eg MySQLdb and DCNL sqlite), there is no implicit yield caused by network I/O since they are DCNL implemented by C libraries that eventlet cannot monkey patch.'
def _ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def _is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def create_engine(sql_connection, sqlite_fk=False): DCNL 'Return a new SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def _patch_mysqldb_with_stacktrace_comments(): DCNL 'Adds current stack trace as a comment in queries. DCNL Patches MySQLdb.cursors.BaseCursor._do_query.'
def _assert_matching_drivers(): DCNL 'Make sure slave handle and normal handle have the same driver.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def _get_drivers(): DCNL 'Instantiates and returns drivers based on the flag values.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def remove_driver(notification_driver): DCNL 'Remove a notification driver at runtime.'
def notify(context, message): DCNL 'Passes notification to multiple notifiers in a list.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model.'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system.'
def notify_decorator(name, fn): DCNL 'Decorator for notify which is used from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC.'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection.'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper. DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper.'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages. DCNL Dispatches to the matchmaker and sends message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def read_cached_file(filename, force_reload=False): DCNL 'Read from a file if it has been modified. DCNL :param force_reload: Whether to reload the file. DCNL :returns: A tuple with a boolean specifying if the data is fresh DCNL or not.'
def delete_if_exists(path): DCNL 'Delete a file, but ignore file not found error. DCNL :param path: File to delete'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed. DCNL :param path: File to work with'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def import_class(import_str): DCNL 'Returns a class from a string including module and class.'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Tries to import object from default namespace. DCNL Imports a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format.'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format.'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object.'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp.'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Overrides utils.utcnow. DCNL Make it return a constant time or a list thereof, one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Return the difference between two timing objects. DCNL Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def notify(context, message): DCNL 'Sends a notification as a meter using Ceilometer pipelines.'
def setup_pipeline(transformer_manager): DCNL 'Setup pipeline manager according to yaml config file.'
def recursive_keypairs(d): DCNL 'Generator that produces sequence of keypairs for nested dictionaries.'
def dt_to_decimal(utc): DCNL 'Datetime to Decimal. DCNL Some databases don\'t store microseconds in datetime DCNL so we always store as Decimal unixtime.'
def decimal_to_dt(dec): DCNL 'Return a datetime from Decimal unixtime format.'
def sanitize_timestamp(timestamp): DCNL 'Return a naive utc datetime object.'
def get_metadata_from_object(instance): DCNL 'Return a metadata dictionary for the instance.'
def initialize_gatherer(gatherer=None): DCNL 'Set the callable used to gather stats for the instance. DCNL gatherer should be a callable accepting one argument (the instance DCNL ref), or None to have a default gatherer used'
def _instance_name(instance): DCNL 'Shortcut to get instance name.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def reverse_timestamp(dt): DCNL 'Reverse timestamp so that newer timestamps are represented by smaller DCNL numbers than older ones. DCNL Reverse timestamps is a technique used in HBase rowkey design. When period DCNL queries are required the HBase rowkeys must include timestamps, but as DCNL rowkeys in HBase are ordered lexicographically, the timestamps must be DCNL reversed.'
def make_query(user=None, project=None, meter=None, resource=None, source=None, start=None, end=None, require_meter=True, query_only=False): DCNL 'Return a filter query string based on the selected parameters. DCNL :param user: Optional user-id DCNL :param project: Optional project-id DCNL :param meter: Optional counter-name DCNL :param resource: Optional resource-id DCNL :param source: Optional source-id DCNL :param start: Optional start timestamp DCNL :param end: Optional end timestamp DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error. DCNL :param query_only: If true only returns the filter query, DCNL otherwise also returns start and stop rowkeys'
def make_query_from_filter(sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param sample_filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def _make_rowkey_scan(meter, rts_start=None, rts_end=None): DCNL 'If it\'s meter filter without start and end, DCNL start_row = meter while end_row = meter + MAX_BYTE'
def _load_hbase_list(d, prefix): DCNL 'Deserialise dict stored as HBase column family'
def make_query_from_filter(query, sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def register_opts(conf): DCNL 'Register any options for the storage system.'
def get_engine(conf): DCNL 'Load the configured engine and return an instance.'
def get_connection(conf): DCNL 'Return an open connection to the database.'
def iter_period(start, end, period): DCNL 'Split a time from start to end in periods of a number of seconds. This DCNL function yield the (start, end) time for each period composing the time DCNL passed as argument. DCNL :param start: When the period set start. DCNL :param end: When the period end starts. DCNL :param period: The duration of the period.'
def make_timestamp_range(start, end): DCNL 'Given two possible datetimes, create the query DCNL document to find timestamps within that range DCNL using $gte for the lower bound and $lt for the DCNL upper bound.'
def make_query_from_filter(sample_filter, require_meter=True): DCNL 'Return a query dictionary based on the settings in the filter. DCNL :param filter: SampleFilter instance DCNL :param require_meter: If true and the filter does not have a meter, DCNL raise an error.'
def require_map_reduce(conn): DCNL 'Raises SkipTest if the connection is using mim.'
def register_opts(config): DCNL 'Register the options for publishing metering messages.'
def compute_signature(message, secret): DCNL 'Return the signature for a message dictionary.'
def verify_signature(message, secret): DCNL 'Check the signature in the message against the value computed DCNL from the rest of the contents.'
def meter_message_from_counter(counter, secret, source): DCNL 'Make a metering message ready to be published or stored. DCNL Returns a dictionary containing a metering message DCNL for a notification message and a Counter instance.'
def get_publisher(url, namespace='ceilometer.publisher'): DCNL 'Get publisher driver and load it. DCNL :param URL: URL for the publisher DCNL :param namespace: Namespace to use to look for drivers.'
def get_client(host, port=None, timeout=None, use_ssl=False, username=None, password=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_upload=False, insecure=False): DCNL 'Returns a new client Glance client object based on common kwargs. DCNL If an option isn\'t specified falls back to common environment variable DCNL defaults.'
def _make_namespaced_xattr_key(key, namespace='user'): DCNL 'Create a fully-qualified xattr-key by including the intended namespace. DCNL Namespacing differs among OSes[1]: DCNL FreeBSD: user, system DCNL Linux: user, system, trusted, security DCNL MacOS X: not needed DCNL Mac OS X won\'t break if we include a namespace qualifier, so, for DCNL simplicity, we always include it. DCNL [1] http://en.wikipedia.org/wiki/Extended_file_attributes'
def get_xattr(path, key, **kwargs): DCNL 'Return the value for a particular xattr DCNL If the key doesn\'t not exist, or xattrs aren\'t supported by the file DCNL system then a KeyError will be raised, that is, unless you specify a DCNL default using kwargs.'
def set_xattr(path, key, value): DCNL 'Set the value of a specified xattr. DCNL If xattrs aren\'t supported by the file-system, we skip setting the value.'
def inc_xattr(path, key, n=1): DCNL 'Increment the value of an xattr (assuming it is an integer). DCNL BEWARE, this code *does* have a RACE CONDITION, since the DCNL read/update/write sequence is not atomic. DCNL Since the use-case for this function is collecting stats--not critical-- DCNL the benefits of simple, lock-free code out-weighs the possibility of an DCNL occasional hit not being counted.'
def create_resource(): DCNL 'Image members resource factory method'
def redact_loc(image_meta): DCNL 'Create a shallow copy of image meta with \'location\' removed DCNL for security (as it can contain credentials).'
def create_resource(): DCNL 'Images resource factory method'
def load_custom_properties(): DCNL 'Find the schema properties files and load them into a dict.'
def create_resource(custom_properties=None): DCNL 'Images resource factory method'
def create_resource(): DCNL 'Image Members resource factory method'
def create_resource(): DCNL 'Image data resource factory method'
def create_resource(): DCNL 'Images resource factory method'
def create_resource(): DCNL 'Cached Images resource factory method'
def image_send_notification(bytes_written, expected_size, image_meta, request, notifier): DCNL 'Send an image.send message to the notifier.'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_member_mutable(context, member): DCNL 'Return True if the image is mutable in this context.'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
def setup(product_name): DCNL 'Setup logging.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def handle_unauthenticated(func): DCNL 'Wrap a function to re-authenticate and retry.'
def handle_redirects(func): DCNL 'Wrap the _do_request function to handle HTTP redirects.'
def get_bind_addr(default_port=None): DCNL 'Return the host and port to bind to.'
def get_socket(default_port): DCNL 'Bind socket to bind ip:port in conf DCNL note: Mostly comes from Swift with a few small changes... DCNL :param default_port: port to bind to if none is specified in conf DCNL :returns : a socket object as returned from socket.listen or DCNL ssl.wrap_socket if conf specifies cert_file'
def chunkreadable(iter, chunk_size=65536): DCNL 'Wrap a readable iterator with a reader yielding chunks of DCNL a preferred size, otherwise leave iterator unchanged. DCNL :param iter: an iter which may also be readable DCNL :param chunk_size: maximum size of chunk'
def chunkiter(fp, chunk_size=65536): DCNL 'Return an iterator to a file-like obj which yields fixed size chunks DCNL :param fp: a file-like object DCNL :param chunk_size: maximum size of chunk'
def cooperative_iter(iter): DCNL 'Return an iterator which schedules after each DCNL iteration. This can prevent eventlet thread starvation. DCNL :param iter: an iterator to wrap'
def cooperative_read(fd): DCNL 'Wrap a file descriptor\'s read with a partial function which schedules DCNL after each read. This can prevent eventlet thread starvation. DCNL :param fd: a file descriptor to wrap'
def image_meta_to_http_headers(image_meta): DCNL 'Returns a set of image metadata into a dict DCNL of HTTP headers that can be fed to either a Webob DCNL Request object or an httplib.HTTP(S)Connection object DCNL :param image_meta: Mapping of image metadata'
def add_features_to_http_headers(features, headers): DCNL 'Adds additional headers representing glance features to be enabled. DCNL :param headers: Base set of headers DCNL :param features: Map of enabled features'
def get_image_meta_from_headers(response): DCNL 'Processes HTTP headers from a supplied response that DCNL match the x-image-meta and x-image-meta-property and DCNL returns a mapping of image metadata and properties DCNL :param response: Response to process'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean-like value.'
def mutating(func): DCNL 'Decorator to enforce read-only logic'
def urlsafe_encrypt(key, plaintext, blocksize=16): DCNL 'Encrypts plaintext. Resulting ciphertext will contain URL-safe characters DCNL :param key: AES secret key DCNL :param plaintext: Input text to be encrypted DCNL :param blocksize: Non-zero integer multiple of AES blocksize in bytes (16) DCNL :returns : Resulting ciphertext'
def urlsafe_decrypt(key, ciphertext): DCNL 'Decrypts URL-safe base64 encoded ciphertext DCNL :param key: AES secret key DCNL :param ciphertext: The encrypted text to decrypt DCNL :returns : Resulting plaintext'
def get_endpoint(service_catalog, service_type='image', endpoint_region=None, endpoint_type='publicURL'): DCNL 'Select an endpoint from the service catalog DCNL We search the full service catalog for services DCNL matching both type and region. If the client DCNL supplied no region then any \'image\' endpoint DCNL is considered a match. There must be one -- and DCNL only one -- successful match in the catalog, DCNL otherwise we will raise an exception.'
def setup_logging(): DCNL 'Sets up the logging options for a log with supplied name'
def _get_deployment_flavor(): DCNL 'Retrieve the paste_deploy.flavor config item, formatted appropriately DCNL for appending to the application name.'
def _get_deployment_config_file(): DCNL 'Retrieve the deployment_config_file config item, formatted as an DCNL absolute pathname.'
def load_paste_app(app_name=None): DCNL 'Builds and returns a WSGI app from a paste config file. DCNL We assume the last config file specified in the supplied ConfigOpts DCNL object is the paste config file. DCNL :param app_name: name of the application to load DCNL :raises RuntimeError when config file cannot be located or application DCNL cannot be loaded from config file'
def make_member_list(members, **attr_map): DCNL 'Create a dict representation of a list of members which we can use DCNL to serialize the members list.  Keyword arguments map the names of DCNL optional attributes to include to the database attribute.'
def create_resource(): DCNL 'Image members resource factory method.'
def make_image_dict(image): DCNL 'Create a dict representation of an image which we can use to DCNL serialize the image.'
def create_resource(): DCNL 'Images resource factory method.'
def configure_registry_client(): DCNL 'Sets up a registry client for use in registry lookups'
def register_models(engine): DCNL 'Creates database tables for all models with the given engine'
def unregister_models(engine): DCNL 'Drops database tables for all models with the given engine'
def from_migration_import(module_name, fromlist): DCNL 'Import a migration file and return the module DCNL :param module_name: name of migration module to import from DCNL (ex: 001_add_images_table) DCNL :param fromlist: list of items to import (ex: define_images_table) DCNL :retval: module object DCNL This bit of ugliness warrants an explanation: DCNL As you\'re writing migrations, you\'ll frequently want to refer to DCNL tables defined in previous migrations. DCNL In the interest of not repeating yourself, you need a way of importing DCNL that table into a \'future\' migration. DCNL However, tables are bound to metadata, so what you need to import is DCNL really a table factory, which you can late-bind to your current DCNL metadata object. DCNL Moreover, migrations begin with a number (001...), which means they DCNL aren\'t valid Python identifiers. This means we can\'t perform a DCNL \'normal\' import on them (the Python lexer will \'splode). Instead, we DCNL need to use __import__ magic to bring the table-factory into our DCNL namespace. DCNL Example Usage: DCNL (define_images_table,) = from_migration_import( DCNL \'001_add_images_table\', [\'define_images_table\']) DCNL images = define_images_table(meta) DCNL # Refer to images table'
def get_images_table(meta): DCNL 'No changes to the images table from 008...'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 008...'
def get_image_members_table(meta): DCNL 'No changes to the image members table from 008...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that corresponds to DCNL the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 006...'
def _sanitize(migrate_engine, table): DCNL 'Avoid possible integrity error by removing deleted rows DCNL to accommdate less restrictive uniqueness constraint'
def migrate_location_credentials(migrate_engine, to_quoted): DCNL 'Migrate location credentials for encrypted swift uri\'s between the DCNL quoted and unquoted forms. DCNL :param migrate_engine: The configured db engine DCNL :param to_quoted: If True, migrate location credentials from DCNL unquoted to quoted form.  If False, do the DCNL reverse.'
def fix_uri_credentials(uri, to_quoted): DCNL 'Fix the given uri\'s embedded credentials by round-tripping with DCNL StoreLocation. DCNL If to_quoted is True, the uri is assumed to have credentials that DCNL have not been quoted, and the resulting uri will contain quoted DCNL credentials. DCNL If to_quoted is False, the uri is assumed to have credentials that DCNL have been quoted, and the resulting uri will contain credentials DCNL that have not been quoted.'
def legacy_parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. It also deals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def get_images_table(meta): DCNL 'No changes to the image properties table from 002...'
def get_image_properties_table(meta): DCNL 'Returns the Table object for the image_properties table that DCNL corresponds to the image_properties table definition of this version.'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 008...'
def get_images_table(meta): DCNL 'No changes to the images table from 007...'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 007...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def get_images_table(meta): DCNL 'Returns the Table object for the images table that DCNL corresponds to the images table definition of this version.'
def get_image_properties_table(meta): DCNL 'No changes to the image properties table from 002...'
def upgrade(migrate_engine): DCNL 'Call the correct dialect-specific upgrade.'
def downgrade(migrate_engine): DCNL 'Call the correct dialect-specific downgrade.'
def _upgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL 'Upgrade 011 -> 012 with special SQLite-compatible logic.'
def _downgrade_sqlite(t_images, t_image_members, t_image_properties): DCNL 'Downgrade 012 -> 011 with special SQLite-compatible logic.'
def _upgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL 'Upgrade 011 -> 012 with logic for non-SQLite databases.'
def _downgrade_other(t_images, t_image_members, t_image_properties, dialect): DCNL 'Downgrade 012 -> 011 with logic for non-SQLite databases.'
def _get_table(table_name, metadata): DCNL 'Return a sqlalchemy Table definition with associated metadata.'
def _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect): DCNL 'Retrieve and return foreign keys for members/properties tables.'
def _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties): DCNL 'Transition from INTEGER id to VARCHAR(36) id.'
def _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties): DCNL 'Transition from VARCHAR(36) id to INTEGER id.'
def migrate_location_credentials(migrate_engine, to_quoted): DCNL 'Migrate location credentials for swift uri\'s between the quoted DCNL and unquoted forms. DCNL :param migrate_engine: The configured db engine DCNL :param to_quoted: If True, migrate location credentials from DCNL unquoted to quoted form.  If False, do the DCNL reverse.'
def fix_uri_credentials(uri, to_quoted): DCNL 'Fix the given uri\'s embedded credentials by round-tripping with DCNL StoreLocation. DCNL If to_quoted is True, the uri is assumed to have credentials that DCNL have not been quoted, and the resulting uri will contain quoted DCNL credentials. DCNL If to_quoted is False, the uri is assumed to have credentials that DCNL have been quoted, and the resulting uri will contain credentials DCNL that have not been quoted.'
def legacy_parse_uri(self, uri): DCNL 'Parse URLs. This method fixes an issue where credentials specified DCNL in the URL are interpreted differently in Python 2.6.1+ than prior DCNL versions of Python. It also deals with the peculiarity that new-style DCNL Swift URIs have where a username can contain a \':\', like so: DCNL swift://account:user:pass@authurl.com/container/obj'
def db_version(): DCNL 'Return the database\'s current migration number DCNL :retval version number'
def upgrade(version=None): DCNL 'Upgrade the database\'s current migration level DCNL :param version: version to upgrade (defaults to latest) DCNL :retval version number'
def downgrade(version): DCNL 'Downgrade the database\'s current migration level DCNL :param version: version to downgrade to DCNL :retval version number'
def version_control(version=None): DCNL 'Place a database under migration control'
def _version_control(version): DCNL 'Place a database under migration control DCNL This will only set the specific version of a database, it won\'t DCNL run any migrations.'
def db_sync(version=None, current_version=None): DCNL 'Place a database under migration control and perform an upgrade DCNL :retval version number'
def get_migrate_repo_path(): DCNL 'Get the path for the migrate repository.'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def setup_db_env(): DCNL 'Setup configuration for database'
def configure_db(): DCNL 'Establish the database, create an engine if needed, and DCNL register the models.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Helper method to grab session'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker.'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def wrap_db_error(f): DCNL 'Retry DB connection. Copied from nova and modified.'
def image_create(context, values): DCNL 'Create an image from the values dictionary.'
def image_update(context, image_id, values, purge_props=False): DCNL 'Set the given properties on an image and update it. DCNL :raises NotFound if image does not exist.'
def image_destroy(context, image_id): DCNL 'Destroy the image or raise if it does not exist.'
def _image_get(context, image_id, session=None, force_show_deleted=False): DCNL 'Get an image or raise if it does not exist.'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_image_sharable(context, image, **kwargs): DCNL 'Return True if the image can be shared to others in this context.'
def is_image_visible(context, image, status=None): DCNL 'Return True if the image is visible in this context.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def image_get_all(context, filters=None, marker=None, limit=None, sort_key='created_at', sort_dir='desc', member_status='accepted'): DCNL 'Get all images that match zero or more filters. DCNL :param filters: dict of filter keys and values. If a \'properties\' DCNL key is present, it is treated as a dict of key/value DCNL filters on the image properties attribute DCNL :param marker: image id after which to start page DCNL :param limit: maximum number of images to return DCNL :param sort_key: image attribute by which results should be sorted DCNL :param sort_dir: direction in which results should be sorted (asc, desc)'
def _drop_protected_attrs(model_class, values): DCNL 'Removed protected attributes from values dictionary using the models DCNL __protected_attributes__ field.'
def validate_image(values): DCNL 'Validates the incoming data and raises a Invalid exception DCNL if anything is out of order. DCNL :param values: Mapping of image metadata to check'
def _image_update(context, values, image_id, purge_props=False): DCNL 'Used internally by image_create and image_update DCNL :param context: Request context DCNL :param values: A dict of attributes to set DCNL :param image_id: If None, create the image, otherwise, find and update it'
def _set_properties_for_image(context, image_ref, properties, purge_props=False, session=None): DCNL 'Create or update a set of image_properties for a given image DCNL :param context: Request context DCNL :param image_ref: An Image object DCNL :param properties: A dict of properties to set DCNL :param session: A SQLAlchemy session to use (if present)'
def image_property_create(context, values, session=None): DCNL 'Create an ImageProperty object'
def _image_property_update(context, prop_ref, values, session=None): DCNL 'Used internally by image_property_create and image_property_update'
def image_property_delete(context, prop_ref, session=None): DCNL 'Used internally by image_property_create and image_property_update'
def image_member_create(context, values, session=None): DCNL 'Create an ImageMember object'
def _image_member_format(member_ref): DCNL 'Format a member ref for consumption outside of this module'
def image_member_update(context, memb_id, values): DCNL 'Update an ImageMember object'
def _image_member_update(context, memb_ref, values, session=None): DCNL 'Apply supplied dictionary of values to a Member object.'
def image_member_delete(context, memb_id, session=None): DCNL 'Delete an ImageMember object'
def _image_member_get(context, memb_id, session): DCNL 'Fetch an ImageMember entity by id'
def image_member_find(context, image_id=None, member=None, status=None): DCNL 'Find all members that meet the given criteria DCNL :param image_id: identifier of image entity DCNL :param member: tenant to which membership has been granted'
def _can_show_deleted(context): DCNL 'Calculates whether to include deleted objects based on context. DCNL Currently just looks for a flag called deleted in the context dict.'
def image_tag_create(context, image_id, value, session=None): DCNL 'Create an image tag.'
def image_tag_delete(context, image_id, value, session=None): DCNL 'Delete an image tag.'
def image_tag_get_all(context, image_id, session=None): DCNL 'Get a list of tags for a specific image.'
def is_image_mutable(context, image): DCNL 'Return True if the image is mutable in this context.'
def is_image_sharable(context, image, **kwargs): DCNL 'Return True if the image can be shared to others in this context.'
def is_image_visible(context, image, status=None): DCNL 'Return True if the image is visible in this context.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def add_cli_options(): DCNL 'Adds any configuration options that the db layer might have. DCNL :retval None'
def http_response_iterator(conn, response, size): DCNL 'Return an iterator for a file-like object. DCNL :param conn: HTTP(S) Connection DCNL :param response: httplib.HTTPResponse object DCNL :param size: Chunk size to iterate with'
def get_bucket(conn, bucket_id): DCNL 'Get a bucket from an s3 connection DCNL :param conn: The ``boto.s3.connection.S3Connection`` DCNL :param bucket_id: ID of the bucket to fetch DCNL :raises ``glance.exception.NotFound`` if bucket is not found.'
def create_bucket_if_missing(bucket, s3_conn): DCNL 'Creates a missing bucket in S3 if the DCNL ``s3_store_create_bucket_on_put`` option is set. DCNL :param bucket: Name of bucket to create DCNL :param s3_conn: Connection to S3'
def get_key(bucket, obj): DCNL 'Get a key from a bucket DCNL :param bucket: The ``boto.s3.Bucket`` DCNL :param obj: Object to get the key for DCNL :raises ``glance.exception.NotFound`` if key is not found.'
def get_location_from_uri(uri): DCNL 'Given a URI, return a Location object that has had an appropriate DCNL store parse the URI. DCNL :param uri: A URI that could come from the end-user in the Location DCNL attribute/header DCNL Example URIs: DCNL https://user:pass@example.com:80/images/some-id DCNL http://images.oracle.com/123456 DCNL swift://example.com/container/obj-id DCNL swift://user:account:pass@authurl.com/container/obj-id DCNL swift+http://user:account:pass@authurl.com/container/obj-id DCNL s3://accesskey:secretkey@s3.amazonaws.com/bucket/key-id DCNL s3+https://accesskey:secretkey@s3.amazonaws.com/bucket/key-id DCNL file:///var/lib/glance/images/1'
def register_scheme_map(scheme_map): DCNL 'Given a mapping of \'scheme\' to store_name, adds the mapping to the DCNL known list of schemes if it does not already exist.'
def create_stores(): DCNL 'Registers all store modules and all schemes DCNL from the given config. Duplicates are not re-registered.'
def get_store_from_scheme(context, scheme, loc=None): DCNL 'Given a scheme, return the appropriate store object DCNL for handling that scheme.'
def get_store_from_uri(context, uri, loc=None): DCNL 'Given a URI, return the store object that would handle DCNL operations on the URI. DCNL :param uri: URI to analyze'
def get_from_backend(context, uri, **kwargs): DCNL 'Yields chunks of data from backend specified by uri'
def get_size_from_backend(context, uri): DCNL 'Retrieves image size from backend specified by uri'
def delete_from_backend(context, uri, **kwargs): DCNL 'Removes chunks of data from backend specified by uri'
def get_store_from_location(uri): DCNL 'Given a location (assumed to be a URL), attempt to determine DCNL the store from the location.  We use here a simple guess that DCNL the scheme of the parsed URL is the store... DCNL :param uri: Location to check for the store'
def safe_delete_from_backend(uri, context, image_id, **kwargs): DCNL 'Given a uri, delete an image from the store.'
def schedule_delayed_delete_from_backend(uri, image_id, **kwargs): DCNL 'Given a uri, schedule the deletion of an image.'
def format_image_notification(image): DCNL 'Given a glance.domain.Image object, return a dictionary of relevant DCNL notification information. We purposely do not include \'location\' DCNL as it may contain credentials.'
def stub_out_registry_and_store_server(stubs, base_dir): DCNL 'Mocks calls to 127.0.0.1 on 9191 and 9292 for testing so DCNL that a real Glance server does not need to be up and DCNL running'
def stub_out_registry_server(stubs, **kwargs): DCNL 'Mocks calls to 127.0.0.1 on 9191 for testing so DCNL that a real Glance Registry server does not need to be up and DCNL running'
def wait_for_scrub(path): DCNL 'NOTE(jkoelker) The build servers sometimes take longer than 15 seconds to DCNL scrub. Give it up to 5 min, checking checking every 15 seconds. When/if it DCNL flips to deleted, bail immediatly.'
def skip_if_disabled(func): DCNL 'Decorator that skips a test if test case is disabled.'
def execute(cmd, raise_error=True, no_venv=False, exec_env=None, expect_exit=True, expected_exitcode=0, context=None): DCNL 'Executes a command in a subprocess. Returns a tuple DCNL of (exitcode, out, err), where out is the string output DCNL from stdout and err is the string output from stderr when DCNL executing the command. DCNL :param cmd: Command string to execute DCNL :param raise_error: If returncode is not 0 (success), then DCNL raise a RuntimeError? Default: True) DCNL :param no_venv: Disable the virtual environment DCNL :param exec_env: Optional dictionary of additional environment DCNL variables; values may be callables, which will DCNL be passed the current value of the named DCNL environment variable DCNL :param expect_exit: Optional flag true iff timely exit is expected DCNL :param expected_exitcode: expected exitcode from the launcher DCNL :param context: additional context for error message'
def find_executable(cmdname): DCNL 'Searches the path for a given cmdname.  Returns an absolute DCNL filename if an executable with the given name exists in the path, DCNL or None if one does not. DCNL :param cmdname: The bare name of the executable to search for'
def get_unused_port(): DCNL 'Returns an unused port on localhost.'
def xattr_writes_supported(path): DCNL 'Returns True if the we can write a file to the supplied DCNL path and subsequently write a xattr to that file.'
def stub_out_http_backend(stubs): DCNL 'Stubs out the httplib.HTTPRequest.getresponse to return DCNL faked-out data instead of grabbing actual contents of a resource DCNL The stubbed getresponse() returns an iterator over DCNL the data "I am a teapot, short and stout DCNL :param stubs: Set of stubout stubs'
def stub_out_registry_image_update(stubs): DCNL 'Stubs an image update on the registry. DCNL :param stubs: Set of stubout stubs'
def format_s3_location(user, key, authurl, bucket, obj): DCNL 'Helper method that returns a S3 store URI given DCNL the component pieces.'
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def get_err_response(code): DCNL 'Given an HTTP response code, create a properly formatted xml error response DCNL :param code: error code DCNL :returns: webob.response object'
def get_acl(account_name, headers): DCNL 'Attempts to construct an S3 ACL based on what is found in the swift headers'
def canonical_string(req): DCNL 'Canonicalize a request to a token that can be signed.'
def swift_acl_translate(acl, group='', user='', xml=False): DCNL 'Takes an S3 style ACL and returns a list of header/value pairs that DCNL implement that ACL in Swift, or "Unsupported" if there isn\'t a way to do DCNL that yet.'
def validate_bucket_name(name): DCNL 'Validates the name of the bucket against S3 criteria, DCNL http://docs.amazonwebservices.com/AmazonS3/latest/BucketRestrictions.html DCNL True if valid, False otherwise'
def filter_factory(global_conf, **local_conf): DCNL 'Standard filter factory to use the middleware with paste.deploy'
def run_command(cmd, redirect_output=True, check_exit_code=True, cwd=ROOT, die_message=None): DCNL 'Runs a command in an out-of-process shell, returning the DCNL output of that command.  Working directory is ROOT.'
def check_dependencies(): DCNL 'Make sure virtualenv is in the path.'
def create_virtualenv(venv=VENV): DCNL 'Creates the virtual environment and installs PIP only into the DCNL virtual environment'
def split(path, result=None): DCNL 'Split a path into components in a platform-neutral way.'
def single_line(text): DCNL 'Quick utility to make comparing template output easier.'
def user_home(request): DCNL 'Reversible named view to direct a user to the appropriate homepage.'
def generate_key(key_length=64): DCNL 'Secret key generator. DCNL The quality of randomness depends on operating system support, DCNL see http://docs.python.org/library/random.html#random.SystemRandom.'
def generate_or_read_from_file(key_file='.secret_key', key_length=64): DCNL 'Multiprocess-safe secret key file generator. DCNL Useful to replace the default (and thus unsafe) SECRET_KEY in settings.py DCNL upon first start. Save to use, i.e. when multiple Python interpreters DCNL serve the dashboard Django application (e.g. in a mod_wsgi + daemonized DCNL environment).  Also checks if file permissions are set correctly and DCNL throws an exception if not.'
def horizon(request): DCNL 'The main Horizon context processor. Required for Horizon to function. DCNL It adds the Horizon config to the context as well as setting the names DCNL ``True`` and ``False`` in the context to their boolean equivalents DCNL for convenience. DCNL .. warning:: DCNL Don\'t put API calls in context processors; they will be called once DCNL for each template/template fragment which takes context that is used DCNL to render the complete output.'
def add_message(request, level, message, extra_tags='', fail_silently=False): DCNL 'Attempts to add a message to the request using the \'messages\' app.'
def debug(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``DEBUG`` level.'
def info(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``INFO`` level.'
def success(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``SUCCESS`` level.'
def warning(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``WARNING`` level.'
def error(request, message, extra_tags='', fail_silently=False): DCNL 'Adds a message with the ``ERROR`` level.'
def _current_component(view_func, dashboard=None, panel=None): DCNL 'Sets the currently-active dashboard and/or panel on the request.'
def require_auth(view_func): DCNL 'Performs user authentication check. DCNL Similar to Django\'s `login_required` decorator, except that this throws DCNL :exc:`~horizon.exceptions.NotAuthenticated` exception if the user is not DCNL signed-in.'
def require_perms(view_func, required): DCNL 'Enforces permission-based access controls. DCNL :param list required: A tuple of permission names, all of which the request DCNL user must possess in order access the decorated view. DCNL Example usage:: DCNL from horizon.decorators import require_perms DCNL @require_perms([\'foo.admin\', \'foo.member\']) DCNL def my_view(request): DCNL Raises a :exc:`~horizon.exceptions.NotAuthorized` exception if the DCNL requirements are not met.'
def check_message(keywords, message): DCNL 'Checks an exception for given keywords and raises a new ``ActionError`` DCNL with the desired message if the keywords are found. This allows selective DCNL control over API error messages.'
def handle(request, message=None, redirect=None, ignore=False, escalate=False, log_level=None, force_log=None): DCNL 'Centralized error handling for Horizon. DCNL Because Horizon consumes so many different APIs with completely DCNL different ``Exception`` types, it\'s necessary to have a centralized DCNL place for handling exceptions which may be raised. DCNL Exceptions are roughly divided into 3 types: DCNL #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization DCNL problems. These result in being logged out and sent to the login screen. DCNL #. ``NOT_FOUND``: Errors resulting from objects which could not be DCNL located via the API. These generally result in a user-facing error DCNL message, but are otherwise returned to the normal code flow. Optionally DCNL a redirect value may be passed to the error handler so users are DCNL returned to a different view than the one requested in addition to the DCNL error message. DCNL #. RECOVERABLE: Generic API errors which generate a user-facing message DCNL but drop directly back to the regular code flow. DCNL All other exceptions bubble the stack as normal unless the ``ignore`` DCNL argument is passed in as ``True``, in which case only unrecognized DCNL errors are bubbled. DCNL If the exception is not re-raised, an appropriate wrapper exception DCNL class indicating the type of exception that was encountered will be DCNL returned.'
@register.filter DCNL def has_permissions(user, component): DCNL 'Checks if the given user meets the permissions requirements for DCNL the component.'
@register.inclusion_tag('horizon/_nav_list.html', takes_context=True) DCNL def horizon_main_nav(context): DCNL 'Generates top-level dashboard navigation entries.'
@register.inclusion_tag('horizon/_subnav_list.html', takes_context=True) DCNL def horizon_dashboard_nav(context): DCNL 'Generates sub-navigation entries for the current dashboard.'
@register.inclusion_tag('horizon/common/_progress_bar.html') DCNL def horizon_progress_bar(current_val, max_val): DCNL 'Renders a progress bar based on parameters passed to the tag. The first DCNL parameter is the current value and the second is the max value. DCNL Example: ``{% progress_bar 25 50 %}`` DCNL This will generate a half-full progress bar. DCNL The rendered progress bar will fill the area of its container. To constrain DCNL the rendered size of the bar provide a container with appropriate width and DCNL height styles.'
@register.tag DCNL def jstemplate(parser, token): DCNL 'Replaces ``[[[`` and ``]]]`` with ``{{{`` and ``}}}``, DCNL ``[[`` and ``]]`` with ``{{`` and ``}}``  and DCNL ``[%`` and ``%]`` with ``{%`` and ``%}`` to avoid conflicts DCNL with Django\'s template engine when using any of the Mustache-based DCNL templating libraries.'
def vip_create(request, **kwargs): DCNL 'Create a vip for a specified pool. DCNL :param request: request context DCNL :param address: virtual IP address DCNL :param name: name for vip DCNL :param description: description for vip DCNL :param subnet_id: subnet_id for subnet of vip DCNL :param protocol_port: transport layer port number for vip DCNL :returns: Vip object'
def pool_create(request, **kwargs): DCNL 'Create a pool for specified protocol DCNL :param request: request context DCNL :param name: name for pool DCNL :param description: description for pool DCNL :param subnet_id: subnet_id for subnet of pool DCNL :param protocol: load balanced protocol DCNL :param lb_method: load balancer method DCNL :param admin_state_up: admin state (default on)'
def pool_health_monitor_create(request, **kwargs): DCNL 'Create a health monitor and associate with pool DCNL :param request: request context DCNL :param type: type of monitor DCNL :param delay: delay of monitor DCNL :param timeout: timeout of monitor DCNL :param max_retries: max retries [1..10] DCNL :param http_method: http method DCNL :param url_path: url path DCNL :param expected_codes: http return code DCNL :param admin_state_up: admin state'
def member_create(request, **kwargs): DCNL 'Create a load balance member DCNL :param request: request context DCNL :param pool_id: pool_id of pool for member DCNL :param address: IP address DCNL :param protocol_port: transport layer port number DCNL :param weight: weight for member DCNL :param admin_state_up: admin_state'
@memoized DCNL def flavor_list(request): DCNL 'Get the list of available instance sizes (flavors).'
def flavor_get_extras(request, flavor_id, raw=False): DCNL 'Get flavor extra specs.'
def flavor_extra_delete(request, flavor_id, keys): DCNL 'Unset the flavor extra spec keys.'
def flavor_extra_set(request, flavor_id, metadata): DCNL 'Set the flavor extra spec keys.'
def server_console_output(request, instance_id, tail_length=None): DCNL 'Gets console output of an instance.'
def server_security_groups(request, instance_id): DCNL 'Gets security groups of an instance.'
def volume_list(request, search_opts=None): DCNL 'To see all volumes in the cloud as an admin you can pass in a special DCNL search option: {\'all_tenants\': 1}'
def image_get(request, image_id): DCNL 'Returns an Image object populated with metadata for image DCNL with supplied identifier.'
def get_ipver_str(ip_version): DCNL 'Convert an ip version number to a human-friendly string'
def network_list_for_tenant(request, tenant_id, **params): DCNL 'Return a network list available for the tenant. DCNL The list contains networks owned by the tenant and public networks. DCNL If requested_networks specified, it searches requested_networks only.'
def network_create(request, **kwargs): DCNL 'Create a subnet on a specified network. DCNL :param request: request context DCNL :param tenant_id: (optional) tenant id of the network created DCNL :param name: (optional) name of the network created DCNL :returns: Subnet object'
def subnet_create(request, network_id, cidr, ip_version, **kwargs): DCNL 'Create a subnet on a specified network. DCNL :param request: request context DCNL :param network_id: network id a subnet is created on DCNL :param cidr: subnet IP address range DCNL :param ip_version: IP version (4 or 6) DCNL :param gateway_ip: (optional) IP address of gateway DCNL :param tenant_id: (optional) tenant id of the subnet created DCNL :param name: (optional) name of the subnet created DCNL :returns: Subnet object'
def port_create(request, network_id, **kwargs): DCNL 'Create a port on a specified network. DCNL :param request: request context DCNL :param network_id: network id a subnet is created on DCNL :param device_id: (optional) device id attached to the port DCNL :param tenant_id: (optional) tenant id of the port created DCNL :param name: (optional) name of the port created DCNL :returns: Port object'
def keystoneclient(request, admin=False): DCNL 'Returns a client connected to the Keystone backend. DCNL Several forms of authentication are supported: DCNL * Username + password -> Unscoped authentication DCNL * Username + password + tenant id -> Scoped authentication DCNL * Unscoped token -> Unscoped authentication DCNL * Unscoped token + tenant id -> Scoped authentication DCNL * Scoped token -> Scoped authentication DCNL Available services and data from the backend will vary depending on DCNL whether the authentication was scoped or unscoped. DCNL Lazy authentication if an ``endpoint`` parameter is provided. DCNL Calls requiring the admin endpoint should have ``admin=True`` passed in DCNL as a keyword argument. DCNL The client is cached so that subsequent API calls during the same DCNL request/response cycle don\'t have to be re-authenticated.'
def token_create_scoped(request, tenant, token): DCNL 'Creates a scoped token using the tenant id and unscoped token; retrieves DCNL the service catalog for the given tenant.'
def role_list(request): DCNL 'Returns a global list of available roles.'
def add_tenant_user_role(request, tenant_id, user_id, role_id): DCNL 'Adds a role for a user on a tenant.'
def remove_tenant_user_role(request, tenant_id, user_id, role_id): DCNL 'Removes a given single role for a user from a tenant.'
def remove_tenant_user(request, tenant_id, user_id): DCNL 'Removes all roles from a user on a tenant, removing them from it.'
def get_default_role(request): DCNL 'Gets the default role object from Keystone and saves it as a global DCNL since this is configured in settings and should not change from request DCNL to request. Supports lookup by name or id.'
def _objectify(items, container_name): DCNL 'Splits a listing of objects into their appropriate wrapper classes.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def get_int_or_uuid(value): DCNL 'Check if a value is valid as UUID or an integer. DCNL This method is mainly used to convert floating IP id to the DCNL appropriate type. For floating IP id, integer is used in Nova\'s DCNL original implementation, but UUID is used in Quantum based one.'
def openstack(request): DCNL 'Context processor necessary for OpenStack Dashboard functionality. DCNL The following variables are added to the request context: DCNL ``authorized_tenants`` DCNL A list of tenant objects which the current user has access to. DCNL ``regions`` DCNL A dictionary containing information about region support, the current DCNL region, and available regions.'
def cinder_todo_format(physical_line): DCNL 'Check for \'TODO()\'. DCNL cinder HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL N101'
def cinder_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL cinder HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL N201'
def cinder_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL cinder HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL N202'
def cinder_one_import_per_line(logical_line): DCNL 'Check for import format. DCNL cinder HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL BAD: from cinder.rpc.common import RemoteError, LOG DCNL N301'
def cinder_import_module_only(logical_line): DCNL 'Check for import module only. DCNL cinder HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL N302 import only modules DCNL N303 Invalid Import DCNL N304 Relative Import'
def cinder_import_alphabetical(physical_line, line_number, lines): DCNL 'Check for imports in alphabetical order. DCNL cinder HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL N306'
def cinder_docstring_start_space(physical_line): DCNL 'Check for docstring not start with space. DCNL cinder HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL N401'
def cinder_docstring_one_line(physical_line): DCNL 'Check one line docstring end. DCNL cinder HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in a period. DCNL N402'
def cinder_docstring_multiline_end(physical_line): DCNL 'Check multi line docstring end. DCNL cinder HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL N403'
def check_l18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def cinder_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL N701: bad localization call DCNL N702: complex expression instead of string as argument to _() DCNL N703: multiple positional placeholders'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_cinder(): DCNL 'Monkey patch in cinder guidelines. DCNL Look for functions that start with cinder_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def _translate_snapshot_detail_view(context, snapshot): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def _translate_attachment_detail_view(_context, vol): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(_context, vol): DCNL 'Maps keys for attachment summary view.'
def _translate_volume_detail_view(context, vol, image_id=None): DCNL 'Maps keys for volumes details view.'
def _translate_volume_summary_view(context, vol, image_id=None): DCNL 'Maps keys for volumes summary view.'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def _translate_snapshot_detail_view(context, snapshot): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def remove_invalid_options(context, filters, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def _list_hosts(req, service=None): DCNL 'Returns a summary list of hosts.'
def check_host(fn): DCNL 'Makes sure that the host exists.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail'
def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def limited_by_marker(items, request, max_limit=FLAGS.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.cinder.com/v1.1/123\' DCNL Returns: \'http://www.cinder.com/123\' DCNL Given: \'http://www.cinder.com/v1.1\' DCNL Returns: \'http://www.cinder.com\''
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def set_brain(brain): DCNL 'Set the brain used by enforce(). DCNL Defaults use Brain() if not set.'
def reset(): DCNL 'Clear the brain used by enforce().'
def enforce(match_list, target_dict, credentials_dict, exc=None, *args, **kwargs): DCNL 'Enforces authorization of some rules against credentials. DCNL :param match_list: nested tuples of data to match against DCNL The basic brain supports three types of match lists: DCNL 1) rules DCNL looks like: ``(\'rule:compute:get_instance\',)`` DCNL Retrieves the named rule from the rules dict and recursively DCNL checks against the contents of the rule. DCNL 2) roles DCNL looks like: ``(\'role:compute:admin\',)`` DCNL Matches if the specified role is in credentials_dict[\'roles\']. DCNL 3) generic DCNL looks like: ``(\'tenant_id:%(tenant_id)s\',)`` DCNL Substitutes values from the target dict into the match using DCNL the % operator and matches them against the creds dict. DCNL Combining rules: DCNL The brain returns True if any of the outer tuple of rules DCNL match and also True if all of the inner tuples match. You DCNL can use this to perform simple boolean logic.  For DCNL example, the following rule would return True if the creds DCNL contain the role \'admin\' OR the if the tenant_id matches DCNL the target dict AND the the creds contains the role DCNL \'compute_sysadmin\': DCNL "rule:combined": ( DCNL \'role:admin\', DCNL (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\') DCNL Note that rule and role are reserved words in the credentials match, so DCNL you can\'t match against properties with those names. Custom brains may DCNL also add new reserved words. For example, the HttpBrain adds http as a DCNL reserved word. DCNL :param target_dict: dict of object properties DCNL Target dicts contain as much information as we can about the object being DCNL operated on. DCNL :param credentials_dict: dict of actor properties DCNL Credentials dicts contain as much information as we can about the user DCNL performing the action. DCNL :param exc: exception to raise DCNL Class of the exception to raise if the check fails.  Any remaining DCNL arguments passed to enforce() (both positional and keyword arguments) DCNL will be passed to the exception class.  If exc is not provided, returns DCNL False. DCNL :return: True if the policy allows the action DCNL :return: False if the policy does not allow the action and exc is not set'
def register(name, func=None): DCNL 'Register a function as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default function DCNL will be registered. DCNL :param func: If given, provides the function to register.  If not DCNL given, returns a function taking one argument to DCNL specify the function to register, allowing use as a DCNL decorator.'
@register('rule') DCNL def _check_rule(brain, match_kind, match, target_dict, cred_dict): DCNL 'Recursively checks credentials based on the brains rules.'
@register('role') DCNL def _check_role(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check that there is a matching role in the cred dict.'
@register('http') DCNL def _check_http(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check http: rules by calling to a remote server. DCNL This example implementation simply verifies that the response is DCNL exactly \'True\'. A custom brain using response codes could easily DCNL be implemented.'
@register(None) DCNL def _check_generic(brain, match_kind, match, target_dict, cred_dict): DCNL 'Check an individual match. DCNL Matches look like: DCNL tenant:%(tenant_id)s DCNL role:compute:admin'
def int_from_bool_as_string(subject): DCNL 'Interpret a string as a boolean and return either 1 or 0. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def bool_from_string(subject): DCNL 'Interpret a string as a boolean. DCNL Any string value in: DCNL (\'True\', \'true\', \'On\', \'on\', \'Yes\', \'yes\', \'1\') DCNL is interpreted as a boolean True. DCNL Useful for JSON-decoded stuff and config file parsing'
def safe_decode(text, incoming=None, errors='strict'): DCNL 'Decodes incoming str using `incoming` if they\'re DCNL not already unicode. DCNL :param incoming: Text\'s current encoding DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a unicode `incoming` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def safe_encode(text, incoming=None, encoding='utf-8', errors='strict'): DCNL 'Encodes incoming str/unicode using `encoding`. If DCNL incoming is not specified, text is expected to DCNL be encoded with current python\'s default encoding. DCNL (`sys.getdefaultencoding`) DCNL :param incoming: Text\'s current encoding DCNL :param encoding: Expected encoding for text (Default UTF-8) DCNL :param errors: Errors handling policy. See here for valid DCNL values http://docs.python.org/2/library/codecs.html DCNL :returns: text or a bytestring `encoding` encoded DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None, subsecond=False): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def qemu_img_info(path): DCNL 'Return a object containing the parsed output from qemu-img info.'
def convert_image(source, dest, out_format): DCNL 'Convert image to other format'
def _parse_image_ref(image_href): DCNL 'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_id, host, port) DCNL :raises ValueError'
def _create_glance_client(context, host, port, use_ssl, version=FLAGS.glance_api_version): DCNL 'Instantiate a new glanceclient.Client object'
def get_api_servers(): DCNL 'Shuffle a list of FLAGS.glance_api_servers and return an iterator DCNL that will cycle through the list, looping around to the beginning DCNL if necessary.'
def _convert_timestamps_to_datetimes(image_meta): DCNL 'Returns image with timestamp fields converted to datetime objects.'
def _reraise_translated_image_exception(image_id): DCNL 'Transform the exception for the image but keep its traceback intact.'
def _reraise_translated_exception(): DCNL 'Transform the exception but keep its traceback intact.'
def get_remote_image_service(context, image_href): DCNL 'Create an image_service and parse the id from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\', DCNL or just an id such as \'b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\'. If the DCNL image_href is a standalone id, then the default image service is returned. DCNL :param image_href: href that describes the location of an image DCNL :returns: a tuple of the form (image_service, image_id)'
def find_config(config_path): DCNL 'Find a configuration file using the given hint. DCNL :param config_path: Full or relative path to the config. DCNL :returns: Full path of the config, if it exists. DCNL :raises: `cinder.exception.ConfigNotFound`'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/cinder/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper FLAG. DCNL :raises exception.Error: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=20, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'valid the address strictly as per format xxx.xxx.xxx.xxx. DCNL where xxx is a value between 0 and 255.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using FLAGS.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: \'cinder.api.ec2.cloud:\'      cinder.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See cinder.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
@contextlib.contextmanager DCNL def logging_error(message): DCNL 'Catches exception, write message to the log, re-raise. DCNL This is a common refinement of save_and_reraise that writes a specific DCNL message to the log.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def service_is_up(service): DCNL 'Check whether a service is up based on last heartbeat.'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def strcmp_const_time(s1, s2): DCNL 'Constant-time string comparison. DCNL :params s1: the first string DCNL :params s2: the second string DCNL :return: True if the strings are equal. DCNL This function takes two strings and compares them.  It is intended to be DCNL used when doing a comparison for authentication purposes to help guard DCNL against timing attacks.'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def enforce(context, action, target): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: cinder context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param object: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :raises cinder.exception.PolicyNotAuthorized: if verification fails.'
def check_is_admin(roles): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every tick DCNL of the periodic scheduler. DCNL 2. With arguments, @periodic_task(ticks_between_runs=N), this will be DCNL run on every N ticks of the periodic scheduler.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def register_models(): DCNL 'Register Models and create metadata. DCNL Called from cinder.db.sqlalchemy.__init__ as part of loading the driver, DCNL it will never need to be called explicitly elsewhere unless the DCNL connection is lost and needs to be reestablished.'
def upgrade(migrate_engine): DCNL 'Add source volume id column to volumes.'
def downgrade(migrate_engine): DCNL 'Remove source volume id column to volumes.'
def upgrade(migrate_engine): DCNL 'Convert volume_type_id to UUID.'
def downgrade(migrate_engine): DCNL 'Convert volume_type from UUID back to int.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def is_admin_context(context): DCNL 'Indicates if the request context is an administrator.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`authorize_project_context` and DCNL :py:func:`authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def require_volume_exists(f): DCNL 'Decorator to require the specified volume to exist. DCNL Requires the wrapped function to use context and volume_id as DCNL their first two arguments.'
def require_snapshot_exists(f): DCNL 'Decorator to require the specified snapshot to exist. DCNL Requires the wrapped function to use context and snapshot_id as DCNL their first two arguments.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _dict_with_extra_specs(inst_type_query): DCNL 'Takes an instance, volume, or instance type query returned DCNL by sqlalchemy and returns it as a dictionary, converting the DCNL extra_specs entry from a list of dicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single dict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'
def _quota_reservations(session, context, reservations): DCNL 'Return the relevant reservations.'
@require_admin_context DCNL def volume_type_create(context, values): DCNL 'Create a new instance type. In order to pass in extra specs, DCNL the values dict should contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'
@require_context DCNL def volume_type_get_all(context, inactive=False, filters=None): DCNL 'Returns a dict describing all volume_types with name as key.'
@require_context DCNL def volume_type_get(context, id, session=None): DCNL 'Returns a dict describing specific volume_type'
@require_context DCNL def volume_type_get_by_name(context, name, session=None): DCNL 'Returns a dict describing specific volume_type'
@require_context DCNL def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL 'Return volumes that were active during window.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_get(context, volume_id, session=None): DCNL 'Return the Glance metadata for the specified volume.'
@require_context DCNL @require_snapshot_exists DCNL def volume_snapshot_glance_metadata_get(context, snapshot_id, session=None): DCNL 'Return the Glance metadata for the specified snapshot.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_create(context, volume_id, key, value, session=None): DCNL 'Update the Glance metadata for a volume by adding a new key:value pair. DCNL This API does not support changing the value of a key once it has been DCNL created.'
@require_context DCNL @require_snapshot_exists DCNL def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id, session=None): DCNL 'Update the Glance metadata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the snapshot will retain the original metadata.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id, session=None): DCNL 'Update the Glance metadata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the volume (clone) will retain the original metadata.'
@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id, session=None): DCNL 'Update the Glance metadata from a volume (created from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metadata from the original volume is retained.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def service_destroy(context, service_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_all_volume_sorted(context): DCNL 'Get all volume services sorted by volume count. DCNL :returns: a list of (Service, volume_count) tuples.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of an service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on an service and update it. DCNL Raises NotFound if service does not exist.'
def migration_update(context, id, values): DCNL 'Update a migration instance.'
def migration_create(context, values): DCNL 'Create a migration record.'
def migration_get(context, migration_id): DCNL 'Finds a migration by the id.'
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL 'Finds a migration by the instance uuid its migrating.'
def migration_get_all_unconfirmed(context, confirm_window): DCNL 'Finds all unconfirmed migrations within the confirmation window.'
def iscsi_target_count_by_host(context, host): DCNL 'Return count of export devices.'
def iscsi_target_create_safe(context, values): DCNL 'Create an iscsi_target from the values dictionary. DCNL The device is not returned. If the create violates the unique DCNL constraints because the iscsi_target and host already exist, DCNL no exception is raised.'
def volume_allocate_iscsi_target(context, volume_id, host): DCNL 'Atomically allocate a free iscsi_target from the pool.'
def volume_attached(context, volume_id, instance_id, mountpoint): DCNL 'Ensure that a volume is set as attached.'
def volume_create(context, values): DCNL 'Create a volume from the values dictionary.'
def volume_data_get_for_host(context, host, session=None): DCNL 'Get (volume_count, gigabytes) for project.'
def volume_data_get_for_project(context, project_id, session=None): DCNL 'Get (volume_count, gigabytes) for project.'
def volume_destroy(context, volume_id): DCNL 'Destroy the volume or raise if it does not exist.'
def volume_detached(context, volume_id): DCNL 'Ensure that a volume is set as detached.'
def volume_get(context, volume_id): DCNL 'Get a volume or raise if it does not exist.'
def volume_get_all(context, marker, limit, sort_key, sort_dir): DCNL 'Get all volumes.'
def volume_get_all_by_host(context, host): DCNL 'Get all volumes belonging to a host.'
def volume_get_all_by_instance_uuid(context, instance_uuid): DCNL 'Get all volumes belonging to a instance.'
def volume_get_all_by_project(context, project_id, marker, limit, sort_key, sort_dir): DCNL 'Get all volumes belonging to a project.'
def volume_get_iscsi_target_num(context, volume_id): DCNL 'Get the target num (tid) allocated to the volume.'
def volume_update(context, volume_id, values): DCNL 'Set the given properties on an volume and update it. DCNL Raises NotFound if volume does not exist.'
def snapshot_create(context, values): DCNL 'Create a snapshot from the values dictionary.'
def snapshot_destroy(context, snapshot_id): DCNL 'Destroy the snapshot or raise if it does not exist.'
def snapshot_get(context, snapshot_id): DCNL 'Get a snapshot or raise if it does not exist.'
def snapshot_get_all(context): DCNL 'Get all snapshots.'
def snapshot_get_all_by_project(context, project_id): DCNL 'Get all snapshots belonging to a project.'
def snapshot_get_all_for_volume(context, volume_id): DCNL 'Get all snapshots for a volume.'
def snapshot_update(context, snapshot_id, values): DCNL 'Set the given properties on an snapshot and update it. DCNL Raises NotFound if snapshot does not exist.'
def snapshot_data_get_for_project(context, project_id, session=None): DCNL 'Get count and gigabytes used for snapshots for specified project.'
def snapshot_metadata_get(context, snapshot_id): DCNL 'Get all metadata for a snapshot.'
def snapshot_metadata_delete(context, snapshot_id, key): DCNL 'Delete the given metadata item.'
def snapshot_metadata_update(context, snapshot_id, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def volume_metadata_get(context, volume_id): DCNL 'Get all metadata for a volume.'
def volume_metadata_delete(context, volume_id, key): DCNL 'Delete the given metadata item.'
def volume_metadata_update(context, volume_id, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def volume_type_create(context, values): DCNL 'Create a new volume type.'
def volume_type_get_all(context, inactive=False): DCNL 'Get all volume types.'
def volume_type_get(context, id): DCNL 'Get volume type by id.'
def volume_type_get_by_name(context, name): DCNL 'Get volume type by name.'
def volume_type_destroy(context, id): DCNL 'Delete a volume type.'
def volume_get_active_by_window(context, begin, end=None, project_id=None): DCNL 'Get all the volumes inside the window. DCNL Specifying a project_id will filter for a certain project.'
def volume_type_extra_specs_get(context, volume_type_id): DCNL 'Get all extra specs for a volume type.'
def volume_type_extra_specs_delete(context, volume_type_id, key): DCNL 'Delete the given extra specs item.'
def volume_type_extra_specs_update_or_create(context, volume_type_id, extra_specs): DCNL 'Create or update volume type extra specs. This adds or modifies the DCNL key/value pairs specified in the extra specs dict argument'
def volume_glance_metadata_create(context, volume_id, key, value): DCNL 'Update the Glance metadata for the specified volume.'
def volume_glance_metadata_get(context, volume_id): DCNL 'Return the glance metadata for a volume.'
def volume_snapshot_glance_metadata_get(context, snapshot_id): DCNL 'Return the Glance metadata for the specified snapshot.'
def volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id): DCNL 'Update the Glance metadata for a snapshot by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the snapshot will retain the original metadata.'
def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id): DCNL 'Update the Glance metadata from a volume (created from a snapshot) by DCNL copying all of the key:value pairs from the originating snapshot. This is DCNL so that the Glance metadata from the original volume is retained.'
def volume_glance_metadata_delete_by_volume(context, volume_id): DCNL 'Delete the glance metadata for a volume.'
def volume_glance_metadata_delete_by_snapshot(context, snapshot_id): DCNL 'Delete the glance metadata for a snapshot.'
def volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id): DCNL 'Update the Glance metadata for a volume by copying all of the key:value DCNL pairs from the originating volume. This is so that a volume created from DCNL the volume (clone) will retain the original metadata.'
def sm_backend_conf_create(context, values): DCNL 'Create a new SM Backend Config entry.'
def sm_backend_conf_update(context, sm_backend_conf_id, values): DCNL 'Update a SM Backend Config entry.'
def sm_backend_conf_delete(context, sm_backend_conf_id): DCNL 'Delete a SM Backend Config.'
def sm_backend_conf_get(context, sm_backend_conf_id): DCNL 'Get a specific SM Backend Config.'
def sm_backend_conf_get_by_sr(context, sr_uuid): DCNL 'Get a specific SM Backend Config.'
def sm_backend_conf_get_all(context): DCNL 'Get all SM Backend Configs.'
def sm_flavor_create(context, values): DCNL 'Create a new SM Flavor entry.'
def sm_flavor_update(context, sm_flavor_id, values): DCNL 'Update a SM Flavor entry.'
def sm_flavor_delete(context, sm_flavor_id): DCNL 'Delete a SM Flavor.'
def sm_flavor_get(context, sm_flavor): DCNL 'Get a specific SM Flavor.'
def sm_flavor_get_all(context): DCNL 'Get all SM Flavors.'
def sm_volume_create(context, values): DCNL 'Create a new child Zone entry.'
def sm_volume_update(context, volume_id, values): DCNL 'Update a child Zone entry.'
def sm_volume_delete(context, volume_id): DCNL 'Delete a child Zone.'
def sm_volume_get(context, volume_id): DCNL 'Get a specific child Zone.'
def sm_volume_get_all(context): DCNL 'Get all child Zones.'
def quota_create(context, project_id, resource, limit): DCNL 'Create a quota for the given project and resource.'
def quota_get(context, project_id, resource): DCNL 'Retrieve a quota or raise if it does not exist.'
def quota_get_all_by_project(context, project_id): DCNL 'Retrieve all quotas associated with a given project.'
def quota_update(context, project_id, resource, limit): DCNL 'Update a quota or raise if it does not exist.'
def quota_destroy(context, project_id, resource): DCNL 'Destroy the quota or raise if it does not exist.'
def quota_class_create(context, class_name, resource, limit): DCNL 'Create a quota class for the given name and resource.'
def quota_class_get(context, class_name, resource): DCNL 'Retrieve a quota class or raise if it does not exist.'
def quota_class_get_all_by_name(context, class_name): DCNL 'Retrieve all quotas associated with a given quota class.'
def quota_class_update(context, class_name, resource, limit): DCNL 'Update a quota class or raise if it does not exist.'
def quota_class_destroy(context, class_name, resource): DCNL 'Destroy the quota class or raise if it does not exist.'
def quota_class_destroy_all_by_name(context, class_name): DCNL 'Destroy all quotas associated with a given quota class.'
def quota_usage_create(context, project_id, resource, in_use, reserved, until_refresh): DCNL 'Create a quota usage for the given project and resource.'
def quota_usage_get(context, project_id, resource): DCNL 'Retrieve a quota usage or raise if it does not exist.'
def quota_usage_get_all_by_project(context, project_id): DCNL 'Retrieve all usage associated with a given resource.'
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL 'Create a reservation for the given project and resource.'
def reservation_get(context, uuid): DCNL 'Retrieve a reservation or raise if it does not exist.'
def reservation_get_all_by_project(context, project_id): DCNL 'Retrieve all reservations associated with a given project.'
def reservation_destroy(context, uuid): DCNL 'Destroy the reservation or raise if it does not exist.'
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL 'Check quotas and create appropriate reservations.'
def reservation_commit(context, reservations, project_id=None): DCNL 'Commit quota reservations.'
def reservation_rollback(context, reservations, project_id=None): DCNL 'Roll back quota reservations.'
def quota_destroy_all_by_project(context, project_id): DCNL 'Destroy all quotas associated with a given project.'
def reservation_expire(context): DCNL 'Roll back any expired reservations.'
def backup_get(context, backup_id): DCNL 'Get a backup or raise if it does not exist.'
def backup_get_all(context): DCNL 'Get all backups.'
def backup_get_all_by_host(context, host): DCNL 'Get all backups belonging to a host.'
def backup_create(context, values): DCNL 'Create a backup from the values dictionary.'
def backup_get_all_by_project(context, project_id): DCNL 'Get all backups belonging to a project.'
def backup_update(context, backup_id, values): DCNL 'Set the given properties on a backup and update it. DCNL Raises NotFound if backup does not exist.'
def backup_destroy(context, backup_id): DCNL 'Destroy the backup or raise if it does not exist.'
def volume_update_db(context, volume_id, host): DCNL 'Set the host and set the scheduled_at field of a volume. DCNL :returns: A Volume with the updated fields set properly.'
def skip_if_fake(func): DCNL 'Decorator that skips a test if running in fake mode.'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def compare_links(actual, expected): DCNL 'Compare xml atom links.'
def compare_media_types(actual, expected): DCNL 'Compare xml media types.'
def compare_tree_to_dict(actual, expected, keys): DCNL 'Compare parts of lxml.etree objects to dicts.'
def example_decorator(name, function): DCNL 'decorator for notify which is used from utils.monkey_patch(). DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def serialize_args(*args, **kwargs): DCNL 'Workaround for float string conversion issues in Python 2.6.'
def fake_execute_set_repliers(repliers): DCNL 'Allows the client to configure replies to commands.'
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL 'A reply handler for commands that haven\'t been added to the reply list. DCNL Returns empty strings for stdout and stderr.'
def fake_execute(*cmd_parts, **kwargs): DCNL 'This function stubs out execute. DCNL It optionally executes a preconfigued function to return expected data.'
def stub_out(stubs, funcs): DCNL 'Set the stubs in mapping in the db api.'
def stub_out_https_backend(stubs): DCNL 'Stubs out the httplib.HTTPRequest.getresponse to return DCNL faked-out data instead of grabbing actual contents of a resource DCNL The stubbed getresponse() returns an iterator over DCNL the data "I am a teapot, short and stout DCNL :param stubs: Set of stubout stubs'
def generate_random_alphanumeric(length): DCNL 'Creates a random alphanumeric string of specified length.'
def generate_random_numeric(length): DCNL 'Creates a random numeric string of specified length.'
def generate_new_element(items, prefix, numeric=False): DCNL 'Creates a random string with prefix, that is not in \'items\' list.'
def _get_connect_string(backend, user='openstack_citest', passwd='openstack_citest', database='openstack_citest'): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def create(context, name, extra_specs={}): DCNL 'Creates volume types.'
def destroy(context, id): DCNL 'Marks volume types as deleted.'
def get_all_types(context, inactive=0, search_opts={}): DCNL 'Get all non-deleted volume_types. DCNL Pass true as argument if you want deleted volume types returned also.'
def get_volume_type(ctxt, id): DCNL 'Retrieves single volume type by id.'
def get_volume_type_by_name(context, name): DCNL 'Retrieves single volume type by name.'
def get_default_volume_type(): DCNL 'Get the default volume type.'
def notify_usage_exists(context, volume_ref, current_period=False): DCNL 'Generates \'exists\' notification for a volume for usage auditing DCNL purposes. DCNL Generates usage for last completed period, unless \'current_period\' DCNL is True.'
def wrap_check_policy(func): DCNL 'Check policy corresponding to the wrapped methods prior to execution DCNL This decorator requires the first 3 args of the wrapped function DCNL to be (self, context, volume)'
def connect_ec2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): DCNL ':type aws_access_key_id: string DCNL :param aws_access_key_id: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL :rtype: :class:`boto.ec2.connection.EC2Connection` DCNL :return: A connection to Amazon\'s EC2'
def excluded(self, filename): DCNL 'Check if options.exclude contains a pattern that matches filename.'
def input_dir(self, dirname): DCNL 'Check all files in this directory and all subdirectories.'
def nova_todo_format(physical_line, tokens): DCNL 'Check for \'TODO()\'. DCNL nova HACKING guide recommendation for TODO: DCNL Include your name with TODOs as in "#TODO(termie)" DCNL Okay: #TODO(sdague) DCNL N101: #TODO fail DCNL N101: #TODO (jogo) fail'
def nova_except_format(logical_line): DCNL 'Check for \'except:\'. DCNL nova HACKING guide recommends not using except: DCNL Do not write "except:", use "except Exception:" at the very least DCNL Okay: except Exception: DCNL N201: except:'
def nova_except_format_assert(logical_line): DCNL 'Check for \'assertRaises(Exception\'. DCNL nova HACKING guide recommends not using assertRaises(Exception...): DCNL Do not use overly broad Exception type DCNL Okay: self.assertRaises(NovaException) DCNL N202: self.assertRaises(Exception)'
def nova_import_rules(logical_line): DCNL 'Check for imports. DCNL nova HACKING guide recommends one import per line: DCNL Do not import more than one module per line DCNL Examples: DCNL Okay: from nova.compute import api DCNL N301: from nova.compute import api, utils DCNL Imports should usually be on separate lines. DCNL nova HACKING guide recommends importing only modules: DCNL Do not import objects, only modules DCNL Examples: DCNL Okay: from os import path DCNL Okay: from os import path as p DCNL Okay: from os import (path as p) DCNL Okay: import os.path DCNL Okay: from nova.compute import rpcapi DCNL N302: from os.path import dirname as dirname2 DCNL N302: from os.path import (dirname as dirname2) DCNL N303: from os.path import * DCNL N304: from .compute import rpcapi'
def nova_import_alphabetical(logical_line, blank_lines, previous_logical, indent_level, previous_indent_level): DCNL 'Check for imports in alphabetical order. DCNL nova HACKING guide recommendation for imports: DCNL imports in human alphabetical order DCNL Okay: import os\nimport sys\n\nimport nova\nfrom nova import test DCNL N306: import sys\nimport os'
def nova_import_no_db_in_virt(logical_line, filename): DCNL 'Check for db calls from nova/virt DCNL As of grizzly-2 all the database calls have been removed from DCNL nova/virt, and we want to keep it that way. DCNL N307'
def is_docstring(physical_line, previous_logical): DCNL 'Return True if found docstring DCNL \'A docstring is a string literal that occurs as the first statement in a DCNL module, function, class,\' DCNL http://www.python.org/dev/peps/pep-0257/#what-is-a-docstring'
def nova_docstring_start_space(physical_line, previous_logical): DCNL 'Check for docstring not start with space. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should not start with space DCNL Okay: def foo():\n    \'\'\'This is good.\'\'\' DCNL Okay: def foo():\n    a = \'\'\' This is not a docstring.\'\'\' DCNL Okay: def foo():\n    pass\n    \'\'\' This is not.\'\'\' DCNL N401: def foo():\n    \'\'\' This is not.\'\'\''
def nova_docstring_one_line(physical_line, previous_logical): DCNL 'Check one line docstring end. DCNL nova HACKING guide recommendation for one line docstring: DCNL A one line docstring looks like this and ends in punctuation. DCNL Okay: def foo():\n    \'\'\'This is good.\'\'\' DCNL Okay: def foo():\n    \'\'\'This is good too!\'\'\' DCNL Okay: def foo():\n    \'\'\'How about this?\'\'\' DCNL Okay: def foo():\n    a = \'\'\'This is not a docstring\'\'\' DCNL Okay: def foo():\n    pass\n    \'\'\'This is not a docstring\'\'\' DCNL Okay: class Foo:\n    pass\n    \'\'\'This is not a docstring\'\'\' DCNL N402: def foo():\n    \'\'\'This is not\'\'\' DCNL N402: def foo():\n    \'\'\'Bad punctuation,\'\'\' DCNL N402: class Foo:\n    \'\'\'Bad punctuation,\'\'\''
def nova_docstring_multiline_end(physical_line, previous_logical, tokens): DCNL 'Check multi line docstring end. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should end on a new line DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: class Foo:\n    \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    a = \'\'\'not\na\ndocstring\'\'\' DCNL Okay: def foo():\n    pass\n\'\'\'foobar\nfoo\nbar\n   d\'\'\' DCNL N403: def foo():\n    \'\'\'foobar\nfoo\nbar\ndocstring\'\'\' DCNL N403: class Foo:\n    \'\'\'foobar\nfoo\nbar\ndocstring\'\'\'\n\n'
def nova_docstring_multiline_start(physical_line, previous_logical, tokens): DCNL 'Check multi line docstring start with summary. DCNL nova HACKING guide recommendation for docstring: DCNL Docstring should start with A multi line docstring has a one-line summary DCNL Okay: \'\'\'foobar\nfoo\nbar\n\'\'\' DCNL Okay: def foo():\n    a = \'\'\'\nnot\na docstring\n\'\'\' DCNL N404: def foo():\n\'\'\'\nfoo\nbar\n\'\'\'\n\n'
def nova_no_cr(physical_line): DCNL 'Check that we only use newlines not carriage returns. DCNL Okay: import os\nimport sys DCNL # pep8 doesn\'t yet replace \r in strings, will work on an DCNL # upstream fix DCNL N901 import os\r\nimport sys'
def check_i18n(): DCNL 'Generator that checks token stream for localization errors. DCNL Expects tokens to be ``send``ed one by one. DCNL Raises LocalizationError if some error is found.'
def nova_localization_strings(logical_line, tokens): DCNL 'Check localization in line. DCNL Okay: _("This is fine") DCNL Okay: _("This is also fine %s") DCNL N701: _(\'\') DCNL N702: _("Bob" + " foo") DCNL N702: _("Bob %s" % foo) DCNL # N703 check is not quite right, disabled by removing colon DCNL N703 _("%s %s" % (foo, bar))'
def nova_is_not(logical_line): DCNL 'Check localization in line. DCNL Okay: if x is not y DCNL N901: if not X is Y DCNL N901: if not X.B is Y'
def nova_not_in(logical_line): DCNL 'Check localization in line. DCNL Okay: if x not in y DCNL Okay: if not (X in Y or X is Z) DCNL Okay: if not (X in Y) DCNL N902: if not X in Y DCNL N902: if not X.B in Y'
def readlines(filename): DCNL 'Record the current file being tested.'
def add_nova(): DCNL 'Monkey patch in nova guidelines. DCNL Look for functions that start with nova_  and have arguments DCNL and add them to pep8 module DCNL Assumes you know how to write pep8.py checks'
def once_git_check_commit_title(): DCNL 'Check git commit messages. DCNL nova HACKING recommends not referencing a bug or blueprint in first line, DCNL it should provide an accurate description of the change DCNL N801 DCNL N802 Title limited to 72 chars'
def _bytes2int(bytes): DCNL 'Convert bytes to int.'
def _parse_network_details(machine_id): DCNL 'Parse the machine_id to get MAC, IP, Netmask and Gateway fields per NIC. DCNL machine_id is of the form (\'NIC_record#NIC_record#\', \'\') DCNL Each of the NIC will have record NIC_record in the form DCNL \'MAC;IP;Netmask;Gateway;Broadcast;DNS\' where \';\' is field separator. DCNL Each record is separated by \'#\' from next record.'
def _get_windows_network_adapters(): DCNL 'Get the list of windows network adapters.'
def _get_linux_network_adapters(): DCNL 'Get the list of Linux network adapters.'
def _get_adapter_name_and_ip_address(network_adapters, mac_address): DCNL 'Get the adapter name based on the MAC address.'
def _get_win_adapter_name_and_ip_address(mac_address): DCNL 'Get Windows network adapter name.'
def _get_linux_adapter_name_and_ip_address(mac_address): DCNL 'Get Linux network adapter name.'
def _execute(cmd_list, process_input=None, check_exit_code=True): DCNL 'Executes the command with the list of arguments specified.'
def _windows_set_networking(): DCNL 'Set IP address for the windows VM.'
def _set_rhel_networking(network_details=None): DCNL 'Set IPv4 network settings for RHEL distros.'
def _set_ubuntu_networking(network_details=None): DCNL 'Set IPv4 network settings for Ubuntu.'
def _linux_set_networking(): DCNL 'Set IP address for the Linux VM.'
def call_xenapi(xenapi, method, *args): DCNL 'Make a call to xapi.'
def find_orphaned_instances(xenapi): DCNL 'Find and return a list of orphaned instances.'
def cleanup_instance(xenapi, instance, vm_ref, vm_rec): DCNL 'Delete orphaned instances.'
def _get_applicable_vm_recs(xenapi): DCNL 'An \'applicable\' VM is one that is not a template and not the control DCNL domain.'
def print_xen_object(obj_type, obj, indent_level=0, spaces_per_indent=4): DCNL 'Pretty-print a Xen object. DCNL Looks like: DCNL VM (abcd-abcd-abcd): \'name label here\''
def _find_vdis_connected_to_vm(xenapi, connected_vdi_uuids): DCNL 'Find VDIs which are connected to VBDs which are connected to VMs.'
def _find_all_vdis_and_system_vdis(xenapi, all_vdi_uuids, connected_vdi_uuids): DCNL 'Collects all VDIs and adds system VDIs to the connected set.'
def find_orphaned_vdi_uuids(xenapi): DCNL 'Walk VM -> VBD -> VDI change and accumulate connected VDIs.'
def list_orphaned_vdis(vdi_uuids): DCNL 'List orphaned VDIs.'
def clean_orphaned_vdis(xenapi, vdi_uuids): DCNL 'Clean orphaned VDIs.'
def list_orphaned_instances(orphaned_instances): DCNL 'List orphaned instances.'
def clean_orphaned_instances(xenapi, orphaned_instances): DCNL 'Clean orphaned instances.'
def main(): DCNL 'Main loop.'
def _sanitize_default(s): DCNL 'Set up a reasonably sensible default for pybasedir, my_ip and host.'
def execute_get_output(*command): DCNL 'Execute and return stdout.'
def execute(*command): DCNL 'Execute without returning stdout.'
def validate_exists(args, key, default=None): DCNL 'Validates that a string argument to a RPC method call is given, and DCNL matches the shell-safe regex, with an optional default value in case it DCNL does not exist. DCNL Returns the string.'
def validate_bool(args, key, default=None): DCNL 'Validates that a string argument to a RPC method call is a boolean DCNL string, with an optional default value in case it does not exist. DCNL Returns the python boolean value.'
def exists(args, key): DCNL 'Validates that a freeform string argument to a RPC method call is given. DCNL Returns the string.'
def optional(args, key): DCNL 'If the given key is in args, return the corresponding value, otherwise DCNL return None'
def vbd_unplug_with_retry(session, vbd): DCNL 'Call VBD.unplug on the given VBD, with a retry if we get DCNL DEVICE_DETACH_REJECTED.  For reasons which I don\'t understand, we\'re DCNL seeing the device still in use, even when all processes using the device DCNL should be dead.'
def _record_exists(arg_dict): DCNL 'Returns whether or not the given record exists. The record path DCNL is determined from the given path and dom_id in the arg_dict.'
@jsonify DCNL def read_record(self, arg_dict): DCNL 'Returns the value stored at the given path for the given dom_id. DCNL These must be encoded as key/value pairs in arg_dict. You can DCNL optinally include a key \'ignore_missing_path\'; if this is present DCNL and boolean True, attempting to read a non-existent path will return DCNL the string \'None\' instead of raising an exception.'
@jsonify DCNL def write_record(self, arg_dict): DCNL 'Writes to xenstore at the specified path. If there is information DCNL already stored in that location, it is overwritten. As in read_record, DCNL the dom_id and path must be specified in the arg_dict; additionally, DCNL you must specify a \'value\' key, whose value must be a string. Typically, DCNL you can json-ify more complex values and store the json output.'
@jsonify DCNL def list_records(self, arg_dict): DCNL 'Returns all the stored data at or below the given path for the DCNL given dom_id. The data is returned as a json-ified dict, with the DCNL path as the key and the stored value as the value. If the path DCNL doesn\'t exist, an empty dict is returned.'
@jsonify DCNL def delete_record(self, arg_dict): DCNL 'Just like it sounds: it removes the record for the specified DCNL VM and the specified path from xenstore.'
def _paths_from_ls(recs): DCNL 'The xenstore-ls command returns a listing that isn\'t terribly DCNL useful. This method cleans that up into a dict with each path DCNL as the key, and the associated string as the value.'
def _run_command(cmd): DCNL 'Abstracts out the basics of issuing system commands. If the command DCNL returns anything in stderr, a PluginError is raised with that information. DCNL Otherwise, a tuple of (return code, stdout data) is returned.'
def make_subprocess(cmdline, stdout=False, stderr=False, stdin=False, universal_newlines=False): DCNL 'Make a subprocess according to the given command-line string'
def finish_subprocess(proc, cmdline, ok_exit_codes=None): DCNL 'Ensure that the process returned a zero exit code indicating success'
def make_staging_area(sr_path): DCNL 'The staging area is a place where we can temporarily store and DCNL manipulate VHDs. The use of the staging area is different for upload and DCNL download: DCNL Download DCNL When we download the tarball, the VHDs contained within will have names DCNL like "snap.vhd" and "image.vhd". We need to assign UUIDs to them before DCNL moving them into the SR. However, since \'image.vhd\' may be a base_copy, we DCNL need to link it to \'snap.vhd\' (using vhd-util modify) before moving both DCNL into the SR (otherwise the SR.scan will cause \'image.vhd\' to be deleted). DCNL The staging area gives us a place to perform these operations before they DCNL are moved to the SR, scanned, and then registered with XenServer. DCNL Upload DCNL On upload, we want to rename the VHDs to reflect what they are, \'snap.vhd\' DCNL in the case of the snapshot VHD, and \'image.vhd\' in the case of the DCNL base_copy. The staging area provides a directory in which we can create DCNL hard-links to rename the VHDs without affecting what\'s in the SR. DCNL NOTE DCNL The staging area is created as a subdirectory within the SR in order to DCNL guarantee that it resides within the same filesystem and therefore permit DCNL hard-linking and cheap file moves.'
def cleanup_staging_area(staging_path): DCNL 'Remove staging area directory DCNL On upload, the staging area contains hard-links to the VHDs in the SR; DCNL it\'s safe to remove the staging-area because the SR will keep the link DCNL count > 0 (so the VHDs in the SR will not be deleted).'
def _handle_old_style_images(staging_path): DCNL 'Rename files to conform to new image format, if needed. DCNL Old-Style: DCNL snap.vhd -> image.vhd -> base.vhd DCNL New-Style: DCNL 0.vhd -> 1.vhd -> ... (n-1).vhd DCNL The New-Style format has the benefit of being able to support a VDI chain DCNL of arbitrary length.'
def _assert_vhd_not_hidden(path): DCNL 'Sanity check to ensure that only appropriate VHDs are marked as hidden. DCNL If this flag is incorrectly set, then when we move the VHD into the SR, it DCNL will be deleted out from under us.'
def _validate_footer_timestamp(vdi_path): DCNL 'This check ensures that the timestamps listed in the VHD footer aren\'t in DCNL the future.  This can occur during a migration if the clocks on the the two DCNL Dom0\'s are out-of-sync. This would corrupt the SR if it were imported, so DCNL generate an exception to bail.'
def _validate_vdi_chain(vdi_path): DCNL 'This check ensures that the parent pointers on the VHDs are valid DCNL before we move the VDI chain to the SR. This is *very* important DCNL because a bad parent pointer will corrupt the SR causing a cascade of DCNL failures.'
def _validate_sequenced_vhds(staging_path): DCNL 'This check ensures that the VHDs in the staging area are sequenced DCNL properly from 0 to n-1 with no gaps.'
def import_vhds(sr_path, staging_path, uuid_stack): DCNL 'Move VHDs from staging area into the SR. DCNL The staging area is necessary because we need to perform some fixups DCNL (assigning UUIDs, relinking the VHD chain) before moving into the SR, DCNL otherwise the SR manager process could potentially delete the VHDs out from DCNL under us. DCNL Returns: A dict of imported VHDs: DCNL {\'root\': {\'uuid\': \'ffff-aaaa\'}}'
def prepare_staging_area(sr_path, staging_path, vdi_uuids, seq_num=0): DCNL 'Hard-link VHDs into staging area.'
def create_tarball(fileobj, path, callback=None): DCNL 'Create a tarball from a given path. DCNL :param fileobj: a file-like object holding the tarball byte-stream. DCNL If None, then only the callback will be used. DCNL :param path: path to create tarball from DCNL :param callback: optional callback to call on each chunk written'
def extract_tarball(fileobj, path, callback=None): DCNL 'Extract a tarball to a given path. DCNL :param fileobj: a file-like object holding the tarball byte-stream DCNL :param path: path to extract tarball into DCNL :param callback: optional callback to call on each chunk read'
def register_plugin_calls(*funcs): DCNL 'Wrapper around XenAPIPlugin.dispatch which handles pickle DCNL serialization.'
def serializers(**serializers): DCNL 'Attaches serializers to a method. DCNL This decorator associates a dictionary of serializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def deserializers(**deserializers): DCNL 'Attaches deserializers to a method. DCNL This decorator associates a dictionary of deserializers with a DCNL method.  Note that the function attributes are directly DCNL manipulated; the method is not wrapped.'
def response(code): DCNL 'Attaches response code to a method. DCNL This decorator associates a response code with a method.  Note DCNL that the function attributes are directly manipulated; the method DCNL is not wrapped.'
def action_peek_json(body): DCNL 'Determine action to invoke.'
def action_peek_xml(body): DCNL 'Determine action to invoke.'
def action(name): DCNL 'Mark a function as an action. DCNL The given name will be taken as the action key in the body. DCNL This is also overloaded to allow extensions to provide DCNL non-extending definitions of create and delete operations.'
def extends(*args, **kwargs): DCNL 'Indicate a function extends an operation. DCNL Can be used as either:: DCNL @extends DCNL def index(...): DCNL pass DCNL or as:: DCNL @extends(action=\'resize\') DCNL def _action_resize(...): DCNL pass'
def get_items(obj): DCNL 'Get items in obj.'
def SubTemplateElement(parent, tag, attrib=None, selector=None, subselector=None, **extra): DCNL 'Create a template element as a child of another. DCNL Corresponds to the etree.SubElement interface.  Parameters are as DCNL for TemplateElement, with the addition of the parent.'
def make_links(parent, selector=None): DCNL 'Attach an Atom <links> element to the parent.'
def make_flat_dict(name, selector=None, subselector=None, ns=None): DCNL 'Utility for simple XML templates that traditionally used DCNL XMLDictSerializer with no metadata.  Returns a template element DCNL where the top-level element has the given tag name, and where DCNL sub-elements have tag names derived from the object\'s keys and DCNL text derived from the object\'s values.  This only works for flat DCNL dictionary objects, not dictionaries containing nested lists or DCNL dictionaries.'
def safe_minidom_parse_string(xml_string): DCNL 'Parse an XML string using minidom safely.'
def wrap_errors(fn): DCNL 'Ensure errors are not passed along.'
def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL 'Registers all standard API extensions.'
def status_from_state(vm_state, task_state='default'): DCNL 'Given vm_state and task_state, return a status string.'
def vm_state_from_status(status): DCNL 'Map the server status string to a vm state.'
def get_pagination_params(request): DCNL 'Return marker, limit tuple from request. DCNL :param request: `wsgi.Request` possibly containing \'marker\' and \'limit\' DCNL GET variables. \'marker\' is the id of the last element DCNL the client has seen, and \'limit\' is the maximum number DCNL of items to return. If \'limit\' is not specified, 0, or DCNL > max_limit, we default to max_limit. Negative values DCNL for either marker or limit will cause DCNL exc.HTTPBadRequest() exceptions to be raised.'
def _get_limit_param(request): DCNL 'Extract integer limit from request or fail.'
def _get_marker_param(request): DCNL 'Extract marker id from request or fail.'
def limited(items, request, max_limit=CONF.osapi_max_limit): DCNL 'Return a slice of items according to requested offset and limit. DCNL :param items: A sliceable entity DCNL :param request: ``wsgi.Request`` possibly containing \'offset\' and \'limit\' DCNL GET variables. \'offset\' is where to start in the list, DCNL and \'limit\' is the maximum number of items to return. If DCNL \'limit\' is not specified, 0, or > max_limit, we default DCNL to max_limit. Negative values for either offset or limit DCNL will cause exc.HTTPBadRequest() exceptions to be raised. DCNL :kwarg max_limit: The maximum number of items to return from \'items\''
def get_limit_and_marker(request, max_limit=CONF.osapi_max_limit): DCNL 'get limited parameter from request.'
def limited_by_marker(items, request, max_limit=CONF.osapi_max_limit): DCNL 'Return a slice of items according to the requested marker and limit.'
def get_id_from_href(href): DCNL 'Return the id or uuid portion of a url. DCNL Given: \'http://www.foo.com/bar/123?q=4\' DCNL Returns: \'123\' DCNL Given: \'http://www.foo.com/bar/abc123?q=4\' DCNL Returns: \'abc123\''
def remove_version_from_href(href): DCNL 'Removes the first api version from the href. DCNL Given: \'http://www.nova.com/v1.1/123\' DCNL Returns: \'http://www.nova.com/123\' DCNL Given: \'http://www.nova.com/v1.1\' DCNL Returns: \'http://www.nova.com\''
def get_networks_for_instance(context, instance): DCNL 'Returns a prepared nw_info list for passing into the view builders DCNL We end up with a data structure like:: DCNL {\'public\': {\'ips\': [{\'addr\': \'10.0.0.1\', \'version\': 4}, DCNL {\'addr\': \'2001::1\', \'version\': 6}], DCNL \'floating_ips\': [{\'addr\': \'172.16.0.1\', \'version\': 4}, DCNL {\'addr\': \'172.16.2.1\', \'version\': 4}]},'
def raise_http_conflict_for_instance_invalid_state(exc, action): DCNL 'Return a webob.exc.HTTPConflict instance containing a message DCNL appropriate to return via the API based on the original DCNL InstanceInvalidState exception.'
def _translate_keys(cons): DCNL 'Coerces a console instance into proper dictionary format.'
def _translate_detail_keys(cons): DCNL 'Coerces a console instance into proper dictionary format with DCNL correctly mapped attributes'
def remove_invalid_options(context, search_options, allowed_search_options): DCNL 'Remove search options that are not valid for non-admin API/context.'
def _unquote_domain(domain): DCNL 'Unquoting function for receiving a domain name in a URL. DCNL Domain names tend to have .\'s in them.  Urllib doesn\'t quote dots, DCNL but Routes tends to choke on them, so we need an extra level of DCNL by-hand quoting here.'
def _translate_volume_detail_view(context, vol): DCNL 'Maps keys for volumes details view.'
def _translate_volume_summary_view(context, vol): DCNL 'Maps keys for volumes summary view.'
def _translate_attachment_detail_view(volume_id, instance_uuid, mountpoint): DCNL 'Maps keys for attachment details view.'
def _translate_attachment_summary_view(volume_id, instance_uuid, mountpoint): DCNL 'Maps keys for attachment summary view.'
def _translate_snapshot_detail_view(context, vol): DCNL 'Maps keys for snapshots details view.'
def _translate_snapshot_summary_view(context, vol): DCNL 'Maps keys for snapshots summary view.'
def get_host_from_body(fn): DCNL 'Makes sure that the host exists.'
def _filter_keys(item, keys): DCNL 'Filters all model attributes except for keys DCNL item is a dict'
def _translate_interface_attachment_view(port_info): DCNL 'Maps keys for interface attachment details view.'
def _translate_vif_summary_view(_context, vif): DCNL 'Maps keys for VIF summary view.'
def unquote_header_value(value): DCNL 'Unquotes a header value. DCNL This does not use the real unquoting but what browsers are actually DCNL using for quoting. DCNL :param value: the header value to unquote.'
def parse_list_header(value): DCNL 'Parse lists as described by RFC 2068 Section 2. DCNL In particular, parse comma-separated lists where the elements of DCNL the list may include quoted-strings.  A quoted-string could DCNL contain a comma.  A non-quoted string could have quotes in the DCNL middle.  Quotes are removed automatically after parsing. DCNL The return value is a standard :class:`list`: DCNL >>> parse_list_header(\'token, "quoted value"\') DCNL [\'token\', \'quoted value\'] DCNL :param value: a string with a list header. DCNL :return: :class:`list`'
def parse_options_header(value): DCNL 'Parse a ``Content-Type`` like header into a tuple with the content DCNL type and the options: DCNL >>> parse_options_header(\'Content-Type: text/html; mimetype=text/html\') DCNL (\'Content-Type:\', {\'mimetype\': \'text/html\'}) DCNL :param value: the header to parse. DCNL :return: (str, options)'
def ec2_error(req, request_id, code, message): DCNL 'Helper to send an ec2_compatible error.'
def image_type(image_type): DCNL 'Converts to a three letter image type. DCNL aki, kernel => aki DCNL ari, ramdisk => ari DCNL anything else => ami'
@memoize DCNL def id_to_glance_id(context, image_id): DCNL 'Convert an internal (db) id to a glance id.'
@memoize DCNL def glance_id_to_id(context, glance_id): DCNL 'Convert a glance id to an internal (db) id.'
def ec2_id_to_id(ec2_id): DCNL 'Convert an ec2 ID (i-[base 16 number]) to an instance id (int).'
def image_ec2_id(image_id, image_type='ami'): DCNL 'Returns image ec2_id using id and three letter type.'
def get_ip_info_for_instance(context, instance): DCNL 'Return a dictionary of IP information for an instance.'
def id_to_ec2_id(instance_id, template='i-%08x'): DCNL 'Convert an instance ID (int) to an ec2 ID (i-[base 16 number]).'
def id_to_ec2_inst_id(instance_id): DCNL 'Get or create an ec2 instance ID (i-[base 16 number]) from uuid.'
def ec2_inst_id_to_uuid(context, ec2_id): DCNL '"Convert an instance id to uuid.'
def id_to_ec2_snap_id(snapshot_id): DCNL 'Get or create an ec2 volume ID (vol-[base 16 number]) from uuid.'
def id_to_ec2_vol_id(volume_id): DCNL 'Get or create an ec2 volume ID (vol-[base 16 number]) from uuid.'
def ec2_vol_id_to_uuid(ec2_id): DCNL 'Get the corresponding UUID for the given ec2-id.'
def is_ec2_timestamp_expired(request, expires=None): DCNL 'Checks the timestamp or expiry time included in an EC2 request DCNL and returns true if the request is expired'
def ec2_snap_id_to_uuid(ec2_id): DCNL 'Get the corresponding UUID for the given ec2-id.'
def _try_convert(value): DCNL 'Return a non-string from a string or unicode, if possible. DCNL When value is returns DCNL zero-length   \'\' DCNL \'None\'        None DCNL \'True\'        True case insensitive DCNL \'False\'       False case insensitive DCNL \'0\', \'-0\'     0 DCNL 0xN, -0xN     int from hex (positive) (N is any number) DCNL 0bN, -0bN     int from binary (positive) (N is any number) DCNL *             try conversion to int, float, complex, fallback value'
def dict_from_dotted_str(items): DCNL 'parse multi dot-separated argument into dict. DCNL EBS boot uses multi dot-separated arguments like DCNL BlockDeviceMapping.1.DeviceName=snap-id DCNL Convert the above into DCNL {\'block_device_mapping\': {\'1\': {\'device_name\': snap-id}}}'
def _state_description(vm_state, _shutdown_terminate): DCNL 'Map the vm state to the server status string.'
def _parse_block_device_mapping(bdm): DCNL 'Parse BlockDeviceMappingItemType into flat hash DCNL BlockDevicedMapping.<N>.DeviceName DCNL BlockDevicedMapping.<N>.Ebs.SnapshotId DCNL BlockDevicedMapping.<N>.Ebs.VolumeSize DCNL BlockDevicedMapping.<N>.Ebs.DeleteOnTermination DCNL BlockDevicedMapping.<N>.Ebs.NoDevice DCNL BlockDevicedMapping.<N>.VirtualName DCNL => remove .Ebs and allow volume id in SnapshotId'
def _format_block_device_mapping(bdm): DCNL 'Construct BlockDeviceMappingItemType DCNL {\'device_name\': \'...\', \'snapshot_id\': , ...} DCNL => BlockDeviceMappingItemType'
def _format_mappings(properties, result): DCNL 'Format multiple BlockDeviceMappingItemType.'
def _database_to_isoformat(datetimeobj): DCNL 'Return a xs:dateTime parsable string from datatime.'
def convert_password(context, password): DCNL 'Stores password as system_metadata items. DCNL Password is stored with the keys \'password_0\' -> \'password_3\'.'
def pipeline_factory(loader, global_conf, **local_conf): DCNL 'A paste pipeline replica that keys off of auth_strategy.'
def validate_url_path(val): DCNL 'True if val is matched by the path component grammar in rfc3986.'
def validate_user_data(user_data): DCNL 'Check if the user_data is encoded properly.'
def validate(args, validator): DCNL 'Validate values of args against validators in validator. DCNL :param args:      Dict of values to be validated. DCNL :param validator: A dict where the keys map to keys in args DCNL and the values are validators. DCNL Applies each validator to ``args[key]`` DCNL :returns: True if validation succeeds. Otherwise False. DCNL A validator should be a callable which accepts 1 argument and which DCNL returns True if the argument passes validation. False otherwise. DCNL A validator should not raise an exception to indicate validity of the DCNL argument. DCNL Only validates keys which show up in both args and validator.'
def execute(*cmd, **kwargs): DCNL 'Helper method to shell out and execute a command through subprocess with DCNL optional retry. DCNL :param cmd:             Passed to subprocess.Popen. DCNL :type cmd:              string DCNL :param process_input:   Send to opened process. DCNL :type proces_input:     string DCNL :param check_exit_code: Defaults to 0. Will raise DCNL :class:`ProcessExecutionError` DCNL if the command exits without returning this value DCNL as a returncode DCNL :type check_exit_code:  int DCNL :param delay_on_retry:  True | False. Defaults to True. If set to True, DCNL wait a short amount of time before retrying. DCNL :type delay_on_retry:   boolean DCNL :param attempts:        How many times to retry cmd. DCNL :type attempts:         int DCNL :param run_as_root:     True | False. Defaults to False. If set to True, DCNL the command is prefixed by the command specified DCNL in the root_helper kwarg. DCNL :type run_as_root:      boolean DCNL :param root_helper:     command to prefix all cmd\'s with DCNL :type root_helper:      string DCNL :returns:               (stdout, stderr) from process execution DCNL :raises:                :class:`UnknownArgumentError` on DCNL receiving unknown arguments DCNL :raises:                :class:`ProcessExecutionError`'
def is_uuid_like(val): DCNL 'Returns validation of a value as a UUID. DCNL For our purposes, a UUID is a canonical form string: DCNL aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'
@contextlib.contextmanager DCNL def save_and_reraise_exception(): DCNL 'Save current exception, run some code and then re-raise. DCNL In some cases the exception context can be cleared, resulting in None DCNL being attempted to be re-raised after an exception handler is run. This DCNL can happen when eventlet switches greenthreads or when running an DCNL exception handler, code raises and catches an exception. In both DCNL cases the exception context will be cleared. DCNL To work around this, we save the exception state, run handler code, and DCNL then re-raise the original exception. If another exception occurs, the DCNL saved exception is logged and the new exception is re-raised.'
def get_context_from_function_and_args(function, args, kwargs): DCNL 'Find an arg of type RequestContext and return it. DCNL This is useful in a couple of decorators where we don\'t DCNL know much about the function we\'re wrapping.'
def setup(product_name): DCNL 'Setup logging.'
def build_filter(class_name, *args): DCNL 'Returns a filter object of class class_name'
def load_filters(filters_path): DCNL 'Load filters from a list of directories'
def match_filter(filters, userargs, exec_dirs=[]): DCNL 'Checks user command and arguments through command filters and DCNL returns the first matching filter. DCNL Raises NoFilterMatched if no filter matched. DCNL Raises FilterMatchNotExecutable if no executable was found for the DCNL best filter match.'
def to_primitive(value, convert_instances=False, convert_datetime=True, level=0, max_depth=3): DCNL 'Convert a complex object into primitives. DCNL Handy for JSON serialization. We can optionally handle instances, DCNL but since this is a recursive function, we could have cyclical DCNL data structures. DCNL To handle cyclical data structures we could track the actual objects DCNL visited in a set, but not all objects are hashable. Instead we just DCNL track the depth of the object inspections and don\'t go too deep. DCNL Therefore, convert_instances=True is lossy ... be aware.'
def canonicalize_emails(changelog, mapping): DCNL 'Takes in a string and an email alias mapping and replaces all DCNL instances of the aliases in the string with their real email.'
def write_git_changelog(): DCNL 'Write a changelog based on the git changelog.'
def generate_authors(): DCNL 'Create AUTHORS file using git commits.'
def get_cmdclass(): DCNL 'Return dict of commands to run from setup.py.'
def _get_revno(git_dir): DCNL 'Return the number of commits since the most recent tag. DCNL We use git-describe to find this out, but if there are no DCNL tags then we fall back to counting commits since the beginning DCNL of time.'
def _get_version_from_git(pre_version): DCNL 'Return a version which is equal to the tag that\'s on the current DCNL revision if there is one, or tag plus number of additional revisions DCNL if the current revision has no tag.'
def _get_version_from_pkg_info(package_name): DCNL 'Get the version from PKG-INFO file if we can.'
def get_version(package_name, pre_version=None): DCNL 'Get the version of the project. First, try getting it from PKG-INFO, if DCNL it exists. If it does, that means we\'re in a distribution tarball or that DCNL install has happened. Otherwise, if there is no PKG-INFO file, pull the DCNL version from git. DCNL We do not support setup.py version sanity in git archive tarballs, nor do DCNL we support packagers directly sucking our git repo into theirs. We expect DCNL that a source tarball be made from our git repo - or that if someone wants DCNL to make a source tarball from a fork of our repo with additional tags in it DCNL that they understand and desire the results of doing that.'
def parse_host_port(address, default_port=None): DCNL 'Interpret a string as a host:port pair. DCNL An IPv6 address MUST be escaped if accompanied by a port, DCNL because otherwise ambiguity ensues: 2001:db8:85a3::8a2e:370:7334 DCNL means both [2001:db8:85a3::8a2e:370:7334] and DCNL [2001:db8:85a3::8a2e:370]:7334. DCNL >>> parse_host_port(\'server01:80\') DCNL (\'server01\', 80) DCNL >>> parse_host_port(\'server01\') DCNL (\'server01\', None) DCNL >>> parse_host_port(\'server01\', default_port=1234) DCNL (\'server01\', 1234) DCNL >>> parse_host_port(\'[::1]:80\') DCNL (\'::1\', 80) DCNL >>> parse_host_port(\'[::1]\') DCNL (\'::1\', None) DCNL >>> parse_host_port(\'[::1]\', default_port=1234) DCNL (\'::1\', 1234) DCNL >>> parse_host_port(\'2001:db8:85a3::8a2e:370:7334\', default_port=1234) DCNL (\'2001:db8:85a3::8a2e:370:7334\', 1234)'
def set_rules(rules): DCNL 'Set the rules in use for policy checks.'
def reset(): DCNL 'Clear the rules used for policy checks.'
def check(rule, target, creds, exc=None, *args, **kwargs): DCNL 'Checks authorization of a rule against the target and credentials. DCNL :param rule: The rule to evaluate. DCNL :param target: As much information about the object being operated DCNL on as possible, as a dictionary. DCNL :param creds: As much information about the user performing the DCNL action as possible, as a dictionary. DCNL :param exc: Class of the exception to raise if the check fails. DCNL Any remaining arguments passed to check() (both DCNL positional and keyword arguments) will be passed to DCNL the exception class.  If exc is not provided, returns DCNL False. DCNL :return: Returns False if the policy does not allow the action and DCNL exc is not provided; otherwise, returns a value that DCNL evaluates to True.  Note: for rules using the "case" DCNL expression, this True value will be the specified string DCNL from the expression.'
def _parse_check(rule): DCNL 'Parse a single base check rule into an appropriate Check object.'
def _parse_list_rule(rule): DCNL 'Provided for backwards compatibility.  Translates the old DCNL list-of-lists syntax into a tree of Check objects.'
def _parse_tokenize(rule): DCNL 'Tokenizer for the policy language. DCNL Most of the single-character tokens are specified in the DCNL _tokenize_re; however, parentheses need to be handled specially, DCNL because they can appear inside a check string.  Thankfully, those DCNL parentheses that appear inside a check string can never occur at DCNL the very beginning or end ("%(variable)s" is the correct syntax).'
def reducer(*tokens): DCNL 'Decorator for reduction methods.  Arguments are a sequence of DCNL tokens, in order, which should trigger running this reduction DCNL method.'
def _parse_text_rule(rule): DCNL 'Translates a policy written in the policy language into a tree of DCNL Check objects.'
def parse_rule(rule): DCNL 'Parses a policy rule into a tree of Check objects.'
def register(name, func=None): DCNL 'Register a function or Check class as a policy check. DCNL :param name: Gives the name of the check type, e.g., \'rule\', DCNL \'role\', etc.  If name is None, a default check type DCNL will be registered. DCNL :param func: If given, provides the function or class to register. DCNL If not given, returns a function taking one argument DCNL to specify the function or class to register, DCNL allowing use as a decorator.'
def validate_args(fn, *args, **kwargs): DCNL 'Check that the supplied args are sufficient for calling a function. DCNL >>> validate_args(lambda a: None) DCNL Traceback (most recent call last): DCNL MissingArgs: An argument is missing DCNL >>> validate_args(lambda a, b, c, d: None, 0, c=1) DCNL Traceback (most recent call last): DCNL MissingArgs: 2 arguments are missing DCNL :param fn: the function to check DCNL :param arg: the positional arguments supplied DCNL :param kwargs: the keyword arguments supplied'
def synchronized(name, lock_file_prefix, external=False, lock_path=None): DCNL 'Synchronization decorator. DCNL Decorating a method like so:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL ensures that only one thread will execute the foo method at a time. DCNL Different methods can share the same lock:: DCNL @synchronized(\'mylock\') DCNL def foo(self, *args): DCNL @synchronized(\'mylock\') DCNL def bar(self, *args): DCNL This way only one of either foo or bar can be executing at a time. DCNL The lock_file_prefix argument is used to provide lock files on disk with a DCNL meaningful prefix. The prefix should end with a hyphen (\'-\') if specified. DCNL The external keyword argument denotes whether this lock should work across DCNL multiple processes. This means that if two different workers both run a DCNL a method decorated with @synchronized(\'mylock\', external=True), only one DCNL of them will execute at a time. DCNL The lock_path keyword argument is used to specify a special location for DCNL external lock files to live. If nothing is set, then CONF.lock_path is DCNL used as a default.'
def set_defaults(sql_connection, sqlite_db): DCNL 'Set defaults for configuration variables.'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def raise_if_duplicate_entry_error(integrity_error, engine_name): DCNL 'In this function will be raised DBDuplicateEntry exception if integrity DCNL error wrap unique constraint violation.'
def raise_if_deadlock_error(operational_error, engine_name): DCNL 'Raise DBDeadlock exception if OperationalError contains a Deadlock DCNL condition.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL 'Switch sqlite connections to non-synchronous mode.'
def add_regexp_listener(dbapi_con, con_record): DCNL 'Add REGEXP function to sqlite connections.'
def greenthread_yield(dbapi_con, con_record): DCNL 'Ensure other greenthreads get a chance to execute by forcing a context DCNL switch. With common database backends (eg MySQLdb and sqlite), there is DCNL no implicit yield caused by network I/O since they are implemented by DCNL C libraries that eventlet cannot monkey patch.'
def ping_listener(dbapi_conn, connection_rec, connection_proxy): DCNL 'Ensures that MySQL connections checked out of the DCNL pool are alive. DCNL Borrowed from: DCNL http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f'
def is_db_connection_error(args): DCNL 'Return True if error in connecting to db.'
def create_engine(sql_connection): DCNL 'Return a new SQLAlchemy engine.'
def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy sessionmaker using the given engine.'
def patch_mysqldb_with_stacktrace_comments(): DCNL 'Adds current stack trace as a comment in queries by patching DCNL MySQLdb.cursors.BaseCursor._do_query.'
def paginate_query(query, model, limit, sort_keys, marker=None, sort_dir=None, sort_dirs=None): DCNL 'Returns a query with sorting / pagination criteria added. DCNL Pagination works by requiring a unique sort_key, specified by sort_keys. DCNL (If sort_keys is not unique, then we risk looping through values.) DCNL We use the last row in the previous page as the \'marker\' for pagination. DCNL So we must return values that follow the passed marker in the order. DCNL With a single-valued sort_key, this would be easy: sort_key > X. DCNL With a compound-values sort_key, (k1, k2, k3) we must do this to repeat DCNL the lexicographical ordering: DCNL (k1 > X1) or (k1 == X1 && k2 > X2) or (k1 == X1 && k2 == X2 && k3 > X3) DCNL We also have to cope with different sort_directions. DCNL Typically, the id of the last row is used as the client-facing pagination DCNL marker, then the actual marker object must be fetched from the db and DCNL passed in to us as marker. DCNL :param query: the query object to which we should add paging/sorting DCNL :param model: the ORM model class DCNL :param limit: maximum number of items to return DCNL :param sort_keys: array of attributes by which results should be sorted DCNL :param marker: the last item of the previous page; we returns the next DCNL results after this value. DCNL :param sort_dir: direction in which results should be sorted (asc, desc) DCNL :param sort_dirs: per-column array of sort_dirs, corresponding to sort_keys DCNL :rtype: sqlalchemy.orm.query.Query DCNL :return: The query with sorting/pagination added.'
def notify(context, message): DCNL 'Deprecated in Grizzly. Please use rpc_notifier instead.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model'
def notify(_context, message): DCNL 'Test notifier, stores notifications in memory for unittests.'
def notify(_context, message): DCNL 'Notifies the recipient of the desired event given the model. DCNL Log notifications using openstack\'s default logging system'
def notify_decorator(name, fn): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def notify(context, publisher_id, event_type, priority, payload): DCNL 'Sends a notification using the specified driver DCNL :param publisher_id: the source worker_type.host of the message DCNL :param event_type:   the literal type of event (ex. Instance Creation) DCNL :param priority:     patterned after the enumeration of Python logging DCNL levels in the set (DEBUG, WARN, INFO, ERROR, CRITICAL) DCNL :param payload:       A python dictionary of attributes DCNL Outgoing message format includes the above parameters, and appends the DCNL following: DCNL message_id DCNL a UUID representing the id for this notification DCNL timestamp DCNL the GMT timestamp the notification was sent at DCNL The composite message will be constructed as a dictionary of the above DCNL attributes, which will then be sent via the transport mechanism defined DCNL by the driver. DCNL Message example:: DCNL {\'message_id\': str(uuid.uuid4()), DCNL \'publisher_id\': \'compute.host1\', DCNL \'timestamp\': timeutils.utcnow(), DCNL \'priority\': \'WARN\', DCNL \'event_type\': \'compute.create_instance\', DCNL \'payload\': {\'instance_id\': 12, ... }}'
def _get_drivers(): DCNL 'Instantiate, cache, and return drivers based on the CONF.'
def add_driver(notification_driver): DCNL 'Add a notification driver at runtime.'
def _reset_drivers(): DCNL 'Used by unit tests to reset the drivers.'
def notify(context, message): DCNL 'Sends a notification via RPC'
def _get_queue_arguments(conf): DCNL 'Construct the arguments for declaring a queue. DCNL If the rabbit_ha_queues option is set, we declare a mirrored queue DCNL as described here: DCNL http://www.rabbitmq.com/ha.html DCNL Setting x-ha-policy to all means that the queue will be mirrored DCNL to all nodes in the cluster.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(conf, new=True): DCNL 'Create a connection'
def check_serialize(msg): DCNL 'Make sure a message intended for rpc can be serialized.'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Cast to all consumers of a topic'
def create_connection(conf, new=True): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout=None): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout=None): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, envelope): DCNL 'Sends a notification event on a topic.'
def msg_reply(conf, msg_id, reply_q, connection_pool, reply=None, failure=None, ending=False, log_failure=True): DCNL 'Sends a reply or an error on the channel signified by msg_id. DCNL Failure should be a sys.exc_info() tuple.'
def unpack_context(conf, msg): DCNL 'Unpack context from msg.'
def pack_context(msg, context): DCNL 'Pack context into msg. DCNL Values for message keys need to be less than 255 chars, so we pull DCNL context out into a bunch of separate keys. If we want to support DCNL more arguments in rabbit messages, we may want to do the same DCNL for args at some point.'
def _add_unique_id(msg): DCNL 'Add unique_id for checking duplicate messages.'
def create_connection(conf, new, connection_pool): DCNL 'Create a connection'
def multicall(conf, context, topic, msg, timeout, connection_pool): DCNL 'Make a call that returns multiple times.'
def call(conf, context, topic, msg, timeout, connection_pool): DCNL 'Sends a message on a topic and wait for a response.'
def cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a topic without waiting for a response.'
def fanout_cast(conf, context, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange without waiting for a response.'
def cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a topic to a specific server.'
def fanout_cast_to_server(conf, context, server_params, topic, msg, connection_pool): DCNL 'Sends a message on a fanout exchange to a specific server.'
def notify(conf, context, topic, msg, connection_pool, envelope): DCNL 'Sends a notification event on a topic.'
def create_connection(new=True): DCNL 'Create a connection to the message bus used for rpc. DCNL For some example usage of creating a connection and some consumers on that DCNL connection, see nova.service. DCNL :param new: Whether or not to create a new connection.  A new connection DCNL will be created by default.  If new is False, the DCNL implementation is free to return an existing connection from a DCNL pool. DCNL :returns: An instance of openstack.common.rpc.common.Connection'
def call(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method that returns something. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: A dict from the remote method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def cast(context, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast(context, topic, msg): DCNL 'Broadcast a remote method invocation with no return. DCNL This method will get invoked on all consumers that were set up with this DCNL topic name and fanout=True. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=True. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def multicall(context, topic, msg, timeout=None, check_for_lock=False): DCNL 'Invoke a remote method and get back an iterator. DCNL In this case, the remote method will be returning multiple values in DCNL separate messages, so the return values can be processed as the come in via DCNL an iterator. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the rpc message to.  This correlates to the DCNL topic argument of DCNL openstack.common.rpc.common.Connection.create_consumer() DCNL and only applies when the consumer was created with DCNL fanout=False. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :param timeout: int, number of seconds to use for a response timeout. DCNL If set, this overrides the rpc_response_timeout option. DCNL :param check_for_lock: if True, a warning is emitted if a RPC call is made DCNL with a lock held. DCNL :returns: An iterator.  The iterator will yield a tuple (N, X) where N is DCNL an index that starts at 0 and increases by one for each value DCNL returned and X is the Nth value that was returned by the remote DCNL method. DCNL :raises: openstack.common.rpc.common.Timeout if a complete response DCNL is not received before the timeout is reached.'
def notify(context, topic, msg, envelope=False): DCNL 'Send notification event. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict of content of event. DCNL :param envelope: Set to True to enable message envelope for notifications. DCNL :returns: None'
def cleanup(): DCNL 'Clean up resoruces in use by implementation. DCNL Clean up any resources that have been allocated by the RPC implementation. DCNL This is typically open connections to a messaging service.  This function DCNL would get called before an application using this API exits to allow DCNL connections to get torn down cleanly. DCNL :returns: None'
def cast_to_server(context, server_params, topic, msg): DCNL 'Invoke a remote method that does not return anything. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def fanout_cast_to_server(context, server_params, topic, msg): DCNL 'Broadcast to a remote method invocation with no return. DCNL :param context: Information that identifies the user that has made this DCNL request. DCNL :param server_params: Connection information DCNL :param topic: The topic to send the notification to. DCNL :param msg: This is a dict in the form { "method" : "method_to_invoke", DCNL "args" : dict_of_kwargs } DCNL :returns: None'
def queue_get_for(context, topic, host): DCNL 'Get a queue name for a given topic + host. DCNL This function only works if this naming convention is followed on the DCNL consumer side, as well.  For example, in nova, every instance of the DCNL nova-foo service calls create_consumer() for two topics: DCNL foo DCNL foo.<host> DCNL Messages sent to the \'foo\' topic are distributed to exactly one instance of DCNL the nova-foo service.  The services are chosen in a round-robin fashion. DCNL Messages sent to the \'foo.<host>\' topic are sent to the nova-foo service on DCNL <host>.'
def _get_impl(): DCNL 'Delay import of rpc_backend until configuration is loaded.'
def _safe_log(log_func, msg, msg_data): DCNL 'Sanitizes the msg_data field before logging.'
def serialize_remote_exception(failure_info, log_failure=True): DCNL 'Prepares exception data to be sent over rpc. DCNL Failure_info should be a sys.exc_info() tuple.'
def client_exceptions(*exceptions): DCNL 'Decorator for manager methods that raise expected exceptions. DCNL Marking a Manager method with this decorator allows the declaration DCNL of expected exceptions that the RPC layer should not consider fatal, DCNL and not log as if they were generated in a real error scenario. Note DCNL that this will cause listed exceptions to be wrapped in a DCNL ClientException, which is used internally by the RPC layer.'
def version_is_compatible(imp_version, version): DCNL 'Determine whether versions are compatible. DCNL :param imp_version: The version implemented DCNL :param version: The version requested by an incoming message.'
def _serialize(data): DCNL 'Serialization wrapper DCNL We prefer using JSON, but it cannot encode all types. DCNL Error if a developer passes us bad data.'
def _deserialize(data): DCNL 'Deserialization wrapper'
def unflatten_envelope(packenv): DCNL 'Unflattens the RPC envelope. DCNL Takes a list and returns a dictionary. DCNL i.e. [1,2,3,4] => {1: 2, 3: 4}'
def _multi_send(method, context, topic, msg, timeout=None, envelope=False, _msg_id=None): DCNL 'Wraps the sending of messages, DCNL dispatches to the matchmaker and sends DCNL message to all relevant hosts.'
def multicall(conf, *args, **kwargs): DCNL 'Multiple calls.'
def call(conf, *args, **kwargs): DCNL 'Send a message, expect a response.'
def cast(conf, *args, **kwargs): DCNL 'Send a message expecting no reply.'
def fanout_cast(conf, context, topic, msg, **kwargs): DCNL 'Send a message to all listening and expect no reply.'
def notify(conf, context, topic, msg, envelope): DCNL 'Send notification event. DCNL Notifications are sent to topic-priority. DCNL This differs from the AMQP drivers which send to topic.priority.'
def cleanup(): DCNL 'Clean up resources in use by implementation.'
def ensure_tree(path): DCNL 'Create a directory (and any ancestor directories required) DCNL :param path: Directory to create'
def import_class(import_str): DCNL 'Returns a class from a string including module and class'
def import_object(import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it.'
def import_object_ns(name_space, import_str, *args, **kwargs): DCNL 'Import a class and return an instance of it, first by trying DCNL to find the class in a default namespace, then failing back to DCNL a full path if not found in the default namespace.'
def import_module(import_str): DCNL 'Import a module.'
def try_import(import_str, default=None): DCNL 'Try to import a module and if it fails return default.'
def isotime(at=None): DCNL 'Stringify time in ISO 8601 format'
def parse_isotime(timestr): DCNL 'Parse time from ISO 8601 format'
def strtime(at=None, fmt=PERFECT_TIME_FORMAT): DCNL 'Returns formatted utcnow.'
def parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT): DCNL 'Turn a formatted time back into a datetime.'
def normalize_time(timestamp): DCNL 'Normalize time in arbitrary timezone to UTC naive object'
def is_older_than(before, seconds): DCNL 'Return True if before is older than seconds.'
def is_newer_than(after, seconds): DCNL 'Return True if after is newer than seconds.'
def utcnow_ts(): DCNL 'Timestamp version of our utcnow function.'
def utcnow(): DCNL 'Overridable version of utils.utcnow.'
def iso8601_from_timestamp(timestamp): DCNL 'Returns a iso8601 formated date from timestamp'
def set_time_override(override_time=datetime.datetime.utcnow()): DCNL 'Override utils.utcnow to return a constant time or a list thereof, DCNL one at a time.'
def advance_time_delta(timedelta): DCNL 'Advance overridden time using a datetime.timedelta.'
def advance_time_seconds(seconds): DCNL 'Advance overridden time by seconds.'
def clear_time_override(): DCNL 'Remove the overridden time.'
def marshall_now(now=None): DCNL 'Make an rpc-safe datetime with microseconds. DCNL Note: tzinfo is stripped, but not required for relative times.'
def unmarshall_time(tyme): DCNL 'Unmarshall a datetime dict.'
def delta_seconds(before, after): DCNL 'Compute the difference in seconds between two date, time, or DCNL datetime objects (as a float, to microsecond resolution).'
def is_soon(dt, window): DCNL 'Determines if time is going to happen in the next window seconds. DCNL :params dt: the time DCNL :params window: minimum seconds to remain to consider the time not soon DCNL :return: True if expiration is within the given duration'
def basedir_def(*args): DCNL 'Return an uninterpolated path relative to $pybasedir.'
def bindir_def(*args): DCNL 'Return an uninterpolated path relative to $bindir.'
def state_path_def(*args): DCNL 'Return an uninterpolated path relative to $state_path.'
def basedir_rel(*args): DCNL 'Return a path relative to $pybasedir.'
def bindir_rel(*args): DCNL 'Return a path relative to $bindir.'
def state_path_rel(*args): DCNL 'Return a path relative to $state_path.'
def send_api_fault(url, status, exception): DCNL 'Send an api.fault notification.'
def send_update(context, old_instance, new_instance, service=None, host=None): DCNL 'Send compute.instance.update notification to report any changes occurred DCNL in that instance'
def send_update_with_states(context, instance, old_vm_state, new_vm_state, old_task_state, new_task_state, service='compute', host=None, verify_states=False): DCNL 'Send compute.instance.update notification to report changes if there DCNL are any, in the instance'
def _send_instance_update_notification(context, instance, old_vm_state=None, old_task_state=None, new_vm_state=None, new_task_state=None, service='compute', host=None): DCNL 'Send \'compute.instance.update\' notification to inform observers DCNL about instance state changes'
def audit_period_bounds(current_period=False): DCNL 'Get the start and end of the relevant audit usage period DCNL :param current_period: if True, this will generate a usage for the DCNL current usage period; if False, this will generate a usage for the DCNL previous audit period.'
def bandwidth_usage(instance_ref, audit_start, ignore_missing_network_data=True): DCNL 'Get bandwidth usage information for the instance for the DCNL specified audit period.'
def image_meta(system_metadata): DCNL 'Format image metadata for use in notifications from the instance DCNL system metadata.'
def info_from_instance(context, instance_ref, network_info, system_metadata, **kw): DCNL 'Get detailed instance information for an instance which is common to all DCNL notifications. DCNL :param network_info: network_info provided if not None DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unused here in trunk, but needed for DCNL potential custom modifications.'
def generate_glance_url(): DCNL 'Generate the URL to glance.'
def generate_image_url(image_ref): DCNL 'Generate an image URL from an image_ref.'
def _parse_image_ref(image_href): DCNL 'Parse an image href into composite parts. DCNL :param image_href: href of an image DCNL :returns: a tuple of the form (image_id, host, port) DCNL :raises ValueError'
def _create_glance_client(context, host, port, use_ssl, version=1): DCNL 'Instantiate a new glanceclient.Client object.'
def get_api_servers(): DCNL 'Shuffle a list of CONF.glance_api_servers and return an iterator DCNL that will cycle through the list, looping around to the beginning DCNL if necessary.'
def _convert_timestamps_to_datetimes(image_meta): DCNL 'Returns image with timestamp fields converted to datetime objects.'
def _reraise_translated_image_exception(image_id): DCNL 'Transform the exception for the image but keep its traceback intact.'
def _reraise_translated_exception(): DCNL 'Transform the exception but keep its traceback intact.'
def get_remote_image_service(context, image_href): DCNL 'Create an image_service and parse the id from the given image_href. DCNL The image_href param can be an href of the form DCNL \'http://example.com:9292/v1/images/b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\', DCNL or just an id such as \'b8b2c6f7-7345-4e2f-afa2-eedaba9cbbe3\'. If the DCNL image_href is a standalone id, then the default image service is returned. DCNL :param image_href: href that describes the location of an image DCNL :returns: a tuple of the form (image_service, image_id)'
def _cleanse_dict(original): DCNL 'Strip all admin_password, new_pass, rescue_pass keys from a dict.'
def wrap_exception(notifier=None, publisher_id=None, event_type=None, level=None): DCNL 'This decorator wraps a method to catch any exceptions that may DCNL get thrown. It logs the exception as well as optionally sending DCNL it to the notification system.'
def is_user_context(context): DCNL 'Indicates if the request context is a normal user.'
def require_admin_context(ctxt): DCNL 'Raise exception.AdminRequired() if context is an admin context.'
def require_context(ctxt): DCNL 'Raise exception.NotAuthorized() if context is not a user or an DCNL admin context.'
def authorize_project_context(context, project_id): DCNL 'Ensures a request has permission to access the given project.'
def authorize_user_context(context, user_id): DCNL 'Ensures a request has permission to access the given user.'
def authorize_quota_class_context(context, class_name): DCNL 'Ensures a request has permission to access the given quota class.'
def add_hook(name): DCNL 'Execute optional pre and post methods around the decorated DCNL function.  This is useful for customization around callables.'
def reset(): DCNL 'Clear loaded hooks.'
def _get_my_ip(): DCNL 'Returns the actual ip of the local machine. DCNL This code figures out what source address would be used if some traffic DCNL were to be sent out to some well known address on the Internet. In this DCNL case, a Google DNS server is used, but the specific address does not DCNL matter much.  No traffic is actually sent.'
def qemu_img_info(path): DCNL 'Return an object containing the parsed output from qemu-img info.'
def convert_image(source, dest, out_format, run_as_root=False): DCNL 'Convert image to other format.'
def get_injected_network_template(network_info, use_ipv6=CONF.use_ipv6, template=CONF.injected_network_template): DCNL 'return a rendered network template for the given network_info DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL Note: this code actually depends on the legacy network_info, but will DCNL convert the type itself if necessary.'
def build_pxe_config(deployment_id, deployment_key, deployment_iscsi_iqn, deployment_aki_path, deployment_ari_path, aki_path, ari_path): DCNL 'Build the PXE config file for a node DCNL This method builds the PXE boot configuration file for a node, DCNL given all the required parameters. DCNL The resulting file has both a "deploy" and "boot" label, which correspond DCNL to the two phases of booting. This may be extended later.'
def get_image_dir_path(instance): DCNL 'Generate the dir for an instances disk.'
def get_image_file_path(instance): DCNL 'Generate the full path for an instances disk.'
def get_pxe_config_file_path(instance): DCNL 'Generate the path for an instances PXE config file.'
def get_pxe_mac_path(mac): DCNL 'Convert a MAC address into a PXE config file name.'
def get_tftp_image_info(instance, instance_type): DCNL 'Generate the paths for tftp files for this instance DCNL Raises NovaException if DCNL - instance does not contain kernel_id or ramdisk_id DCNL - deploy_kernel_id or deploy_ramdisk_id can not be read from DCNL instance_type[\'extra_specs\'] and defaults are not set'
def get_session(autocommit=True, expire_on_commit=False): DCNL 'Return a SQLAlchemy session.'
def get_engine(): DCNL 'Return a SQLAlchemy engine.'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def model_query(context, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id.'
@sqlalchemy_api.require_admin_context DCNL def bm_node_associate_and_update(context, node_uuid, values): DCNL 'Associate an instance to a node safely DCNL Associate an instance to a node only if that node is not yet assocated. DCNL Allow the caller to set any other fields they require in the same DCNL operation. For example, this is used to set the node\'s task_state to DCNL BUILDING at the beginning of driver.spawn().'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def _update_state(context, node, instance, state): DCNL 'Update the node state in baremetal DB DCNL If instance is not supplied, reset the instance_uuid field for this node.'
def get_host_iqn(session, cluster=None): DCNL 'Return the host iSCSI IQN.'
def find_st(session, data, cluster=None): DCNL 'Return the iSCSI Target given a volume info.'
def rescan_iscsi_hba(session, cluster=None): DCNL 'Rescan the iSCSI HBA to discover iSCSI targets.'
def mountpoint_to_number(mountpoint): DCNL 'Translate a mountpoint like /dev/sdc into a numeric.'
def start_transfer(context, read_file_handle, data_size, write_file_handle=None, image_service=None, image_id=None, image_meta=None): DCNL 'Start the data transfer from the reader to the writer. DCNL Reader writes to the pipe and the writer reads from the pipe. This means DCNL that the total transfer time boils down to the slower of the read/write DCNL and not the addition of the two times.'
def fetch_image(context, image, instance, **kwargs): DCNL 'Download image from the glance image server.'
def upload_image(context, image, instance, **kwargs): DCNL 'Upload the snapshotted vm disk file to Glance image server.'
def get_vmdk_size_and_properties(context, image, instance): DCNL 'Get size of the vmdk file that is to be downloaded for attach in spawn. DCNL Need this to create the dummy virtual disk for the meta-data file. The DCNL geometry of the disk created depends on the size.'
def log_db_contents(msg=None): DCNL 'Log DB Contents.'
def reset(): DCNL 'Resets the db contents.'
def cleanup(): DCNL 'Clear the db contents.'
def _create_object(table, table_obj): DCNL 'Create an object in the db.'
def _get_objects(obj_type): DCNL 'Get objects of the type.'
def _add_file(file_path): DCNL 'Adds a file reference to the  db.'
def _remove_file(file_path): DCNL 'Removes a file reference from the db.'
def fake_plug_vifs(*args, **kwargs): DCNL 'Fakes plugging vifs.'
def fake_get_network(*args, **kwargs): DCNL 'Fake get network.'
def fake_fetch_image(context, image, instance, **kwargs): DCNL 'Fakes fetch image call. Just adds a reference to the db for the file.'
def fake_upload_image(context, image, instance, **kwargs): DCNL 'Fakes the upload of an image.'
def fake_get_vmdk_size_and_properties(context, image_id, instance): DCNL 'Fakes the file size and properties fetch for the image file.'
def _get_vm_mdo(vm_ref): DCNL 'Gets the Virtual Machine with the ref from the db.'
def build_selection_spec(client_factory, name): DCNL 'Builds the selection spec.'
def build_traversal_spec(client_factory, name, spec_type, path, skip, select_set): DCNL 'Builds the traversal spec object.'
def build_recursive_traversal_spec(client_factory): DCNL 'Builds the Recursive Traversal Spec to traverse the object managed DCNL object hierarchy.'
def build_property_spec(client_factory, type='VirtualMachine', properties_to_collect=None, all_properties=False): DCNL 'Builds the Property Spec.'
def build_object_spec(client_factory, root_folder, traversal_specs): DCNL 'Builds the object Spec.'
def build_property_filter_spec(client_factory, property_specs, object_specs): DCNL 'Builds the Property Filter Spec.'
def get_object_properties(vim, collector, mobj, type, properties): DCNL 'Gets the properties of the Managed object specified.'
def get_dynamic_property(vim, mobj, type, property_name): DCNL 'Gets a particular property of the Managed Object.'
def get_objects(vim, type, properties_to_collect=None, all=False): DCNL 'Gets the list of objects of the type specified.'
def get_prop_spec(client_factory, spec_type, properties): DCNL 'Builds the Property Spec Object.'
def get_obj_spec(client_factory, obj, select_set=None): DCNL 'Builds the Object Spec object.'
def get_prop_filter_spec(client_factory, obj_spec, prop_spec): DCNL 'Builds the Property Filter Spec Object.'
def get_properties_for_a_collection_of_objects(vim, type, obj_list, properties): DCNL 'Gets the list of properties for the collection of DCNL objects of the type specified.'
def ensure_vlan_bridge(session, vif, cluster=None): DCNL 'Create a vlan and bridge unless they already exist.'
def build_datastore_path(datastore_name, path): DCNL 'Build the datastore compliant path.'
def split_datastore_path(datastore_path): DCNL 'Split the VMware style datastore path to get the Datastore DCNL name and the entity path.'
def get_vm_create_spec(client_factory, instance, data_store_name, vif_infos, os_type='otherGuest'): DCNL 'Builds the VM Create spec.'
def create_controller_spec(client_factory, key, adapter_type='lsiLogic'): DCNL 'Builds a Config Spec for the LSI or Bus Logic Controller\'s addition DCNL which acts as the controller for the virtual hard disk to be attached DCNL to the VM.'
def create_network_spec(client_factory, vif_info): DCNL 'Builds a config spec for the addition of a new network DCNL adapter to the VM.'
def get_vmdk_attach_config_spec(client_factory, adapter_type='lsiLogic', disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, controller_key=None, unit_number=None, device_name=None): DCNL 'Builds the vmdk attach config spec.'
def get_vmdk_detach_config_spec(client_factory, device): DCNL 'Builds the vmdk detach config spec.'
def get_vmdk_path_and_adapter_type(hardware_devices): DCNL 'Gets the vmdk file path and the storage adapter type.'
def get_rdm_disk(hardware_devices, uuid): DCNL 'Gets the RDM disk key.'
def get_copy_virtual_disk_spec(client_factory, adapter_type='lsilogic', disk_type='preallocated'): DCNL 'Builds the Virtual Disk copy spec.'
def get_vmdk_create_spec(client_factory, size_in_kb, adapter_type='lsiLogic', disk_type='preallocated'): DCNL 'Builds the virtual disk create spec.'
def get_rdm_create_spec(client_factory, device, adapter_type='lsiLogic', disk_type='rdmp'): DCNL 'Builds the RDM virtual disk create spec.'
def create_virtual_disk_spec(client_factory, controller_key, disk_type='preallocated', file_path=None, disk_size=None, linked_clone=False, unit_number=None, device_name=None): DCNL 'Builds spec for the creation of a new/ attaching of an already existing DCNL Virtual Disk to the VM.'
def delete_virtual_disk_spec(client_factory, device): DCNL 'Builds spec for the deletion of an already existing Virtual Disk from VM.'
def clone_vm_spec(client_factory, location, power_on=False, snapshot=None, template=False): DCNL 'Builds the VM clone spec.'
def relocate_vm_spec(client_factory, datastore=None, host=None, disk_move_type='moveAllDiskBackingsAndAllowSharing'): DCNL 'Builds the VM relocation spec.'
def get_dummy_vm_create_spec(client_factory, name, data_store_name): DCNL 'Builds the dummy VM create spec.'
def get_machine_id_change_spec(client_factory, machine_id_str): DCNL 'Builds the machine id change config spec.'
def get_add_vswitch_port_group_spec(client_factory, vswitch_name, port_group_name, vlan_id): DCNL 'Builds the virtual switch port group add spec.'
def get_vnc_config_spec(client_factory, port, password): DCNL 'Builds the vnc config spec.'
def search_datastore_spec(client_factory, file_name): DCNL 'Builds the datastore search spec.'
def get_vm_ref_from_name(session, vm_name): DCNL 'Get reference to the VM with the name specified.'
def get_cluster_ref_from_name(session, cluster_name): DCNL 'Get reference to the cluster with the name specified.'
def get_host_ref(session, cluster=None): DCNL 'Get reference to a host within the cluster specified.'
def get_datastore_ref_and_name(session, cluster=None, host=None): DCNL 'Get the datastore list and choose the first local storage.'
def get_network_with_the_name(session, network_name='vmnet0', cluster=None): DCNL 'Gets reference to the network whose name is passed as the DCNL argument.'
def get_vswitch_for_vlan_interface(session, vlan_interface, cluster=None): DCNL 'Gets the vswitch associated with the physical network adapter DCNL with the name supplied.'
def check_if_vlan_interface_exists(session, vlan_interface, cluster=None): DCNL 'Checks if the vlan_interface exists on the esx host.'
def get_vlanid_and_vswitch_for_portgroup(session, pg_name, cluster=None): DCNL 'Get the vlan id and vswicth associated with the port group.'
def create_port_group(session, pg_name, vswitch_name, vlan_id=0, cluster=None): DCNL 'Creates a port group on the host system with the vlan tags DCNL supplied. VLAN id 0 means no vlan id association.'
def set_nodes(nodes): DCNL 'Sets FakeDriver\'s node.list. DCNL It has effect on the following methods: DCNL get_available_nodes() DCNL get_available_resource DCNL get_host_stats() DCNL To restore the change, call restore_nodes()'
def restore_nodes(): DCNL 'Resets FakeDriver\'s node list modified by set_nodes(). DCNL Usually called from tearDown().'
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def register_storage_use(storage_path, hostname): DCNL 'Idenfity the id of this instance storage.'
@lockutils.synchronized('storage-registry-lock', 'nova-', external=True) DCNL def get_storage_users(storage_path): DCNL 'Get a list of all the users of this storage path.'
def create_vm(session, instance, name_label, kernel, ramdisk, use_pv_kernel=False): DCNL 'Create a VM record.  Returns new VM reference. DCNL the use_pv_kernel flag indicates whether the guest is HVM or PV DCNL There are 3 scenarios: DCNL 1. Using paravirtualization, kernel passed in DCNL 2. Using paravirtualization, kernel within the image DCNL 3. Using hardware virtualization'
def destroy_vm(session, instance, vm_ref): DCNL 'Destroys a VM record.'
def find_vbd_by_number(session, vm_ref, number): DCNL 'Get the VBD reference from the device number.'
def unplug_vbd(session, vbd_ref): DCNL 'Unplug VBD from VM.'
def destroy_vbd(session, vbd_ref): DCNL 'Destroy VBD from host database.'
def create_vbd(session, vm_ref, vdi_ref, userdevice, vbd_type='disk', read_only=False, bootable=False, osvol=False): DCNL 'Create a VBD record and returns its reference.'
def safe_destroy_vdis(session, vdi_refs): DCNL 'Destroys the requested VDIs, logging any StorageError exceptions.'
def create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size, read_only=False): DCNL 'Create a VDI record and returns its reference.'
@contextlib.contextmanager DCNL def _dummy_vm(session, instance, vdi_ref): DCNL 'This creates a temporary VM so that we can snapshot a VDI. DCNL VDI\'s can\'t be snapshotted directly since the API expects a `vm_ref`. To DCNL work around this, we need to create a temporary VM and then map the VDI to DCNL the VM using a temporary VBD.'
def _safe_copy_vdi(session, sr_ref, instance, vdi_to_copy_ref): DCNL 'Copy a VDI and return the new VDIs reference. DCNL This function differs from the XenAPI `VDI.copy` call in that the copy is DCNL atomic and isolated, meaning we don\'t see half-downloaded images. It DCNL accomplishes this by copying the VDI\'s into a temporary directory and then DCNL atomically renaming them into the SR when the copy is completed. DCNL The correct long term solution is to fix `VDI.copy` so that it is atomic DCNL and isolated.'
def _clone_vdi(session, vdi_to_clone_ref): DCNL 'Clones a VDI and return the new VDIs reference.'
def get_vdi_for_vm_safely(session, vm_ref): DCNL 'Retrieves the primary VDI for a VM.'
def get_sr_path(session): DCNL 'Return the path to our storage repository DCNL This is used when we\'re dealing with VHDs directly, either by taking DCNL snapshots or by restoring an image in the DISK_VHD format.'
def destroy_cached_images(session, sr_ref, all_cached=False, dry_run=False): DCNL 'Destroy used or unused cached images. DCNL A cached image that is being used by at least one VM is said to be \'used\'. DCNL In the case of an \'unused\' image, the cached image will be the only DCNL descendent of the base-copy. So when we delete the cached-image, the DCNL refcount will drop to zero and XenServer will automatically destroy the DCNL base-copy for us. DCNL The default behavior of this function is to destroy only \'unused\' cached DCNL images. To destroy all cached images, use the `all_cached=True` kwarg.'
def _find_cached_images(session, sr_ref): DCNL 'Return a dict(uuid=vdi_ref) representing all cached images.'
def _find_cached_image(session, image_id, sr_ref): DCNL 'Returns the vdi-ref of the cached image.'
def auto_configure_disk(session, vdi_ref, new_gb): DCNL 'Partition and resize FS to match the size specified by DCNL instance_types.root_gb. DCNL This is a fail-safe to prevent accidentally destroying data on a disk DCNL erroneously marked as auto_disk_config=True. DCNL The criteria for allowing resize are: DCNL 1. \'auto_disk_config\' must be true for the instance (and image). DCNL (If we\'ve made it here, then auto_disk_config=True.) DCNL 2. The disk must have only one partition. DCNL 3. The file-system on the one partition must be ext3 or ext4.'
def _generate_disk(session, instance, vm_ref, userdevice, name_label, disk_type, size_mb, fs_type): DCNL 'Steps to programmatically generate a disk: DCNL 1. Create VDI of desired size DCNL 2. Attach VDI to compute worker DCNL 3. Create partition DCNL 4. Create VBD between instance VM and VDI'
def create_kernel_image(context, session, instance, name_label, image_id, image_type): DCNL 'Creates kernel/ramdisk file from the image stored in the cache. DCNL If the image is not present in the cache, it streams it from glance. DCNL Returns: A list of dictionaries that describe VDIs'
def _create_image(context, session, instance, name_label, image_id, image_type): DCNL 'Creates VDI from the image stored in the local cache. If the image DCNL is not present in the cache, it streams it from glance. DCNL Returns: A list of dictionaries that describe VDIs'
def _fetch_image(context, session, instance, name_label, image_id, image_type): DCNL 'Fetch image from glance based on image type. DCNL Returns: A single filename if image_type is KERNEL or RAMDISK DCNL A list of dictionaries that describe VDIs, otherwise'
def _fetch_vhd_image(context, session, instance, image_id): DCNL 'Tell glance to download an image and put the VHDs into the SR DCNL Returns: A list of dictionaries that describe VDIs'
def _get_vdi_chain_size(session, vdi_uuid): DCNL 'Compute the total size of a VDI chain, starting with the specified DCNL VDI UUID. DCNL This will walk the VDI chain to the root, add the size of each VDI into DCNL the total.'
def _fetch_disk_image(context, session, instance, name_label, image_id, image_type): DCNL 'Fetch the image from Glance DCNL NOTE: DCNL Unlike _fetch_vhd_image, this method does not use the Glance DCNL plugin; instead, it streams the disks through domU to the VDI DCNL directly. DCNL Returns: A single filename if image_type is KERNEL_RAMDISK DCNL A list of dictionaries that describe VDIs, otherwise'
def determine_disk_image_type(image_meta): DCNL 'Disk Image Types are used to determine where the kernel will reside DCNL within an image. To figure out which type we\'re dealing with, we use DCNL the following rules: DCNL 1. If we\'re using Glance, we can use the image_type field to DCNL determine the image_type DCNL 2. If we\'re not using Glance, then we need to deduce this based on DCNL whether a kernel_id is specified.'
def determine_is_pv(session, vdi_ref, disk_image_type, os_type): DCNL 'Determine whether the VM will use a paravirtualized kernel or if it DCNL will use hardware virtualization. DCNL 1. Glance (VHD): then we use `os_type`, raise if not set DCNL 2. Glance (DISK_RAW): use Pygrub to figure out if pv kernel is DCNL available DCNL 3. Glance (DISK): pv is assumed DCNL 4. Glance (DISK_ISO): no pv is assumed DCNL 5. Boot From Volume - without image metadata (None): attempt to DCNL use Pygrub to figure out if the volume stores a PV VM or a DCNL HVM one. Log a warning, because there may be cases where the DCNL volume is RAW (in which case using pygrub is fine) and cases DCNL where the content of the volume is VHD, and pygrub might not DCNL work as expected. DCNL NOTE: if disk_image_type is not specified, instances launched DCNL from remote volumes will have to include kernel and ramdisk DCNL because external kernel and ramdisk will not be fetched.'
def lookup_vm_vdis(session, vm_ref): DCNL 'Look for the VDIs that are attached to the VM.'
def lookup(session, name_label): DCNL 'Look the instance up and return it if available.'
def preconfigure_instance(session, instance, vdi_ref, network_info): DCNL 'Makes alterations to the image before launching as part of spawn.'
def compile_info(record): DCNL 'Fill record with VM status information.'
def compile_diagnostics(record): DCNL 'Compile VM diagnostics data.'
def compile_metrics(start_time, stop_time=None): DCNL 'Compile bandwidth usage, cpu, and disk metrics for all VMs on DCNL this host. DCNL Note that some stats, like bandwidth, do not seem to be very DCNL accurate in some of the data from XenServer (mdragon).'
def _scan_sr(session, sr_ref=None): DCNL 'Scans the SR specified by sr_ref.'
def scan_default_sr(session): DCNL 'Looks for the system default SR and triggers a re-scan.'
def safe_find_sr(session): DCNL 'Same as _find_sr except raises a NotFound exception if SR cannot be DCNL determined'
def _find_sr(session): DCNL 'Return the storage repository to hold VM images.'
def _safe_find_iso_sr(session): DCNL 'Same as _find_iso_sr except raises a NotFound exception if SR DCNL cannot be determined'
def _find_iso_sr(session): DCNL 'Return the storage repository to hold ISO images.'
def _get_rrd_server(): DCNL 'Return server\'s scheme and address to use for retrieving RRD XMLs.'
def _get_rrd(server, vm_uuid): DCNL 'Return the VM RRD XML as a string.'
def _get_rrd_updates(server, start_time): DCNL 'Return the RRD updates XML as a string.'
def get_instance_vdis_for_sr(session, vm_ref, sr_ref): DCNL 'Return opaqueRef for all the vdis which live on sr.'
def _walk_vdi_chain(session, vdi_uuid): DCNL 'Yield vdi_recs for each element in a VDI chain.'
def _child_vhds(session, sr_ref, vdi_uuid): DCNL 'Return the immediate children of a given VHD. DCNL This is not recursive, only the immediate children are returned.'
def _wait_for_vhd_coalesce(session, instance, sr_ref, vdi_ref, original_parent_uuid): DCNL 'Spin until the parent VHD is coalesced into its parent VHD DCNL Before coalesce: DCNL * original_parent_vhd DCNL * parent_vhd DCNL snapshot DCNL After coalesce: DCNL * parent_vhd DCNL snapshot'
def _remap_vbd_dev(dev): DCNL 'Return the appropriate location for a plugged-in VBD device DCNL Ubuntu Maverick moved xvd? -> sd?. This is considered a bug and will be DCNL fixed in future versions: DCNL https://bugs.launchpad.net/ubuntu/+source/linux/+bug/684875 DCNL For now, we work around it by just doing a string replace.'
def _wait_for_device(dev): DCNL 'Wait for device node to appear.'
def cleanup_attached_vdis(session): DCNL 'Unplug any instance VDIs left after an unclean restart.'
def _get_partitions(dev): DCNL 'Return partition information (num, size, type) for a device.'
def _resize_part_and_fs(dev, start, old_sectors, new_sectors): DCNL 'Resize partition and fileystem. DCNL This assumes we are dealing with a single primary partition and using DCNL ext3 or ext4.'
def _sparse_copy(src_path, dst_path, virtual_size, block_size=4096): DCNL 'Copy data, skipping long runs of zeros to create a sparse file.'
def _mount_filesystem(dev_path, dir): DCNL 'mounts the device specified by dev_path in dir.'
def _mounted_processing(device, key, net, metadata): DCNL 'Callback which runs with the image VDI attached.'
def _prepare_injectables(inst, network_info): DCNL 'prepares the ssh key and the network configuration file to be DCNL injected into the disk image'
def ensure_correct_host(session): DCNL 'Ensure we\'re connected to the host we\'re running on. This is the DCNL required configuration for anything that uses vdi_attached_here.'
def move_disks(session, instance, disk_info): DCNL 'Move and possibly link VHDs via the XAPI plugin.'
def cmp_version(a, b): DCNL 'Compare two version strings (eg 0.0.1.10 > 0.0.1.9).'
def make_step_decorator(context, instance, instance_update): DCNL 'Factory to create a decorator that records instance progress as a series DCNL of discrete steps. DCNL Each time the decorator is invoked we bump the total-step-count, so after:: DCNL @step DCNL def step1(): DCNL @step DCNL def step2(): DCNL we have a total-step-count of 2. DCNL Each time the step-function (not the step-decorator!) is invoked, we bump DCNL the current-step-count by 1, so after:: DCNL step1() DCNL the current-step-count would be 1 giving a progress of ``1 / 2 * DCNL 100`` or 50%.'
def swap_xapi_host(url, host_addr): DCNL 'Replace the XenServer address present in \'url\' with \'host_addr\'.'
def after_VBD_create(vbd_ref, vbd_rec): DCNL 'Create read-only fields and backref from VM and VDI to VBD when VBD DCNL is created.'
def after_VM_create(vm_ref, vm_rec): DCNL 'Create read-only fields in the VM record.'
def create_local_pifs(): DCNL 'Adds a PIF for each to the local database with VLAN=-1. DCNL Do this one per host.'
def create_local_srs(): DCNL 'Create an SR that looks like the one created on the local disk by DCNL default by the XenServer installer.  Do this one per host. Also, fake DCNL the installation of an ISO SR.'
def as_value(s): DCNL 'Helper function for simulating XenAPI plugin responses.  It DCNL escapes and wraps the given argument.'
def as_json(*args, **kwargs): DCNL 'Helper function for simulating XenAPI plugin responses for those DCNL that are returning JSON.  If this function is given plain arguments, DCNL then these are rendered as a JSON list.  If it\'s given keyword DCNL arguments then these are rendered as a JSON dict.'
def _call_agent(session, instance, vm_ref, method, addl_args=None, timeout=None): DCNL 'Abstracts out the interaction with the agent xenapi plugin.'
def find_guest_agent(base_dir): DCNL 'tries to locate a guest agent at the path DCNL specificed by agent_rel_path'
def find_network_with_bridge(session, bridge): DCNL 'Return the network on which the bridge is attached, if found. DCNL The bridge is defined in the nova db and can be found either in the DCNL \'bridge\' or \'name_label\' fields of the XenAPI network record.'
def forget_sr(session, sr_ref): DCNL 'Forgets the storage repository without destroying the VDIs within'
def find_sr_by_uuid(session, sr_uuid): DCNL 'Return the storage repository given a uuid.'
def find_sr_from_vbd(session, vbd_ref): DCNL 'Find the SR reference from the VBD reference.'
def introduce_vdi(session, sr_ref, vdi_uuid=None, target_lun=None): DCNL 'Introduce VDI in the host.'
def parse_volume_info(connection_data): DCNL 'Parse device_path and mountpoint as they can be used by XenAPI. DCNL In particular, the mountpoint (e.g. /dev/sdc) must be translated DCNL into a numeric literal.'
def mountpoint_to_number(mountpoint): DCNL 'Translate a mountpoint like /dev/sdc into a numeric.'
def _get_volume_id(path_or_id): DCNL 'Retrieve the volume id from device_path.'
def _get_target_host(iscsi_string): DCNL 'Retrieve target host.'
def _get_target_port(iscsi_string): DCNL 'Retrieve target port.'
def call_xenhost(session, method, arg_dict): DCNL 'There will be several methods that will need this general DCNL handling for interacting with the xenhost plugin, so this abstracts DCNL out that behavior.'
def _uuid_find(virtapi, context, host, name_label): DCNL 'Return instance uuid by name_label.'
def _host_find(context, session, src_aggregate, dst): DCNL 'Return the host from the xenapi host reference. DCNL :param src_aggregate: the aggregate that the compute host being put in DCNL maintenance (source of VMs) belongs to DCNL :param dst: the hypervisor host reference (destination of VMs) DCNL :return: the compute host that manages dst'
def is_hv_pool(metadata): DCNL 'Checks if aggregate is a hypervisor_pool.'
def get_disk_size(path): DCNL 'Get the (virtual) size of a disk image DCNL :param path: Path to the disk image DCNL :returns: Size (in bytes) of the given disk image as it would be seen DCNL by a virtual machine.'
def extend(image, size): DCNL 'Increase image to size.'
def can_resize_fs(image, size, use_cow=False): DCNL 'Check whether we can resize contained file system.'
def inject_data(image, key=None, net=None, metadata=None, admin_password=None, files=None, partition=None, use_cow=False, mandatory=()): DCNL 'Inject the specified items into a disk image. DCNL If an item name is not specified in the MANDATORY iterable, then a warning DCNL is logged on failure to inject that item, rather than raising an exception. DCNL it will mount the image as a fully partitioned disk and attempt to inject DCNL into the specified partition number. DCNL If PARTITION is not specified the image is mounted as a single partition. DCNL Returns True if all requested operations completed without issue. DCNL Raises an exception if a mandatory item can\'t be injected.'
def setup_container(image, container_dir, use_cow=False): DCNL 'Setup the LXC container. DCNL It will mount the loopback image to the container directory in order DCNL to create the root filesystem for the container.'
def teardown_container(container_dir): DCNL 'Teardown the container rootfs mounting once it is spawned. DCNL It will umount the container that is mounted, DCNL and delete any linked devices.'
def clean_lxc_namespace(container_dir): DCNL 'Clean up the container namespace rootfs mounting one spawned. DCNL It will umount the mounted names that is mounted DCNL but leave the linked deivces alone.'
def inject_data_into_fs(fs, key, net, metadata, admin_password, files, mandatory=()): DCNL 'Injects data into a filesystem already mounted by the caller. DCNL Virt connections can call this directly if they mount their fs DCNL in a different way to inject_data. DCNL If an item name is not specified in the MANDATORY iterable, then a warning DCNL is logged on failure to inject that item, rather than raising an exception. DCNL Returns True if all requested operations completed without issue. DCNL Raises an exception if a mandatory item can\'t be injected.'
def _setup_selinux_for_keys(fs, sshdir): DCNL 'Get selinux guests to ensure correct context on injected keys.'
def _inject_key_into_fs(key, fs): DCNL 'Add the given public ssh key to root\'s authorized_keys. DCNL key is an ssh key string. DCNL fs is the path to the base of the filesystem into which to inject the key.'
def _inject_net_into_fs(net, fs): DCNL 'Inject /etc/network/interfaces into the filesystem rooted at fs. DCNL net is the contents of /etc/network/interfaces.'
def _inject_admin_password_into_fs(admin_passwd, fs): DCNL 'Set the root password to admin_passwd DCNL admin_password is a root password DCNL fs is the path to the base of the filesystem into which to inject DCNL the key. DCNL This method modifies the instance filesystem directly, DCNL and does not require a guest agent running in the instance.'
def _set_passwd(username, admin_passwd, passwd_data, shadow_data): DCNL 'set the password for username to admin_passwd DCNL The passwd_file is not modified.  The shadow_file is updated. DCNL if the username is not found in both files, an exception is raised. DCNL :param username: the username DCNL :param encrypted_passwd: the  encrypted password DCNL :param passwd_file: path to the passwd file DCNL :param shadow_file: path to the shadow password file DCNL :returns: nothing DCNL :raises: exception.NovaException(), IOError()'
def get_cache_fname(images, key): DCNL 'Return a filename based on the SHA1 hash of a given image ID. DCNL Image files stored in the _base directory that match this pattern DCNL are considered for cleanup by the image cache manager. The cache DCNL manager considers the file to be in use if it matches an instance\'s DCNL image_ref, kernel_id or ramdisk_id property. DCNL However, in grizzly-3 and before, only the image_ref property was DCNL considered. This means that it\'s unsafe to store kernel and ramdisk DCNL images using this pattern until we\'re sure that all compute nodes DCNL are running a cache manager newer than grizzly-3. For now, we DCNL require admins to confirm that by setting the remove_unused_kernels DCNL boolean but, at some point in the future, we\'ll be safely able to DCNL assume this.'
def get_info_filename(base_path): DCNL 'Construct a filename for storing additional information about a base DCNL image. DCNL Returns a filename.'
def is_valid_info_file(path): DCNL 'Test if a given path matches the pattern for info files.'
def read_stored_info(target, field=None, timestamped=False): DCNL 'Read information about an image. DCNL Returns an empty dictionary if there is no info, just the field value if DCNL a field is requested, or the entire dictionary otherwise.'
def write_stored_info(target, field=None, value=None): DCNL 'Write information about an image.'
def read_stored_checksum(target, timestamped=True): DCNL 'Read the checksum. DCNL Returns the checksum (as hex) or None.'
def write_stored_checksum(target): DCNL 'Write a checksum to disk for a file in _base.'
def has_disk_dev(mapping, disk_dev): DCNL 'Determine if a disk device name has already been used. DCNL Looks at all the keys in mapping to see if any DCNL corresponding disk_info tuple has a device name DCNL matching disk_dev DCNL Returns True if the disk_dev is in use.'
def get_dev_prefix_for_disk_bus(disk_bus): DCNL 'Determine the dev prefix for a disk bus. DCNL Determine the dev prefix to be combined DCNL with a disk number to fix a disk_dev. DCNL eg \'hd\' for \'ide\' bus can be used to DCNL form a disk dev \'hda\' DCNL Returns the dev prefix or raises an DCNL exception if the disk bus is unknown.'
def get_dev_count_for_disk_bus(disk_bus): DCNL 'Determine the number disks supported. DCNL Determine how many disks can be supported in DCNL a single VM for a particular disk bus. DCNL Returns the number of disks supported.'
def find_disk_dev_for_disk_bus(mapping, bus, last_device=False): DCNL 'Identify a free disk dev name for a bus. DCNL Determines the possible disk dev names for DCNL the bus, and then checks them in order until DCNL it identifies one that is not yet used in the DCNL disk mapping. If \'last_device\' is set, it will DCNL only consider the last available disk dev name. DCNL Returns the chosen disk_dev name, or raises an DCNL exception if none is available.'
def get_disk_bus_for_device_type(virt_type, image_meta=None, device_type='disk'): DCNL 'Determine the best disk bus to use for a device type. DCNL Considering the currently configured virtualization DCNL type, return the optimal disk_bus to use for a given DCNL device type. For example, for a disk on KVM it will DCNL return \'virtio\', while for a CDROM it will return \'ide\' DCNL Returns the disk_bus, or returns None if the device DCNL type is not supported for this virtualization'
def get_disk_bus_for_disk_dev(virt_type, disk_dev): DCNL 'Determine the disk bus for a disk dev. DCNL Given a disk devi like \'hda\', \'sdf\', \'xvdb\', etc DCNL guess what the most appropriate disk bus is for DCNL the currently configured virtualization technology DCNL Returns the disk bus, or raises an Exception if DCNL the disk dev prefix is unknown.'
def get_next_disk_info(mapping, disk_bus, device_type='disk', last_device=False): DCNL 'Determine the disk info for the next device on disk_bus. DCNL Considering the disks already listed in the disk mapping, DCNL determine the next available disk dev that can be assigned DCNL for the disk bus. DCNL Returns the disk_info for the next available disk.'
def get_disk_mapping(virt_type, instance, disk_bus, cdrom_bus, block_device_info=None, image_meta=None, rescue=False): DCNL 'Determine how to map default disks to the virtual machine. DCNL This is about figuring out whether the default \'disk\', DCNL \'disk.local\', \'disk.swap\' and \'disk.config\' images have DCNL been overriden by the block device mapping. DCNL Returns the guest disk mapping for the devices.'
def get_disk_info(virt_type, instance, block_device_info=None, image_meta=None, rescue=False): DCNL 'Determine guest disk mapping info. DCNL This is a wrapper around get_disk_mapping, which DCNL also returns the chosen disk_bus and cdrom_bus. DCNL The returned data is in a dict DCNL - disk_bus: the bus for harddisks DCNL - cdrom_bus: the bus for CDROMs DCNL - mapping: the disk mapping DCNL Returns the disk mapping disk.'
def set_vif_guest_frontend_config(conf, mac, model, driver): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with guest frontend details'
def set_vif_host_backend_bridge_config(conf, brname, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for a software bridge'
def set_vif_host_backend_ethernet_config(conf, tapname): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an externally configured DCNL host device. DCNL NB use of this configuration is discouraged by DCNL libvirt project and will mark domains as \'tainted\''
def set_vif_host_backend_ovs_config(conf, brname, interfaceid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an OpenVSwitch bridge'
def set_vif_host_backend_802qbg_config(conf, devname, managerid, typeid, typeidversion, instanceid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an 802.1qbg device'
def set_vif_host_backend_802qbh_config(conf, devname, profileid, tapname=None): DCNL 'Populate a LibvirtConfigGuestInterface instance DCNL with host backend details for an 802.1qbh device'
def set_vif_bandwidth_config(conf, extra_specs): DCNL 'Config vif inbound/outbound bandwidth limit. parameters are DCNL set in instance_type_extra_specs table, key is in  the format DCNL quota:vif_inbound_average.'
def get_iscsi_initiator(): DCNL 'Get iscsi initiator name for this machine.'
def get_fc_hbas(): DCNL 'Get the Fibre Channel HBA information.'
def get_fc_hbas_info(): DCNL 'Get Fibre Channel WWNs and device paths from the system, if any.'
def get_fc_wwpns(): DCNL 'Get Fibre Channel WWPNs from the system, if any.'
def get_fc_wwnns(): DCNL 'Get Fibre Channel WWNNs from the system, if any.'
def create_image(disk_format, path, size): DCNL 'Create a disk image DCNL :param disk_format: Disk image format (as known by qemu-img) DCNL :param path: Desired location of the disk image DCNL :param size: Desired size of disk image. May be given as an int or DCNL a string. If given as an int, it will be interpreted DCNL as bytes. If it\'s a string, it should consist of a number DCNL with an optional suffix (\'K\' for Kibibytes, DCNL M for Mebibytes, \'G\' for Gibibytes, \'T\' for Tebibytes). DCNL If no suffix is given, it will be interpreted as bytes.'
def create_cow_image(backing_file, path, size=None): DCNL 'Create COW image DCNL Creates a COW image with the given backing file DCNL :param backing_file: Existing image on which to base the COW image DCNL :param path: Desired location of the COW image'
def create_lvm_image(vg, lv, size, sparse=False): DCNL 'Create LVM image. DCNL Creates a LVM image with given size. DCNL :param vg: existing volume group which should hold this image DCNL :param lv: name for this image (logical volume) DCNL :size: size of image in bytes DCNL :sparse: create sparse logical volume'
def get_volume_group_info(vg): DCNL 'Return free/used/total space info for a volume group in bytes DCNL :param vg: volume group name DCNL :returns: A dict containing: DCNL :total: How big the filesystem is (in bytes) DCNL :free: How much space is free (in bytes) DCNL :used: How much space is used (in bytes)'
def list_logical_volumes(vg): DCNL 'List logical volumes paths for given volume group. DCNL :param vg: volume group name'
def logical_volume_info(path): DCNL 'Get logical volume info. DCNL :param path: logical volume path'
def logical_volume_size(path): DCNL 'Get logical volume size in bytes. DCNL :param path: logical volume path'
def clear_logical_volume(path): DCNL 'Obfuscate the logical volume. DCNL :param path: logical volume path'
def remove_logical_volumes(*paths): DCNL 'Remove one or more logical volume.'
def pick_disk_driver_name(is_block_dev=False): DCNL 'Pick the libvirt primary backend driver name DCNL If the hypervisor supports multiple backend drivers, then the name DCNL attribute selects the primary backend driver name, while the optional DCNL type attribute provides the sub-type.  For example, xen supports a name DCNL of "tap", "tap2", "phy", or "file", with a type of "aio" or "qcow2", DCNL while qemu only supports a name of "qemu", but multiple types including DCNL "raw", "bochs", "qcow2", and "qed". DCNL :param is_block_dev: DCNL :returns: driver_name or None'
def get_disk_size(path): DCNL 'Get the (virtual) size of a disk image DCNL :param path: Path to the disk image DCNL :returns: Size (in bytes) of the given disk image as it would be seen DCNL by a virtual machine.'
def get_disk_backing_file(path, basename=True): DCNL 'Get the backing file of a disk image DCNL :param path: Path to the disk image DCNL :returns: a path to the image\'s backing store'
def copy_image(src, dest, host=None): DCNL 'Copy a disk image to an existing directory DCNL :param src: Source image DCNL :param dest: Destination path DCNL :param host: Remote host'
def write_to_file(path, contents, umask=None): DCNL 'Write the given contents to a file DCNL :param path: Destination file DCNL :param contents: Desired contents of the file DCNL :param umask: Umask to set when creating this file (will be reset)'
def chown(path, owner): DCNL 'Change ownership of file or directory DCNL :param path: File or directory whose ownership to change DCNL :param owner: Desired new owner (given as uid or username)'
def create_snapshot(disk_path, snapshot_name): DCNL 'Create a snapshot in a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image'
def delete_snapshot(disk_path, snapshot_name): DCNL 'Create a snapshot in a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image'
def extract_snapshot(disk_path, source_fmt, snapshot_name, out_path, dest_fmt): DCNL 'Extract a named snapshot from a disk image DCNL :param disk_path: Path to disk image DCNL :param snapshot_name: Name of snapshot in disk image DCNL :param out_path: Desired path of extracted snapshot'
def load_file(path): DCNL 'Read contents of file DCNL :param path: File to read'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def file_delete(path): DCNL 'Delete (unlink) file DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def find_disk(virt_dom): DCNL 'Find root device path for instance DCNL May be file or device'
def get_disk_type(path): DCNL 'Retrieve disk type (raw, qcow2, lvm) for given file.'
def get_fs_info(path): DCNL 'Get free/used/total space info for a filesystem DCNL :param path: Any dirent on the filesystem DCNL :returns: A dict containing: DCNL :free: How much space is free (in bytes) DCNL :used: How much space is used (in bytes) DCNL :total: How big the filesystem is (in bytes)'
def fetch_image(context, target, image_id, user_id, project_id): DCNL 'Grab image.'
def get_instance_path(instance, forceold=False): DCNL 'Determine the correct path for instance storage. DCNL This method determines the directory name for instance storage, while DCNL handling the fact that we changed the naming style to something more DCNL unique in the grizzly release. DCNL :param instance: the instance we want a path for DCNL :param forceold: force the use of the pre-grizzly format DCNL :returns: a path to store information about that instance'
def patch_tpool_proxy(): DCNL 'eventlet.tpool.Proxy doesn\'t work with old-style class in __str__() DCNL or __repr__() calls. See bug #962840 for details. DCNL We perform a monkey patch to replace those two instance methods.'
def load_compute_driver(virtapi, compute_driver=None): DCNL 'Load a compute driver module. DCNL Load the compute driver module specified by the compute_driver DCNL configuration option or, if supplied, the driver name supplied as an DCNL argument. DCNL Compute drivers constructors take a VirtAPI object as their first object DCNL and this must be supplied. DCNL :param virtapi: a VirtAPI instance DCNL :param compute_driver: a compute driver name to override the config opt DCNL :returns: a ComputeDriver instance'
def ssh_connect(connection): DCNL 'Method to connect to remote system using ssh protocol. DCNL :param connection: a Connection object. DCNL :returns: paramiko.SSHClient -- an active ssh connection. DCNL :raises: PowerVMConnectionFailed'
def ssh_command_as_root(ssh_connection, cmd, check_exit_code=True): DCNL 'Method to execute remote command as root. DCNL :param connection: an active paramiko.SSHClient connection. DCNL :param command: string containing the command to run. DCNL :returns: Tuple -- a tuple of (stdout, stderr) DCNL :raises: nova.exception.ProcessExecutionError'
def ftp_put_command(connection, local_path, remote_dir): DCNL 'Method to transfer a file via ftp. DCNL :param connection: a Connection object. DCNL :param local_path: path to the local file DCNL :param remote_dir: path to remote destination DCNL :raises: PowerVMFileTransferFailed'
def ftp_get_command(connection, remote_path, local_path): DCNL 'Retrieve a file via FTP DCNL :param connection: a Connection object. DCNL :param remote_path: path to the remote file DCNL :param local_path: path to local destination DCNL :raises: PowerVMFileTransferFailed'
def aix_path_join(path_one, path_two): DCNL 'Ensures file path is built correctly for remote UNIX system DCNL :param path_one: string of the first file path DCNL :param path_two: string of the second file path DCNL :returns: a uniform path constructed from both strings'
@contextlib.contextmanager DCNL def vios_to_vios_auth(source, dest, conn_info): DCNL 'Context allowing for SSH between VIOS partitions DCNL This context will build an SSH key on the source host, put the key DCNL into the authorized_keys on the destination host, and make the DCNL private key file name available within the context. DCNL The key files and key inserted into authorized_keys will be DCNL removed when the context exits. DCNL :param source: source IP or DNS name DCNL :param dest: destination IP or DNS name DCNL :param conn_info: dictionary object with SSH connection DCNL information for both hosts'
def load_from_conf_data(conf_data): DCNL 'LPAR configuration data parser. DCNL The configuration data is a string representation of DCNL the attributes of a Logical Partition. The attributes DCNL consists of name/value pairs, which are in command separated DCNL value format. DCNL Example format: name=lpar_name,lpar_id=1,lpar_env=aixlinux DCNL :param conf_data: string containing the LPAR configuration data. DCNL :returns: LPAR -- LPAR object.'
def getcallargs(function, *args, **kwargs): DCNL 'This is a simplified inspect.getcallargs (2.7+). DCNL It should be replaced when python >= 2.7 is standard.'
def vpn_ping(address, port, timeout=0.05, session_id=None): DCNL 'Sends a vpn negotiation packet and returns the server session. DCNL Returns False on a failure. Basic packet structure is below. DCNL Client packet (14 bytes):: DCNL 0 1      8 9  13 DCNL |x| cli_id |?????| DCNL x = packet identifier 0x38 DCNL cli_id = 64 bit identifier DCNL ? = unknown, probably flags/padding DCNL Server packet (26 bytes):: DCNL 0 1      8 9  13 14    21 2225 DCNL |x| srv_id |?????| cli_id |????| DCNL x = packet identifier 0x40 DCNL cli_id = 64 bit identifier DCNL ? = unknown, probably flags/padding DCNL bit 9 was 1 and the rest were 0 in testing'
def execute(*cmd, **kwargs): DCNL 'Helper method to execute command with optional retry. DCNL If you add a run_as_root=True command, don\'t forget to add the DCNL corresponding filter to etc/nova/rootwrap.d ! DCNL :param cmd:                Passed to subprocess.Popen. DCNL :param process_input:      Send to opened process. DCNL :param check_exit_code:    Single bool, int, or list of allowed exit DCNL codes.  Defaults to [0].  Raise DCNL exception.ProcessExecutionError unless DCNL program exits with one of these code. DCNL :param delay_on_retry:     True | False. Defaults to True. If set to DCNL True, wait a short amount of time DCNL before retrying. DCNL :param attempts:           How many times to retry cmd. DCNL :param run_as_root:        True | False. Defaults to False. If set to True, DCNL the command is run with rootwrap. DCNL :raises exception.NovaException: on receiving unknown arguments DCNL :raises exception.ProcessExecutionError: DCNL :returns: a tuple, (stdout, stderr) from the spawned process, or None if DCNL the command fails.'
def trycmd(*args, **kwargs): DCNL 'A wrapper around execute() to more easily handle warnings and errors. DCNL Returns an (out, err) tuple of strings containing the output of DCNL the command\'s stdout and stderr.  If \'err\' is not empty then the DCNL command can be considered to have failed. DCNL :discard_warnings   True | False. Defaults to False. If set to True, DCNL then for succeeding commands, stderr is cleared'
def last_completed_audit_period(unit=None, before=None): DCNL 'This method gives you the most recently *completed* audit period. DCNL arguments: DCNL units: string, one of \'hour\', \'day\', \'month\', \'year\' DCNL Periods normally begin at the beginning (UTC) of the DCNL period unit (So a \'day\' period begins at midnight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appended with an optional offset DCNL like so:  \'day@18\'  This will begin the period at 18:00 DCNL UTC.  \'month@15\' starts a monthly period on the 15th, DCNL and year@3 begins a yearly one on March 1st. DCNL before: Give the audit period most recently completed before DCNL <timestamp>. Defaults to now. DCNL returns:  2 tuple of datetimes (begin, end) DCNL The begin timestamp of this audit period is the same as the DCNL end of the previous.'
def generate_password(length=None, symbolgroups=DEFAULT_PASSWORD_SYMBOLS): DCNL 'Generate a random password from the supplied symbol groups. DCNL At least one symbol from each group will be included. Unpredictable DCNL results if length is less than the number of symbol groups. DCNL Believed to be reasonably secure (with a reasonable password length!)'
def xhtml_escape(value): DCNL 'Escapes a string so it is valid within XML or XHTML.'
def utf8(value): DCNL 'Try to turn a string into utf-8 if possible. DCNL Code is directly from the utf8 function in DCNL http://github.com/facebook/tornado/blob/master/tornado/escape.py'
def to_bytes(text, default=0): DCNL 'Try to turn a string into a number of bytes. Looks at the last DCNL characters of the text to determine what conversion is needed to DCNL turn the input text into a byte number. DCNL Supports: B/b, K/k, M/m, G/g, T/t (or the same with b/B on the end)'
def delete_if_exists(pathname): DCNL 'delete a file, but ignore file not found error.'
def get_from_path(items, path): DCNL 'Returns a list of items matching the specified path. DCNL Takes an XPath-like expression e.g. prop1/prop2/prop3, and for each item DCNL in items, looks up items[prop1][prop2][prop3].  Like XPath, if any of the DCNL intermediate results are lists it will treat each list item individually. DCNL A \'None\' in items or any child expressions will be ignored, this function DCNL will not throw because of None (anywhere) in items.  The returned list DCNL will contain no None values.'
def flatten_dict(dict_, flattened=None): DCNL 'Recursively flatten a nested dictionary.'
def partition_dict(dict_, keys): DCNL 'Return two dicts, one with `keys` the other with everything else.'
def map_dict_keys(dict_, key_map): DCNL 'Return a dict in which the dictionaries keys are mapped to new keys.'
def subset_dict(dict_, keys): DCNL 'Return a dict that only contains a subset of keys.'
def diff_dict(orig, new): DCNL 'Return a dict describing how to change orig to new.  The keys DCNL correspond to values that have changed; the value will be a list DCNL of one or two elements.  The first element of the list will be DCNL either \'+\' or \'-\', indicating whether the key was updated or DCNL deleted; if the key was updated, the list will contain a second DCNL element, giving the updated value.'
def check_isinstance(obj, cls): DCNL 'Checks that obj is of type cls, and lets PyLint infer types.'
def parse_server_string(server_str): DCNL 'Parses the given server_string and returns a list of host and port. DCNL If it\'s not a combination of host part and port, the port element DCNL is a null string. If the input is invalid expression, return a null DCNL list.'
def bool_from_str(val): DCNL 'Convert a string representation of a bool into a bool value.'
def is_int_like(val): DCNL 'Check if a value looks like an int.'
def is_valid_boolstr(val): DCNL 'Check if the provided string is a valid bool string or not.'
def is_valid_ipv4(address): DCNL 'Verify that address represents a valid IPv4 address.'
def is_valid_cidr(address): DCNL 'Check if the provided ipv4 or ipv6 address is a valid DCNL CIDR address or not'
def get_ip_version(network): DCNL 'Returns the IP version of a network (IPv4 or IPv6). Raises DCNL AddrFormatError if invalid network.'
def monkey_patch(): DCNL 'If the Flags.monkey_patch set as True, DCNL this function patches a decorator DCNL for all functions in specified modules. DCNL You can set decorators for each modules DCNL using CONF.monkey_patch_modules. DCNL The format is "Module path:Decorator function". DCNL Example: DCNL \'nova.api.ec2.cloud:nova.openstack.common.notifier.api.notify_decorator\' DCNL Parameters of the decorator is as follows. DCNL (See nova.openstack.common.notifier.api.notify_decorator) DCNL name - name of the function DCNL function - object of the function'
def convert_to_list_dict(lst, label): DCNL 'Convert a value or list into a list of dicts.'
def timefunc(func): DCNL 'Decorator that logs how long a particular function took to execute.'
@contextlib.contextmanager DCNL def remove_path_on_error(path): DCNL 'Protect code that wants to operate on PATH atomically. DCNL Any exception will cause PATH to be removed.'
def make_dev_path(dev, partition=None, base='/dev'): DCNL 'Return a path to a particular device. DCNL >>> make_dev_path(\'xvdc\') DCNL /dev/xvdc DCNL >>> make_dev_path(\'xvdc\', 1) DCNL /dev/xvdc1'
def total_seconds(td): DCNL 'Local total_seconds implementation for compatibility with python 2.6.'
def sanitize_hostname(hostname): DCNL 'Return a hostname which conforms to RFC-952 and RFC-1123 specs.'
def read_cached_file(filename, cache_info, reload_func=None): DCNL 'Read from a file if it has been modified. DCNL :param cache_info: dictionary to hold opaque cache. DCNL :param reload_func: optional function to be called with data when DCNL file is reloaded due to a modification. DCNL :returns: data from file'
def file_open(*args, **kwargs): DCNL 'Open file DCNL see built-in file() documentation for more details DCNL Note: The reason this is kept in a separate module is to easily DCNL be able to provide a stub module that doesn\'t alter system DCNL state at all (for unit tests)'
def hash_file(file_like_object): DCNL 'Generate a hash for the contents of a file.'
@contextlib.contextmanager DCNL def temporary_mutation(obj, **kwargs): DCNL 'Temporarily set the attr on a particular object to a given value then DCNL revert when finished. DCNL One use of this is to temporarily set the read_deleted flag on a context DCNL object: DCNL with temporary_mutation(context, read_deleted="yes"): DCNL do_something_that_needed_deleted_objects()'
def generate_mac_address(): DCNL 'Generate an Ethernet MAC address.'
def read_file_as_root(file_path): DCNL 'Secure helper to read file as root.'
@contextlib.contextmanager DCNL def temporary_chown(path, owner_uid=None): DCNL 'Temporarily chown a path. DCNL :params owner_uid: UID of temporary owner (defaults to current user)'
def walk_class_hierarchy(clazz, encountered=None): DCNL 'Walk class hierarchy, yielding most derived classes first.'
def mkfs(fs, path, label=None): DCNL 'Format a file or block device DCNL :param fs: Filesystem type (examples include \'swap\', \'ext3\', \'ext4\' DCNL \'btrfs\', etc.) DCNL :param path: Path to file or block device to format DCNL :param label: Volume label to use'
def last_bytes(file_like_object, num): DCNL 'Return num bytes from the end of the file, and remaining byte count. DCNL :param file_like_object: The file to read DCNL :param num: The number of bytes to return DCNL :returns (data, remaining)'
def get_wrapped_function(function): DCNL 'Get the method at the bottom of a stack of decorators.'
def check_string_length(value, name, min_length=0, max_length=None): DCNL 'Check the length of specified string DCNL :param value: the value of the string DCNL :param name: the name of the string DCNL :param min_length: the min_length of the string DCNL :param max_length: the max_length of the string'
def enforce(context, action, target, do_raise=True): DCNL 'Verifies that the action is valid on the target in this context. DCNL :param context: nova context DCNL :param action: string representing the action to be checked DCNL this should be colon separated for clarity. DCNL i.e. ``compute:create_instance``, DCNL ``compute:attach_volume``, DCNL ``volume:attach_volume`` DCNL :param target: dictionary representing the object of the action DCNL for object creation this should be a dictionary representing the DCNL location of the object e.g. ``{\'project_id\': context.project_id}`` DCNL :param do_raise: if True (the default), raises PolicyNotAuthorized; DCNL if False, returns False DCNL :raises nova.exception.PolicyNotAuthorized: if verification fails DCNL and do_raise is True. DCNL :return: returns a non-False value (not necessarily "True") if DCNL authorized, and the exact value False if not authorized and DCNL do_raise is False.'
def check_is_admin(context): DCNL 'Whether or not roles contains \'admin\' role according to policy setting.'
def ensure_ca_filesystem(): DCNL 'Ensure the CA filesystem exists.'
def fetch_crl(project_id): DCNL 'Get crl file for project.'
def convert_from_sshrsa_to_pkcs8(pubkey): DCNL 'Convert a ssh public key to openssl format DCNL Equivalent to the ssh-keygen\'s -m option'
def ssh_encrypt_text(ssh_public_key, text): DCNL 'Encrypt text with an ssh public key.'
def revoke_cert(project_id, file_name): DCNL 'Revoke a cert by file name.'
def revoke_certs_by_user(user_id): DCNL 'Revoke all user certs.'
def revoke_certs_by_project(project_id): DCNL 'Revoke all project certs.'
def revoke_certs_by_user_and_project(user_id, project_id): DCNL 'Revoke certs for user in project.'
def _project_cert_subject(project_id): DCNL 'Helper to generate user cert subject.'
def _user_cert_subject(user_id, project_id): DCNL 'Helper to generate user cert subject.'
def generate_x509_cert(user_id, project_id, bits=1024): DCNL 'Generate and sign a cert for user in project.'
def compute_md5(fp): DCNL 'Compute an md5 hash. DCNL :type fp: file DCNL :param fp: File pointer to the file to MD5 hash.  The file pointer will be DCNL reset to the beginning of the file before the method returns. DCNL :rtype: tuple DCNL :returns: the hex digest version of the MD5 hash'
def periodic_task(*args, **kwargs): DCNL 'Decorator to indicate that a method is a periodic task. DCNL This decorator can be used in two ways: DCNL 1. Without arguments \'@periodic_task\', this will be run on every cycle DCNL of the periodic scheduler. DCNL 2. With arguments: DCNL @periodic_task(spacing=N [, run_immediately=[True|False]]) DCNL this will be run on approximately every N seconds. If this number is DCNL negative the periodic task will be disabled. If the run_immediately DCNL argument is provided and has a value of \'True\', the first run of the DCNL task will be shortly after task scheduler starts.  If DCNL run_immediately is omitted or set to \'False\', the first time the DCNL task runs will be approximately N seconds after the task scheduler DCNL starts.'
def properties_root_device_name(properties): DCNL 'get root device name from image meta data. DCNL If it isn\'t specified, return None.'
def mappings_prepend_dev(mappings): DCNL 'Prepend \'/dev/\' to \'device\' entry of swap/ephemeral virtual type.'
def strip_dev(device_name): DCNL 'remove leading \'/dev/\'.'
def strip_prefix(device_name): DCNL 'remove both leading /dev/ and xvd or sd or vd.'
def match_device(device): DCNL 'Matches device name and returns prefix, suffix.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(43) defined in version 149.'
def upgrade(migrate_engine): DCNL 'Convert String columns holding IP addresses to INET for postgresql.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(255).'
def upgrade(migrate_engine): DCNL 'Convert period_beginning and period_ending to DateTime.'
def downgrade(migrate_engine): DCNL 'Convert columns back to String(255).'
def _drop_index(engine, table, idx_name): DCNL 'Drop index from DB and remove index from SQLAlchemy table metadata. DCNL idx.drop() in SQLAlchemy will issue a DROP INDEX statement to the DB but DCNL WILL NOT update the table metadata to remove the `Index` object. DCNL This can cause subsequent drop column calls on a related column to fail DCNL because `drop_column` will see an `Index` object that isn\'t there, thus DCNL issuing an erroneous second DROP INDEX call. DCNL The solution is to update the table metadata to reflect the now dropped DCNL column.'
def _map_nodes(meta): DCNL 'Map host to compute node(s) for the purpose of determining which hosts DCNL are single vs multi-node.'
def _update_nodes(nodemap, instances, migrations): DCNL 'For each migration and matching instance record, update the node columns DCNL if the referenced host is single-node. DCNL Skip updates for multi-node hosts.  In that case, there\'s no way to DCNL determine which node on a host the record should be associated with.'
def upgrade(migrate_engine): DCNL 'Convert String columns holding IP addresses to INET for postgresql.'
def downgrade(migrate_engine): DCNL 'Convert columns back to the larger String(255).'
def _find_migrate_repo(): DCNL 'Get the path for the migrate repository.'
def drop_unique_constraint(migrate_engine, table_name, uc_name, *columns, **col_name_col_instance): DCNL 'This method drops UC from table and works for mysql, postgresql and sqlite. DCNL In mysql and postgresql we are able to use "alter table" constuction. In DCNL sqlite is only one way to drop UC: DCNL 1) Create new table with same columns, indexes and constraints DCNL (except one that we want to drop). DCNL 2) Copy data from old table to new. DCNL 3) Drop old table. DCNL 4) Rename new table to the name of old table. DCNL :param migrate_engine: sqlalchemy engine DCNL :param table_name:     name of table that contains uniq constarint. DCNL :param uc_name:        name of uniq constraint that will be dropped. DCNL :param columns:        columns that are in uniq constarint. DCNL :param col_name_col_instance:   contains pair column_name=column_instance. DCNL column_instance is instance of Column. These params DCNL are required only for columns that have unsupported DCNL types by sqlite. For example BigInteger.'
def drop_old_duplicate_entries_from_table(migrate_engine, table_name, use_soft_delete, *uc_column_names): DCNL 'This method is used to drop all old rows that have the same values for DCNL columns in uc_columns.'
def get_backend(): DCNL 'The backend is this module itself.'
def require_admin_context(f): DCNL 'Decorator to require admin request context. DCNL The first argument to the wrapped function must be the context.'
def require_context(f): DCNL 'Decorator to require *any* user or admin context. DCNL This does no authorization for user or project access matching, see DCNL :py:func:`nova.context.authorize_project_context` and DCNL :py:func:`nova.context.authorize_user_context`. DCNL The first argument to the wrapped function must be the context.'
def require_instance_exists_using_uuid(f): DCNL 'Decorator to require the specified instance to exist. DCNL Requires the wrapped function to use context and instance_uuid as DCNL their first two arguments.'
def require_aggregate_exists(f): DCNL 'Decorator to require the specified aggregate to exist. DCNL Requires the wrapped function to use context and aggregate_id as DCNL their first two arguments.'
def _retry_on_deadlock(f): DCNL 'Decorator to retry a DB API call if Deadlock was received.'
def model_query(context, model, *args, **kwargs): DCNL 'Query helper that accounts for context\'s `read_deleted` field. DCNL :param context: context to query under DCNL :param session: if present, the session to use DCNL :param read_deleted: if present, overrides context\'s read_deleted field. DCNL :param project_only: if present and context is user-type, then restrict DCNL query to match the context\'s project_id. If set to \'allow_none\', DCNL restriction includes project_id = None. DCNL :param base_model: Where model_query is passed a "model" parameter which is DCNL not a subclass of NovaBase, we should pass an extra base_model DCNL parameter that is a subclass of NovaBase and corresponds to the DCNL model parameter.'
def exact_filter(query, model, filters, legal_keys): DCNL 'Applies exact match filtering to a query. DCNL Returns the updated query.  Modifies filters argument to remove DCNL filters consumed. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to, for IN-style DCNL filtering DCNL :param filters: dictionary of filters; values that are lists, DCNL tuples, sets, or frozensets cause an \'IN\' test to DCNL be performed, while exact matching (\'==\' operator) DCNL is used for other values DCNL :param legal_keys: list of keys to apply exact filtering to'
def _prep_stats_dict(values): DCNL 'Make list of ComputeNodeStats.'
@require_admin_context DCNL def compute_node_create(context, values): DCNL 'Creates a new ComputeNode and populates the capacity fields DCNL with the most recent data.'
@require_admin_context DCNL def compute_node_update(context, compute_id, values, prune_stats=False): DCNL 'Updates the ComputeNode record with the most recent data.'
@require_admin_context DCNL def compute_node_delete(context, compute_id): DCNL 'Delete a ComputeNode record.'
def compute_node_statistics(context): DCNL 'Compute statistics over all compute nodes.'
def _ip_range_splitter(ips, block_size=256): DCNL 'Yields blocks of IPs no more than block_size elements long.'
@require_admin_context DCNL def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL 'Keyword arguments: DCNL reserved -- should be a boolean value(True or False), exact value will be DCNL used to filter on the fixed ip address'
@require_admin_context DCNL def fixed_ip_get_by_address_detailed(context, address, session=None): DCNL ':returns: a tuple of (models.FixedIp, models.Network, models.Instance)'
@require_context DCNL def virtual_interface_create(context, values): DCNL 'Create a new virtual interface record in the database. DCNL :param values: = dict containing column values'
@require_context DCNL def virtual_interface_get(context, vif_id): DCNL 'Gets a virtual interface from the table. DCNL :param vif_id: = id of the virtual interface'
@require_context DCNL def virtual_interface_get_by_address(context, address): DCNL 'Gets a virtual interface from the table. DCNL :param address: = the address of the interface you\'re looking to get'
@require_context DCNL def virtual_interface_get_by_uuid(context, vif_uuid): DCNL 'Gets a virtual interface from the table. DCNL :param vif_uuid: the uuid of the interface you\'re looking to get'
@require_context DCNL @require_instance_exists_using_uuid DCNL def virtual_interface_get_by_instance(context, instance_uuid): DCNL 'Gets all virtual interfaces for instance. DCNL :param instance_uuid: = uuid of the instance to retrieve vifs for'
@require_context DCNL def virtual_interface_get_by_instance_and_network(context, instance_uuid, network_id): DCNL 'Gets virtual interface for instance that\'s associated with network.'
@require_context DCNL def virtual_interface_delete_by_instance(context, instance_uuid): DCNL 'Delete virtual interface records that are associated DCNL with the instance given by instance_id. DCNL :param instance_uuid: = uuid of instance'
@require_context DCNL def virtual_interface_get_all(context): DCNL 'Get all vifs.'
@require_context DCNL def instance_create(context, values): DCNL 'Create a new Instance record in the database. DCNL context - request context object DCNL values - dict containing column values.'
def _instances_fill_metadata(context, instances, manual_joins=None): DCNL 'Selectively fill instances with manually-joined metadata. Note that DCNL instance will be converted to a dict. DCNL :param context: security context DCNL :param instances: list of instances to fill DCNL :param manual_joins: list of tables to manually join (can be any DCNL combination of \'metadata\' and \'system_metadata\' or DCNL None to take the default of both)'
@require_context DCNL def instance_get_all_by_filters(context, filters, sort_key, sort_dir, limit=None, marker=None, columns_to_join=None, session=None): DCNL 'Return instances that match all filters.  Deleted instances DCNL will be returned by default, unless there\'s a filter that says DCNL otherwise'
def regex_filter(query, model, filters): DCNL 'Applies regular expression filtering to a query. DCNL Returns the updated query. DCNL :param query: query to apply filters to DCNL :param model: model object the query applies to DCNL :param filters: dictionary of filters with regex values'
@require_context DCNL def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL 'Return instances and joins that were active during window.'
@require_admin_context DCNL def _instance_get_all_uuids_by_host(context, host, session=None): DCNL 'Return a list of the instance uuids on a given host. DCNL Returns a list of UUIDs, not Instance model objects. This internal version DCNL allows you to specify a session object as a kwarg.'
@require_context DCNL def instance_update_and_get_original(context, instance_uuid, values): DCNL 'Set the given properties on an instance and update it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL updated one. DCNL :param context: = request context object DCNL :param instance_uuid: = instance uuid DCNL :param values: = dict containing column values DCNL If "expected_task_state" exists in values, the update can only happen DCNL when the task state before update matches expected_task_state. Otherwise DCNL a UnexpectedTaskStateError is thrown. DCNL :returns: a tuple of the form (old_instance_ref, new_instance_ref) DCNL Raises NotFound if instance does not exist.'
def instance_add_security_group(context, instance_uuid, security_group_id): DCNL 'Associate the given security group with the given instance.'
@require_context DCNL def instance_remove_security_group(context, instance_uuid, security_group_id): DCNL 'Disassociate the given security group from the given instance.'
@require_context DCNL def instance_info_cache_get(context, instance_uuid): DCNL 'Gets an instance info cache from the table. DCNL :param instance_uuid: = uuid of the info cache\'s instance DCNL :param session: = optional session object'
@require_context DCNL def instance_info_cache_update(context, instance_uuid, values): DCNL 'Update an instance info cache record in the table. DCNL :param instance_uuid: = uuid of info cache\'s instance DCNL :param values: = dict containing column values to update DCNL :param session: = optional session object'
@require_context DCNL def instance_info_cache_delete(context, instance_uuid): DCNL 'Deletes an existing instance_info_cache record DCNL :param instance_uuid: = uuid of the instance tied to the cache record DCNL :param session: = optional session object'
@require_admin_context DCNL def network_associate(context, project_id, network_id=None, force=False): DCNL 'Associate a project with a network. DCNL called by project_get_networks under certain conditions DCNL and network manager add_network_to_project() DCNL only associate if the project doesn\'t already have a network DCNL or if force is True DCNL force solves race condition where a fresh project has multiple instance DCNL builds simultaneously picked up by multiple network hosts which attempt DCNL to associate the project with multiple networks DCNL force should only be used as a direct consequence of user request DCNL all automated requests should not use force'
def _quota_reservations_query(session, context, reservations): DCNL 'Return the relevant reservations.'
@require_context DCNL def ec2_volume_create(context, volume_uuid, id=None): DCNL 'Create ec2 compatible volume by provided uuid.'
@require_context DCNL def ec2_snapshot_create(context, snapshot_uuid, id=None): DCNL 'Create ec2 compatible snapshot by provided uuid.'
def _security_group_get_by_names(context, session, project_id, group_names): DCNL 'Get security group models for a project by a list of names. DCNL Raise SecurityGroupNotFoundForProject for a name not found.'
def security_group_ensure_default(context, session=None): DCNL 'Ensure default security group exists for a project_id. DCNL Returns a tuple with the first element being a bool indicating DCNL if the default security group previously existed. Second DCNL element is the dict used to create the default security group.'
@require_admin_context DCNL def instance_type_create(context, values): DCNL 'Create a new instance type. In order to pass in extra specs, DCNL the values dict should contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'
def _dict_with_extra_specs(inst_type_query): DCNL 'Takes an instance or instance type query returned DCNL by sqlalchemy and returns it as a dictionary, converting the DCNL extra_specs entry from a list of dicts: DCNL \'extra_specs\' : [{\'key\': \'k1\', \'value\': \'v1\', ...}, ...] DCNL to a single dict: DCNL \'extra_specs\' : {\'k1\': \'v1\'}'
@require_context DCNL def instance_type_get_all(context, inactive=False, filters=None): DCNL 'Returns all instance types.'
@require_context DCNL def instance_type_get(context, id, session=None): DCNL 'Returns a dict describing specific instance_type.'
@require_context DCNL def instance_type_get_by_name(context, name, session=None): DCNL 'Returns a dict describing specific instance_type.'
@require_context DCNL def instance_type_get_by_flavor_id(context, flavor_id, session=None): DCNL 'Returns a dict describing specific flavor_id.'
@require_admin_context DCNL def instance_type_destroy(context, name): DCNL 'Marks specific instance_type as deleted.'
@require_admin_context DCNL def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL 'Get flavor access list by flavor id.'
@require_admin_context DCNL def instance_type_access_add(context, flavor_id, project_id): DCNL 'Add given tenant to the flavor access list.'
@require_admin_context DCNL def instance_type_access_remove(context, flavor_id, project_id): DCNL 'Remove given tenant from the flavor access list.'
@require_context DCNL def vol_get_usage_by_time(context, begin): DCNL 'Return volumes usage that have been updated after a specified time.'
def s3_image_get(context, image_id): DCNL 'Find local s3 image represented by the provided id.'
def s3_image_get_by_uuid(context, image_uuid): DCNL 'Find local s3 image represented by the provided uuid.'
def s3_image_create(context, image_uuid): DCNL 'Create local s3 image represented by provided uuid.'
def instance_fault_create(context, values): DCNL 'Create a new InstanceFault.'
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL 'Get all instance faults for the provided instance_uuids.'
def actions_get(context, instance_uuid): DCNL 'Get all instance actions for the provided uuid.'
def action_get_by_request_id(context, instance_uuid, request_id): DCNL 'Get the action by request_id and given instance.'
def action_event_start(context, values): DCNL 'Start an event on an instance action.'
def action_event_finish(context, values): DCNL 'Finish an event on an instance action.'
@require_context DCNL def ec2_instance_create(context, instance_uuid, id=None): DCNL 'Create ec2 compatible instance by provided uuid.'
@require_admin_context DCNL def archive_deleted_rows_for_table(context, tablename, max_rows): DCNL 'Move up to max_rows rows from one tables to the corresponding DCNL shadow table. DCNL :returns: number of rows archived'
@require_admin_context DCNL def archive_deleted_rows(context, max_rows=None): DCNL 'Move up to max_rows rows from production tables to the corresponding DCNL shadow tables. DCNL :returns: Number of rows archived.'
def db_sync(version=None): DCNL 'Migrate the database to `version` or the most recent version.'
def db_version(): DCNL 'Display the current database version.'
def constraint(**conditions): DCNL 'Return a constraint object suitable for use with some updates.'
def equal_any(*values): DCNL 'Return an equality condition object suitable for use in a constraint. DCNL Equal_any conditions require that a model object\'s attribute equal any DCNL one of the given values.'
def not_equal(*values): DCNL 'Return an inequality condition object suitable for use in a constraint. DCNL Not_equal conditions require that a model object\'s attribute differs from DCNL all of the given values.'
def service_destroy(context, instance_id): DCNL 'Destroy the service or raise if it does not exist.'
def service_get(context, service_id): DCNL 'Get a service or raise if it does not exist.'
def service_get_by_host_and_topic(context, host, topic): DCNL 'Get a service by host it\'s on and topic it listens to.'
def service_get_all(context, disabled=None): DCNL 'Get all services.'
def service_get_all_by_topic(context, topic): DCNL 'Get all services for a given topic.'
def service_get_all_by_host(context, host): DCNL 'Get all services for a given host.'
def service_get_by_compute_host(context, host): DCNL 'Get the service entry for a given compute host. DCNL Returns the service entry joined with the compute_node entry.'
def service_get_by_args(context, host, binary): DCNL 'Get the state of a service by node name and binary.'
def service_create(context, values): DCNL 'Create a service from the values dictionary.'
def service_update(context, service_id, values): DCNL 'Set the given properties on a service and update it. DCNL Raises NotFound if service does not exist.'
def compute_node_get(context, compute_id): DCNL 'Get a computeNode.'
def compute_node_get_all(context): DCNL 'Get all computeNodes.'
def compute_node_search_by_hypervisor(context, hypervisor_match): DCNL 'Get computeNodes given a hypervisor hostname match string.'
def compute_node_create(context, values): DCNL 'Create a computeNode from the values dictionary.'
def compute_node_update(context, compute_id, values, prune_stats=False): DCNL 'Set the given properties on a computeNode and update it. DCNL Raises ComputeHostNotFound if computeNode does not exist.'
def compute_node_delete(context, compute_id): DCNL 'Delete a computeNode from the database. DCNL Raises ComputeHostNotFound if computeNode does not exist.'
def certificate_create(context, values): DCNL 'Create a certificate from the values dictionary.'
def certificate_get_all_by_project(context, project_id): DCNL 'Get all certificates for a project.'
def certificate_get_all_by_user(context, user_id): DCNL 'Get all certificates for a user.'
def certificate_get_all_by_user_and_project(context, user_id, project_id): DCNL 'Get all certificates for a user and project.'
def floating_ip_get_pools(context): DCNL 'Returns a list of floating ip pools.'
def floating_ip_allocate_address(context, project_id, pool): DCNL 'Allocate free floating ip from specified pool and return the address. DCNL Raises if one is not available.'
def floating_ip_bulk_create(context, ips): DCNL 'Create a lot of floating ips from the values dictionary.'
def floating_ip_bulk_destroy(context, ips): DCNL 'Destroy a lot of floating ips from the values dictionary.'
def floating_ip_create(context, values): DCNL 'Create a floating ip from the values dictionary.'
def floating_ip_count_by_project(context, project_id, session=None): DCNL 'Count floating ips used by project.'
def floating_ip_deallocate(context, address): DCNL 'Deallocate a floating ip by address.'
def floating_ip_destroy(context, address): DCNL 'Destroy the floating_ip or raise if it does not exist.'
def floating_ip_disassociate(context, address): DCNL 'Disassociate a floating ip from a fixed ip by address. DCNL :returns: the fixed ip record joined to network record or None DCNL if the ip was not associated to an ip.'
def floating_ip_fixed_ip_associate(context, floating_address, fixed_address, host): DCNL 'Associate a floating ip to a fixed_ip by address. DCNL :returns: the fixed ip record joined to network record or None DCNL if the ip was already associated to the fixed ip.'
def floating_ip_get_all(context): DCNL 'Get all floating ips.'
def floating_ip_get_all_by_host(context, host): DCNL 'Get all floating ips by host.'
def floating_ip_get_all_by_project(context, project_id): DCNL 'Get all floating ips by project.'
def floating_ip_get_by_address(context, address): DCNL 'Get a floating ip by address or raise if it doesn\'t exist.'
def floating_ip_get_by_fixed_address(context, fixed_address): DCNL 'Get a floating ips by fixed address.'
def floating_ip_get_by_fixed_ip_id(context, fixed_ip_id): DCNL 'Get a floating ips by fixed address.'
def floating_ip_update(context, address, values): DCNL 'Update a floating ip by address or raise if it doesn\'t exist.'
def floating_ip_set_auto_assigned(context, address): DCNL 'Set auto_assigned flag to floating ip.'
def dnsdomain_list(context): DCNL 'Get a list of all zones in our database, public and private.'
def dnsdomain_register_for_zone(context, fqdomain, zone): DCNL 'Associated a DNS domain with an availability zone.'
def dnsdomain_register_for_project(context, fqdomain, project): DCNL 'Associated a DNS domain with a project id.'
def dnsdomain_unregister(context, fqdomain): DCNL 'Purge associations for the specified DNS zone.'
def dnsdomain_get(context, fqdomain): DCNL 'Get the db record for the specified domain.'
def migration_update(context, id, values): DCNL 'Update a migration instance.'
def migration_create(context, values): DCNL 'Create a migration record.'
def migration_get(context, migration_id): DCNL 'Finds a migration by the id.'
def migration_get_by_instance_and_status(context, instance_uuid, status): DCNL 'Finds a migration by the instance uuid its migrating.'
def migration_get_unconfirmed_by_dest_compute(context, confirm_window, dest_compute): DCNL 'Finds all unconfirmed migrations within the confirmation window for DCNL a specific destination compute host.'
def migration_get_in_progress_by_host_and_node(context, host, node): DCNL 'Finds all migrations for the given host + node  that are not yet DCNL confirmed or reverted.'
def fixed_ip_associate(context, address, instance_uuid, network_id=None, reserved=False): DCNL 'Associate fixed ip to instance. DCNL Raises if fixed ip is not available.'
def fixed_ip_associate_pool(context, network_id, instance_uuid=None, host=None): DCNL 'Find free ip in network and associate it to instance or host. DCNL Raises if one is not available.'
def fixed_ip_create(context, values): DCNL 'Create a fixed ip from the values dictionary.'
def fixed_ip_bulk_create(context, ips): DCNL 'Create a lot of fixed ips from the values dictionary.'
def fixed_ip_disassociate(context, address): DCNL 'Disassociate a fixed ip from an instance by address.'
def fixed_ip_disassociate_all_by_timeout(context, host, time): DCNL 'Disassociate old fixed ips from host.'
def fixed_ip_get(context, id, get_network=False): DCNL 'Get fixed ip by id or raise if it does not exist. DCNL If get_network is true, also return the assocated network.'
def fixed_ip_get_all(context): DCNL 'Get all defined fixed ips.'
def fixed_ip_get_by_address(context, address): DCNL 'Get a fixed ip by address or raise if it does not exist.'
def fixed_ip_get_by_address_detailed(context, address): DCNL 'Get detailed fixed ip info by address or raise if it does not exist.'
def fixed_ip_get_by_floating_address(context, floating_address): DCNL 'Get a fixed ip by a floating address.'
def fixed_ip_get_by_instance(context, instance_uuid): DCNL 'Get fixed ips by instance or raise if none exist.'
def fixed_ip_get_by_host(context, host): DCNL 'Get fixed ips by compute host.'
def fixed_ip_get_by_network_host(context, network_uuid, host): DCNL 'Get fixed ip for a host in a network.'
def fixed_ips_by_virtual_interface(context, vif_id): DCNL 'Get fixed ips by virtual interface or raise if none exist.'
def fixed_ip_update(context, address, values): DCNL 'Create a fixed ip from the values dictionary.'
def fixed_ip_count_by_project(context, project_id, session=None): DCNL 'Count fixed ips used by project.'
def virtual_interface_create(context, values): DCNL 'Create a virtual interface record in the database.'
def virtual_interface_get(context, vif_id): DCNL 'Gets a virtual interface from the table.'
def virtual_interface_get_by_address(context, address): DCNL 'Gets a virtual interface from the table filtering on address.'
def virtual_interface_get_by_uuid(context, vif_uuid): DCNL 'Gets a virtual interface from the table filtering on vif uuid.'
def virtual_interface_get_by_instance(context, instance_id): DCNL 'Gets all virtual_interfaces for instance.'
def virtual_interface_get_by_instance_and_network(context, instance_id, network_id): DCNL 'Gets all virtual interfaces for instance.'
def virtual_interface_delete_by_instance(context, instance_id): DCNL 'Delete virtual interface records associated with instance.'
def virtual_interface_get_all(context): DCNL 'Gets all virtual interfaces from the table.'
def instance_create(context, values): DCNL 'Create an instance from the values dictionary.'
def instance_data_get_for_project(context, project_id, session=None): DCNL 'Get (instance_count, total_cores, total_ram) for project.'
def instance_destroy(context, instance_uuid, constraint=None, update_cells=True): DCNL 'Destroy the instance or raise if it does not exist.'
def instance_get_by_uuid(context, uuid): DCNL 'Get an instance or raise if it does not exist.'
def instance_get(context, instance_id): DCNL 'Get an instance or raise if it does not exist.'
def instance_get_all(context, columns_to_join=None): DCNL 'Get all instances.'
def instance_get_all_by_filters(context, filters, sort_key='created_at', sort_dir='desc', limit=None, marker=None, columns_to_join=None): DCNL 'Get all instances that match all filters.'
def instance_get_active_by_window_joined(context, begin, end=None, project_id=None, host=None): DCNL 'Get instances and joins active during a certain time window. DCNL Specifying a project_id will filter for a certain project. DCNL Specifying a host will filter for instances on a given compute host.'
def instance_get_all_by_host(context, host, columns_to_join=None): DCNL 'Get all instances belonging to a host.'
def instance_get_all_by_host_and_node(context, host, node): DCNL 'Get all instances belonging to a node.'
def instance_get_all_by_host_and_not_type(context, host, type_id=None): DCNL 'Get all instances belonging to a host with a different type_id.'
def instance_get_floating_address(context, instance_id): DCNL 'Get the first floating ip address of an instance.'
def instance_floating_address_get_all(context, instance_uuid): DCNL 'Get all floating ip addresses of an instance.'
def instance_get_all_hung_in_rebooting(context, reboot_window): DCNL 'Get all instances stuck in a rebooting state.'
def instance_test_and_set(context, instance_uuid, attr, ok_states, new_state): DCNL 'Atomically check if an instance is in a valid state, and if it is, set DCNL the instance into a new state.'
def instance_update(context, instance_uuid, values, update_cells=True): DCNL 'Set the given properties on an instance and update it. DCNL Raises NotFound if instance does not exist.'
def instance_update_and_get_original(context, instance_uuid, values): DCNL 'Set the given properties on an instance and update it. Return DCNL a shallow copy of the original instance reference, as well as the DCNL updated one. DCNL :param context: = request context object DCNL :param instance_id: = instance id or uuid DCNL :param values: = dict containing column values DCNL :returns: a tuple of the form (old_instance_ref, new_instance_ref) DCNL Raises NotFound if instance does not exist.'
def instance_add_security_group(context, instance_id, security_group_id): DCNL 'Associate the given security group with the given instance.'
def instance_remove_security_group(context, instance_id, security_group_id): DCNL 'Disassociate the given security group from the given instance.'
def instance_info_cache_get(context, instance_uuid): DCNL 'Gets an instance info cache from the table. DCNL :param instance_uuid: = uuid of the info cache\'s instance'
def instance_info_cache_update(context, instance_uuid, values, update_cells=True): DCNL 'Update an instance info cache record in the table. DCNL :param instance_uuid: = uuid of info cache\'s instance DCNL :param values: = dict containing column values to update'
def instance_info_cache_delete(context, instance_uuid): DCNL 'Deletes an existing instance_info_cache record DCNL :param instance_uuid: = uuid of the instance tied to the cache record'
def key_pair_create(context, values): DCNL 'Create a key_pair from the values dictionary.'
def key_pair_destroy(context, user_id, name): DCNL 'Destroy the key_pair or raise if it does not exist.'
def key_pair_get(context, user_id, name): DCNL 'Get a key_pair or raise if it does not exist.'
def key_pair_get_all_by_user(context, user_id): DCNL 'Get all key_pairs by user.'
def key_pair_count_by_user(context, user_id): DCNL 'Count number of key pairs for the given user ID.'
def network_associate(context, project_id, network_id=None, force=False): DCNL 'Associate a free network to a project.'
def network_count_reserved_ips(context, network_id): DCNL 'Return the number of reserved ips in the network.'
def network_create_safe(context, values): DCNL 'Create a network from the values dict. DCNL The network is only returned if the create succeeds. If the create violates DCNL constraints because the network already exists, no exception is raised.'
def network_delete_safe(context, network_id): DCNL 'Delete network with key network_id. DCNL This method assumes that the network is not associated with any project'
def network_disassociate(context, network_id, disassociate_host=True, disassociate_project=True): DCNL 'Disassociate the network from project or host and raise if it does DCNL not exist.'
def network_get(context, network_id, project_only='allow_none'): DCNL 'Get a network or raise if it does not exist.'
def network_get_all(context): DCNL 'Return all defined networks.'
def network_get_all_by_uuids(context, network_uuids, project_only='allow_none'): DCNL 'Return networks by ids.'
def network_in_use_on_host(context, network_id, host=None): DCNL 'Indicates if a network is currently in use on host.'
def network_get_associated_fixed_ips(context, network_id, host=None): DCNL 'Get all network\'s ips that have been associated.'
def network_get_by_uuid(context, uuid): DCNL 'Get a network by uuid or raise if it does not exist.'
def network_get_by_cidr(context, cidr): DCNL 'Get a network by cidr or raise if it does not exist.'
def network_get_all_by_instance(context, instance_id): DCNL 'Get all networks by instance id or raise if none exist.'
def network_get_all_by_host(context, host): DCNL 'All networks for which the given host is the network host.'
def network_set_host(context, network_id, host_id): DCNL 'Safely set the host for network.'
def network_update(context, network_id, values): DCNL 'Set the given properties on a network and update it. DCNL Raises NotFound if network does not exist.'
def quota_create(context, project_id, resource, limit): DCNL 'Create a quota for the given project and resource.'
def quota_get(context, project_id, resource): DCNL 'Retrieve a quota or raise if it does not exist.'
def quota_get_all_by_project(context, project_id): DCNL 'Retrieve all quotas associated with a given project.'
def quota_update(context, project_id, resource, limit): DCNL 'Update a quota or raise if it does not exist.'
def quota_class_create(context, class_name, resource, limit): DCNL 'Create a quota class for the given name and resource.'
def quota_class_get(context, class_name, resource): DCNL 'Retrieve a quota class or raise if it does not exist.'
def quota_class_get_all_by_name(context, class_name): DCNL 'Retrieve all quotas associated with a given quota class.'
def quota_class_update(context, class_name, resource, limit): DCNL 'Update a quota class or raise if it does not exist.'
def quota_usage_get(context, project_id, resource): DCNL 'Retrieve a quota usage or raise if it does not exist.'
def quota_usage_get_all_by_project(context, project_id): DCNL 'Retrieve all usage associated with a given resource.'
def quota_usage_update(context, project_id, resource, **kwargs): DCNL 'Update a quota usage or raise if it does not exist.'
def reservation_create(context, uuid, usage, project_id, resource, delta, expire): DCNL 'Create a reservation for the given project and resource.'
def reservation_get(context, uuid): DCNL 'Retrieve a reservation or raise if it does not exist.'
def quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=None): DCNL 'Check quotas and create appropriate reservations.'
def reservation_commit(context, reservations, project_id=None): DCNL 'Commit quota reservations.'
def reservation_rollback(context, reservations, project_id=None): DCNL 'Roll back quota reservations.'
def quota_destroy_all_by_project(context, project_id): DCNL 'Destroy all quotas associated with a given project.'
def reservation_expire(context): DCNL 'Roll back any expired reservations.'
def block_device_mapping_create(context, values): DCNL 'Create an entry of block device mapping.'
def block_device_mapping_update(context, bdm_id, values): DCNL 'Update an entry of block device mapping.'
def block_device_mapping_update_or_create(context, values): DCNL 'Update an entry of block device mapping. DCNL If not existed, create a new entry'
def block_device_mapping_get_all_by_instance(context, instance_uuid): DCNL 'Get all block device mapping belonging to an instance.'
def block_device_mapping_destroy(context, bdm_id): DCNL 'Destroy the block device mapping.'
def block_device_mapping_destroy_by_instance_and_device(context, instance_uuid, device_name): DCNL 'Destroy the block device mapping.'
def block_device_mapping_destroy_by_instance_and_volume(context, instance_uuid, volume_id): DCNL 'Destroy the block device mapping.'
def security_group_get_all(context): DCNL 'Get all security groups.'
def security_group_get(context, security_group_id): DCNL 'Get security group by its id.'
def security_group_get_by_name(context, project_id, group_name): DCNL 'Returns a security group with the specified name from a project.'
def security_group_get_by_project(context, project_id): DCNL 'Get all security groups belonging to a project.'
def security_group_get_by_instance(context, instance_id): DCNL 'Get security groups to which the instance is assigned.'
def security_group_exists(context, project_id, group_name): DCNL 'Indicates if a group name exists in a project.'
def security_group_in_use(context, group_id): DCNL 'Indicates if a security group is currently in use.'
def security_group_create(context, values): DCNL 'Create a new security group.'
def security_group_ensure_default(context): DCNL 'Ensure default security group exists for a project_id. DCNL Returns a tuple with the first element being a bool indicating DCNL if the default security group previously existed. Second DCNL element is the dict used to create the default security group.'
def security_group_destroy(context, security_group_id): DCNL 'Deletes a security group.'
def security_group_count_by_project(context, project_id, session=None): DCNL 'Count number of security groups in a project.'
def security_group_rule_create(context, values): DCNL 'Create a new security group.'
def security_group_rule_get_by_security_group(context, security_group_id): DCNL 'Get all rules for a given security group.'
def security_group_rule_get_by_security_group_grantee(context, security_group_id): DCNL 'Get all rules that grant access to the given security group.'
def security_group_rule_destroy(context, security_group_rule_id): DCNL 'Deletes a security group rule.'
def security_group_rule_get(context, security_group_rule_id): DCNL 'Gets a security group rule.'
def security_group_rule_count_by_group(context, security_group_id): DCNL 'Count rules in a given security group.'
def provider_fw_rule_create(context, rule): DCNL 'Add a firewall rule at the provider level (all hosts & instances).'
def provider_fw_rule_get_all(context): DCNL 'Get all provider-level firewall rules.'
def provider_fw_rule_destroy(context, rule_id): DCNL 'Delete a provider firewall rule from the database.'
def project_get_networks(context, project_id, associate=True): DCNL 'Return the network associated with the project. DCNL If associate is true, it will attempt to associate a new DCNL network if one is not found, otherwise it returns None.'
def console_pool_create(context, values): DCNL 'Create console pool.'
def console_pool_get_by_host_type(context, compute_host, proxy_host, console_type): DCNL 'Fetch a console pool for a given proxy host, compute host, and type.'
def console_pool_get_all_by_host_type(context, host, console_type): DCNL 'Fetch all pools for given proxy host and type.'
def console_create(context, values): DCNL 'Create a console.'
def console_delete(context, console_id): DCNL 'Delete a console.'
def console_get_by_pool_instance(context, pool_id, instance_uuid): DCNL 'Get console entry for a given instance and pool.'
def console_get_all_by_instance(context, instance_uuid): DCNL 'Get consoles for a given instance.'
def console_get(context, console_id, instance_uuid=None): DCNL 'Get a specific console (possibly on a given instance).'
def instance_type_create(context, values): DCNL 'Create a new instance type.'
def instance_type_get_all(context, inactive=False, filters=None): DCNL 'Get all instance types.'
def instance_type_get(context, id): DCNL 'Get instance type by id.'
def instance_type_get_by_name(context, name): DCNL 'Get instance type by name.'
def instance_type_get_by_flavor_id(context, id): DCNL 'Get instance type by flavor id.'
def instance_type_destroy(context, name): DCNL 'Delete an instance type.'
def instance_type_access_get_by_flavor_id(context, flavor_id): DCNL 'Get flavor access by flavor id.'
def instance_type_access_add(context, flavor_id, project_id): DCNL 'Add flavor access for project.'
def instance_type_access_remove(context, flavor_id, project_id): DCNL 'Remove flavor access for project.'
def cell_create(context, values): DCNL 'Create a new child Cell entry.'
def cell_update(context, cell_name, values): DCNL 'Update a child Cell entry.'
def cell_delete(context, cell_name): DCNL 'Delete a child Cell.'
def cell_get(context, cell_name): DCNL 'Get a specific child Cell.'
def cell_get_all(context): DCNL 'Get all child Cells.'
def instance_metadata_get(context, instance_uuid): DCNL 'Get all metadata for an instance.'
def instance_metadata_delete(context, instance_uuid, key): DCNL 'Delete the given metadata item.'
def instance_metadata_update(context, instance_uuid, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def instance_system_metadata_get(context, instance_uuid): DCNL 'Get all system metadata for an instance.'
def instance_system_metadata_update(context, instance_uuid, metadata, delete): DCNL 'Update metadata if it exists, otherwise create it.'
def agent_build_create(context, values): DCNL 'Create a new agent build entry.'
def agent_build_get_by_triple(context, hypervisor, os, architecture): DCNL 'Get agent build by hypervisor/OS/architecture triple.'
def agent_build_get_all(context, hypervisor=None): DCNL 'Get all agent builds.'
def agent_build_destroy(context, agent_update_id): DCNL 'Destroy agent build entry.'
def agent_build_update(context, agent_build_id, values): DCNL 'Update agent build entry.'
def bw_usage_get(context, uuid, start_period, mac): DCNL 'Return bw usage for instance and mac in a given audit period.'
def bw_usage_get_by_uuids(context, uuids, start_period): DCNL 'Return bw usages for instance(s) in a given audit period.'
def bw_usage_update(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=None, update_cells=True): DCNL 'Update cached bandwidth usage for an instance\'s network based on mac DCNL address.  Creates new record if needed.'
def instance_type_extra_specs_get(context, flavor_id): DCNL 'Get all extra specs for an instance type.'
def instance_type_extra_specs_delete(context, flavor_id, key): DCNL 'Delete the given extra specs item.'
def instance_type_extra_specs_update_or_create(context, flavor_id, extra_specs): DCNL 'Create or update instance type extra specs. This adds or modifies the DCNL key/value pairs specified in the extra specs dict argument'
def vol_get_usage_by_time(context, begin): DCNL 'Return volumes usage that have been updated after a specified time.'
def vol_usage_update(context, id, rd_req, rd_bytes, wr_req, wr_bytes, instance_id, last_refreshed=None, update_totals=False): DCNL 'Update cached volume usage for a volume DCNL Creates new record if needed.'
def s3_image_get(context, image_id): DCNL 'Find local s3 image represented by the provided id.'
def s3_image_get_by_uuid(context, image_uuid): DCNL 'Find local s3 image represented by the provided uuid.'
def s3_image_create(context, image_uuid): DCNL 'Create local s3 image represented by provided uuid.'
def aggregate_create(context, values, metadata=None): DCNL 'Create a new aggregate with metadata.'
def aggregate_get(context, aggregate_id): DCNL 'Get a specific aggregate by id.'
def aggregate_get_by_host(context, host, key=None): DCNL 'Get a list of aggregates that host belongs to.'
def aggregate_metadata_get_by_host(context, host, key=None): DCNL 'Get metadata for all aggregates that host belongs to. DCNL Returns a dictionary where each value is a set, this is to cover the case DCNL where there two aggregates have different values for the same key. DCNL Optional key filter'
def aggregate_host_get_by_metadata_key(context, key): DCNL 'Get hosts with a specific metadata key metadata for all aggregates. DCNL Returns a dictionary where each key is a hostname and each value is a set DCNL of the key values DCNL return value:  {machine: set( az1, az2 )}'
def aggregate_update(context, aggregate_id, values): DCNL 'Update the attributes of an aggregates. If values contains a metadata DCNL key, it updates the aggregate metadata too.'
def aggregate_delete(context, aggregate_id): DCNL 'Delete an aggregate.'
def aggregate_get_all(context): DCNL 'Get all aggregates.'
def aggregate_metadata_add(context, aggregate_id, metadata, set_delete=False): DCNL 'Add/update metadata. If set_delete=True, it adds only.'
def aggregate_metadata_get(context, aggregate_id): DCNL 'Get metadata for the specified aggregate.'
def aggregate_metadata_delete(context, aggregate_id, key): DCNL 'Delete the given metadata key.'
def aggregate_host_add(context, aggregate_id, host): DCNL 'Add host to the aggregate.'
def aggregate_host_get_all(context, aggregate_id): DCNL 'Get hosts for the specified aggregate.'
def aggregate_host_delete(context, aggregate_id, host): DCNL 'Delete the given host from the aggregate.'
def instance_fault_create(context, values, update_cells=True): DCNL 'Create a new Instance Fault.'
def instance_fault_get_by_instance_uuids(context, instance_uuids): DCNL 'Get all instance faults for the provided instance_uuids.'
def action_start(context, values): DCNL 'Start an action for an instance.'
def action_finish(context, values): DCNL 'Finish an action for an instance.'
def actions_get(context, uuid): DCNL 'Get all instance actions for the provided instance.'
def action_get_by_request_id(context, uuid, request_id): DCNL 'Get the action by request_id and given instance.'
def action_event_start(context, values): DCNL 'Start an event on an instance action.'
def action_event_finish(context, values): DCNL 'Finish an event on an instance action.'
def action_events_get(context, action_id): DCNL 'Get the events by action id.'
def get_ec2_instance_id_by_uuid(context, instance_id): DCNL 'Get ec2 id through uuid from instance_id_mappings table.'
def get_instance_uuid_by_ec2_id(context, ec2_id): DCNL 'Get uuid through ec2 id from instance_id_mappings table.'
def ec2_instance_create(context, instance_uuid, id=None): DCNL 'Create the ec2 id to instance uuid mapping on demand.'
def task_log_end_task(context, task_name, period_beginning, period_ending, host, errors, message=None): DCNL 'Mark a task as complete for a given host/time period.'
def task_log_begin_task(context, task_name, period_beginning, period_ending, host, task_items=None, message=None): DCNL 'Mark a task as started for a given host/time period.'
def archive_deleted_rows(context, max_rows=None): DCNL 'Move up to max_rows rows from production tables to corresponding shadow DCNL tables. DCNL :returns: number of rows archived.'
def archive_deleted_rows_for_table(context, tablename, max_rows=None): DCNL 'Move up to max_rows rows from tablename to corresponding shadow DCNL table. DCNL :returns: number of rows archived.'
def all_filters(): DCNL 'Return a list of filter classes found in this directory. DCNL This method is used as the default for available scheduler filters DCNL and should return a list of all filter classes available.'
def standard_filters(): DCNL 'Deprecated.  Configs should change to use all_filters().'
def new_host_state(self, host, node, capabilities=None, service=None): DCNL 'Returns an instance of BaremetalHostState or HostState according to DCNL capabilities. If \'baremetal_driver\' is in capabilities, it returns an DCNL instance of BaremetalHostState. If not, returns an instance of HostState.'
def all_weighers(): DCNL 'Return a list of weight plugin classes found in this directory.'
def noop_cost_fn(host_state, weight_properties): DCNL 'Return a pre-weight cost of 1 for each host.'
def compute_fill_first_cost_fn(host_state, weight_properties): DCNL 'Higher weights win, so we should return a lower weight DCNL when there\'s more free ram available. DCNL Note: the weight modifier for this function in default configuration DCNL is -1.0. With -1.0 this function runs in reverse, so systems DCNL with the most free memory will be preferred.'
def _get_cost_functions(): DCNL 'Returns a list of tuples containing weights and cost functions to DCNL use for weighing hosts'
def instance_update_db(context, instance_uuid, extra_values=None): DCNL 'Clear the host and node - set the scheduled_at field of an Instance. DCNL :returns: An Instance with the updated fields set properly.'
def encode_instance(instance, local=True): DCNL 'Encode locally created instance for return via RPC.'
def create(name, memory, vcpus, root_gb, ephemeral_gb=None, flavorid=None, swap=None, rxtx_factor=None, is_public=True): DCNL 'Creates instance types.'
def destroy(name): DCNL 'Marks instance types as deleted.'
def get_all_types(ctxt=None, inactive=False, filters=None): DCNL 'Get all non-deleted instance_types. DCNL Pass true as argument if you want deleted instance types returned also.'
def get_default_instance_type(): DCNL 'Get the default instance type.'
def get_instance_type(instance_type_id, ctxt=None, inactive=False): DCNL 'Retrieves single instance type by id.'
def get_instance_type_by_name(name, ctxt=None): DCNL 'Retrieves single instance type by name.'
def get_instance_type_by_flavor_id(flavorid, ctxt=None, read_deleted='yes'): DCNL 'Retrieve instance type by flavorid. DCNL :raises: FlavorNotFound'
def get_instance_type_access_by_flavor_id(flavorid, ctxt=None): DCNL 'Retrieve instance type access list by flavor id.'
def add_instance_type_access(flavorid, projectid, ctxt=None): DCNL 'Add instance type access for project.'
def remove_instance_type_access(flavorid, projectid, ctxt=None): DCNL 'Remove instance type access for project.'
def extract_instance_type(instance, prefix=''): DCNL 'Create an InstanceType-like object from instance\'s system_metadata DCNL information.'
def save_instance_type_info(metadata, instance_type, prefix=''): DCNL 'Save properties from instance_type into instance\'s system_metadata, DCNL in the format of: DCNL [prefix]instance_type_[key] DCNL This can be used to update system_metadata in place from a type, as well DCNL as stash information about another instance_type for later use (such as DCNL during resize).'
def delete_instance_type_info(metadata, *prefixes): DCNL 'Delete instance_type information from instance\'s system_metadata DCNL by prefix.'
def _compute_topic(topic, ctxt, host, instance): DCNL 'Get the topic to use for a message. DCNL :param topic: the base topic DCNL :param ctxt: request context DCNL :param host: explicit host to send the message to. DCNL :param instance: If an explicit host was not specified, use DCNL instance[\'host\'] DCNL :returns: A topic string'
def add_instance_fault_from_exc(context, conductor, instance, fault, exc_info=None): DCNL 'Adds the specified fault to the database.'
def get_device_name_for_instance(context, instance, bdms, device): DCNL 'Validates (or generates) a device name for instance. DCNL If device is not set, it will generate a unique device appropriate DCNL for the instance. It uses the block device mapping table to find DCNL valid device names. If the device name is valid but applicable to DCNL a different backend (for example /dev/vdc is specified but the DCNL backend uses /dev/xvdc), the device name will be converted to the DCNL appropriate format.'
def notify_usage_exists(context, instance_ref, current_period=False, ignore_missing_network_data=True, system_metadata=None, extra_usage_info=None): DCNL 'Generates \'exists\' notification for an instance for usage auditing DCNL purposes. DCNL :param current_period: if True, this will generate a usage for the DCNL current usage period; if False, this will generate a usage for the DCNL previous audit period. DCNL :param ignore_missing_network_data: if True, log any exceptions generated DCNL while getting network info; if False, raise the exception. DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if not None.  *NOTE*: Currently unused here in trunk, but needed for DCNL potential custom modifications. DCNL :param extra_usage_info: Dictionary containing extra values to add or DCNL override in the notification if not None.'
def notify_about_instance_usage(context, instance, event_suffix, network_info=None, system_metadata=None, extra_usage_info=None, host=None): DCNL 'Send a notification about an instance. DCNL :param event_suffix: Event type like "delete.start" or "exists" DCNL :param network_info: Networking information, if provided. DCNL :param system_metadata: system_metadata DB entries for the instance, DCNL if provided. DCNL :param extra_usage_info: Dictionary containing extra values to add or DCNL override in the notification. DCNL :param host: Compute host for the instance, if specified.  Default is DCNL CONF.host'
def reverts_task_state(function): DCNL 'Decorator to revert task_state on failure.'
def wrap_instance_fault(function): DCNL 'Wraps a method to catch exceptions related to instances. DCNL This decorator wraps a method to catch any exceptions having to do with DCNL an instance that may get thrown. It then logs an instance fault in the db.'
def wrap_instance_event(function): DCNL 'Wraps a method to log the event taken on the instance, and result. DCNL This decorator wraps a method to log the start and result of an event, as DCNL part of an action taken on an instance.'
def HostAPI(*args, **kwargs): DCNL 'Returns the \'HostAPI\' class from the same module as the configured compute DCNL api'
def InstanceActionAPI(*args, **kwargs): DCNL 'Returns the \'InstanceActionAPI\' class from the same module as the DCNL configured compute api.'
def check_instance_state(vm_state=None, task_state=(None,)): DCNL 'Decorator to check VM and/or task state before entry to API functions. DCNL If the instance is in the wrong state, the wrapper will raise an exception.'
def policy_decorator(scope): DCNL 'Check corresponding policy prior of wrapped method to execution.'
def _ensure_requested_network_ordering(accessor, unordered, preferred): DCNL 'Sort a list with respect to the preferred network ordering.'
def get_binary_name(): DCNL 'Grab the name of the binary we\'re running in.'
def metadata_forward(): DCNL 'Create forwarding rule for metadata.'
def metadata_accept(): DCNL 'Create the filter accept rule for metadata.'
def init_host(ip_range=None): DCNL 'Basic networking setup goes here.'
def bind_floating_ip(floating_ip, device): DCNL 'Bind ip to public interface.'
def unbind_floating_ip(floating_ip, device): DCNL 'Unbind a public ip from public interface.'
def ensure_metadata_ip(): DCNL 'Sets up local metadata ip.'
def ensure_vpn_forward(public_ip, port, private_ip): DCNL 'Sets up forwarding rules for vlan.'
def ensure_floating_forward(floating_ip, fixed_ip, device, network): DCNL 'Ensure floating ip forwarding rule.'
def remove_floating_forward(floating_ip, fixed_ip, device, network): DCNL 'Remove forwarding for floating ip.'
def floating_ebtables_rules(fixed_ip, network): DCNL 'Makes sure only in-network traffic is bridged.'
def get_dhcp_leases(context, network_ref): DCNL 'Return a network\'s hosts config in dnsmasq leasefile format.'
def get_dhcp_hosts(context, network_ref): DCNL 'Get network\'s hosts config in dhcp-host format.'
def get_dns_hosts(context, network_ref): DCNL 'Get network\'s DNS hosts in hosts format.'
def _add_dnsmasq_accept_rules(dev): DCNL 'Allow DHCP and DNS traffic through to dnsmasq.'
def _remove_dnsmasq_accept_rules(dev): DCNL 'Remove DHCP and DNS traffic allowed through to dnsmasq.'
def get_dhcp_opts(context, network_ref): DCNL 'Get network\'s hosts config in dhcp-opts format.'
@lockutils.synchronized('dnsmasq_start', 'nova-') DCNL def restart_dhcp(context, dev, network_ref): DCNL '(Re)starts a dnsmasq server for a given network. DCNL If a dnsmasq instance is already running then send a HUP DCNL signal causing it to reload, otherwise spawn a new instance.'
def _host_lease(data): DCNL 'Return a host string for an address in leasefile format.'
def _host_dhcp(data): DCNL 'Return a host string for an address in dhcp-host format.'
def _host_dhcp_opts(data): DCNL 'Return an empty gateway option.'
def _execute(*cmd, **kwargs): DCNL 'Wrapper around utils._execute for fake_network.'
def device_exists(device): DCNL 'Check if ethernet device exists.'
def _dhcp_file(dev, kind): DCNL 'Return path to a pid, leases, hosts or conf file for a bridge/device.'
def _ra_file(dev, kind): DCNL 'Return path to a pid or conf file for a bridge/device.'
def _dnsmasq_pid_for(dev): DCNL 'Returns the pid for prior dnsmasq instance for a bridge/device. DCNL Returns None if no pid file exists. DCNL If machine has rebooted pid might be incorrect (caller should check).'
def _ra_pid_for(dev): DCNL 'Returns the pid for prior radvd instance for a bridge/device. DCNL Returns None if no pid file exists. DCNL If machine has rebooted pid might be incorrect (caller should check).'
def _ip_bridge_cmd(action, params, device): DCNL 'Build commands to add/del ips to bridges/devices.'
def _create_veth_pair(dev1_name, dev2_name): DCNL 'Create a pair of veth devices with the specified names, DCNL deleting any previous devices with those names.'
def refresh_cache(f): DCNL 'Decorator to update the instance_info_cache DCNL Requires context and instance as function args'
def wrap_check_policy(func): DCNL 'Check policy corresponding to the wrapped methods prior to execution.'
def echo_scsi_command(path, content): DCNL 'Used to echo strings to scsi subsystem.'
def find_multipath_device(device): DCNL 'Try and discover the multipath device for a volume.'
def stub_out_glanceclient_create(stubs, sent_to_glance): DCNL 'We return the metadata sent to glance by modifying the sent_to_glance dict DCNL in place.'
def webob_factory(url): DCNL 'Factory for removing duplicate webob code from tests.'
def compare_links(actual, expected): DCNL 'Compare xml atom links.'
def compare_media_types(actual, expected): DCNL 'Compare xml media types.'
def compare_tree_to_dict(actual, expected, keys): DCNL 'Compare parts of lxml.etree objects to dicts.'
def format_action(action): DCNL 'Remove keys that aren\'t serialized.'
def format_event(event): DCNL 'Remove keys that aren\'t serialized.'
def stub_set_host_enabled(context, host_name, enabled): DCNL 'Simulates three possible behaviours for VM drivers or compute drivers when DCNL enabling or disabling a host. DCNL \'enabled\' means new instances can go to this host DCNL \'disabled\' means they can\'t'
def _create_instance(**kwargs): DCNL 'Create a test instance.'
def _create_instance_dict(**kwargs): DCNL 'Create a dictionary for a test instance.'
def _quote_domain(domain): DCNL 'Domain names tend to have .\'s in them.  Urllib doesn\'t quote dots, DCNL but Routes tends to choke on them, so we need an extra level of DCNL by-hand quoting here.  This function needs to duplicate the one in DCNL python-novaclient/novaclient/v1_1/floating_ip_dns.py'
def wire_HTTPConnection_to_WSGI(host, app): DCNL 'Monkeypatches HTTPConnection so that if you try to connect to host, you DCNL are instead routed straight to the given WSGI app. DCNL After calling this method, when any code calls DCNL httplib.HTTPConnection(host) DCNL the connection object will be a fake.  Its requests will be sent directly DCNL to the given WSGI app rather than through a socket. DCNL Code connecting to hosts other than host will not be affected. DCNL This method may be called multiple times to map different hosts to DCNL different apps. DCNL This method returns the original HTTPConnection object, so that the caller DCNL can restore the default HTTPConnection interface (for all hosts).'
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
def get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
@webob.dec.wsgify DCNL def conditional_forbid(req): DCNL 'Helper wsgi app returns 403 if param \'die\' is 1.'
def stub_vm_utils_with_vdi_attached_here(function, should_return=True): DCNL 'vm_utils.with_vdi_attached_here needs to be stubbed out because it DCNL calls down to the filesystem to attach a vdi. This provides a DCNL decorator to handle that.'
def fake_get_vim_object(arg): DCNL 'Stubs out the VMwareAPISession\'s get_vim_object method.'
def fake_is_vim_object(arg, module): DCNL 'Stubs out the VMwareAPISession\'s is_vim_object method.'
def set_stubs(stubs): DCNL 'Set the stubs.'
def stub_out_db_instance_api(stubs): DCNL 'Stubs out the db API for creating Instances.'
def example_decorator(name, function): DCNL 'decorator for notify which is used from utils.monkey_patch() DCNL :param name: name of the function DCNL :param function: - object of the function DCNL :returns: function -- decorated function'
def stub_out_db_instance_api(stubs): DCNL 'Stubs out the db API for creating Instances.'
def stubout_session(stubs, cls, product_version=(5, 6, 2), product_brand='XenServer', **opt_args): DCNL 'Stubs out methods from XenAPISession.'
def stubout_determine_is_pv_objectstore(stubs): DCNL 'Assumes VMs stu have PV kernels.'
def stubout_is_snapshot(stubs): DCNL 'Always returns true DCNL xenapi fake driver does not create vmrefs for snapshots'
def stubout_lookup_image(stubs): DCNL 'Simulates a failure in lookup image.'
def stubout_fetch_disk_image(stubs, raise_failure=False): DCNL 'Simulates a failure in fetch image_glance_disk.'
def stubout_create_vm(stubs): DCNL 'Simulates a failure in create_vm.'
def stubout_attach_disks(stubs): DCNL 'Simulates a failure in _attach_disks.'
def fake_execute_set_repliers(repliers): DCNL 'Allows the client to configure replies to commands.'
def fake_execute_default_reply_handler(*ignore_args, **ignore_kwargs): DCNL 'A reply handler for commands that haven\'t been added to the reply list. DCNL Returns empty strings for stdout and stderr.'
def fake_execute(*cmd_parts, **kwargs): DCNL 'This function stubs out execute. DCNL It optionally executes a preconfigued function to return expected data.'
def stub_out(stubs, funcs): DCNL 'Set the stubs in mapping in the db api.'
def stub_out_db_instance_api(stubs, injected=True): DCNL 'Stubs out the db API for creating Instances.'
def initialize(_uri): DCNL 'Opens a fake connection with an LDAP server.'
def _match_query(query, attrs): DCNL 'Match an ldap query to an attribute dictionary. DCNL The characters &, |, and ! are supported in the query. No syntax checking DCNL is performed, so malformed queries will not work correctly.'
def _paren_groups(source): DCNL 'Split a string into parenthesized groups.'
def _match(key, value, attrs): DCNL 'Match a given key and value against an attribute list.'
def _subs(value): DCNL 'Returns a list of subclass strings. DCNL The strings represent the ldap object class plus any subclasses that DCNL inherit from it. Fakeldap doesn\'t know about the ldap object structure, DCNL so subclasses need to be defined manually in the dictionary below.'
def _from_json(encoded): DCNL 'Convert attribute values from json representation. DCNL Args: DCNL encoded -- a json encoded string DCNL Returns a list of strings'
def _to_json(unencoded): DCNL 'Convert attribute values into json representation. DCNL Args: DCNL unencoded -- an unencoded string or list of strings.  If it DCNL is a single string, it will be converted into a list. DCNL Returns a json string'
def _get_instances_with_cached_ips(orig_func, *args, **kwargs): DCNL 'Kludge the cache into instance(s) without having to create DB DCNL entries'
def generate_random_alphanumeric(length): DCNL 'Creates a random alphanumeric string of specified length.'
def generate_random_numeric(length): DCNL 'Creates a random numeric string of specified length.'
def generate_new_element(items, prefix, numeric=False): DCNL 'Creates a random string with prefix, that is not in \'items\' list.'
def _get_connect_string(backend, user, passwd, database): DCNL 'Try to get a connection with a very specific set of values, if we get DCNL these then we\'ll run the tests, otherwise they are skipped'
def get_table(engine, name): DCNL 'Returns an sqlalchemy table dynamically from db. DCNL Needed because the models don\'t work for us in migrations DCNL as models will be far out of sync with the current data.'
def catch_notimplementederror(f): DCNL 'Decorator to simplify catching drivers raising NotImplementedError DCNL If a particular call makes a driver raise NotImplementedError, we DCNL log it so that we can extract this information afterwards to DCNL automatically generate a hypervisor/feature support matrix.'
def get_availability_zones(context): DCNL 'Return available and unavailable zones.'
def get_instances_to_sync(context, updated_since=None, project_id=None, deleted=True, shuffle=False, uuids_only=False): DCNL 'Return a generator that will return a list of active and DCNL deleted instances to sync with parent cells.  The list may DCNL optionally be shuffled for periodic updates so that multiple DCNL cells services aren\'t self-healing the same instances in nearly DCNL lockstep.'
def cell_with_item(cell_name, item): DCNL 'Turn cell_name and item into <cell_name>@<item>.'
def split_cell_and_item(cell_and_item): DCNL 'Split a combined cell@item and return them.'
def add_cell_to_compute_node(compute_node, cell_name): DCNL 'Fix compute_node attributes that should be unique.  Allows DCNL API cell to query the \'id\' by cell@id.'
def add_cell_to_service(service, cell_name): DCNL 'Fix service attributes that should be unique.  Allows DCNL API cell to query the \'id\' or \'host\' by cell@id/host.'
def add_cell_to_task_log(task_log, cell_name): DCNL 'Fix task_log attributes that should be unique.  In particular, DCNL the \'id\' and \'host\' fields should be prepended with cell name.'
def sync_from_db(f): DCNL 'Use as a decorator to wrap methods that use cell information to DCNL make sure they sync the latest information from the DB periodically.'
def _reverse_path(path): DCNL 'Reverse a path.  Used for sending responses upstream.'
def _response_cell_name_from_path(routing_path, neighbor_only=False): DCNL 'Reverse the routing_path.  If we only want to send to our parent, DCNL set neighbor_only to True.'
def _untranslate_volume_summary_view(context, vol): DCNL 'Maps keys for volumes summary view.'
def _untranslate_snapshot_summary_view(context, snapshot): DCNL 'Maps keys for snapshots summary view.'
def parse_css_data(): DCNL 'Returns a dictionary containing values associated to their property names'
def get_tag_to_attributes(): DCNL 'Returns a dictionary with attributes accociated to tags DCNL This assumes that all tags can have global attributes as per MDN: DCNL https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes'
def normalize(a, axis=None): DCNL 'Normalizes the input array so that it sums to 1. DCNL Parameters DCNL a : array DCNL Non-normalized input data. DCNL axis : int DCNL Dimension along which normalization is performed. DCNL Notes DCNL Modifies the input **inplace**.'
def log_normalize(a, axis=None): DCNL 'Normalizes the input array so that the exponent of the sum is 1. DCNL Parameters DCNL a : array DCNL Non-normalized input data. DCNL axis : int DCNL Dimension along which normalization is performed. DCNL Notes DCNL Modifies the input **inplace**.'
def log_mask_zero(a): DCNL 'Computes the log of input probabilities masking divide by zero in log. DCNL Notes DCNL During the M-step of EM-algorithm, very small intermediate start DCNL or transition probabilities could be normalized to zero, causing a DCNL *RuntimeWarning: divide by zero encountered in log*. DCNL This function masks this unharmful warning.'
def gen_data(min_length=MIN_LENGTH, max_length=MAX_LENGTH, n_batch=N_BATCH): DCNL 'Generate a batch of sequences for the "add" task, e.g. the target for the DCNL following DCNL ``| 0.5 | 0.7 | 0.3 | 0.1 | 0.2 | ... | 0.5 | 0.9 | ... | 0.8 | 0.2 | DCNL |  0  |  0  |  1  |  0  |  0  |     |  0  |  1  |     |  0  |  0  |`` DCNL would be 0.3 + .9 = 1.2.  This task was proposed in [1]_ and explored in DCNL e.g. [2]_. DCNL Parameters DCNL min_length : int DCNL Minimum sequence length. DCNL max_length : int DCNL Maximum sequence length. DCNL n_batch : int DCNL Number of samples in the batch. DCNL Returns DCNL X : np.ndarray DCNL Input to the network, of shape (n_batch, max_length, 2), where the last DCNL dimension corresponds to the two sequences shown above. DCNL y : np.ndarray DCNL Correct output for each sample, shape (n_batch,). DCNL mask : np.ndarray DCNL A binary matrix of shape (n_batch, max_length) where ``mask[i, j] = 1`` DCNL when ``j <= (length of sequence i)`` and ``mask[i, j] = 0`` when ``j > DCNL (length of sequence i)``. DCNL References DCNL .. [1] Hochreiter, Sepp, and Jürgen Schmidhuber. "Long short-term memory." DCNL Neural computation 9.8 (1997): 1735-1780. DCNL .. [2] Sutskever, Ilya, et al. "On the importance of initialization and DCNL momentum in deep learning." Proceedings of the 30th international DCNL conference on machine learning (ICML-13). 2013.'
def get_or_compute_grads(loss_or_grads, params): DCNL 'Helper function returning a list of gradients DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to return the gradients for DCNL Returns DCNL list of expressions DCNL If `loss_or_grads` is a list, it is assumed to be a list of DCNL gradients and returned as is, unless it does not match the length DCNL of `params`, in which case a `ValueError` is raised. DCNL Otherwise, `loss_or_grads` is assumed to be a cost expression and DCNL the function returns `theano.grad(loss_or_grads, params)`. DCNL Raises DCNL ValueError DCNL If `loss_or_grads` is a list of a different length than `params`, or if DCNL any element of `params` is not a shared variable (while we could still DCNL compute its gradient, we can never update it and want to fail early).'
def sgd(loss_or_grads, params, learning_rate): DCNL 'Stochastic Gradient Descent (SGD) updates DCNL Generates update expressions of the form: DCNL * ``param := param - learning_rate * gradient`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression'
def apply_momentum(updates, params=None, momentum=0.9): DCNL 'Returns a modified update dictionary including momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity + updates[param] - param`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL updates : OrderedDict DCNL A dictionary mapping parameters to update expressions DCNL params : iterable of shared variables, optional DCNL The variables to apply momentum to. If omitted, will apply DCNL momentum to all `updates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A copy of `updates` with momentum updates for all `params`. DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL See Also DCNL momentum : Shortcut applying momentum to SGD updates'
def momentum(loss_or_grads, params, learning_rate, momentum=0.9): DCNL 'Stochastic Gradient Descent (SGD) updates with momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * gradient`` DCNL * ``param := param + velocity`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL See Also DCNL apply_momentum : Generic function applying momentum to updates DCNL nesterov_momentum : Nesterov\'s variant of SGD with momentum'
def apply_nesterov_momentum(updates, params=None, momentum=0.9): DCNL 'Returns a modified update dictionary including Nesterov momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity + updates[param] - param`` DCNL * ``param := param + momentum * velocity + updates[param] - param`` DCNL Parameters DCNL updates : OrderedDict DCNL A dictionary mapping parameters to update expressions DCNL params : iterable of shared variables, optional DCNL The variables to apply momentum to. If omitted, will apply DCNL momentum to all `updates.keys()`. DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A copy of `updates` with momentum updates for all `params`. DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerated DCNL gradient) requires the gradient to be evaluated at the predicted next DCNL position in parameter space. Here, we use the formulation described at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the gradient to be evaluated at the current parameters. DCNL See Also DCNL nesterov_momentum : Shortcut applying Nesterov momentum to SGD updates'
def nesterov_momentum(loss_or_grads, params, learning_rate, momentum=0.9): DCNL 'Stochastic Gradient Descent (SGD) updates with Nesterov momentum DCNL Generates update expressions of the form: DCNL * ``velocity := momentum * velocity - learning_rate * gradient`` DCNL * ``param := param + momentum * velocity - learning_rate * gradient`` DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL momentum : float or symbolic scalar, optional DCNL The amount of momentum to apply. Higher momentum results in DCNL smoothing over more update steps. Defaults to 0.9. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Higher momentum also results in larger update steps. To counter that, DCNL you can optionally scale your learning rate by `1 - momentum`. DCNL The classic formulation of Nesterov momentum (or Nesterov accelerated DCNL gradient) requires the gradient to be evaluated at the predicted next DCNL position in parameter space. Here, we use the formulation described at DCNL https://github.com/lisa-lab/pylearn2/pull/136#issuecomment-10381617, DCNL which allows the gradient to be evaluated at the current parameters. DCNL See Also DCNL apply_nesterov_momentum : Function applying momentum to updates'
def adagrad(loss_or_grads, params, learning_rate=1.0, epsilon=1e-06): DCNL 'Adagrad updates DCNL Scale learning rates by dividing with the square root of accumulated DCNL squared gradients. See [1]_ for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL Using step size eta Adagrad calculates the learning rate for feature i at DCNL time step t as: DCNL .. math:: \eta_{t,i} = \frac{\eta} DCNL {\sqrt{\sum^t_{t^\prime} g^2_{t^\prime,i}+\epsilon}} g_{t,i} DCNL as such the learning rate is monotonically decreasing. DCNL Epsilon is not included in the typical formula, see [2]_. DCNL References DCNL .. [1] Duchi, J., Hazan, E., & Singer, Y. (2011): DCNL Adaptive subgradient methods for online learning and stochastic DCNL optimization. JMLR, 12:2121-2159. DCNL .. [2] Chris Dyer: DCNL Notes on AdaGrad. http://www.ark.cs.cmu.edu/cdyer/adagrad.pdf'
def rmsprop(loss_or_grads, params, learning_rate=1.0, rho=0.9, epsilon=1e-06): DCNL 'RMSProp updates DCNL Scale learning rates by dividing with the moving average of the root mean DCNL squared (RMS) gradients. See [1]_ for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL rho : float or symbolic scalar DCNL Gradient moving average decay factor DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL `rho` should be between 0 and 1. A value of `rho` close to 1 will decay the DCNL moving average slowly and a value close to 0 will decay the moving average DCNL fast. DCNL Using the step size :math:`\eta` and a decay factor :math:`\rho` the DCNL learning rate :math:`\eta_t` is calculated as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \frac{\eta}{\sqrt{r_t + \epsilon}} DCNL References DCNL .. [1] Tieleman, T. and Hinton, G. (2012): DCNL Neural Networks for Machine Learning, Lecture 6.5 - rmsprop. DCNL Coursera. http://www.youtube.com/watch?v=O3sxAc4hxZU (formula @5:20)'
def adadelta(loss_or_grads, params, learning_rate=1.0, rho=0.95, epsilon=1e-06): DCNL 'Adadelta updates DCNL Scale learning rates by the ratio of accumulated gradients to accumulated DCNL updates, see [1]_ and notes for further description. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float or symbolic scalar DCNL The learning rate controlling the size of update steps DCNL rho : float or symbolic scalar DCNL Squared gradient moving average decay factor DCNL epsilon : float or symbolic scalar DCNL Small value added for numerical stability DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL rho should be between 0 and 1. A value of rho close to 1 will decay the DCNL moving average slowly and a value close to 0 will decay the moving average DCNL fast. DCNL rho = 0.95 and epsilon=1e-6 are suggested in the paper and reported to DCNL work for multiple datasets (MNIST, speech). DCNL In the paper, no learning rate is considered (so learning_rate=1.0). DCNL Probably best to keep it at this value. DCNL epsilon is important for the very first update (so the numerator does DCNL not become 0). DCNL Using the step size eta and a decay factor rho the learning rate is DCNL calculated as: DCNL .. math:: DCNL r_t &= \rho r_{t-1} + (1-\rho)*g^2\\ DCNL \eta_t &= \eta \frac{\sqrt{s_{t-1} + \epsilon}} DCNL {\sqrt{r_t + \epsilon}}\\ DCNL s_t &= \rho s_{t-1} + (1-\rho)*(\eta_t*g)^2 DCNL References DCNL .. [1] Zeiler, M. D. (2012): DCNL ADADELTA: An Adaptive Learning Rate Method. DCNL arXiv Preprint arXiv:1212.5701.'
def adam(loss_or_grads, params, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL 'Adam updates DCNL Adam updates implemented as in [1]_. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential decay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential decay rate for the second moment estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL Notes DCNL The paper [1]_ includes an additional hyperparameter lambda. This is only DCNL needed to prove convergence of the algorithm and has no practical use DCNL (personal communication with the authors), it is therefore omitted here. DCNL References DCNL .. [1] Kingma, Diederik, and Jimmy Ba (2014): DCNL Adam: A Method for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980.'
def adamax(loss_or_grads, params, learning_rate=0.002, beta1=0.9, beta2=0.999, epsilon=1e-08): DCNL 'Adamax updates DCNL Adamax updates implemented as in [1]_. This is a variant of of the Adam DCNL algorithm based on the infinity norm. DCNL Parameters DCNL loss_or_grads : symbolic expression or list of expressions DCNL A scalar loss expression, or a list of gradient expressions DCNL params : list of shared variables DCNL The variables to generate update expressions for DCNL learning_rate : float DCNL Learning rate DCNL beta1 : float DCNL Exponential decay rate for the first moment estimates. DCNL beta2 : float DCNL Exponential decay rate for the weighted infinity norm estimates. DCNL epsilon : float DCNL Constant for numerical stability. DCNL Returns DCNL OrderedDict DCNL A dictionary mapping each parameter to its update expression DCNL References DCNL .. [1] Kingma, Diederik, and Jimmy Ba (2014): DCNL Adam: A Method for Stochastic Optimization. DCNL arXiv preprint arXiv:1412.6980.'
def norm_constraint(tensor_var, max_norm, norm_axes=None, epsilon=1e-07): DCNL 'Max weight norm constraints and gradient clipping DCNL This takes a TensorVariable and rescales it so that incoming weight DCNL norms are below a specified constraint value. Vectors violating the DCNL constraint are rescaled so that they are within the allowed range. DCNL Parameters DCNL tensor_var : TensorVariable DCNL Theano expression for update, gradient, or other quantity. DCNL max_norm : scalar DCNL This value sets the maximum allowed value of any norm in DCNL `tensor_var`. DCNL norm_axes : sequence (list or tuple) DCNL The axes over which to compute the norm.  This overrides the DCNL default norm axes defined for the number of dimensions DCNL in `tensor_var`. When this is not specified and `tensor_var` is a DCNL matrix (2D), this is set to `(0,)`. If `tensor_var` is a 3D, 4D or DCNL 5D tensor, it is set to a tuple listing all axes but axis 0. The DCNL former default is useful for working with dense layers, the latter DCNL is useful for 1D, 2D and 3D convolutional layers. DCNL (Optional) DCNL epsilon : scalar, optional DCNL Value used to prevent numerical instability when dividing by DCNL very small or zero norms. DCNL Returns DCNL TensorVariable DCNL Input `tensor_var` with rescaling applied to weight vectors DCNL that violate the specified constraints. DCNL Examples DCNL >>> param = theano.shared( DCNL ...     np.random.randn(100, 200).astype(theano.config.floatX)) DCNL >>> update = param + 100 DCNL >>> update = norm_constraint(update, 10) DCNL >>> func = theano.function([], [], updates=[(param, update)]) DCNL >>> # Apply constrained update DCNL >>> _ = func() DCNL >>> from lasagne.utils import compute_norms DCNL >>> norms = compute_norms(param.get_value()) DCNL >>> np.isclose(np.max(norms), 10) DCNL True DCNL Notes DCNL When `norm_axes` is not specified, the axes over which the norm is DCNL computed depend on the dimensionality of the input variable. If it is DCNL 2D, it is assumed to come from a dense layer, and the norm is computed DCNL over axis 0. If it is 3D, 4D or 5D, it is assumed to come from a DCNL convolutional layer and the norm is computed over all trailing axes DCNL beyond axis 0. For other uses, you should explicitly specify the axes DCNL over which to compute the norm using `norm_axes`.'
def total_norm_constraint(tensor_vars, max_norm, epsilon=1e-07, return_norm=False): DCNL 'Rescales a list of tensors based on their combined norm DCNL If the combined norm of the input tensors exceeds the threshold then all DCNL tensors are rescaled such that the combined norm is equal to the threshold. DCNL Scaling the norms of the gradients is often used when training recurrent DCNL neural networks [1]_. DCNL Parameters DCNL tensor_vars : List of TensorVariables. DCNL Tensors to be rescaled. DCNL max_norm : float DCNL Threshold value for total norm. DCNL epsilon : scalar, optional DCNL Value used to prevent numerical instability when dividing by DCNL very small or zero norms. DCNL return_norm : bool DCNL If true the total norm is also returned. DCNL Returns DCNL tensor_vars_scaled : list of TensorVariables DCNL The scaled tensor variables. DCNL norm : Theano scalar DCNL The combined norms of the input variables prior to rescaling, DCNL only returned if ``return_norms=True``. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> import lasagne DCNL >>> from lasagne.updates import sgd, total_norm_constraint DCNL >>> x = T.matrix() DCNL >>> y = T.ivector() DCNL >>> l_in = InputLayer((5, 10)) DCNL >>> l1 = DenseLayer(l_in, num_units=7, nonlinearity=T.nnet.softmax) DCNL >>> output = lasagne.layers.get_output(l1, x) DCNL >>> cost = T.mean(T.nnet.categorical_crossentropy(output, y)) DCNL >>> all_params = lasagne.layers.get_all_params(l1) DCNL >>> all_grads = T.grad(cost, all_params) DCNL >>> scaled_grads = total_norm_constraint(all_grads, 5) DCNL >>> updates = sgd(scaled_grads, all_params, learning_rate=0.1) DCNL Notes DCNL The total norm can be used to monitor training. DCNL References DCNL .. [1] Sutskever, I., Vinyals, O., & Le, Q. V. (2014): Sequence to sequence DCNL learning with neural networks. In Advances in Neural Information DCNL Processing Systems (pp. 3104-3112).'
def pad(x, width, val=0, batch_ndim=1): DCNL 'Pad a tensor with a constant value. DCNL Parameters DCNL x : tensor DCNL width : int, iterable of int, or iterable of tuple DCNL Padding width. If an int, pads each axis symmetrically with the same DCNL amount in the beginning and end. If an iterable of int, defines the DCNL symmetric padding width separately for each axis. If an iterable of DCNL tuples of two ints, defines a seperate padding width for each beginning DCNL and end of each axis. DCNL val : float DCNL The constant value used for padding DCNL batch_ndim : integer DCNL Dimensions before the value will not be padded.'
def conv1d_sc(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL 'using conv2d with a single input channel'
def conv1d_mc0(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL 'using conv2d with width == 1'
def conv1d_mc1(input, filters, image_shape=None, filter_shape=None, border_mode='valid', subsample=(1,), filter_flip=True): DCNL 'using conv2d with height == 1'
def conv1d_unstrided(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True, implementation=conv1d_sc): DCNL 'perform a strided 1D convolution by reshaping input and filters so that the DCNL stride becomes 1. This function requires that the filter length is a DCNL multiple of the stride. It also truncates the input to have a length DCNL that is a multiple of the stride.'
def conv1d_sd(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True): DCNL 'using a single dot product'
def conv1d_md(input, filters, image_shape, filter_shape, border_mode='valid', subsample=(1,), filter_flip=True): DCNL 'using multiple dot products'
def get_rng(): DCNL 'Get the package-level random number generator. DCNL Returns DCNL :class:`numpy.random.RandomState` instance DCNL The :class:`numpy.random.RandomState` instance passed to the most DCNL recent call of :func:`set_rng`, or ``numpy.random`` if :func:`set_rng` DCNL has never been called.'
def set_rng(new_rng): DCNL 'Set the package-level random number generator. DCNL Parameters DCNL new_rng : ``numpy.random`` or a :class:`numpy.random.RandomState` instance DCNL The random number generator to use.'
def pytest_ignore_collect(path, config): DCNL 'Ignore paths that would otherwise be collceted by the doctest DCNL plugin and lead to ImportError due to missing dependencies.'
def floatX(arr): DCNL 'Converts data to a numpy array of dtype ``theano.config.floatX``. DCNL Parameters DCNL arr : array_like DCNL The data to be converted. DCNL Returns DCNL numpy ndarray DCNL The input array in the ``floatX`` dtype configured for Theano. DCNL If `arr` is an ndarray of correct dtype, it is returned as is.'
def shared_empty(dim=2, dtype=None): DCNL 'Creates empty Theano shared variable. DCNL Shortcut to create an empty Theano shared variable with DCNL the specified number of dimensions. DCNL Parameters DCNL dim : int, optional DCNL The number of dimensions for the empty variable, defaults to 2. DCNL dtype : a numpy data-type, optional DCNL The desired dtype for the variable. Defaults to the Theano DCNL ``floatX`` dtype. DCNL Returns DCNL Theano shared variable DCNL An empty Theano shared variable of dtype ``dtype`` with DCNL `dim` dimensions.'
def as_theano_expression(input): DCNL 'Wrap as Theano expression. DCNL Wraps the given input as a Theano constant if it is not DCNL a valid Theano expression already. Useful to transparently DCNL handle numpy arrays and Python scalars, for example. DCNL Parameters DCNL input : number, numpy array or Theano expression DCNL Expression to be converted to a Theano constant. DCNL Returns DCNL Theano symbolic constant DCNL Theano constant version of `input`.'
def collect_shared_vars(expressions): DCNL 'Returns all shared variables the given expression(s) depend on. DCNL Parameters DCNL expressions : Theano expression or iterable of Theano expressions DCNL The expressions to collect shared variables from. DCNL Returns DCNL list of Theano shared variables DCNL All shared variables the given expression(s) depend on, in fixed order DCNL (as found by a left-recursive depth-first search). If some expressions DCNL are shared variables themselves, they are included in the result.'
def one_hot(x, m=None): DCNL 'One-hot representation of integer vector. DCNL Given a vector of integers from 0 to m-1, returns a matrix DCNL with a one-hot representation, where each row corresponds DCNL to an element of x. DCNL Parameters DCNL x : integer vector DCNL The integer vector to convert to a one-hot representation. DCNL m : int, optional DCNL The number of different columns for the one-hot representation. This DCNL needs to be strictly greater than the maximum value of `x`. DCNL Defaults to ``max(x) + 1``. DCNL Returns DCNL Theano tensor variable DCNL A Theano tensor variable of shape (``n``, `m`), where ``n`` is the DCNL length of `x`, with the one-hot representation of `x`. DCNL Notes DCNL If your integer vector represents target class memberships, and you wish to DCNL compute the cross-entropy between predictions and the target class DCNL memberships, then there is no need to use this function, since the function DCNL :func:`lasagne.objectives.categorical_crossentropy()` can compute the DCNL cross-entropy from the integer vector directly.'
def unique(l): DCNL 'Filters duplicates of iterable. DCNL Create a new list from l with duplicate entries removed, DCNL while preserving the original order. DCNL Parameters DCNL l : iterable DCNL Input iterable to filter of duplicates. DCNL Returns DCNL list DCNL A list of elements of `l` without duplicates and in the same order.'
def as_tuple(x, N, t=None): DCNL 'Coerce a value to a tuple of given length (and possibly given type). DCNL Parameters DCNL x : value or iterable DCNL N : integer DCNL length of the desired tuple DCNL t : type, optional DCNL required type for all elements DCNL Returns DCNL tuple DCNL ``tuple(x)`` if `x` is iterable, ``(x,) * N`` otherwise. DCNL Raises DCNL TypeError DCNL if `type` is given and `x` or any of its elements do not match it DCNL ValueError DCNL if `x` is iterable, but does not have exactly `N` elements'
def compute_norms(array, norm_axes=None): DCNL 'Compute incoming weight vector norms. DCNL Parameters DCNL array : numpy array or Theano expression DCNL Weight or bias. DCNL norm_axes : sequence (list or tuple) DCNL The axes over which to compute the norm.  This overrides the DCNL default norm axes defined for the number of dimensions DCNL in `array`. When this is not specified and `array` is a 2D array, DCNL this is set to `(0,)`. If `array` is a 3D, 4D or 5D array, it is DCNL set to a tuple listing all axes but axis 0. The former default is DCNL useful for working with dense layers, the latter is useful for 1D, DCNL 2D and 3D convolutional layers. DCNL Finally, in case `array` is a vector, `norm_axes` is set to an empty DCNL tuple, and this function will simply return the absolute value for DCNL each element. This is useful when the function is applied to all DCNL parameters of the network, including the bias, without distinction. DCNL (Optional) DCNL Returns DCNL norms : 1D array or Theano vector (1D) DCNL 1D array or Theano vector of incoming weight/bias vector norms. DCNL Examples DCNL >>> array = np.random.randn(100, 200) DCNL >>> norms = compute_norms(array) DCNL >>> norms.shape DCNL (200,) DCNL >>> norms = compute_norms(array, norm_axes=(1,)) DCNL >>> norms.shape DCNL (100,)'
def create_param(spec, shape, name=None): DCNL 'Helper method to create Theano shared variables for layer parameters DCNL and to initialize them. DCNL Parameters DCNL spec : scalar number, numpy array, Theano expression, or callable DCNL Either of the following: DCNL * a scalar or a numpy array with the initial parameter values DCNL * a Theano expression or shared variable representing the parameters DCNL * a function or callable that takes the desired shape of DCNL the parameter array as its single argument and returns DCNL a numpy array, a Theano expression, or a shared variable DCNL representing the parameters. DCNL shape : iterable of int DCNL a tuple or other iterable of integers representing the desired DCNL shape of the parameter array. DCNL name : string, optional DCNL The name to give to the parameter variable. Ignored if `spec` DCNL is or returns a Theano expression or shared variable that DCNL already has a name. DCNL Returns DCNL Theano shared variable or Theano expression DCNL A Theano shared variable or expression representing layer parameters. DCNL If a scalar or a numpy array was provided, a shared variable is DCNL initialized to contain this array. If a shared variable or expression DCNL was provided, it is simply returned. If a callable was provided, it is DCNL called, and its output is used to initialize a shared variable. DCNL Notes DCNL This function is called by :meth:`Layer.add_param()` in the constructor DCNL of most :class:`Layer` subclasses. This enables those layers to DCNL support initialization with scalars, numpy arrays, existing Theano shared DCNL variables or expressions, and callables for generating initial parameter DCNL values, Theano expressions, or shared variables.'
def unroll_scan(fn, sequences, outputs_info, non_sequences, n_steps, go_backwards=False): DCNL 'Helper function to unroll for loops. Can be used to unroll theano.scan. DCNL The parameter names are identical to theano.scan, please refer to here DCNL for more information. DCNL Note that this function does not support the truncate_gradient DCNL setting from theano.scan. DCNL Parameters DCNL fn : function DCNL Function that defines calculations at each step. DCNL sequences : TensorVariable or list of TensorVariables DCNL List of TensorVariable with sequence data. The function iterates DCNL over the first dimension of each TensorVariable. DCNL outputs_info : list of TensorVariables DCNL List of tensors specifying the initial values for each recurrent DCNL value. DCNL non_sequences: list of TensorVariables DCNL List of theano.shared variables that are used in the step function. DCNL n_steps: int DCNL Number of steps to unroll. DCNL go_backwards: bool DCNL If true the recursion starts at sequences[-1] and iterates DCNL backwards. DCNL Returns DCNL List of TensorVariables. Each element in the list gives the recurrent DCNL values at each time step.'
def l1(x): DCNL 'Computes the L1 norm of a tensor DCNL Parameters DCNL x : Theano tensor DCNL Returns DCNL Theano scalar DCNL l1 norm (sum of absolute values of elements)'
def l2(x): DCNL 'Computes the squared L2 norm of a tensor DCNL Parameters DCNL x : Theano tensor DCNL Returns DCNL Theano scalar DCNL squared l2 norm (sum of squared values of elements)'
def apply_penalty(tensor_or_tensors, penalty, **kwargs): DCNL 'Computes the total cost for applying a specified penalty DCNL to a tensor or group of tensors. DCNL Parameters DCNL tensor_or_tensors : Theano tensor or list of tensors DCNL penalty : callable DCNL **kwargs DCNL keyword arguments passed to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the total penalty cost'
def regularize_layer_params(layer, penalty, tags={'regularizable': True}, **kwargs): DCNL 'Computes a regularization cost by applying a penalty to the parameters DCNL of a layer or group of layers. DCNL Parameters DCNL layer : a :class:`Layer` instances or list of layers. DCNL penalty : callable DCNL tags: dict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By default, only parameters with the `regularizable` tag are included. DCNL **kwargs DCNL keyword arguments passed to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'
def regularize_layer_params_weighted(layers, penalty, tags={'regularizable': True}, **kwargs): DCNL 'Computes a regularization cost by applying a penalty to the parameters DCNL of a layer or group of layers, weighted by a coefficient for each layer. DCNL Parameters DCNL layers : dict DCNL A mapping from :class:`Layer` instances to coefficients. DCNL penalty : callable DCNL tags: dict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By default, only parameters with the `regularizable` tag are included. DCNL **kwargs DCNL keyword arguments passed to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'
def regularize_network_params(layer, penalty, tags={'regularizable': True}, **kwargs): DCNL 'Computes a regularization cost by applying a penalty to the parameters DCNL of all layers in a network. DCNL Parameters DCNL layer : a :class:`Layer` instance. DCNL Parameters of this layer and all layers below it will be penalized. DCNL penalty : callable DCNL tags: dict DCNL Tag specifications which filter the parameters of the layer or layers. DCNL By default, only parameters with the `regularizable` tag are included. DCNL **kwargs DCNL keyword arguments passed to penalty. DCNL Returns DCNL Theano scalar DCNL a scalar expression for the cost'
def autocrop(inputs, cropping): DCNL 'Crops the given input arrays. DCNL Cropping takes a sequence of inputs and crops them per-axis in order to DCNL ensure that their sizes are consistent so that they can be combined DCNL in an element-wise fashion. If cropping is enabled for a specific axis, DCNL the minimum size in that axis of all inputs is computed, and all DCNL inputs are cropped to that size. DCNL The per-axis cropping modes are: DCNL `None`: this axis is not cropped, inputs are unchanged in this axis DCNL `\'lower\'`: inputs are cropped choosing the lower portion in this axis DCNL (`a[:crop_size, ...]`) DCNL `\'upper\'`: inputs are cropped choosing the upper portion in this axis DCNL (`a[-crop_size:, ...]`) DCNL `\'center\'`: inputs are cropped choosing the central portion in this axis DCNL (``a[offset:offset+crop_size, ...]`` where DCNL ``offset = (a.shape[0]-crop_size)//2)`` DCNL Parameters DCNL inputs : list of Theano expressions DCNL The input arrays in the form of a list of Theano expressions DCNL cropping : list of cropping modes DCNL Cropping modes, one for each axis. If length of `cropping` is less DCNL than the number of axes in the inputs, it is padded with `None`. DCNL If `cropping` is None, `input` is returned as is. DCNL Returns DCNL list of Theano expressions DCNL each expression is the cropped version of the corresponding input DCNL Example DCNL For example, given three inputs: DCNL >>> import numpy DCNL >>> import theano DCNL >>> a = numpy.random.random((1, 2, 3, 4)) DCNL >>> b = numpy.random.random((5, 4, 4, 2)) DCNL >>> c = numpy.random.random((7, 1, 8, 9)) DCNL Cropping mode for each axis: DCNL >>> cropping = [None, \'lower\', \'center\', \'upper\'] DCNL Crop (note that the input arrays are converted to Theano vars first, DCNL and that the results are converted back from Theano expressions to DCNL numpy arrays by calling `eval()`) DCNL >>> xa, xb, xc = autocrop([theano.shared(a),                                theano.shared(b),                                theano.shared(c)], cropping) DCNL >>> xa, xb, xc = xa.eval(), xb.eval(), xc.eval() DCNL They will be left as is in axis 0 and cropped in the other three, DCNL choosing the lower, center and upper portions: DCNL Axis 0: choose all, axis 1: lower 1 element, DCNL axis 2: central 3 (all) and axis 3: upper 2 DCNL >>> (xa == a[:, :1, :3, -2:]).all() DCNL True DCNL Axis 0: choose all, axis 1: lower 1 element, DCNL axis 2: central 3 starting at 0 and axis 3: upper 2 (all) DCNL >>> (xb == b[:, :1, :3, -2:]).all() DCNL True DCNL Axis 0: all, axis 1: lower 1 element (all), DCNL axis 2: central 3 starting at 2 and axis 3: upper 2 DCNL >>> (xc == c[:, :1, 2:5:, -2:]).all() DCNL True'
def autocrop_array_shapes(input_shapes, cropping): DCNL 'Computes the shapes of the given arrays after auto-cropping is applied. DCNL For more information on cropping, see the :func:`autocrop` function DCNL documentation. DCNL Parameters DCNL input_shapes : the shapes of input arrays prior to cropping in DCNL the form of a list of tuples DCNL cropping : a list of cropping modes, one for each axis. If length of DCNL `cropping` is less than the number of axes in the inputs, it is DCNL padded with `None`. If `cropping` is None, `input_shapes` is returned DCNL as is. For more information on their values and operation, see the DCNL :func:`autocrop` documentation. DCNL Returns DCNL list of tuples DCNL each tuple is a cropped version of the corresponding input DCNL shape tuple in `input_shapes` DCNL For example, given three input shapes with 4 axes each: DCNL >>> a = (1, 2, 3, 4) DCNL >>> b = (5, 4, 4, 2) DCNL >>> c = (7, 1, 8, 9) DCNL Cropping mode for each axis: DCNL >>> cropping = [None, \'lower\', \'center\', \'upper\'] DCNL Apply: DCNL >>> cropped_shapes = autocrop_array_shapes([a, b, c], cropping) DCNL >>> cropped_shapes[0] DCNL (1, 1, 3, 2) DCNL >>> cropped_shapes[1] DCNL (5, 1, 3, 2) DCNL >>> cropped_shapes[2] DCNL (7, 1, 3, 2) DCNL Note that axis 0 remains unchanged, where all the others are cropped DCNL to the minimum size in that axis.'
def conv_output_length(input_length, filter_size, stride, pad=0): DCNL 'Helper function to compute the output size of a convolution operation DCNL This function computes the length along a single axis, which corresponds DCNL to a 1D convolution. It can also be used for convolutions with higher DCNL dimensionalities by using it individually for each axis. DCNL Parameters DCNL input_length : int or None DCNL The size of the input. DCNL filter_size : int DCNL The size of the filter. DCNL stride : int DCNL The stride of the convolution operation. DCNL pad : int, \'full\' or \'same\' (default: 0) DCNL By default, the convolution is only computed where the input and the DCNL filter fully overlap (a valid convolution). When ``stride=1``, this DCNL yields an output that is smaller than the input by ``filter_size - 1``. DCNL The `pad` argument allows you to implicitly pad the input with zeros, DCNL extending the output size. DCNL A single integer results in symmetric zero-padding of the given size on DCNL both borders. DCNL ``\'full\'`` pads with one less than the filter size on both sides. This DCNL is equivalent to computing the convolution wherever the input and the DCNL filter overlap by at least one position. DCNL ``\'same\'`` pads with half the filter size on both sides (one less on DCNL the second side for an even filter size). When ``stride=1``, this DCNL results in an output size equal to the input size. DCNL Returns DCNL int or None DCNL The output size corresponding to the given convolution parameters, or DCNL ``None`` if `input_size` is ``None``. DCNL Raises DCNL ValueError DCNL When an invalid padding is specified, a `ValueError` is raised.'
def conv_input_length(output_length, filter_size, stride, pad=0): DCNL 'Helper function to compute the input size of a convolution operation DCNL This function computes the length along a single axis, which corresponds DCNL to a 1D convolution. It can also be used for convolutions with higher DCNL dimensionalities by using it individually for each axis. DCNL Parameters DCNL output_length : int or None DCNL The size of the output. DCNL filter_size : int DCNL The size of the filter. DCNL stride : int DCNL The stride of the convolution operation. DCNL pad : int, \'full\' or \'same\' (default: 0) DCNL By default, the convolution is only computed where the input and the DCNL filter fully overlap (a valid convolution). When ``stride=1``, this DCNL yields an output that is smaller than the input by ``filter_size - 1``. DCNL The `pad` argument allows you to implicitly pad the input with zeros, DCNL extending the output size. DCNL A single integer results in symmetric zero-padding of the given size on DCNL both borders. DCNL ``\'full\'`` pads with one less than the filter size on both sides. This DCNL is equivalent to computing the convolution wherever the input and the DCNL filter overlap by at least one position. DCNL ``\'same\'`` pads with half the filter size on both sides (one less on DCNL the second side for an even filter size). When ``stride=1``, this DCNL results in an output size equal to the input size. DCNL Returns DCNL int or None DCNL The smallest input size corresponding to the given convolution DCNL parameters for the given output size, or ``None`` if `output_size` is DCNL ``None``. For a strided convolution, any input size of up to DCNL ``stride - 1`` elements larger than returned will still give the same DCNL output size. DCNL Raises DCNL ValueError DCNL When an invalid padding is specified, a `ValueError` is raised. DCNL Notes DCNL This can be used to compute the output size of a convolution backward pass, DCNL also called transposed convolution, fractionally-strided convolution or DCNL (wrongly) deconvolution in the literature.'
def pool_output_length(input_length, pool_size, stride, pad, ignore_border): DCNL 'Compute the output length of a pooling operator DCNL along a single dimension. DCNL Parameters DCNL input_length : integer DCNL The length of the input in the pooling dimension DCNL pool_size : integer DCNL The length of the pooling region DCNL stride : integer DCNL The stride between successive pooling regions DCNL pad : integer DCNL The number of elements to be added to the input on each side. DCNL ignore_border: bool DCNL If ``True``, partial pooling regions will be ignored. DCNL Must be ``True`` if ``pad != 0``. DCNL Returns DCNL output_length DCNL * None if either input is None. DCNL * Computed length of the pooling operator otherwise. DCNL Notes DCNL When ``ignore_border == True``, this is given by the number of full DCNL pooling regions that fit in the padded input length, DCNL divided by the stride (rounding down). DCNL If ``ignore_border == False``, a single partial pooling region is DCNL appended if at least one input element would be left uncovered otherwise.'
def pool_2d(input, **kwargs): DCNL 'Wrapper function that calls :func:`theano.tensor.signal.pool_2d` either DCNL with the new or old keyword argument names expected by Theano.'
def dropout_channels(incoming, *args, **kwargs): DCNL 'Convenience function to drop full channels of feature maps. DCNL Adds a :class:`DropoutLayer` that sets feature map channels to zero, across DCNL all locations, with probability p. For convolutional neural networks, this DCNL may give better results than independent dropout [1]_. DCNL Parameters DCNL incoming : a :class:`Layer` instance or a tuple DCNL the layer feeding into this layer, or the expected input shape DCNL *args, **kwargs DCNL Any additional arguments and keyword arguments are passed on to the DCNL :class:`DropoutLayer` constructor, except for `shared_axes`. DCNL Returns DCNL layer : :class:`DropoutLayer` instance DCNL The dropout layer with `shared_axes` set to drop channels. DCNL References DCNL .. [1] J. Tompson, R. Goroshin, A. Jain, Y. LeCun, C. Bregler (2014): DCNL Efficient Object Localization Using Convolutional Networks. DCNL https://arxiv.org/abs/1411.4280'
def dropout_locations(incoming, *args, **kwargs): DCNL 'Convenience function to drop full locations of feature maps. DCNL Adds a :class:`DropoutLayer` that sets feature map locations (i.e., pixels DCNL or voxels) to zero, across all channels, with probability p. DCNL Parameters DCNL incoming : a :class:`Layer` instance or a tuple DCNL the layer feeding into this layer, or the expected input shape DCNL *args, **kwargs DCNL Any additional arguments and keyword arguments are passed on to the DCNL :class:`DropoutLayer` constructor, except for `shared_axes`. DCNL Returns DCNL layer : :class:`DropoutLayer` instance DCNL The dropout layer with `shared_axes` set to drop locations.'
def batch_norm_dnn(layer, **kwargs): DCNL 'Apply cuDNN batch normalization to an existing layer. This is a drop-in DCNL replacement for :func:`lasagne.layers.batch_norm`; see there for further DCNL information. DCNL Parameters DCNL layer : A :class:`Layer` instance DCNL The layer to apply the normalization to; note that it will be DCNL modified as specified in :func:`lasagne.layers.batch_norm` DCNL **kwargs DCNL Any additional keyword arguments are passed on to the DCNL :class:`BatchNormDNNLayer` constructor. DCNL Returns DCNL BatchNormDNNLayer or NonlinearityLayer instance DCNL A batch normalization layer stacked on the given modified `layer`, or DCNL a nonlinearity layer stacked on top of both if `layer` was nonlinear.'
def get_all_layers(layer, treat_as_input=None): DCNL 'This function gathers all layers below one or more given :class:`Layer` DCNL instances, including the given layer(s). Its main use is to collect all DCNL layers of a network just given the output layer(s). The layers are DCNL guaranteed to be returned in a topological order: a layer in the result DCNL list is always preceded by all layers its input depends on. DCNL Parameters DCNL layer : Layer or list DCNL the :class:`Layer` instance for which to gather all layers feeding DCNL into it, or a list of :class:`Layer` instances. DCNL treat_as_input : None or iterable DCNL an iterable of :class:`Layer` instances to treat as input layers DCNL with no layers feeding into them. They will show up in the result DCNL list, but their incoming layers will not be collected (unless they DCNL are required for other layers as well). DCNL Returns DCNL list DCNL a list of :class:`Layer` instances feeding into the given DCNL instance(s) either directly or indirectly, and the given DCNL instance(s) themselves, in topological order. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> get_all_layers(l1) == [l_in, l1] DCNL True DCNL >>> l2 = DenseLayer(l_in, num_units=10) DCNL >>> get_all_layers([l2, l1]) == [l_in, l2, l1] DCNL True DCNL >>> get_all_layers([l1, l2]) == [l_in, l1, l2] DCNL True DCNL >>> l3 = DenseLayer(l2, num_units=20) DCNL >>> get_all_layers(l3) == [l_in, l2, l3] DCNL True DCNL >>> get_all_layers(l3, treat_as_input=[l2]) == [l2, l3] DCNL True'
def get_output(layer_or_layers, inputs=None, **kwargs): DCNL 'Computes the output of the network at one or more given layers. DCNL Optionally, you can define the input(s) to propagate through the network DCNL instead of using the input variable(s) associated with the network\'s DCNL input layer(s). DCNL Parameters DCNL layer_or_layers : Layer or list DCNL the :class:`Layer` instance for which to compute the output DCNL expressions, or a list of :class:`Layer` instances. DCNL inputs : None, Theano expression, numpy array, or dict DCNL If None, uses the input variables associated with the DCNL :class:`InputLayer` instances. DCNL If a Theano expression, this defines the input for a single DCNL :class:`InputLayer` instance. Will throw a ValueError if there DCNL are multiple :class:`InputLayer` instances. DCNL If a numpy array, this will be wrapped as a Theano constant DCNL and used just like a Theano expression. DCNL If a dictionary, any :class:`Layer` instance (including the DCNL input layers) can be mapped to a Theano expression or numpy DCNL array to use instead of its regular output. DCNL Returns DCNL output : Theano expression or list DCNL the output of the given layer(s) for the given network input DCNL Notes DCNL Depending on your network architecture, `get_output([l1, l2])` may DCNL be crucially different from `[get_output(l1), get_output(l2)]`. Only DCNL the former ensures that the output expressions depend on the same DCNL intermediate expressions. For example, when `l1` and `l2` depend on DCNL a common dropout layer, the former will use the same dropout mask for DCNL both, while the latter will use two different dropout masks.'
def get_output_shape(layer_or_layers, input_shapes=None): DCNL 'Computes the output shape of the network at one or more given layers. DCNL Parameters DCNL layer_or_layers : Layer or list DCNL the :class:`Layer` instance for which to compute the output DCNL shapes, or a list of :class:`Layer` instances. DCNL input_shapes : None, tuple, or dict DCNL If None, uses the input shapes associated with the DCNL :class:`InputLayer` instances. DCNL If a tuple, this defines the input shape for a single DCNL :class:`InputLayer` instance. Will throw a ValueError if there DCNL are multiple :class:`InputLayer` instances. DCNL If a dictionary, any :class:`Layer` instance (including the DCNL input layers) can be mapped to a shape tuple to use instead of DCNL its regular output shape. DCNL Returns DCNL tuple or list DCNL the output shape of the given layer(s) for the given network input'
def get_all_params(layer, unwrap_shared=True, **tags): DCNL 'Returns a list of Theano shared variables or expressions that DCNL parameterize the layer. DCNL This function gathers all parameters of all layers below one or more given DCNL :class:`Layer` instances, including the layer(s) itself. Its main use is to DCNL collect all parameters of a network just given the output layer(s). DCNL By default, all shared variables that participate in the forward pass will DCNL be returned. The list can optionally be filtered by specifying tags as DCNL keyword arguments. For example, ``trainable=True`` will only return DCNL trainable parameters, and ``regularizable=True`` will only return DCNL parameters that can be regularized (e.g., by L2 decay). DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to gather all parameters, or a DCNL list of :class:`Layer` instances. DCNL unwrap_shared : bool (default: True) DCNL Affects only parameters that were set to a Theano expression. If DCNL ``True`` the function returns the shared variables contained in DCNL the expression, otherwise the Theano expression itself. DCNL **tags (optional) DCNL tags can be specified to filter the list. Specifying ``tag1=True`` DCNL will limit the list to parameters that are tagged with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not tagged with ``tag1``. Commonly used tags are DCNL ``regularizable`` and ``trainable``. DCNL Returns DCNL params : list DCNL A list of Theano shared variables or expressions representing DCNL the parameters. DCNL Notes DCNL If any of the layers\' parameters was set to a Theano expression instead DCNL of a shared variable, `unwrap_shared` controls whether to return the DCNL shared variables involved in that expression (``unwrap_shared=True``, DCNL the default), or the expression itself (``unwrap_shared=False``). In DCNL either case, tag filtering applies to the expressions, considering all DCNL variables within an expression to be tagged the same. DCNL Examples DCNL Collecting all parameters from a two-layer network: DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> l2 = DenseLayer(l1, num_units=30) DCNL >>> all_params = get_all_params(l2) DCNL >>> all_params == [l1.W, l1.b, l2.W, l2.b] DCNL True DCNL Parameters can be filtered by tags, and parameter expressions are DCNL unwrapped to return involved shared variables by default: DCNL >>> from lasagne.utils import floatX DCNL >>> w1 = theano.shared(floatX(.01 * np.random.randn(50, 30))) DCNL >>> w2 = theano.shared(floatX(1)) DCNL >>> l2 = DenseLayer(l1, num_units=30, W=theano.tensor.exp(w1) - w2, b=None) DCNL >>> all_params = get_all_params(l2, regularizable=True) DCNL >>> all_params == [l1.W, w1, w2] DCNL True DCNL When disabling unwrapping, the expression for ``l2.W`` is returned instead: DCNL >>> all_params = get_all_params(l2, regularizable=True, DCNL ...                             unwrap_shared=False) DCNL >>> all_params == [l1.W, l2.W] DCNL True'
def count_params(layer, **tags): DCNL 'This function counts all parameters (i.e., the number of scalar DCNL values) of all layers below one or more given :class:`Layer` instances, DCNL including the layer(s) itself. DCNL This is useful to compare the capacity of various network architectures. DCNL All parameters returned by the :class:`Layer`s\' `get_params` methods are DCNL counted. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to count the parameters, or a DCNL list of :class:`Layer` instances. DCNL **tags (optional) DCNL tags can be specified to filter the list of parameter variables that DCNL will be included in the count. Specifying ``tag1=True`` DCNL will limit the list to parameters that are tagged with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not tagged with ``tag1``. Commonly used tags are DCNL ``regularizable`` and ``trainable``. DCNL Returns DCNL int DCNL The total number of learnable parameters. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> param_count = count_params(l1) DCNL >>> param_count DCNL 1050 DCNL >>> param_count == 20 * 50 + 50  # 20 input * 50 units + 50 biases DCNL True'
def get_all_param_values(layer, **tags): DCNL 'This function returns the values of the parameters of all layers below one DCNL or more given :class:`Layer` instances, including the layer(s) itself. DCNL This function can be used in conjunction with set_all_param_values to save DCNL and restore model parameters. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to gather all parameter values, DCNL or a list of :class:`Layer` instances. DCNL **tags (optional) DCNL tags can be specified to filter the list. Specifying ``tag1=True`` DCNL will limit the list to parameters that are tagged with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not tagged with ``tag1``. Commonly used tags are DCNL ``regularizable`` and ``trainable``. DCNL Returns DCNL list of numpy.array DCNL A list of numpy arrays representing the parameter values. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> all_param_values = get_all_param_values(l1) DCNL >>> (all_param_values[0] == l1.W.get_value()).all() DCNL True DCNL >>> (all_param_values[1] == l1.b.get_value()).all() DCNL True'
def set_all_param_values(layer, values, **tags): DCNL 'Given a list of numpy arrays, this function sets the parameters of all DCNL layers below one or more given :class:`Layer` instances (including the DCNL layer(s) itself) to the given values. DCNL This function can be used in conjunction with get_all_param_values to save DCNL and restore model parameters. DCNL Parameters DCNL layer : Layer or list DCNL The :class:`Layer` instance for which to set all parameter values, or a DCNL list of :class:`Layer` instances. DCNL values : list of numpy.array DCNL A list of numpy arrays representing the parameter values, must match DCNL the number of parameters. DCNL Every parameter\'s shape must match the shape of its new value. DCNL **tags (optional) DCNL tags can be specified to filter the list of parameters to be set. DCNL Specifying ``tag1=True`` will limit the list to parameters that are DCNL tagged with ``tag1``. DCNL Specifying ``tag1=False`` will limit the list to parameters that DCNL are not tagged with ``tag1``. Commonly used tags are DCNL ``regularizable`` and ``trainable``. DCNL Raises DCNL ValueError DCNL If the number of values is not equal to the number of params, or DCNL if a parameter\'s shape does not match the shape of its new value. DCNL Examples DCNL >>> from lasagne.layers import InputLayer, DenseLayer DCNL >>> l_in = InputLayer((100, 20)) DCNL >>> l1 = DenseLayer(l_in, num_units=50) DCNL >>> all_param_values = get_all_param_values(l1) DCNL >>> # all_param_values is now [l1.W.get_value(), l1.b.get_value()] DCNL >>> set_all_param_values(l1, all_param_values) DCNL >>> # the parameter values are restored.'
def standardize(layer, offset, scale, shared_axes='auto'): DCNL 'Convenience function for standardizing inputs by applying a fixed offset DCNL and scale.  This is usually useful when you want the input to your network DCNL to, say, have zero mean and unit standard deviation over the feature DCNL dimensions.  This layer allows you to include the appropriate statistics to DCNL achieve this normalization as part of your network, and applies them to its DCNL input.  The statistics are supplied as the `offset` and `scale` parameters, DCNL which are applied to the input by subtracting `offset` and dividing by DCNL `scale`, sharing dimensions as specified by the `shared_axes` argument. DCNL Parameters DCNL layer : a :class:`Layer` instance or a tuple DCNL The layer feeding into this layer, or the expected input shape. DCNL offset : Theano shared variable or numpy array DCNL The offset to apply (via subtraction) to the axis/axes being DCNL standardized. DCNL scale : Theano shared variable or numpy array DCNL The scale to apply (via division) to the axis/axes being standardized. DCNL shared_axes : \'auto\', int or tuple of int DCNL The axis or axes to share the offset and scale over. If ``\'auto\'`` (the DCNL default), share over all axes except for the second: this will share DCNL scales over the minibatch dimension for dense layers, and additionally DCNL over all spatial dimensions for convolutional layers. DCNL Examples DCNL Assuming your training data exists in a 2D numpy ndarray called DCNL ``training_data``, you can use this function to scale input features to the DCNL [0, 1] range based on the training set statistics like so: DCNL >>> import lasagne DCNL >>> import numpy as np DCNL >>> training_data = np.random.standard_normal((100, 20)) DCNL >>> input_shape = (None, training_data.shape[1]) DCNL >>> l_in = lasagne.layers.InputLayer(input_shape) DCNL >>> offset = training_data.min(axis=0) DCNL >>> scale = training_data.max(axis=0) - training_data.min(axis=0) DCNL >>> l_std = standardize(l_in, offset, scale, shared_axes=0) DCNL Alternatively, to z-score your inputs based on training set statistics, you DCNL could set ``offset = training_data.mean(axis=0)`` and DCNL ``scale = training_data.std(axis=0)`` instead.'
def _get_transformed_points_tps(new_points, source_points, coefficients, num_points, batch_size): DCNL 'Calculates the transformed points\' value using the provided coefficients DCNL :param new_points: num_batch x 2 x num_to_transform tensor DCNL :param source_points: 2 x num_points array of source points DCNL :param coefficients: coefficients (should be shape (num_batch, 2, DCNL control_points + 3)) DCNL :param num_points: the number of points DCNL :return: the x and y coordinates of each transformed point. Shape ( DCNL num_batch, 2, num_to_transform)'
def _U_func_numpy(x1, y1, x2, y2): DCNL 'Function which implements the U function from Bookstein paper DCNL :param x1: x coordinate of the first point DCNL :param y1: y coordinate of the first point DCNL :param x2: x coordinate of the second point DCNL :param y2: y coordinate of the second point DCNL :return: value of z'
def _initialize_tps(num_control_points, input_shape, downsample_factor, precompute_grid): DCNL 'Initializes the thin plate spline calculation by creating the source DCNL point array and the inverted L matrix used for calculating the DCNL transformations as in ref [2]_ DCNL :param num_control_points: the number of control points. Must be a DCNL perfect square. Points will be used to generate an evenly spaced grid. DCNL :param input_shape: tuple with 4 elements specifying the input shape DCNL :param downsample_factor: tuple with 2 elements specifying the DCNL downsample for the height and width, respectively DCNL :param precompute_grid: boolean specifying whether to precompute the DCNL grid matrix DCNL :return: DCNL right_mat: shape (num_control_points + 3, out_height*out_width) tensor DCNL L_inv: shape (num_control_points + 3, num_control_points + 3) tensor DCNL source_points: shape (2, num_control_points) tensor DCNL out_height: tensor constant specifying the ouptut height DCNL out_width: tensor constant specifying the output width'
def prelu(layer, **kwargs): DCNL 'Convenience function to apply parametric rectify to a given layer\'s output. DCNL Will set the layer\'s nonlinearity to identity if there is one and will DCNL apply the parametric rectifier instead. DCNL Parameters DCNL layer: a :class:`Layer` instance DCNL The `Layer` instance to apply the parametric rectifier layer to; DCNL note that it will be irreversibly modified as specified above DCNL **kwargs DCNL Any additional keyword arguments are passed to the DCNL :class:`ParametericRectifierLayer` DCNL Examples DCNL Note that this function modifies an existing layer, like this: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, prelu DCNL >>> layer = InputLayer((32, 100)) DCNL >>> layer = DenseLayer(layer, num_units=200) DCNL >>> layer = prelu(layer) DCNL In particular, :func:`prelu` can *not* be passed as a nonlinearity.'
def rrelu(layer, **kwargs): DCNL 'Convenience function to apply randomized rectify to a given layer\'s output. DCNL Will set the layer\'s nonlinearity to identity if there is one and will DCNL apply the randomized rectifier instead. DCNL Parameters DCNL layer: a :class:`Layer` instance DCNL The `Layer` instance to apply the randomized rectifier layer to; DCNL note that it will be irreversibly modified as specified above DCNL **kwargs DCNL Any additional keyword arguments are passed to the DCNL :class:`RandomizedRectifierLayer` DCNL Examples DCNL Note that this function modifies an existing layer, like this: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, rrelu DCNL >>> layer = InputLayer((32, 100)) DCNL >>> layer = DenseLayer(layer, num_units=200) DCNL >>> layer = rrelu(layer) DCNL In particular, :func:`rrelu` can *not* be passed as a nonlinearity.'
def batch_norm(layer, **kwargs): DCNL 'Apply batch normalization to an existing layer. This is a convenience DCNL function modifying an existing layer to include batch normalization: It DCNL will steal the layer\'s nonlinearity if there is one (effectively DCNL introducing the normalization right before the nonlinearity), remove DCNL the layer\'s bias if there is one (because it would be redundant), and add DCNL a :class:`BatchNormLayer` and :class:`NonlinearityLayer` on top. DCNL Parameters DCNL layer : A :class:`Layer` instance DCNL The layer to apply the normalization to; note that it will be DCNL irreversibly modified as specified above DCNL **kwargs DCNL Any additional keyword arguments are passed on to the DCNL :class:`BatchNormLayer` constructor. DCNL Returns DCNL BatchNormLayer or NonlinearityLayer instance DCNL A batch normalization layer stacked on the given modified `layer`, or DCNL a nonlinearity layer stacked on top of both if `layer` was nonlinear. DCNL Examples DCNL Just wrap any layer into a :func:`batch_norm` call on creating it: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, batch_norm DCNL >>> from lasagne.nonlinearities import tanh DCNL >>> l1 = InputLayer((64, 768)) DCNL >>> l2 = batch_norm(DenseLayer(l1, num_units=500, nonlinearity=tanh)) DCNL This introduces batch normalization right before its nonlinearity: DCNL >>> from lasagne.layers import get_all_layers DCNL >>> [l.__class__.__name__ for l in get_all_layers(l2)] DCNL [\'InputLayer\', \'DenseLayer\', \'BatchNormLayer\', \'NonlinearityLayer\']'
def align_targets(predictions, targets): DCNL 'Helper function turning a target 1D vector into a column if needed. DCNL This way, combining a network of a single output unit with a target vector DCNL works as expected by most users, not broadcasting outputs against targets. DCNL Parameters DCNL predictions : Theano tensor DCNL Expression for the predictions of a neural network. DCNL targets : Theano tensor DCNL Expression or variable for corresponding targets. DCNL Returns DCNL predictions : Theano tensor DCNL The predictions unchanged. DCNL targets : Theano tensor DCNL If `predictions` is a column vector and `targets` is a 1D vector, DCNL returns `targets` turned into a column vector. Otherwise, returns DCNL `targets` unchanged.'
def binary_crossentropy(predictions, targets): DCNL 'Computes the binary cross-entropy between predictions and targets. DCNL .. math:: L = -t \log(p) - (1 - t) \log(1 - p) DCNL Parameters DCNL predictions : Theano tensor DCNL Predictions in (0, 1), such as sigmoidal output of a neural network. DCNL targets : Theano tensor DCNL Targets in [0, 1], such as ground truth labels. DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary cross-entropy. DCNL Notes DCNL This is the loss function of choice for binary classification problems DCNL and sigmoid output units.'
def categorical_crossentropy(predictions, targets): DCNL 'Computes the categorical cross-entropy between predictions and targets. DCNL .. math:: L_i = - \sum_j{t_{i,j} \log(p_{i,j})} DCNL Parameters DCNL predictions : Theano 2D tensor DCNL Predictions in (0, 1), such as softmax output of a neural network, DCNL with data points in rows and class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either targets in [0, 1] matching the layout of `predictions`, or DCNL a vector of int giving the correct class index per data point. DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise categorical cross-entropy. DCNL Notes DCNL This is the loss function of choice for multi-class classification DCNL problems and softmax output units. For hard targets, i.e., targets DCNL that assign all of the probability to a single class per data point, DCNL providing a vector of int for the targets is usually slightly more DCNL efficient than providing a matrix with a single 1.0 per row.'
def squared_error(a, b): DCNL 'Computes the element-wise squared difference between two tensors. DCNL .. math:: L = (p - t)^2 DCNL Parameters DCNL a, b : Theano tensor DCNL The tensors to compute the squared difference between. DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise squared difference. DCNL Notes DCNL This is the loss function of choice for many regression problems DCNL or auto-encoders with linear output units.'
def aggregate(loss, weights=None, mode='mean'): DCNL 'Aggregates an element- or item-wise loss to a scalar loss. DCNL Parameters DCNL loss : Theano tensor DCNL The loss expression to aggregate. DCNL weights : Theano tensor, optional DCNL The weights for each element or item, must be broadcastable to DCNL the same shape as `loss` if given. If omitted, all elements will DCNL be weighted the same. DCNL mode : {\'mean\', \'sum\', \'normalized_sum\'} DCNL Whether to aggregate by averaging, by summing or by summing and DCNL dividing by the total weights (which requires `weights` to be given). DCNL Returns DCNL Theano scalar DCNL A scalar loss expression suitable for differentiation. DCNL Notes DCNL By supplying binary weights (i.e., only using values 0 and 1), this DCNL function can also be used for masking out particular entries in the DCNL loss expression. Note that masked entries still need to be valid DCNL values, not-a-numbers (NaNs) will propagate through. DCNL When applied to batch-wise loss expressions, setting `mode` to DCNL ``\'normalized_sum\'`` ensures that the loss per batch is of a similar DCNL magnitude, independent of associated weights. However, it means that DCNL a given data point contributes more to the loss when it shares a batch DCNL with low-weighted or masked data points than with high-weighted ones.'
def binary_hinge_loss(predictions, targets, delta=1, log_odds=None, binary=True): DCNL 'Computes the binary hinge loss between predictions and targets. DCNL .. math:: L_i = \max(0, \delta - t_i p_i) DCNL Parameters DCNL predictions : Theano tensor DCNL Predictions in (0, 1), such as sigmoidal output of a neural network DCNL (or log-odds of predictions depending on `log_odds`). DCNL targets : Theano tensor DCNL Targets in {0, 1} (or in {-1, 1} depending on `binary`), such as DCNL ground truth labels. DCNL delta : scalar, default 1 DCNL The hinge loss margin DCNL log_odds : bool, default None DCNL ``False`` if predictions are sigmoid outputs in (0, 1), ``True`` if DCNL predictions are sigmoid inputs, or log-odds. If ``None``, will assume DCNL ``True``, but warn that the default will change to ``False``. DCNL binary : bool, default True DCNL ``True`` if targets are in {0, 1}, ``False`` if they are in {-1, 1} DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary hinge loss DCNL Notes DCNL This is an alternative to the binary cross-entropy loss for binary DCNL classification problems. DCNL Note that it is a drop-in replacement only when giving ``log_odds=False``. DCNL Otherwise, it requires log-odds rather than sigmoid outputs. Be aware that DCNL depending on the Theano version, ``log_odds=False`` with a sigmoid DCNL output layer may be less stable than ``log_odds=True`` with a linear layer.'
def multiclass_hinge_loss(predictions, targets, delta=1): DCNL 'Computes the multi-class hinge loss between predictions and targets. DCNL .. math:: L_i = \max_{j \not = p_i} (0, t_j - t_{p_i} + \delta) DCNL Parameters DCNL predictions : Theano 2D tensor DCNL Predictions in (0, 1), such as softmax output of a neural network, DCNL with data points in rows and class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either a vector of int giving the correct class index per data point DCNL or a 2D tensor of one-hot encoding of the correct class in the same DCNL layout as predictions (non-binary targets in [0, 1] do not work!) DCNL delta : scalar, default 1 DCNL The hinge loss margin DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise multi-class hinge loss DCNL Notes DCNL This is an alternative to the categorical cross-entropy loss for DCNL multi-class classification problems'
def binary_accuracy(predictions, targets, threshold=0.5): DCNL 'Computes the binary accuracy between predictions and targets. DCNL .. math:: L_i = \mathbb{I}(t_i = \mathbb{I}(p_i \ge \alpha)) DCNL Parameters DCNL predictions : Theano tensor DCNL Predictions in [0, 1], such as a sigmoidal output of a neural network, DCNL giving the probability of the positive class DCNL targets : Theano tensor DCNL Targets in {0, 1}, such as ground truth labels. DCNL threshold : scalar, default: 0.5 DCNL Specifies at what threshold to consider the predictions being of the DCNL positive class DCNL Returns DCNL Theano tensor DCNL An expression for the element-wise binary accuracy in {0, 1} DCNL Notes DCNL This objective function should not be used with a gradient calculation; DCNL its gradient is zero everywhere. It is intended as a convenience for DCNL validation and testing, not training. DCNL To obtain the average accuracy, call :func:`theano.tensor.mean()` on the DCNL result, passing ``dtype=theano.config.floatX`` to compute the mean on GPU.'
def categorical_accuracy(predictions, targets, top_k=1): DCNL 'Computes the categorical accuracy between predictions and targets. DCNL .. math:: L_i = \mathbb{I}(t_i = \operatorname{argmax}_c p_{i,c}) DCNL Can be relaxed to allow matches among the top :math:`k` predictions: DCNL .. math:: DCNL L_i = \mathbb{I}(t_i \in \operatorname{argsort}_c (-p_{i,c})_{:k}) DCNL Parameters DCNL predictions : Theano 2D tensor DCNL Predictions in (0, 1), such as softmax output of a neural network, DCNL with data points in rows and class probabilities in columns. DCNL targets : Theano 2D tensor or 1D tensor DCNL Either a vector of int giving the correct class index per data point DCNL or a 2D tensor of 1 hot encoding of the correct class in the same DCNL layout as predictions DCNL top_k : int DCNL Regard a prediction to be correct if the target class is among the DCNL `top_k` largest class probabilities. For the default value of 1, a DCNL prediction is correct only if the target class is the most probable. DCNL Returns DCNL Theano 1D tensor DCNL An expression for the item-wise categorical accuracy in {0, 1} DCNL Notes DCNL This is a strictly non differential function as it includes an argmax. DCNL This objective function should never be used with a gradient calculation. DCNL It is intended as a convenience for validation and testing not training. DCNL To obtain the average accuracy, call :func:`theano.tensor.mean()` on the DCNL result, passing ``dtype=theano.config.floatX`` to compute the mean on GPU.'
def sigmoid(x): DCNL 'Sigmoid activation function :math:`\varphi(x) = \frac{1}{1 + e^{-x}}` DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 in [0, 1] DCNL The output of the sigmoid function applied to the activation.'
def softmax(x): DCNL 'Softmax activation function DCNL :math:`\varphi(\mathbf{x})_j = DCNL \frac{e^{\mathbf{x}_j}}{\sum_{k=1}^K e^{\mathbf{x}_k}}` DCNL where :math:`K` is the total number of neurons in the layer. This DCNL activation function gets applied row-wise. DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 where the sum of the row is 1 and each single value is in [0, 1] DCNL The output of the softmax function applied to the activation.'
def tanh(x): DCNL 'Tanh activation function :math:`\varphi(x) = \tanh(x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 in [-1, 1] DCNL The output of the tanh function applied to the activation.'
def rectify(x): DCNL 'Rectify activation function :math:`\varphi(x) = \max(0, x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 DCNL The output of the rectify function applied to the activation.'
def elu(x): DCNL 'Exponential Linear Unit :math:`\varphi(x) = (x > 0) ? x : e^x - 1` DCNL The Exponential Linear Unit (ELU) was introduced in [1]_. Compared to the DCNL linear rectifier :func:`rectify`, it has a mean activation closer to zero DCNL and nonzero gradient for negative input, which can help convergence. DCNL Compared to the leaky rectifier :class:`LeakyRectify`, it saturates for DCNL highly negative inputs. DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighed input of a neuron). DCNL Returns DCNL float32 DCNL The output of the exponential linear unit for the activation. DCNL Notes DCNL In [1]_, an additional parameter :math:`\alpha` controls the (negative) DCNL saturation value for negative inputs, but is set to 1 for all experiments. DCNL It is omitted here. DCNL References DCNL .. [1] Djork-Arné Clevert, Thomas Unterthiner, Sepp Hochreiter (2015): DCNL Fast and Accurate Deep Network Learning by Exponential Linear Units DCNL (ELUs), http://arxiv.org/abs/1511.07289'
def softplus(x): DCNL 'Softplus activation function :math:`\varphi(x) = \log(1 + e^x)` DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 DCNL The output of the softplus function applied to the activation.'
def linear(x): DCNL 'Linear activation function :math:`\varphi(x) = x` DCNL Parameters DCNL x : float32 DCNL The activation (the summed, weighted input of a neuron). DCNL Returns DCNL float32 DCNL The output of the identity applied to the activation.'
def locally_connected2d(input, W, flip_filters=True): DCNL '2D convolution with unshared weights, no stride, \'same\' padding, DCNL no dilation and no bias'
def channelwise_locally_connected2d(input, W, flip_filters=True): DCNL 'channelwise 2D convolution with unshared weights, no stride, DCNL \'same\' padding, no dilation and no bias'
def convNd(input, kernel, pad, stride=1, n=None): DCNL 'Execute a batch of a stack of N-dimensional convolutions. DCNL Parameters DCNL input : numpy array DCNL kernel : numpy array DCNL pad : {0, \'valid\', \'same\', \'full\'}, int or tuple of int DCNL stride : int or tuple of int DCNL n : int DCNL Returns DCNL numpy array'
def dilate(input, factors): DCNL 'Inserts `factors[i] - 1` zeros between input elements on axis i.'
